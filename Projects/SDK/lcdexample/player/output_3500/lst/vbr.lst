TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   1
C:\STMP3XXX_SDK_FIRMWARE_320_finalfix\Projects\SDK\lcdexample\player\make\ccfc77db.src
M:ADDR CODE           CYCLES LINE SOURCELINE
                                1 ; TASKING DSP2410 C compiler v1.5r1 Build 208 SN 00100122
                                2 ; options: -OG -si -DPLAYER -DALL -DD3500 -DMMC -DLIION -DPL3_FB
                                3 ;          -DSTMP_BUILD_PLAYER -DPLAYER_BUILD -DPLAYER -DSTFM1000_LCD
                                4 ;          -DFULL_PLAYER_KERNEL -DDCDC_POWER_TRANSFER -DBACKLIGHT
                                5 ;          -DWMAAPI_NO_DRM -DREVB_ENGR_BD -DSED15XX_LCD -DSYNC_LYRICS
                                6 ;          -DTUNER_STFM1000 -DFM_EUROPE_REGION -DSD_USE_100KHZ_TUNING_GRID
                                7 ;          -DNEWSHINGYIH -DREAL_I2S_DATA -DFUNCLET
                                8 ;          -DMEDIA_DDI_COUNT_HIDDEN_SYSTEM_BLOCKS -DFMTUNER -DMP3_ENCODE
                                9 ;          -DCHKDSK -DFAT16 -DDEBUG -DDEVICE_3500 -DSDK2400 -DENGR_BD
                               10 ;          -DUSE_PLAYLIST3 -DBATTERY_TYPE_LI_ION -DBATTERY_CHARGE -w68 -w66
                               11 ;          -I..\output_3500\include
                               12 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\Player
                               13 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\Player\Menus -I..\..
                               14 ;          -I..\..\..\..\..\inc -I..\..\..\..\..\System\Common
                               15 ;          -I..\..\..\..\..\System\Common\symbols
                               16 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\Player\Display
                               17 ;          -I..\..\..\..\..\Algorithms\DRM\janus\src\h
                               18 ;          -I..\..\..\..\..\FileSystem\Fat32\h
                               19 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               20 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               21 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               22 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand -I -I
                               23 ;          -I..\..\..\..\..\system\common\resourcemanager -I..\..\..\..\..\inc
                               24 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               25 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive\include
                               26 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               27 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               28 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive
                               29 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               30 ;          -I..\..\..\..\..\FileSystem\Fat32\h
                               31 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               32 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               33 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               34 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               35 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               36 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               37 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               38 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               39 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common
                               40 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               41 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive\include
                               42 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               43 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               44 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive
                               45 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               46 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media\include
                               47 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               48 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               49 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media
                               50 ;          -I..\..\..\..\..\devicedriver\media\include
                               51 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               52 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               53 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               54 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               55 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL
                               56 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               57 ;          -I..\..\..\..\..\DeviceDriver\Media\include
                               58 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash\include
                               59 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash
                               60 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               61 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               62 ;          -I..\..\..\..\..\libsource\sysserialnumber
                               63 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               64 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               65 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               66 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\Media
                               67 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\HAL\include
                               68 ;          -I..\..\..\..\..\FileSystem\Fat32\h
                               69 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               70 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               71 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               72 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               73 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               74 ;          -I..\..\..\..\..\System\MsgModules\Software\Effects\srswow
                               75 ;          -I..\..\..\..\..\System\Common\rtcaccess
                               76 ;          -I..\..\..\..\..\System\Common\playlist3
                               77 ;          -I..\..\..\..\..\System\Common\record
                               78 ;          -I..\..\..\..\..\System\Common\mp3filename
                               79 ;          -I..\..\..\..\..\FileSystem\chkdsk\include
                               80 ;          -I..\..\..\..\..\FileSystem\Fat32\h -DFULL_PLAYER_KERNEL
                               81 ;          -DSYNC_LYRICS -DMP3_ENCODE -DBATTERY_TYPE_LI_ION -Dk_opt_single_fat
                               82 ;          -DPL3_FB -g -O2 -R -Cs -DMS_ADPCM -DIMA_ADPCM -DWINDOWS_PCM
                               83 ;          -I..\..\..\..\..\System\MsgModules\Software\musiclib\ghdr
                               84 ;          -I..\..\..\..\..\devicedriver\display
                               85 ;          -I..\..\..\..\..\System\MsgModules\Hardware\Display -MmyL
                               86 
                               94 
                               95 ;          vbr.c:
                               96 ; 1    |///////////////////////////////////////////////////////////////////////////////
                               97 ; 2    |// Copyright(C) SigmaTel, Inc. 2002-2003
                               98 ; 3    |//
                               99 ; 4    |// Filename: vbr.c
                              100 ; 5    |// Description: Functions for extracting the mp3 meta-data.
                              101 ; 6    |///////////////////////////////////////////////////////////////////////////////
                              102 ; 7    |#include "types.h"
                              103 
                              105 
                              106 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              107 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              108 ; 3    |//
                              109 ; 4    |// Filename: types.h
                              110 ; 5    |// Description: Standard data types
                              111 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              112 ; 7    |
                              113 ; 8    |#ifndef _TYPES_H
                              114 ; 9    |#define _TYPES_H
                              115 ; 10   |
                              116 ; 11   |// TODO:  move this outta here!
                              117 ; 12   |#if !defined(NOERROR)
                              118 ; 13   |#define NOERROR 0
                              119 ; 14   |#define SUCCESS 0
                              120 ; 15   |#endif 
                              121 ; 16   |#if !defined(SUCCESS)
                              122 ; 17   |#define SUCCESS  0
                              123 ; 18   |#endif
                              124 ; 19   |#if !defined(ERROR)
                              125 ; 20   |#define ERROR   -1
                              126 ; 21   |#endif
                              127 ; 22   |#if !defined(FALSE)
                              128 ; 23   |#define FALSE 0
                              129 ; 24   |#endif
                              130 ; 25   |#if !defined(TRUE)
                              131 ; 26   |#define TRUE  1
                              132 ; 27   |#endif
                              133 ; 28   |
                              134 ; 29   |#if !defined(NULL)
                              135 ; 30   |#define NULL 0
                              136 ; 31   |#endif
                              137 ; 32   |
                              138 ; 33   |#define MAX_INT     0x7FFFFF
                              139 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              140 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              141 ; 36   |#define MAX_ULONG   (-1) 
                              142 ; 37   |
                              143 ; 38   |#define WORD_SIZE   24              // word size in bits
                              144 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              145 ; 40   |
                              146 ; 41   |
                              147 ; 42   |#define BYTE    unsigned char       // btVarName
                              148 ; 43   |#define CHAR    signed char         // cVarName
                              149 ; 44   |#define USHORT  unsigned short      // usVarName
                              150 ; 45   |#define SHORT   unsigned short      // sVarName
                              151 ; 46   |#define WORD    unsigned int        // wVarName
                              152 ; 47   |#define INT     signed int          // iVarName
                              153 ; 48   |#define DWORD   unsigned long       // dwVarName
                              154 ; 49   |#define LONG    signed long         // lVarName
                              155 ; 50   |#define BOOL    unsigned int        // bVarName
                              156 ; 51   |#define FRACT   _fract              // frVarName
                              157 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              158 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              159 ; 54   |#define FLOAT   float               // fVarName
                              160 ; 55   |#define DBL     double              // dVarName
                              161 ; 56   |#define ENUM    enum                // eVarName
                              162 ; 57   |#define CMX     _complex            // cmxVarName
                              163 ; 58   |typedef WORD UCS3;                   // 
                              164 ; 59   |
                              165 ; 60   |#define UINT16  unsigned short
                              166 ; 61   |#define UINT8   unsigned char   
                              167 ; 62   |#define UINT32  unsigned long
                              168 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              169 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              170 ; 65   |#define WCHAR   UINT16
                              171 ; 66   |
                              172 ; 67   |//UINT128 is 16 bytes or 6 words
                              173 ; 68   |typedef struct UINT128_3500 {   
                              174 ; 69   |    int val[6];     
                              175 ; 70   |} UINT128_3500;
                              176 ; 71   |
                              177 ; 72   |#define UINT128   UINT128_3500
                              178 ; 73   |
                              179 ; 74   |// Little endian word packed byte strings:   
                              180 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              181 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              182 ; 77   |// Little endian word packed byte strings:   
                              183 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              184 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              185 ; 80   |
                              186 ; 81   |// Declare Memory Spaces To Use When Coding
                              187 ; 82   |// A. Sector Buffers
                              188 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              189 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              190 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              191 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              192 
                              194 
                              195 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              196 ; 88   |// B. Media DDI Memory
                              197 ; 89   |#define MEDIA_DDI_MEM _Y
                              198 ; 90   |
                              199 ; 91   |
                              200 ; 92   |
                              201 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              202 ; 94   |// Examples of circular pointers:
                              203 ; 95   |//    INT CIRC cpiVarName
                              204 ; 96   |//    DWORD CIRC cpdwVarName
                              205 ; 97   |
                              206 ; 98   |#define RETCODE INT                 // rcVarName
                              207 ; 99   |
                              208 ; 100  |// generic bitfield structure
                              209 ; 101  |struct Bitfield {
                              210 ; 102  |    unsigned int B0  :1;
                              211 ; 103  |    unsigned int B1  :1;
                              212 ; 104  |    unsigned int B2  :1;
                              213 ; 105  |    unsigned int B3  :1;
                              214 ; 106  |    unsigned int B4  :1;
                              215 ; 107  |    unsigned int B5  :1;
                              216 ; 108  |    unsigned int B6  :1;
                              217 ; 109  |    unsigned int B7  :1;
                              218 ; 110  |    unsigned int B8  :1;
                              219 ; 111  |    unsigned int B9  :1;
                              220 ; 112  |    unsigned int B10 :1;
                              221 ; 113  |    unsigned int B11 :1;
                              222 ; 114  |    unsigned int B12 :1;
                              223 ; 115  |    unsigned int B13 :1;
                              224 ; 116  |    unsigned int B14 :1;
                              225 ; 117  |    unsigned int B15 :1;
                              226 ; 118  |    unsigned int B16 :1;
                              227 ; 119  |    unsigned int B17 :1;
                              228 ; 120  |    unsigned int B18 :1;
                              229 ; 121  |    unsigned int B19 :1;
                              230 ; 122  |    unsigned int B20 :1;
                              231 ; 123  |    unsigned int B21 :1;
                              232 ; 124  |    unsigned int B22 :1;
                              233 ; 125  |    unsigned int B23 :1;
                              234 ; 126  |};
                              235 ; 127  |
                              236 ; 128  |union BitInt {
                              237 ; 129  |        struct Bitfield B;
                              238 ; 130  |        int        I;
                              239 ; 131  |};
                              240 ; 132  |
                              241 ; 133  |#define MAX_MSG_LENGTH 10
                              242 ; 134  |struct CMessage
                              243 ; 135  |{
                              244 ; 136  |        unsigned int m_uLength;
                              245 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              246 ; 138  |};
                              247 ; 139  |
                              248 ; 140  |typedef struct {
                              249 ; 141  |    WORD m_wLength;
                              250 ; 142  |    WORD m_wMessage;
                              251 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              252 ; 144  |} Message;
                              253 ; 145  |
                              254 ; 146  |struct MessageQueueDescriptor
                              255 ; 147  |{
                              256 ; 148  |        int *m_pBase;
                              257 ; 149  |        int m_iModulo;
                              258 ; 150  |        int m_iSize;
                              259 ; 151  |        int *m_pHead;
                              260 ; 152  |        int *m_pTail;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   2

M:ADDR CODE           CYCLES LINE SOURCELINE
                              261 ; 153  |};
                              262 ; 154  |
                              263 ; 155  |struct ModuleEntry
                              264 ; 156  |{
                              265 ; 157  |    int m_iSignaledEventMask;
                              266 ; 158  |    int m_iWaitEventMask;
                              267 ; 159  |    int m_iResourceOfCode;
                              268 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              269 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                              270 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              271 ; 163  |    int m_uTimeOutHigh;
                              272 ; 164  |    int m_uTimeOutLow;
                              273 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              274 ; 166  |};
                              275 ; 167  |
                              276 ; 168  |union WaitMask{
                              277 ; 169  |    struct B{
                              278 ; 170  |        unsigned int m_bNone     :1;
                              279 ; 171  |        unsigned int m_bMessage  :1;
                              280 ; 172  |        unsigned int m_bTimer    :1;
                              281 ; 173  |        unsigned int m_bButton   :1;
                              282 ; 174  |    } B;
                              283 ; 175  |    int I;
                              284 ; 176  |} ;
                              285 ; 177  |
                              286 ; 178  |
                              287 ; 179  |struct Button {
                              288 ; 180  |        WORD wButtonEvent;
                              289 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              290 ; 182  |};
                              291 ; 183  |
                              292 ; 184  |struct Message {
                              293 ; 185  |        WORD wMsgLength;
                              294 ; 186  |        WORD wMsgCommand;
                              295 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              296 ; 188  |};
                              297 ; 189  |
                              298 ; 190  |union EventTypes {
                              299 ; 191  |        struct CMessage msg;
                              300 ; 192  |        struct Button Button ;
                              301 ; 193  |        struct Message Message;
                              302 ; 194  |};
                              303 ; 195  |
                              304 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              305 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              306 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              307 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              308 ; 200  |
                              309 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              310 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              311 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              312 ; 204  |
                              313 ; 205  |#if DEBUG
                              314 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              315 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              316 ; 208  |#else 
                              317 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                              318 ; 210  |#define DebugBuildAssert(x)    
                              319 ; 211  |#endif
                              320 ; 212  |
                              321 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              322 ; 214  |//  #pragma asm
                              323 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              324 ; 216  |//  #pragma endasm
                              325 ; 217  |
                              326 ; 218  |
                              327 ; 219  |#ifdef COLOR_262K
                              328 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                              329 ; 221  |#elif defined(COLOR_65K)
                              330 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                              331 ; 223  |#else
                              332 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                              333 ; 225  |#endif
                              334 ; 226  |    
                              335 ; 227  |#endif // #ifndef _TYPES_H
                              336 
                              338 
                              339 ; 8    |#include "stringlib.h"
                              340 
                              342 
                              343 ; 1    |#ifndef STRINGLIB_H
                              344 ; 2    |#define STRINGLIB_H
                              345 
                              347 
                              348 ; 3    |_asmfunc int pack_string(UCS3 _Y * _Y pUnpacked, _packed BYTE _Y * _Y pPacked);
                              349 ; 4    |_asmfunc int unpack_string( _packed BYTE _Y * _Y pPacked,  UCS3 _Y * _Y pUnpacked);
                              350 ; 5    |_asmfunc int unpack_data( _packed BYTE _Y * _Y pPacked,  BYTE _Y * _Y pUnpacked, INT iCount);
                              351 ; 6    |
                              352 ; 7    |_asmfunc BYTE GetByteFromArrayInX( void _X * p,int n);
                              353 ; 8    |_asmfunc void PutByteInArrayInX( void _X * p,int n, int newchar);
                              354 ; 9    |_asmfunc BYTE GetByteFromArrayInY( void _Y * p,int n);
                              355 ; 10   |_asmfunc void PutByteInArrayInY( void _Y * p,int n, int newchar);
                              356 ; 11   |
                              357 ; 12   |_asmfunc BYTE packed_get( _packed BYTE _Y * p,int n);
                              358 ; 13   |_asmfunc void packed_set( _packed BYTE _Y * p,int n, int newchar);
                              359 ; 14   |
                              360 ; 15   |_asmfunc int packed_strlen( _packed BYTE _Y * _Y p);
                              361 ; 16   |
                              362 ; 17   |_asmfunc _packed BYTE _Y * packed_strncpy( _packed BYTE _Y * _Y pDest,_packed BYTE _Y * _Y pSrc, int iCount);
                              363 ; 18   |_asmfunc _packed BYTE _Y * packed_strcpy ( _packed BYTE _Y * _Y pDest,_packed BYTE _Y * _Y pSrc);
                              364 ; 19   |
                              365 ; 20   |
                              366 ; 21   |_asmfunc int packed_strncmp( _packed BYTE _Y * _Y pLeft,_packed BYTE _Y * _Y pRight, int iCount);
                              367 ; 22   |_asmfunc int packed_strcmp ( _packed BYTE _Y * _Y pLeft,_packed BYTE _Y * _Y pRight);
                              368 ; 23   |
                              369 ; 24   |_asmfunc int packed_strncat( _packed BYTE _Y * _Y pDest,_packed BYTE _Y * _Y pSource, int iCount);
                              370 ; 25   |_asmfunc int packed_strcat ( _packed BYTE _Y * _Y pDest,_packed BYTE _Y * _Y pSource);
                              371 ; 26   |
                              372 ; 27   |
                              373 ; 28   |_asmfunc int strlen(UCS3 _Y * _Y p);
                              374 ; 29   |
                              375 ; 30   |_asmfunc UCS3 *strchr(UCS3 _Y * _Y pUnpacked, UCS3 CharToFind);
                              376 ; 31   |_asmfunc UCS3 *strrchr(UCS3 _Y * _Y pUnpacked, UCS3 CharToFind);
                              377 ; 32   |
                              378 ; 33   |_asmfunc void strncpy(UCS3 _Y * _Y pDest, UCS3 _Y * _Y pSource, BYTE iCount);
                              379 ; 34   |_asmfunc void strcpy(UCS3 _Y * _Y pDest, UCS3 _Y * _Y pSource);
                              380 ; 35   |
                              381 ; 36   |_asmfunc char *strncat(UCS3 _Y * _Y pDest, UCS3 _Y * _Y pSource, int iCount);
                              382 ; 37   |_asmfunc char *strcat(UCS3 _Y * _Y pDest, UCS3 _Y * _Y pSource);
                              383 ; 38   |
                              384 ; 39   |_asmfunc int strncmp(UCS3 _Y * _Y pDest, UCS3 _Y * _Y pSource, int iCount);
                              385 ; 40   |_asmfunc int strcmp(UCS3 _Y * _Y pDest, UCS3 _Y * _Y pSource);
                              386 ; 41   |
                              387 ; 42   |#endif
                              388 
                              390 
                              391 ; 9    |#include "hwequ.h"
                              392 
                              394 
                              395 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                              396 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2001
                              397 ; 3    |//  File        : hwequ.inc
                              398 ; 4    |//  Description : STMP Hardware Constants
                              399 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                              400 ; 6    |
                              401 ; 7    |// ////////////////////////////////////////////////////////////////////////////////
                              402 ; 8    |// hwequ is being eliminated for SDK3XXX.  For SDK2.5XX it will now reside in the   
                              403 ; 9    |// local folder instead of ..\inc.  All register includes are converted to .h by 
                              404 ; 10   |// registers.mk placed in the ..\lcdexample\player\output_XXXX folder.
                              405 ; 11   |// ////////////////////////////////////////////////////////////////////////////////
                              406 ; 12   |
                              407 ; 13   |#if (!defined(HWEQU_INC))
                              408 ; 14   |#define HWEQU_INC 1
                              409 ; 15   |
                              410 ; 16   |#include "types.h"
                              411 
                              413 
                              414 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              415 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              416 ; 3    |//
                              417 ; 4    |// Filename: types.h
                              418 ; 5    |// Description: Standard data types
                              419 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              420 ; 7    |
                              421 ; 8    |#ifndef _TYPES_H
                              422 ; 9    |#define _TYPES_H
                              423 ; 10   |
                              424 ; 11   |// TODO:  move this outta here!
                              425 ; 12   |#if !defined(NOERROR)
                              426 ; 13   |#define NOERROR 0
                              427 ; 14   |#define SUCCESS 0
                              428 ; 15   |#endif 
                              429 ; 16   |#if !defined(SUCCESS)
                              430 ; 17   |#define SUCCESS  0
                              431 ; 18   |#endif
                              432 ; 19   |#if !defined(ERROR)
                              433 ; 20   |#define ERROR   -1
                              434 ; 21   |#endif
                              435 ; 22   |#if !defined(FALSE)
                              436 ; 23   |#define FALSE 0
                              437 ; 24   |#endif
                              438 ; 25   |#if !defined(TRUE)
                              439 ; 26   |#define TRUE  1
                              440 ; 27   |#endif
                              441 ; 28   |
                              442 ; 29   |#if !defined(NULL)
                              443 ; 30   |#define NULL 0
                              444 ; 31   |#endif
                              445 ; 32   |
                              446 ; 33   |#define MAX_INT     0x7FFFFF
                              447 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              448 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              449 ; 36   |#define MAX_ULONG   (-1) 
                              450 ; 37   |
                              451 ; 38   |#define WORD_SIZE   24              // word size in bits
                              452 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              453 ; 40   |
                              454 ; 41   |
                              455 ; 42   |#define BYTE    unsigned char       // btVarName
                              456 ; 43   |#define CHAR    signed char         // cVarName
                              457 ; 44   |#define USHORT  unsigned short      // usVarName
                              458 ; 45   |#define SHORT   unsigned short      // sVarName
                              459 ; 46   |#define WORD    unsigned int        // wVarName
                              460 ; 47   |#define INT     signed int          // iVarName
                              461 ; 48   |#define DWORD   unsigned long       // dwVarName
                              462 ; 49   |#define LONG    signed long         // lVarName
                              463 ; 50   |#define BOOL    unsigned int        // bVarName
                              464 ; 51   |#define FRACT   _fract              // frVarName
                              465 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              466 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              467 ; 54   |#define FLOAT   float               // fVarName
                              468 ; 55   |#define DBL     double              // dVarName
                              469 ; 56   |#define ENUM    enum                // eVarName
                              470 ; 57   |#define CMX     _complex            // cmxVarName
                              471 ; 58   |typedef WORD UCS3;                   // 
                              472 ; 59   |
                              473 ; 60   |#define UINT16  unsigned short
                              474 ; 61   |#define UINT8   unsigned char   
                              475 ; 62   |#define UINT32  unsigned long
                              476 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              477 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              478 ; 65   |#define WCHAR   UINT16
                              479 ; 66   |
                              480 ; 67   |//UINT128 is 16 bytes or 6 words
                              481 ; 68   |typedef struct UINT128_3500 {   
                              482 ; 69   |    int val[6];     
                              483 ; 70   |} UINT128_3500;
                              484 ; 71   |
                              485 ; 72   |#define UINT128   UINT128_3500
                              486 ; 73   |
                              487 ; 74   |// Little endian word packed byte strings:   
                              488 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              489 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              490 ; 77   |// Little endian word packed byte strings:   
                              491 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              492 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              493 ; 80   |
                              494 ; 81   |// Declare Memory Spaces To Use When Coding
                              495 ; 82   |// A. Sector Buffers
                              496 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              497 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              498 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              499 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              500 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              501 ; 88   |// B. Media DDI Memory
                              502 ; 89   |#define MEDIA_DDI_MEM _Y
                              503 ; 90   |
                              504 ; 91   |
                              505 ; 92   |
                              506 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              507 ; 94   |// Examples of circular pointers:
                              508 ; 95   |//    INT CIRC cpiVarName
                              509 ; 96   |//    DWORD CIRC cpdwVarName
                              510 ; 97   |
                              511 ; 98   |#define RETCODE INT                 // rcVarName
                              512 ; 99   |
                              513 ; 100  |// generic bitfield structure
                              514 ; 101  |struct Bitfield {
                              515 ; 102  |    unsigned int B0  :1;
                              516 ; 103  |    unsigned int B1  :1;
                              517 ; 104  |    unsigned int B2  :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   3

M:ADDR CODE           CYCLES LINE SOURCELINE
                              518 ; 105  |    unsigned int B3  :1;
                              519 ; 106  |    unsigned int B4  :1;
                              520 ; 107  |    unsigned int B5  :1;
                              521 ; 108  |    unsigned int B6  :1;
                              522 ; 109  |    unsigned int B7  :1;
                              523 ; 110  |    unsigned int B8  :1;
                              524 ; 111  |    unsigned int B9  :1;
                              525 ; 112  |    unsigned int B10 :1;
                              526 ; 113  |    unsigned int B11 :1;
                              527 ; 114  |    unsigned int B12 :1;
                              528 ; 115  |    unsigned int B13 :1;
                              529 ; 116  |    unsigned int B14 :1;
                              530 ; 117  |    unsigned int B15 :1;
                              531 ; 118  |    unsigned int B16 :1;
                              532 ; 119  |    unsigned int B17 :1;
                              533 ; 120  |    unsigned int B18 :1;
                              534 ; 121  |    unsigned int B19 :1;
                              535 ; 122  |    unsigned int B20 :1;
                              536 ; 123  |    unsigned int B21 :1;
                              537 ; 124  |    unsigned int B22 :1;
                              538 ; 125  |    unsigned int B23 :1;
                              539 ; 126  |};
                              540 ; 127  |
                              541 ; 128  |union BitInt {
                              542 ; 129  |        struct Bitfield B;
                              543 ; 130  |        int        I;
                              544 ; 131  |};
                              545 ; 132  |
                              546 ; 133  |#define MAX_MSG_LENGTH 10
                              547 ; 134  |struct CMessage
                              548 ; 135  |{
                              549 ; 136  |        unsigned int m_uLength;
                              550 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              551 ; 138  |};
                              552 ; 139  |
                              553 ; 140  |typedef struct {
                              554 ; 141  |    WORD m_wLength;
                              555 ; 142  |    WORD m_wMessage;
                              556 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              557 ; 144  |} Message;
                              558 ; 145  |
                              559 ; 146  |struct MessageQueueDescriptor
                              560 ; 147  |{
                              561 ; 148  |        int *m_pBase;
                              562 ; 149  |        int m_iModulo;
                              563 ; 150  |        int m_iSize;
                              564 ; 151  |        int *m_pHead;
                              565 ; 152  |        int *m_pTail;
                              566 ; 153  |};
                              567 ; 154  |
                              568 ; 155  |struct ModuleEntry
                              569 ; 156  |{
                              570 ; 157  |    int m_iSignaledEventMask;
                              571 ; 158  |    int m_iWaitEventMask;
                              572 ; 159  |    int m_iResourceOfCode;
                              573 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              574 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                              575 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              576 ; 163  |    int m_uTimeOutHigh;
                              577 ; 164  |    int m_uTimeOutLow;
                              578 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              579 ; 166  |};
                              580 ; 167  |
                              581 ; 168  |union WaitMask{
                              582 ; 169  |    struct B{
                              583 ; 170  |        unsigned int m_bNone     :1;
                              584 ; 171  |        unsigned int m_bMessage  :1;
                              585 ; 172  |        unsigned int m_bTimer    :1;
                              586 ; 173  |        unsigned int m_bButton   :1;
                              587 ; 174  |    } B;
                              588 ; 175  |    int I;
                              589 ; 176  |} ;
                              590 ; 177  |
                              591 ; 178  |
                              592 ; 179  |struct Button {
                              593 ; 180  |        WORD wButtonEvent;
                              594 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              595 ; 182  |};
                              596 ; 183  |
                              597 ; 184  |struct Message {
                              598 ; 185  |        WORD wMsgLength;
                              599 ; 186  |        WORD wMsgCommand;
                              600 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              601 ; 188  |};
                              602 ; 189  |
                              603 ; 190  |union EventTypes {
                              604 ; 191  |        struct CMessage msg;
                              605 ; 192  |        struct Button Button ;
                              606 ; 193  |        struct Message Message;
                              607 ; 194  |};
                              608 ; 195  |
                              609 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              610 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              611 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              612 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              613 ; 200  |
                              614 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              615 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              616 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              617 ; 204  |
                              618 ; 205  |#if DEBUG
                              619 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              620 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              621 ; 208  |#else 
                              622 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                              623 ; 210  |#define DebugBuildAssert(x)    
                              624 ; 211  |#endif
                              625 ; 212  |
                              626 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              627 ; 214  |//  #pragma asm
                              628 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              629 ; 216  |//  #pragma endasm
                              630 ; 217  |
                              631 ; 218  |
                              632 ; 219  |#ifdef COLOR_262K
                              633 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                              634 ; 221  |#elif defined(COLOR_65K)
                              635 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                              636 ; 223  |#else
                              637 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                              638 ; 225  |#endif
                              639 ; 226  |    
                              640 ; 227  |#endif // #ifndef _TYPES_H
                              641 
                              643 
                              644 ; 17   |#include "regsclkctrl.h"
                              645 
                              647 
                              648 ; 1    |#if !(defined(__REGS_CLK_CONTROL_INC))
                              649 ; 2    |#define __REGS_CLK_CONTROL_INC 1
                              650 ; 3    |
                              651 ; 4    |
                              652 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                              653 ; 6    |//  Clock Control Register (HW_CCR) Bit Positions
                              654 ; 7    |#define HW_CCR_CKRST_BITPOS 0
                              655 ; 8    |#define HW_CCR_LTC_BITPOS 1
                              656 ; 9    |#define HW_CCR_PLLEN_BITPOS 2
                              657 ; 10   |#define HW_CCR_XTLEN_BITPOS 3
                              658 ; 11   |#define HW_CCR_PLL_SOURCE_SEL_BITPOS 4
                              659 ; 12   |#define HW_CCR_ADIV_B0_BITPOS 5
                              660 ; 13   |#define HW_CCR_ADIV_B1_BITPOS 6
                              661 ; 14   |#define HW_CCR_ADIV_B2_BITPOS 7
                              662 ; 15   |#define HW_CCR_CKSRC_BITPOS 8
                              663 ; 16   |#define HW_CCR_DDIV_BITPOS 9
                              664 ; 17   |#define HW_CCR_DDIV_B0_BITPOS 9
                              665 ; 18   |#define HW_CCR_DDIV_B1_BITPOS 10
                              666 ; 19   |#define HW_CCR_DDIV_B2_BITPOS 11
                              667 ; 20   |#define HW_CCR_PDIV_BITPOS 12
                              668 ; 21   |#define HW_CCR_PDIV_B0_BITPOS 12
                              669 ; 22   |#define HW_CCR_PDIV_B1_BITPOS 13
                              670 ; 23   |#define HW_CCR_PDIV_B2_BITPOS 14
                              671 ; 24   |#define HW_CCR_PDIV_B3_BITPOS 15
                              672 ; 25   |#define HW_CCR_PDIV_B4_BITPOS 16
                              673 ; 26   |#define HW_CCR_PWDN_BITPOS 17
                              674 ; 27   |#define HW_CCR_ACKEN_BITPOS 18
                              675 ; 28   |#define HW_CCR_LOCK_BITPOS 19
                              676 ; 29   |#define HW_CCR_DACDIV_BITPOS 20
                              677 ; 30   |#define HW_CCR_ADIV1_B0_BITPOS 20
                              678 ; 31   |#define HW_CCR_ADIV1_B1_BITPOS 21
                              679 ; 32   |#define HW_CCR_ADIV1_B2_BITPOS 22
                              680 ; 33   |#define HW_CCR_DDIV_MSB_BITPOS 23
                              681 ; 34   |
                              682 ; 35   |#define HW_CCR_CKRST_SETMASK 1<<HW_CCR_CKRST_BITPOS
                              683 ; 36   |#define HW_CCR_LTC_SETMASK 1<<HW_CCR_LTC_BITPOS
                              684 ; 37   |#define HW_CCR_PLLEN_SETMASK 1<<HW_CCR_PLLEN_BITPOS
                              685 ; 38   |#define HW_CCR_XTLEN_SETMASK 1<<HW_CCR_XTLEN_BITPOS
                              686 ; 39   |#define HW_CCR_ADCDIV_SETMASK 0x7<<HW_CCR_ADIV_B0_BITPOS
                              687 ; 40   |#define HW_CCR_CKSRC_SETMASK 1<<HW_CCR_CKSRC_BITPOS
                              688 ; 41   |#define HW_CCR_DDIV_SETMASK 0x7<<HW_CCR_DDIV_BITPOS
                              689 ; 42   |#define HW_CCR_PDIV_SETMASK 0x1F<<HW_CCR_PDIV_BITPOS
                              690 ; 43   |#define HW_CCR_PWDN_SETMASK 1<<HW_CCR_PWDN_BITPOS
                              691 ; 44   |#define HW_CCR_ACKEN_SETMASK 1<<HW_CCR_ACKEN_BITPOS
                              692 ; 45   |#define HW_CCR_LOCK_SETMASK 1<<HW_CCR_LOCK_BITPOS
                              693 ; 46   |#define HW_CCR_DACDIV_SETMASK 0x7<<HW_CCR_DACDIV_BITPOS
                              694 ; 47   |
                              695 ; 48   |#define HW_CCR_CKRST_CLRMASK ~(WORD)HW_CCR_CKRST_SETMASK
                              696 ; 49   |#define HW_CCR_LTC_CLRMASK ~(WORD)HW_CCR_LTC_SETMASK
                              697 ; 50   |#define HW_CCR_PLLEN_CLRMASK ~(WORD)HW_CCR_PLLEN_SETMASK
                              698 ; 51   |#define HW_CCR_XTLEN_CLRMASK ~(WORD)HW_CCR_XTLEN_SETMASK
                              699 ; 52   |#define HW_CCR_ADCDIV_CLRMASK ~(WORD)HW_CCR_ADCDIV_SETMASK
                              700 ; 53   |#define HW_CCR_CKSRC_CLRMASK ~(WORD)HW_CCR_CKSRC_SETMASK
                              701 ; 54   |#define HW_CCR_DDIV_CLRMASK ~(WORD)HW_CCR_DDIV_SETMASK
                              702 ; 55   |#define HW_CCR_PDIV_CLRMASK ~(WORD)HW_CCR_PDIV_SETMASK
                              703 ; 56   |#define HW_CCR_PWDN_CLRMASK ~(WORD)HW_CCR_PWDN_SETMASK
                              704 ; 57   |#define HW_CCR_ACKEN_CLRMASK ~(WORD)HW_CCR_ACKEN_SETMASK
                              705 ; 58   |#define HW_CCR_LOCK_CLRMASK ~(WORD)HW_CCR_LOCK_SETMASK
                              706 ; 59   |#define HW_CCR_DACDIV_CLRMASK ~(WORD)HW_CCR_DACDIV_SETMASK
                              707 ; 60   |
                              708 ; 61   |typedef union               
                              709 ; 62   |{
                              710 ; 63   |    struct
                              711 ; 64   |    {
                              712 ; 65   |        int CKRST       :1; // Clock Reset
                              713 ; 66   |        int LTC         :1;
                              714 ; 67   |        int PLLEN       :1;
                              715 ; 68   |        int XTLEN       :1;
                              716 ; 69   |        int FLB         :1;
                              717 ; 70   |        unsigned ADIV   :3;
                              718 ; 71   |        int CKSRC       :1;
                              719 ; 72   |        unsigned DDIV   :3;
                              720 ; 73   |        unsigned PDIV   :5;
                              721 ; 74   |        int PWDN        :1;
                              722 ; 75   |        int ACKEN       :1;
                              723 ; 76   |        int LOCK        :1;
                              724 ; 77   |        unsigned ADIV1  :3;
                              725 ; 78   |        unsigned DDIV_MSB:1;
                              726 ; 79   |    } B;
                              727 ; 80   |
                              728 ; 81   |    int I;
                              729 ; 82   |    unsigned int U;
                              730 ; 83   |
                              731 ; 84   |} ccr_type;
                              732 ; 85   |#define HW_CCR     (*(volatile ccr_type _X*) (0xFA00))
                              733 ; 86   |
                              734 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                              735 ; 88   |//  Reset Control Register (HW_RCR) Bit Positions
                              736 ; 89   |#define HW_RCR_STKLVL_BITPOS 0
                              737 ; 90   |#define HW_RCR_SRST_BITPOS 4
                              738 ; 91   |#define HW_RCR_IRQA_BITPOS 8
                              739 ; 92   |#define HW_RCR_IRQB_BITPOS 9
                              740 ; 93   |#define HW_RCR_NMI_BITPOS 10
                              741 ; 94   |#define HW_RCR_SUNFLLVL_BITPOS 11
                              742 ; 95   |#define HW_RCR_SUNFLEN_BITPOS 15
                              743 ; 96   |#define HW_RCR_SOVFLLVL_BITPOS 16
                              744 ; 97   |#define HW_RCR_SOVFLEN_BITPOS 20
                              745 ; 98   |#define HW_RCR_IRQB2NMI_BITPOS 21
                              746 ; 99   |#define HW_RCR_SUNFL_BITPOS 22
                              747 ; 100  |#define HW_RCR_SOVFL_BITPOS 23
                              748 ; 101  |
                              749 ; 102  |#define HW_RCR_STKLVL_WIDTH (4)
                              750 ; 103  |#define HW_RCR_SRST_WIDTH (4)
                              751 ; 104  |#define HW_RCR_IRQA_WIDTH (1)
                              752 ; 105  |#define HW_RCR_IRQB_WIDTH (1)
                              753 ; 106  |#define HW_RCR_NMI_WIDTH (1)
                              754 ; 107  |#define HW_RCR_SUNFLLVL_WIDTH (4)
                              755 ; 108  |#define HW_RCR_SUNFLEN_WIDTH (1)
                              756 ; 109  |#define HW_RCR_SOVFLLVL_WIDTH (4)
                              757 ; 110  |#define HW_RCR_SOVFLEN_WIDTH (1)
                              758 ; 111  |#define HW_RCR_IRQB2NMI_WIDTH (1)
                              759 ; 112  |#define HW_RCR_SUNFL_WIDTH (1)
                              760 ; 113  |#define HW_RCR_SOVFL_WIDTH (1)
                              761 ; 114  |
                              762 ; 115  |#define HW_RCR_STKLVL_SETMASK (((1<<HW_RCR_STKLVL_WIDTH)-1)<<HW_RCR_STKLVL_BITPOS)
                              763 ; 116  |#define HW_RCR_SRST_SETMASK (((1<<HW_RCR_SRST_WIDTH)-1)<<HW_RCR_SRST_BITPOS)
                              764 ; 117  |#define HW_RCR_IRQA_SETMASK (((1<<HW_RCR_IRQA_WIDTH)-1)<<HW_RCR_IRQA_BITPOS)
                              765 ; 118  |#define HW_RCR_IRQB_SETMASK (((1<<HW_RCR_IRQB_WIDTH)-1)<<HW_RCR_IRQB_BITPOS)
                              766 ; 119  |#define HW_RCR_NMI_SETMASK (((1<<HW_RCR_NMI_WIDTH)-1)<<HW_RCR_NMI_BITPOS)
                              767 ; 120  |#define HW_RCR_SUNFLLVL_SETMASK (((1<<HW_RCR_SUNFLLVL_WIDTH)-1)<<HW_RCR_SUNFLLVL_BITPOS)
                              768 ; 121  |#define HW_RCR_SUNFLEN_SETMASK (((1<<HW_RCR_SUNFLEN_WIDTH)-1)<<HW_RCR_SUNFLEN_BITPOS)
                              769 ; 122  |#define HW_RCR_SOVFLLVL_SETMASK (((1<<HW_RCR_SOVFLLVL_WIDTH)-1)<<HW_RCR_SOVFLLVL_BITPOS)
                              770 ; 123  |#define HW_RCR_SOVFLEN_SETMASK (((1<<HW_RCR_SOVFLEN_WIDTH)-1)<<HW_RCR_SOVFLEN_BITPOS)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   4

M:ADDR CODE           CYCLES LINE SOURCELINE
                              771 ; 124  |#define HW_RCR_IRQB2NMI_SETMASK (((1<<HW_RCR_IRQB2NMI_WIDTH)-1)<<HW_RCR_IRQB2NMI_BITPOS)
                              772 ; 125  |#define HW_RCR_SUNFL_SETMASK (((1<<HW_RCR_SUNFL_WIDTH)-1)<<HW_RCR_SUNFL_BITPOS)
                              773 ; 126  |#define HW_RCR_SOVFL_SETMASK (((1<<HW_RCR_SOVFL_WIDTH)-1)<<HW_RCR_SOVFL_BITPOS)
                              774 ; 127  |
                              775 ; 128  |#define HW_RCR_STKLVL_CLRMASK ~(WORD)HW_RCR_STKLVL_SETMASK
                              776 ; 129  |#define HW_RCR_SRST_CLRMASK ~(WORD)HW_RCR_SRST_SETMASK
                              777 ; 130  |#define HW_RCR_IRQA_CLRMASK ~(WORD)HW_RCR_IRQA_SETMASK
                              778 ; 131  |#define HW_RCR_IRQB_CLRMASK ~(WORD)HW_RCR_IRQB_SETMASK
                              779 ; 132  |#define HW_RCR_NMI_CLRMASK ~(WORD)HW_RCR_NMI_SETMASK
                              780 ; 133  |#define HW_RCR_SUNFLLVL_CLRMASK ~(WORD)HW_RCR_SUNFLLVL_SETMASK
                              781 ; 134  |#define HW_RCR_SUNFLEN_CLRMASK ~(WORD)HW_RCR_SUNFLEN_SETMASK
                              782 ; 135  |#define HW_RCR_SOVFLLVL_CLRMASK ~(WORD)HW_RCR_SOVFLLVL_SETMASK
                              783 ; 136  |#define HW_RCR_SOVFLEN_CLRMASK ~(WORD)HW_RCR_SOVFLEN_SETMASK
                              784 ; 137  |#define HW_RCR_IRQB2NMI_CLRMASK ~(WORD)HW_RCR_IRQB2NMI_SETMASK
                              785 ; 138  |#define HW_RCR_SUNFL_CLRMASK ~(WORD)HW_RCR_SUNFL_SETMASK
                              786 ; 139  |#define HW_RCR_SOVFL_CLRMASK ~(WORD)HW_RCR_SOVFL_SETMASK
                              787 ; 140  |
                              788 ; 141  |typedef union               
                              789 ; 142  |{
                              790 ; 143  |    struct
                              791 ; 144  |   {
                              792 ; 145  |        int STKLVL   : HW_RCR_STKLVL_WIDTH;
                              793 ; 146  |        int SRST     : HW_RCR_SRST_WIDTH;
                              794 ; 147  |        int IRQA     : HW_RCR_IRQA_WIDTH;
                              795 ; 148  |        int IRQB     : HW_RCR_IRQB_WIDTH;
                              796 ; 149  |        int NMI      : HW_RCR_NMI_WIDTH;
                              797 ; 150  |        int SUNFLLVL : HW_RCR_SUNFLLVL_WIDTH;
                              798 ; 151  |        int SUNFLEN  : HW_RCR_SUNFLEN_WIDTH;
                              799 ; 152  |        int SOVFLLVL : HW_RCR_SOVFLLVL_WIDTH;
                              800 ; 153  |        int SOVFLEN  : HW_RCR_SOVFLEN_WIDTH;
                              801 ; 154  |        int IRQB2NMI : HW_RCR_IRQB2NMI_WIDTH;
                              802 ; 155  |        int SUNFL    : HW_RCR_SUNFL_WIDTH;
                              803 ; 156  |        int SOVFL    : HW_RCR_SOVFL_WIDTH;
                              804 ; 157  |    } B;
                              805 ; 158  |
                              806 ; 159  |    int I;
                              807 ; 160  |    unsigned int U;
                              808 ; 161  |
                              809 ; 162  |} rcr_type;
                              810 ; 163  |#define HW_RCR     (*(volatile rcr_type _X*) (0xFA01))
                              811 ; 164  |
                              812 ; 165  |
                              813 ; 166  |/////////////////////////////////////////////////////////////////////////////////
                              814 ; 167  |//  DCLK Count Lower register (HW_DCLKCNTL) Bit Positions
                              815 ; 168  |#define HW_DCLKCNTL_LOW_BITPOS 0
                              816 ; 169  |
                              817 ; 170  |#define HW_DCLKCNTL_LOW_WIDTH (24)        
                              818 ; 171  |
                              819 ; 172  |#define HW_DCLKCNTL_LOW_SETMASK (((1<<HW_DCLKCNTL_LOW_WIDTH)-1)<<HW_DCLKCNTL_LOW_BITPOS) 
                              820 ; 173  |#define HW_DCLKCNTL_LOW_CLRMASK ~(WORD)HW_DCLKCNTL_LOW_SETMASK
                              821 ; 174  |typedef union               
                              822 ; 175  |{
                              823 ; 176  |    struct
                              824 ; 177  |   {
                              825 ; 178  |        int LOW;
                              826 ; 179  |    } B;
                              827 ; 180  |
                              828 ; 181  |    int I;
                              829 ; 182  |    unsigned int U;
                              830 ; 183  |
                              831 ; 184  |} dclkcntl_type;
                              832 ; 185  |#define HW_DCLKCNTL (*(volatile dclkcntl_type _X*) (0xFFEA))
                              833 ; 186  |
                              834 ; 187  |/////////////////////////////////////////////////////////////////////////////////
                              835 ; 188  |//  DCLK Count UPPER register (HW_DCLKCNTU) Bit Positions
                              836 ; 189  |#define HW_DCLKCNTU_HIGH_BITPOS 0
                              837 ; 190  |
                              838 ; 191  |#define HW_DCLKCNTU_HIGH_WIDTH (24)        
                              839 ; 192  |
                              840 ; 193  |#define HW_DCLKCNTU_HIGH_SETMASK (((1<<HW_DCLKCNTU_HIGH_WIDTH)-1)<<HW_DCLKCNTU_HIGH_BITPOS) 
                              841 ; 194  |#define HW_DCLKCNTU_HIGH_CLRMASK ~(WORD)HW_DCLKCNTU_HIGH_SETMASK
                              842 ; 195  |typedef union               
                              843 ; 196  |{
                              844 ; 197  |    struct
                              845 ; 198  |   {
                              846 ; 199  |        int HIGH;
                              847 ; 200  |    } B;
                              848 ; 201  |
                              849 ; 202  |    int I;
                              850 ; 203  |    unsigned int U;
                              851 ; 204  |
                              852 ; 205  |} dclkcntu_type;
                              853 ; 206  |#define HW_DCLKCNTU (*(volatile dclkcntu_type _X*) (0xFFEB))
                              854 ; 207  |
                              855 ; 208  |//*********************  REGISTER ALIAS DEFINES TO MATCH LEGACY CODE *******************************
                              856 ; 209  |// The following defines were added to match regs3410.inc definition to build SDK2XXX code without needing 
                              857 ; 210  |// to update the actual files. Only the defines needed to build SDK2.400 were added. 
                              858 ; 211  |
                              859 ; 212  |// Clock count register (lower)
                              860 ; 213  |#define HW_CLK_CNT_L 0x00FFEA         
                              861 ; 214  |// Clock count register (upper)
                              862 ; 215  |#define HW_CLK_CNT_U 0x00FFEB         
                              863 ; 216  |// Cycle steal count register
                              864 ; 217  |#define HW_CYC_STEAL 0x00FFEC         
                              865 ; 218  |
                              866 ; 219  |#endif
                              867 ; 220  |
                              868 ; 221  |
                              869 
                              871 
                              872 ; 18   |#include "regscore.h"
                              873 
                              875 
                              876 ; 1    |#if !(defined(__REGS_STATUS_INC))
                              877 ; 2    |#define __REGS_STATUS_INC 1
                              878 ; 3    |
                              879 ; 4    |
                              880 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                              881 ; 6    |//  OMR Register (HW_OMR) Bit Positions
                              882 ; 7    |#define HW_OMR_MA_BITPOS 0
                              883 ; 8    |#define HW_OMR_MB_BITPOS 1
                              884 ; 9    |#define HW_OMR_DE_BITPOS 2
                              885 ; 10   |#define HW_OMR_YE_BITPOS 3
                              886 ; 11   |#define HW_OMR_MC_BITPOS 4
                              887 ; 12   |#define HW_OMR_SD_BITPOS 6
                              888 ; 13   |
                              889 ; 14   |#define HW_OMR_MA_SETMASK 1<<HW_OMR_MA_BITPOS
                              890 ; 15   |#define HW_OMR_MB_SETMASK 1<<HW_OMR_MB_BITPOS
                              891 ; 16   |#define HW_OMR_DE_SETMASK 1<<HW_OMR_DE_BITPOS
                              892 ; 17   |#define HW_OMR_YE_SETMASK 1<<HW_OMR_YE_BITPOS
                              893 ; 18   |#define HW_OMR_MC_SETMASK 1<<HW_OMR_MC_BITPOS
                              894 ; 19   |#define HW_OMR_SD_SETMASK 1<<HW_OMR_SD_BITPOS
                              895 ; 20   |
                              896 ; 21   |#define HW_OMR_MA_CLRMASK ~(WORD)HW_OMR_MA_SETMASK
                              897 ; 22   |#define HW_OMR_MB_CLRMASK ~(WORD)HW_OMR_MB_SETMASK
                              898 ; 23   |#define HW_OMR_DE_CLRMASK ~(WORD)HW_OMR_DE_SETMASK
                              899 ; 24   |#define HW_OMR_YE_CLRMASK ~(WORD)HW_OMR_YE_SETMASK
                              900 ; 25   |#define HW_OMR_MC_CLRMASK ~(WORD)HW_OMR_MC_SETMASK
                              901 ; 26   |#define HW_OMR_SD_CLRMASK ~(WORD)HW_OMR_SD_SETMASK
                              902 ; 27   |
                              903 ; 28   |
                              904 ; 29   |/////////////////////////////////////////////////////////////////////////////////
                              905 ; 30   |//  Status Register (HW_SR) Bit Positions
                              906 ; 31   |#define HW_SR_C_BITPOS 0
                              907 ; 32   |#define HW_SR_O_BITPOS 1
                              908 ; 33   |#define HW_SR_Z_BITPOS 2
                              909 ; 34   |#define HW_SR_N_BITPOS 3
                              910 ; 35   |#define HW_SR_U_BITPOS 4
                              911 ; 36   |#define HW_SR_E_BITPOS 5
                              912 ; 37   |#define HW_SR_L_BITPOS 6
                              913 ; 38   |#define HW_SR_IM_BITPOS 8
                              914 ; 39   |#define HW_SR_IM0_BITPOS 8
                              915 ; 40   |#define HW_SR_IM1_BITPOS 9
                              916 ; 41   |#define HW_SR_SM_BITPOS 10
                              917 ; 42   |#define HW_SR_SM0_BITPOS 10
                              918 ; 43   |#define HW_SR_SM1_BITPOS 11
                              919 ; 44   |#define HW_SR_TM_BITPOS 13
                              920 ; 45   |#define HW_SR_DP_BITPOS 14
                              921 ; 46   |#define HW_SR_LOOP_BITPOS 15
                              922 ; 47   |
                              923 ; 48   |#define HW_SR_C_SETMASK 1<<HW_SR_C_BITPOS
                              924 ; 49   |#define HW_SR_O_SETMASK 1<<HW_SR_O_BITPOS
                              925 ; 50   |#define HW_SR_Z_SETMASK 1<<HW_SR_Z_BITPOS
                              926 ; 51   |#define HW_SR_N_SETMASK 1<<HW_SR_N_BITPOS
                              927 ; 52   |#define HW_SR_U_SETMASK 1<<HW_SR_U_BITPOS
                              928 ; 53   |#define HW_SR_E_SETMASK 1<<HW_SR_E_BITPOS
                              929 ; 54   |#define HW_SR_L_SETMASK 1<<HW_SR_L_BITPOS
                              930 ; 55   |#define HW_SR_IM_SETMASK 3<<HW_SR_IM_BITPOS
                              931 ; 56   |#define HW_SR_IM0_SETMASK 1<<HW_SR_IM0_BITPOS
                              932 ; 57   |#define HW_SR_IM1_SETMASK 1<<HW_SR_IM1_BITPOS
                              933 ; 58   |#define HW_SR_IM_L0_SETMASK 0<<HW_SR_IM_BITPOS
                              934 ; 59   |#define HW_SR_IM_L1_SETMASK 1<<HW_SR_IM_BITPOS
                              935 ; 60   |#define HW_SR_IM_L2_SETMASK 2<<HW_SR_IM_BITPOS
                              936 ; 61   |#define HW_SR_IM_L3_SETMASK 3<<HW_SR_IM_BITPOS
                              937 ; 62   |#define HW_SR_SM_SETMASK 3<<HW_SR_SM_BITPOS
                              938 ; 63   |#define HW_SR_SM0_SETMASK 1<<HW_SR_SM0_BITPOS
                              939 ; 64   |#define HW_SR_SM1_SETMASK 1<<HW_SR_SM1_BITPOS
                              940 ; 65   |#define HW_SR_TM_SETMASK 1<<HW_SR_TM_BITPOS
                              941 ; 66   |#define HW_SR_DP_SETMASK 1<<HW_SR_DP_BITPOS
                              942 ; 67   |#define HW_SR_LOOP_SETMASK 1<<HW_SR_LOOP_BITPOS
                              943 ; 68   |
                              944 ; 69   |#define HW_SR_C_CLRMASK ~(WORD)HW_SR_C_SETMASK
                              945 ; 70   |#define HW_SR_O_CLRMASK ~(WORD)HW_SR_O_SETMASK
                              946 ; 71   |#define HW_SR_Z_CLRMASK ~(WORD)HW_SR_Z_SETMASK
                              947 ; 72   |#define HW_SR_N_CLRMASK ~(WORD)HW_SR_N_SETMASK
                              948 ; 73   |#define HW_SR_U_CLRMASK ~(WORD)HW_SR_U_SETMASK
                              949 ; 74   |#define HW_SR_E_CLRMASK ~(WORD)HW_SR_E_SETMASK
                              950 ; 75   |#define HW_SR_L_CLRMASK ~(WORD)HW_SR_L_SETMASK
                              951 ; 76   |#define HW_SR_IM_CLRMASK (0x00FFFF)&(~(WORD)HW_SR_IM_SETMASK)
                              952 ; 77   |#define HW_SR_IM0_CLRMASK ~(WORD)HW_SR_IM0_SETMASK
                              953 ; 78   |#define HW_SR_IM1_CLRMASK ~(WORD)HW_SR_IM1_SETMASK
                              954 ; 79   |#define HW_SR_SM_CLRMASK ~(WORD)HW_SR_SM_SETMASK
                              955 ; 80   |#define HW_SR_SM0_CLRMASK ~(WORD)HW_SR_SM0_SETMASK
                              956 ; 81   |#define HW_SR_SM1_CLRMASK ~(WORD)HW_SR_SM1_SETMASK
                              957 ; 82   |#define HW_SR_TM_CLRMASK ~(WORD)HW_SR_TM_SETMASK
                              958 ; 83   |#define HW_SR_DP_CLRMASK ~(WORD)HW_SR_DP_SETMASK
                              959 ; 84   |#define HW_SR_LOOP_CLRMASK ~(WORD)HW_SR_LOOP_SETMASK
                              960 ; 85   |
                              961 ; 86   |/////////////////////////////////////////////////////////////////////////////////
                              962 ; 87   |//  RAM/ROM Config Register Bit Positions
                              963 ; 88   |#define HW_RAM_ROM_CFG_ROM_IMAGE_EN_BITPOS 18
                              964 ; 89   |#define HW_RAM_ROM_CFG_ROM_CLK_EN_BITPOS 19
                              965 ; 90   |#define HW_RAM_ROM_CFG_PXRAM_CLK_EN_BITPOS 20
                              966 ; 91   |#define HW_RAM_ROM_CFG_PYRAM_CLK_EN_BITPOS 21
                              967 ; 92   |#endif
                              968 ; 93   |
                              969 ; 94   |
                              970 
                              972 
                              973 ; 19   |#include "regscodec.h"
                              974 
                              976 
                              977 ; 1    |#if !(defined(regscodecinc))
                              978 ; 2    |#define regscodecinc 1
                              979 ; 3    |
                              980 ; 4    |
                              981 ; 5    |
                              982 ; 6    |#include "types.h"
                              983 
                              985 
                              986 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              987 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              988 ; 3    |//
                              989 ; 4    |// Filename: types.h
                              990 ; 5    |// Description: Standard data types
                              991 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              992 ; 7    |
                              993 ; 8    |#ifndef _TYPES_H
                              994 ; 9    |#define _TYPES_H
                              995 ; 10   |
                              996 ; 11   |// TODO:  move this outta here!
                              997 ; 12   |#if !defined(NOERROR)
                              998 ; 13   |#define NOERROR 0
                              999 ; 14   |#define SUCCESS 0
                             1000 ; 15   |#endif 
                             1001 ; 16   |#if !defined(SUCCESS)
                             1002 ; 17   |#define SUCCESS  0
                             1003 ; 18   |#endif
                             1004 ; 19   |#if !defined(ERROR)
                             1005 ; 20   |#define ERROR   -1
                             1006 ; 21   |#endif
                             1007 ; 22   |#if !defined(FALSE)
                             1008 ; 23   |#define FALSE 0
                             1009 ; 24   |#endif
                             1010 ; 25   |#if !defined(TRUE)
                             1011 ; 26   |#define TRUE  1
                             1012 ; 27   |#endif
                             1013 ; 28   |
                             1014 ; 29   |#if !defined(NULL)
                             1015 ; 30   |#define NULL 0
                             1016 ; 31   |#endif
                             1017 ; 32   |
                             1018 ; 33   |#define MAX_INT     0x7FFFFF
                             1019 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             1020 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             1021 ; 36   |#define MAX_ULONG   (-1) 
                             1022 ; 37   |
                             1023 ; 38   |#define WORD_SIZE   24              // word size in bits
                             1024 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             1025 ; 40   |
                             1026 ; 41   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   5

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1027 ; 42   |#define BYTE    unsigned char       // btVarName
                             1028 ; 43   |#define CHAR    signed char         // cVarName
                             1029 ; 44   |#define USHORT  unsigned short      // usVarName
                             1030 ; 45   |#define SHORT   unsigned short      // sVarName
                             1031 ; 46   |#define WORD    unsigned int        // wVarName
                             1032 ; 47   |#define INT     signed int          // iVarName
                             1033 ; 48   |#define DWORD   unsigned long       // dwVarName
                             1034 ; 49   |#define LONG    signed long         // lVarName
                             1035 ; 50   |#define BOOL    unsigned int        // bVarName
                             1036 ; 51   |#define FRACT   _fract              // frVarName
                             1037 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             1038 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             1039 ; 54   |#define FLOAT   float               // fVarName
                             1040 ; 55   |#define DBL     double              // dVarName
                             1041 ; 56   |#define ENUM    enum                // eVarName
                             1042 ; 57   |#define CMX     _complex            // cmxVarName
                             1043 ; 58   |typedef WORD UCS3;                   // 
                             1044 ; 59   |
                             1045 ; 60   |#define UINT16  unsigned short
                             1046 ; 61   |#define UINT8   unsigned char   
                             1047 ; 62   |#define UINT32  unsigned long
                             1048 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1049 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1050 ; 65   |#define WCHAR   UINT16
                             1051 ; 66   |
                             1052 ; 67   |//UINT128 is 16 bytes or 6 words
                             1053 ; 68   |typedef struct UINT128_3500 {   
                             1054 ; 69   |    int val[6];     
                             1055 ; 70   |} UINT128_3500;
                             1056 ; 71   |
                             1057 ; 72   |#define UINT128   UINT128_3500
                             1058 ; 73   |
                             1059 ; 74   |// Little endian word packed byte strings:   
                             1060 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1061 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1062 ; 77   |// Little endian word packed byte strings:   
                             1063 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1064 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1065 ; 80   |
                             1066 ; 81   |// Declare Memory Spaces To Use When Coding
                             1067 ; 82   |// A. Sector Buffers
                             1068 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             1069 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             1070 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             1071 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             1072 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             1073 ; 88   |// B. Media DDI Memory
                             1074 ; 89   |#define MEDIA_DDI_MEM _Y
                             1075 ; 90   |
                             1076 ; 91   |
                             1077 ; 92   |
                             1078 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             1079 ; 94   |// Examples of circular pointers:
                             1080 ; 95   |//    INT CIRC cpiVarName
                             1081 ; 96   |//    DWORD CIRC cpdwVarName
                             1082 ; 97   |
                             1083 ; 98   |#define RETCODE INT                 // rcVarName
                             1084 ; 99   |
                             1085 ; 100  |// generic bitfield structure
                             1086 ; 101  |struct Bitfield {
                             1087 ; 102  |    unsigned int B0  :1;
                             1088 ; 103  |    unsigned int B1  :1;
                             1089 ; 104  |    unsigned int B2  :1;
                             1090 ; 105  |    unsigned int B3  :1;
                             1091 ; 106  |    unsigned int B4  :1;
                             1092 ; 107  |    unsigned int B5  :1;
                             1093 ; 108  |    unsigned int B6  :1;
                             1094 ; 109  |    unsigned int B7  :1;
                             1095 ; 110  |    unsigned int B8  :1;
                             1096 ; 111  |    unsigned int B9  :1;
                             1097 ; 112  |    unsigned int B10 :1;
                             1098 ; 113  |    unsigned int B11 :1;
                             1099 ; 114  |    unsigned int B12 :1;
                             1100 ; 115  |    unsigned int B13 :1;
                             1101 ; 116  |    unsigned int B14 :1;
                             1102 ; 117  |    unsigned int B15 :1;
                             1103 ; 118  |    unsigned int B16 :1;
                             1104 ; 119  |    unsigned int B17 :1;
                             1105 ; 120  |    unsigned int B18 :1;
                             1106 ; 121  |    unsigned int B19 :1;
                             1107 ; 122  |    unsigned int B20 :1;
                             1108 ; 123  |    unsigned int B21 :1;
                             1109 ; 124  |    unsigned int B22 :1;
                             1110 ; 125  |    unsigned int B23 :1;
                             1111 ; 126  |};
                             1112 ; 127  |
                             1113 ; 128  |union BitInt {
                             1114 ; 129  |        struct Bitfield B;
                             1115 ; 130  |        int        I;
                             1116 ; 131  |};
                             1117 ; 132  |
                             1118 ; 133  |#define MAX_MSG_LENGTH 10
                             1119 ; 134  |struct CMessage
                             1120 ; 135  |{
                             1121 ; 136  |        unsigned int m_uLength;
                             1122 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1123 ; 138  |};
                             1124 ; 139  |
                             1125 ; 140  |typedef struct {
                             1126 ; 141  |    WORD m_wLength;
                             1127 ; 142  |    WORD m_wMessage;
                             1128 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1129 ; 144  |} Message;
                             1130 ; 145  |
                             1131 ; 146  |struct MessageQueueDescriptor
                             1132 ; 147  |{
                             1133 ; 148  |        int *m_pBase;
                             1134 ; 149  |        int m_iModulo;
                             1135 ; 150  |        int m_iSize;
                             1136 ; 151  |        int *m_pHead;
                             1137 ; 152  |        int *m_pTail;
                             1138 ; 153  |};
                             1139 ; 154  |
                             1140 ; 155  |struct ModuleEntry
                             1141 ; 156  |{
                             1142 ; 157  |    int m_iSignaledEventMask;
                             1143 ; 158  |    int m_iWaitEventMask;
                             1144 ; 159  |    int m_iResourceOfCode;
                             1145 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1146 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             1147 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1148 ; 163  |    int m_uTimeOutHigh;
                             1149 ; 164  |    int m_uTimeOutLow;
                             1150 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1151 ; 166  |};
                             1152 ; 167  |
                             1153 ; 168  |union WaitMask{
                             1154 ; 169  |    struct B{
                             1155 ; 170  |        unsigned int m_bNone     :1;
                             1156 ; 171  |        unsigned int m_bMessage  :1;
                             1157 ; 172  |        unsigned int m_bTimer    :1;
                             1158 ; 173  |        unsigned int m_bButton   :1;
                             1159 ; 174  |    } B;
                             1160 ; 175  |    int I;
                             1161 ; 176  |} ;
                             1162 ; 177  |
                             1163 ; 178  |
                             1164 ; 179  |struct Button {
                             1165 ; 180  |        WORD wButtonEvent;
                             1166 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1167 ; 182  |};
                             1168 ; 183  |
                             1169 ; 184  |struct Message {
                             1170 ; 185  |        WORD wMsgLength;
                             1171 ; 186  |        WORD wMsgCommand;
                             1172 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1173 ; 188  |};
                             1174 ; 189  |
                             1175 ; 190  |union EventTypes {
                             1176 ; 191  |        struct CMessage msg;
                             1177 ; 192  |        struct Button Button ;
                             1178 ; 193  |        struct Message Message;
                             1179 ; 194  |};
                             1180 ; 195  |
                             1181 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1182 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1183 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1184 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1185 ; 200  |
                             1186 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1187 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1188 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1189 ; 204  |
                             1190 ; 205  |#if DEBUG
                             1191 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1192 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1193 ; 208  |#else 
                             1194 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             1195 ; 210  |#define DebugBuildAssert(x)    
                             1196 ; 211  |#endif
                             1197 ; 212  |
                             1198 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1199 ; 214  |//  #pragma asm
                             1200 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1201 ; 216  |//  #pragma endasm
                             1202 ; 217  |
                             1203 ; 218  |
                             1204 ; 219  |#ifdef COLOR_262K
                             1205 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             1206 ; 221  |#elif defined(COLOR_65K)
                             1207 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             1208 ; 223  |#else
                             1209 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             1210 ; 225  |#endif
                             1211 ; 226  |    
                             1212 ; 227  |#endif // #ifndef _TYPES_H
                             1213 
                             1215 
                             1216 ; 7    |
                             1217 ; 8    |
                             1218 ; 9    |
                             1219 ; 10   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             1220 ; 11   |
                             1221 ; 12   |//   SYSTEM STMP Registers 
                             1222 ; 13   |//      Last Edited 7.17.2003 M. Henson
                             1223 ; 14   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             1224 ; 15   |
                             1225 ; 16   |#define HW_CODEC_BASEADDR (0xFA00)
                             1226 ; 17   |
                             1227 ; 18   |
                             1228 ; 19   |
                             1229 ; 20   |
                             1230 ; 21   |
                             1231 ; 22   |
                             1232 ; 23   |/////////////////////////////////////////////////////////////////////////////////
                             1233 ; 24   |//   Headphone Control Register (HW_HPCTRL) Bit Definitions
                             1234 ; 25   |#define HW_HPCTRL_TESTIALL_BITPOS 0
                             1235 ; 26   |#define HW_HPCTRL_TESTI1_BITPOS 2
                             1236 ; 27   |#define HW_HPCTRL_POP0_BITPOS 4
                             1237 ; 28   |#define HW_HPCTRL_POP1_BITPOS 5
                             1238 ; 29   |#define HW_HPCTRL_POP2_BITPOS 6
                             1239 ; 30   |#define HW_HPCTRL_RSVD0_BITPOS 7
                             1240 ; 31   |#define HW_HPCTRL_HPPWD_BITPOS 8
                             1241 ; 32   |#define HW_HPCTRL_HPCLASSAB_BITPOS 9
                             1242 ; 33   |#define HW_HPCTRL_CAPLESS_BITPOS 10
                             1243 ; 34   |#define HW_HPCTRL_RSRVD1_BITPOS 11
                             1244 ; 35   |#define HW_HPCTRL_SHORTMODE_LR_BITPOS 12
                             1245 ; 36   |#define HW_HPCTRL_SHORTMODE_CM_BITPOS 14
                             1246 ; 37   |#define HW_HPCTRL_SHORT_LVLADJ_BITPOS 16
                             1247 ; 38   |#define HW_HPCTRL_RSRVD2_BITPOS 19
                             1248 ; 39   |#define HW_HPCTRL_CHOP_CLK_BITPOS 20
                             1249 ; 40   |#define HW_HPCTRL_SHORT_LR_BITPOS 22
                             1250 ; 41   |#define HW_HPCTRL_SHORT_CM_BITPOS 23
                             1251 ; 42   |
                             1252 ; 43   |#define HW_HPCTRL_TESTIALL_WIDTH 2
                             1253 ; 44   |#define HW_HPCTRL_TESTI1_WIDTH 2
                             1254 ; 45   |#define HW_HPCTRL_POP0_WIDTH 1
                             1255 ; 46   |#define HW_HPCTRL_POP1_WIDTH 1
                             1256 ; 47   |#define HW_HPCTRL_POP2_WIDTH 1
                             1257 ; 48   |#define HW_HPCTRL_RSVD0_WIDTH 1
                             1258 ; 49   |#define HW_HPCTRL_HPPWD_WIDTH 1
                             1259 ; 50   |#define HW_HPCTRL_HPCLASSAB_WIDTH 1
                             1260 ; 51   |#define HW_HPCTRL_CAPLESS_WIDTH 1
                             1261 ; 52   |#define HW_HPCTRL_RSRVD1_WIDTH 1
                             1262 ; 53   |#define HW_HPCTRL_SHORTMODE_LR_WIDTH 2
                             1263 ; 54   |#define HW_HPCTRL_SHORTMODE_CM_WIDTH 2
                             1264 ; 55   |#define HW_HPCTRL_SHORT_LVLADJ_WIDTH 3
                             1265 ; 56   |#define HW_HPCTRL_RSRVD2_WIDTH 1
                             1266 ; 57   |#define HW_HPCTRL_CHOP_CLK_WIDTH 2
                             1267 ; 58   |#define HW_HPCTRL_SHORT_LR_WIDTH 1
                             1268 ; 59   |#define HW_HPCTRL_SHORT_CM_WIDTH 1
                             1269 ; 60   |
                             1270 ; 61   |#define HW_HPCTRL_POP_SETMASK 0x7<<HW_HPCTRL_POP0_BITPOS
                             1271 ; 62   |#define HW_HPCTRL_POP_CLRMASK ~(WORD)HW_HPCTRL_POP_SETMASK
                             1272 ; 63   |
                             1273 ; 64   |#define HW_HPCTRL_SHORT_LVLADJ_0_25X_SETMASK 0x3<<HW_HPCTRL_SHORT_LVLADJ_BITPOS
                             1274 ; 65   |#define HW_HPCTRL_SHORT_LVLADJ_0_50X_SETMASK 0x2<<HW_HPCTRL_SHORT_LVLADJ_BITPOS
                             1275 ; 66   |#define HW_HPCTRL_SHORT_LVLADJ_0_75X_SETMASK 0x1<<HW_HPCTRL_SHORT_LVLADJ_BITPOS
                             1276 ; 67   |#define HW_HPCTRL_SHORT_LVLADJ_1_00X_SETMASK 0x0<<HW_HPCTRL_SHORT_LVLADJ_BITPOS
                             1277 ; 68   |#define HW_HPCTRL_SHORT_LVLADJ_1_25X_SETMASK 0x4<<HW_HPCTRL_SHORT_LVLADJ_BITPOS
                             1278 ; 69   |#define HW_HPCTRL_SHORT_LVLADJ_1_50X_SETMASK 0x5<<HW_HPCTRL_SHORT_LVLADJ_BITPOS
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   6

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1279 ; 70   |#define HW_HPCTRL_SHORT_LVLADJ_1_75X_SETMASK 0x6<<HW_HPCTRL_SHORT_LVLADJ_BITPOS
                             1280 ; 71   |#define HW_HPCTRL_SHORT_LVLADJ_2_00X_SETMASK 0x7<<HW_HPCTRL_SHORT_LVLADJ_BITPOS
                             1281 ; 72   |
                             1282 ; 73   |#if defined(CAPLESS_HP)
                             1283 ; 74   |#define HP_SHORT_TRIP_POINT HW_HPCTRL_SHORT_LVLADJ_0_75X_SETMASK
                             1284 ; 75   |#else 
                             1285 ; 76   |#define HP_SHORT_TRIP_POINT HW_HPCTRL_SHORT_LVLADJ_1_00X_SETMASK
                             1286 ; 77   |#endif
                             1287 ; 78   |
                             1288 ; 79   |// Headphone control register
                             1289 ; 80   |#define HW_HPCTRL (*(volatile hpctrl_type _X*)(HW_GLUE_BASEADDR+21))
                             1290 ; 81   |/////////////////////////////////////////////////////////////////////////////////
                             1291 ; 82   |//   Headphone Conrol Volume Register (HW_HPCTRL) Bit Definitions
                             1292 ; 83   |typedef union               
                             1293 ; 84   |{
                             1294 ; 85   |    struct {
                             1295 ; 86   |        unsigned TESTIALL :HW_HPCTRL_TESTIALL_WIDTH;
                             1296 ; 87   |        unsigned TESTI1 :HW_HPCTRL_TESTI1_WIDTH;
                             1297 ; 88   |        unsigned POP0 :HW_HPCTRL_POP0_WIDTH; 
                             1298 ; 89   |        unsigned POP1 :HW_HPCTRL_POP1_WIDTH; 
                             1299 ; 90   |        unsigned POP2 :HW_HPCTRL_POP2_WIDTH; 
                             1300 ; 91   |        unsigned RSVD0 :HW_HPCTRL_RSVD0_WIDTH;
                             1301 ; 92   |        unsigned HPPWD :HW_HPCTRL_HPPWD_WIDTH;
                             1302 ; 93   |        unsigned HPCLASSAB :HW_HPCTRL_HPCLASSAB_WIDTH;
                             1303 ; 94   |        unsigned CAPLESS :HW_HPCTRL_CAPLESS_WIDTH; 
                             1304 ; 95   |        unsigned RSRVD1 :HW_HPCTRL_RSRVD1_WIDTH;
                             1305 ; 96   |        unsigned SHORTMODE_LR :HW_HPCTRL_SHORTMODE_LR_WIDTH; 
                             1306 ; 97   |        unsigned SHORTMODE_CM :HW_HPCTRL_SHORTMODE_CM_WIDTH;
                             1307 ; 98   |        unsigned SHORT_LVLADJ :HW_HPCTRL_SHORT_LVLADJ_WIDTH; 
                             1308 ; 99   |        unsigned RSRVD2 :HW_HPCTRL_RSRVD2_WIDTH;
                             1309 ; 100  |        unsigned CHOP_CLK :HW_HPCTRL_CHOP_CLK_WIDTH; 
                             1310 ; 101  |        unsigned SHORT_LR :HW_HPCTRL_SHORT_LR_WIDTH;
                             1311 ; 102  |        unsigned SHORT_CM :HW_HPCTRL_SHORT_CM_WIDTH;
                             1312 ; 103  |    } B;
                             1313 ; 104  |    int I;
                             1314 ; 105  |    unsigned int U;
                             1315 ; 106  |} hpctrl_type;
                             1316 ; 107  |// Headphone control short mode 2 bit values for above short bitfield.
                             1317 ; 108  |#define HW_AUTO_HEADAMP_SHUTDOWN_HOLD_RESET   0
                             1318 ; 109  |#define HW_AUTO_HEADAMP_SHUTDOWN_EN           1 
                             1319 ; 110  |#define HW_AUTO_HEADAMP_SHUTDOWN_DIS          2
                             1320 ; 111  |#define HW_AUTO_HEADAMP_SHUTDOWN_DIRECT       3
                             1321 ; 112  |
                             1322 ; 113  |
                             1323 ; 114  |/////////////////////////////////////////////////////////////////////////////////
                             1324 ; 115  |/////////////////////////////////////////////////////////////////////////////////
                             1325 ; 116  |/////////////////////////////////////////////////////////////////////////////////
                             1326 ; 117  |/////////////////////////////////////////////////////////////////////////////////
                             1327 ; 118  |///////   MIXER REGISTERS ///////////////////////////////////////////////////////
                             1328 ; 119  |/////////////////////////////////////////////////////////////////////////////////
                             1329 ; 120  |/////////////////////////////////////////////////////////////////////////////////
                             1330 ; 121  |/////////////////////////////////////////////////////////////////////////////////
                             1331 ; 122  |
                             1332 ; 123  |
                             1333 ; 124  |/////////////////////////////////////////////////////////////////////////////////
                             1334 ; 125  |//   Codec/Mixer Test Register (HW_MIXTBR) Bit Definitions 
                             1335 ; 126  |#define HW_MIXTBR_INV_USB_CLK_BITPOS 0
                             1336 ; 127  |#define HW_MIXTBR_USB_DFF_BYPASS_BITPOS 1
                             1337 ; 128  |#define HW_MIXTBR_HOLD_GND_BITPOS 2
                             1338 ; 129  |#define HW_MIXTBR_ACKI_BITPOS 3
                             1339 ; 130  |#define HW_MIXTBR_ASD2X_BITPOS 4
                             1340 ; 131  |#define HW_MIXTBR_PCPCU_BITPOS 5
                             1341 ; 132  |#define HW_MIXTBR_PCPCD_BITPOS 6
                             1342 ; 133  |#define HW_MIXTBR_DCKI_BITPOS 7
                             1343 ; 134  |#define HW_MIXTBR_MIC_BIAS_OUT_SEL_BITPOS 8
                             1344 ; 135  |#define HW_MIXTBR_PSRN_BITPOS 9
                             1345 ; 136  |#define HW_MIXTBR_FX2_BITPOS 10
                             1346 ; 137  |#define HW_MIXTBR_VCOS_BITPOS 11
                             1347 ; 138  |#define HW_MIXTBR_XBCO_BITPOS 12
                             1348 ; 139  |#define HW_MIXTBR_XBGC_BITPOS 13
                             1349 ; 140  |#define HW_MIXTBR_ADTHD_BITPOS 14
                             1350 ; 141  |#define HW_MIXTBR_MICBIAS_LSBITPOS 15
                             1351 ; 142  |#define HW_MIXTBR_PWDADC_BITPOS 16
                             1352 ; 143  |#define HW_MIXTBR_MICBIAS1_BITPOS 17
                             1353 ; 144  |#define HW_MIXTBR_EZD_BITPOS 18
                             1354 ; 145  |#define HW_MIXTBR_DZCDA_BITPOS 19
                             1355 ; 146  |#define HW_MIXTBR_DZCFM_BITPOS 20
                             1356 ; 147  |#define HW_MIXTBR_DZCLI_BITPOS 21
                             1357 ; 148  |#define HW_MIXTBR_DZCMI_BITPOS 22
                             1358 ; 149  |#define HW_MIXTBR_DZCMA_BITPOS 23
                             1359 ; 150  |
                             1360 ; 151  |#define HW_MIXTBR_INV_USB_CLK_WIDTH (1)
                             1361 ; 152  |#define HW_MIXTBR_USB_DFF_BYPASS_WIDTH (1)
                             1362 ; 153  |#define HW_MIXTBR_HOLD_GND_WIDTH (1)
                             1363 ; 154  |#define HW_MIXTBR_ACKI_WIDTH (1)
                             1364 ; 155  |#define HW_MIXTBR_ASD2X_WIDTH (1)
                             1365 ; 156  |#define HW_MIXTBR_PCPCU_WIDTH (1)
                             1366 ; 157  |#define HW_MIXTBR_PCPCD_WIDTH (1)
                             1367 ; 158  |#define HW_MIXTBR_DCKI_WIDTH (1)
                             1368 ; 159  |#define HW_MIXTBR_MIC_BIAS_OUT_SEL_WIDTH (1)
                             1369 ; 160  |#define HW_MIXTBR_PSRN_WIDTH (1)
                             1370 ; 161  |#define HW_MIXTBR_FX2_WIDTH (1)
                             1371 ; 162  |#define HW_MIXTBR_VCOS_WIDTH (1)
                             1372 ; 163  |#define HW_MIXTBR_XBCO_WIDTH (1)
                             1373 ; 164  |#define HW_MIXTBR_XBGC_WIDTH (1)
                             1374 ; 165  |#define HW_MIXTBR_ADTHD_WIDTH (1)
                             1375 ; 166  |#define HW_MIXTBR_MICBIAS_LSWIDTH (1)
                             1376 ; 167  |#define HW_MIXTBR_PWDADC_WIDTH (1)
                             1377 ; 168  |#define HW_MIXTBR_MICBIAS1_WIDTH (1)
                             1378 ; 169  |#define HW_MIXTBR_EZD_WIDTH (1)
                             1379 ; 170  |#define HW_MIXTBR_DZCDA_WIDTH (1)
                             1380 ; 171  |#define HW_MIXTBR_DZCFM_WIDTH (1)
                             1381 ; 172  |#define HW_MIXTBR_DZCLI_WIDTH (1)
                             1382 ; 173  |#define HW_MIXTBR_DZCMI_WIDTH (1)
                             1383 ; 174  |#define HW_MIXTBR_DZCMA_WIDTH (1)
                             1384 ; 175  |
                             1385 ; 176  |
                             1386 ; 177  |#define HW_MIXTBR_INV_USB_CLK_SETMASK 1<<HW_MIXTBR_INV_USB_CLK_BITPOS
                             1387 ; 178  |#define HW_MIXTBR_USB_DFF_BYPASS_SETMASK 1<<HW_MIXTBR_USB_DFF_BYPASS_BITPOS
                             1388 ; 179  |#define HW_MIXTBR_HOLD_GND_SETMASK 1<<HW_MIXTBR_HOLD_GND_BITPOS
                             1389 ; 180  |#define HW_MIXTBR_ACKI_SETMASK 1<<HW_MIXTBR_ACKI_BITPOS
                             1390 ; 181  |#define HW_MIXTBR_ASD2X_SETMASK 1<<HW_MIXTBR_ASD2X_BITPOS
                             1391 ; 182  |#define HW_MIXTBR_PCPCU_SETMASK 1<<HW_MIXTBR_PCPCU_BITPOS
                             1392 ; 183  |#define HW_MIXTBR_PCPCD_SETMASK 1<<HW_MIXTBR_PCPCD_BITPOS
                             1393 ; 184  |#define HW_MIXTBR_DCKI_SETMASK 1<<HW_MIXTBR_DCKI_BITPOS
                             1394 ; 185  |#define HW_MIXTBR_MIC_BIAS_OUT_SEL_SETMASK 1<<HW_MIXTBR_MIC_BIAS_OUT_SEL_BITPOS
                             1395 ; 186  |#define HW_MIXTBR_PSRN_SETMASK 1<<HW_MIXTBR_PSRN_BITPOS
                             1396 ; 187  |#define HW_MIXTBR_FX2_SETMASK 1<<HW_MIXTBR_FX2_BITPOS
                             1397 ; 188  |#define HW_MIXTBR_VCOS_SETMASK 1<<HW_MIXTBR_VCOS_BITPOS
                             1398 ; 189  |#define HW_MIXTBR_XBCO_SETMASK 1<<HW_MIXTBR_XBCO_BITPOS
                             1399 ; 190  |#define HW_MIXTBR_XBGC_SETMASK 1<<HW_MIXTBR_XBGC_BITPOS
                             1400 ; 191  |#define HW_MIXTBR_ADTHD_SETMASK 1<<HW_MIXTBR_ADTHD_BITPOS
                             1401 ; 192  |#define HW_MIXTBR_MICBIAS_LSSETMASK 1<<HW_MIXTBR_MICBIAS_LSBITPOS
                             1402 ; 193  |#define HW_MIXTBR_PWDADC_SETMASK 1<<HW_MIXTBR_PWDADC_BITPOS
                             1403 ; 194  |#define HW_MIXTBR_MICBIAS1_SETMASK 1<<HW_MIXTBR_MICBIAS1_BITPOS
                             1404 ; 195  |#define HW_MIXTBR_EZD_SETMASK 1<<HW_MIXTBR_EZD_BITPOS
                             1405 ; 196  |#define HW_MIXTBR_DZCDA_SETMASK 1<<HW_MIXTBR_DZCDA_BITPOS
                             1406 ; 197  |#define HW_MIXTBR_DZCFM_SETMASK 1<<HW_MIXTBR_DZCFM_BITPOS
                             1407 ; 198  |#define HW_MIXTBR_DZCLI_SETMASK 1<<HW_MIXTBR_DZCLI_BITPOS
                             1408 ; 199  |#define HW_MIXTBR_DZCMI_SETMASK 1<<HW_MIXTBR_DZCMI_BITPOS
                             1409 ; 200  |#define HW_MIXTBR_DZCMA_SETMASK 1<<HW_MIXTBR_DZCMA_BITPOS
                             1410 ; 201  |
                             1411 ; 202  |#define HW_MIXTBR_INV_USB_CLK_CLRMASK ~(WORD)HW_MIXTBR_INV_USB_CLK_SETMASK
                             1412 ; 203  |#define HW_MIXTBR_USB_DFF_BYPASS_CLRMASK ~(WORD)HW_MIXTBR_USB_DFF_BYPASS_SETMASK
                             1413 ; 204  |#define HW_MIXTBR_HOLD_GND_CLRMASK ~(WORD)HW_MIXTBR_HOLD_GND_SETMASK
                             1414 ; 205  |#define HW_MIXTBR_ACKI_CLRMASK ~(WORD)HW_MIXTBR_ACKI_SETMASK
                             1415 ; 206  |#define HW_MIXTBR_ASD2X_CLRMASK ~(WORD)HW_MIXTBR_ASD2X_SETMASK
                             1416 ; 207  |#define HW_MIXTBR_PCPCU_CLRMASK ~(WORD)HW_MIXTBR_PCPCU_SETMASK
                             1417 ; 208  |#define HW_MIXTBR_PCPCD_CLRMASK ~(WORD)HW_MIXTBR_PCPCD_SETMASK
                             1418 ; 209  |#define HW_MIXTBR_DCKI_CLRMASK ~(WORD)HW_MIXTBR_DCKI_SETMASK
                             1419 ; 210  |#define HW_MIXTBR_MIC_BIAS_OUT_SEL_CLRMASK ~(WORD)HW_MIXTBR_MIC_BIAS_OUT_SEL_SETMASK
                             1420 ; 211  |#define HW_MIXTBR_PSRN_CLRMASK ~(WORD)HW_MIXTBR_PSRN_SETMASK
                             1421 ; 212  |#define HW_MIXTBR_FX2_CLRMASK ~(WORD)HW_MIXTBR_FX2_SETMASK
                             1422 ; 213  |#define HW_MIXTBR_VCOS_CLRMASK ~(WORD)HW_MIXTBR_VCOS_SETMASK
                             1423 ; 214  |#define HW_MIXTBR_XBCO_CLRMASK ~(WORD)HW_MIXTBR_XBCO_SETMASK
                             1424 ; 215  |#define HW_MIXTBR_XBGC_CLRMASK ~(WORD)HW_MIXTBR_XBGC_SETMASK
                             1425 ; 216  |#define HW_MIXTBR_ADTHD_CLRMASK ~(WORD)HW_MIXTBR_ADTHD_SETMASK
                             1426 ; 217  |#define HW_MIXTBR_MICBIAS_LSCLRMASK ~(WORD)HW_MIXTBR_MICBIAS_LSSETMASK
                             1427 ; 218  |#define HW_MIXTBR_PWDADC_CLRMASK ~(WORD)HW_MIXTBR_PWDADC_SETMASK
                             1428 ; 219  |#define HW_MIXTBR_MICBIAS1_CLRMASK ~(WORD)HW_MIXTBR_MICBIAS1_SETMASK
                             1429 ; 220  |#define HW_MIXTBR_EZD_CLRMASK ~(WORD)HW_MIXTBR_EZD_SETMASK
                             1430 ; 221  |#define HW_MIXTBR_DZCDA_CLRMASK ~(WORD)HW_MIXTBR_DZCDA_SETMASK
                             1431 ; 222  |#define HW_MIXTBR_DZCFM_CLRMASK ~(WORD)HW_MIXTBR_DZCFM_SETMASK
                             1432 ; 223  |#define HW_MIXTBR_DZCLI_CLRMASK ~(WORD)HW_MIXTBR_DZCLI_SETMASK
                             1433 ; 224  |#define HW_MIXTBR_DZCMI_CLRMASK ~(WORD)HW_MIXTBR_DZCMI_SETMASK
                             1434 ; 225  |#define HW_MIXTBR_DZCMA_CLRMASK ~(WORD)HW_MIXTBR_DZCMA_SETMASK
                             1435 ; 226  |
                             1436 ; 227  |typedef union               
                             1437 ; 228  |{
                             1438 ; 229  |    struct {
                             1439 ; 230  |        int INV_USB_CLK            : 1;
                             1440 ; 231  |        int USB_DFF_BYPASS         : 1;
                             1441 ; 232  |        int HOLD_GND               : 1;
                             1442 ; 233  |        int ACKI                   : 1;
                             1443 ; 234  |        int ASD2X                  : 1;
                             1444 ; 235  |        int PCPCU                  : 1;
                             1445 ; 236  |        int PCPCD                  : 1;
                             1446 ; 237  |        int DCKI                   : 1;
                             1447 ; 238  |        int MIC_BIAS_OUT_SEL       : 1;
                             1448 ; 239  |        int PSRN                   : 1;
                             1449 ; 240  |        int FX2                    : 1;
                             1450 ; 241  |        int VCOS                   : 1;
                             1451 ; 242  |        int XBCO                   : 1;
                             1452 ; 243  |        int XBGC                   : 1;
                             1453 ; 244  |        int ADTHD                  : 1;
                             1454 ; 245  |        int MICBIAS_LSBITPOS       : 1;
                             1455 ; 246  |        int PWDADC                 : 1;
                             1456 ; 247  |        int MICBIAS1               : 1;
                             1457 ; 248  |        int EZD                    : 1;
                             1458 ; 249  |        int DZCDA                  : 1;
                             1459 ; 250  |        int DZCFM                  : 1;
                             1460 ; 251  |        int DZCLI                  : 1;
                             1461 ; 252  |        int DZCMI                  : 1;
                             1462 ; 253  |        int DZCMA                  : 1;
                             1463 ; 254  |    } B;
                             1464 ; 255  |    int I;
                             1465 ; 256  |    unsigned int U;
                             1466 ; 257  |} mix_tbr_type;
                             1467 ; 258  |#define HW_MIXTBR      (*(volatile mix_tbr_type _X*) (HW_CODEC_BASEADDR+3))
                             1468 ; 259  |
                             1469 ; 260  |
                             1470 ; 261  |/////////////////////////////////////////////////////////////////////////////////
                             1471 ; 262  |//   Generic Volume Register (HW_MIXMASTERVR) Bit Definitions
                             1472 ; 263  |#define HW_MIXVOLUMER_MR_BITPOS 0
                             1473 ; 264  |#define HW_MIXVOLUMER_ML_BITPOS 8
                             1474 ; 265  |#define HW_MIXVOLUMER_MUTE_BITPOS 15
                             1475 ; 266  |
                             1476 ; 267  |#define HW_MIXVOLUMER_MR_WIDTH (5)
                             1477 ; 268  |#define HW_MIXVOLUMER_ML_WIDTH (5)
                             1478 ; 269  |#define HW_MIXVOLUMER_MUTE_WIDTH 1
                             1479 ; 270  |
                             1480 ; 271  |#define HW_MIXVOLUMER_MR_SETMASK 0x1F<<HW_MIXVOLUMER_MR_BITPOS
                             1481 ; 272  |#define HW_MIXVOLUMER_ML_SETMASK 0x1F<<HW_MIXVOLUMER_ML_BITPOS
                             1482 ; 273  |#define HW_MIXVOLUMER_MUTE_SETMASK 1<<HW_MIXVOLUMER_MUTE_BITPOS
                             1483 ; 274  |
                             1484 ; 275  |#define HW_MIXVOLUMER_MR_CLRMASK ~(WORD)HW_MIXVOLUMER_MR_SETMASK
                             1485 ; 276  |#define HW_MIXVOLUMER_ML_CLRMASK ~(WORD)HW_MIXVOLUMER_ML_SETMASK
                             1486 ; 277  |#define HW_MIXVOLUMER_MUTE_CLRMASK ~(WORD)HW_MIXVOLUMER_MUTE_SETMASK
                             1487 ; 278  |
                             1488 ; 279  |#define HW_MIXVOLUMER_ML_PLUS_12P0_SETMASK 0<<HW_MIXVOLUMER_ML_BITPOS
                             1489 ; 280  |#define HW_MIXVOLUMER_ML_PLUS_10P5_SETMASK 1<<HW_MIXVOLUMER_ML_BITPOS
                             1490 ; 281  |#define HW_MIXVOLUMER_ML_PLUS_09P0_SETMASK 2<<HW_MIXVOLUMER_ML_BITPOS
                             1491 ; 282  |#define HW_MIXVOLUMER_ML_PLUS_07P5_SETMASK 3<<HW_MIXVOLUMER_ML_BITPOS
                             1492 ; 283  |#define HW_MIXVOLUMER_ML_PLUS_06P0_SETMASK 4<<HW_MIXVOLUMER_ML_BITPOS
                             1493 ; 284  |#define HW_MIXVOLUMER_ML_PLUS_04P5_SETMASK 5<<HW_MIXVOLUMER_ML_BITPOS
                             1494 ; 285  |#define HW_MIXVOLUMER_ML_PLUS_03P0_SETMASK 6<<HW_MIXVOLUMER_ML_BITPOS
                             1495 ; 286  |#define HW_MIXVOLUMER_ML_PLUS_01P5_SETMASK 7<<HW_MIXVOLUMER_ML_BITPOS
                             1496 ; 287  |#define HW_MIXVOLUMER_ML_ZERO_SETMASK 8<<HW_MIXVOLUMER_ML_BITPOS
                             1497 ; 288  |#define HW_MIXVOLUMER_ML_MINUS_01P5_SETMASK 9<<HW_MIXVOLUMER_ML_BITPOS
                             1498 ; 289  |#define HW_MIXVOLUMER_ML_MINUS_03P0_SETMASK 10<<HW_MIXVOLUMER_ML_BITPOS
                             1499 ; 290  |#define HW_MIXVOLUMER_ML_MINUS_04P5_SETMASK 11<<HW_MIXVOLUMER_ML_BITPOS
                             1500 ; 291  |#define HW_MIXVOLUMER_ML_MINUS_06P0_SETMASK 12<<HW_MIXVOLUMER_ML_BITPOS
                             1501 ; 292  |#define HW_MIXVOLUMER_ML_MINUS_07P5_SETMASK 13<<HW_MIXVOLUMER_ML_BITPOS
                             1502 ; 293  |#define HW_MIXVOLUMER_ML_MINUS_09P0_SETMASK 14<<HW_MIXVOLUMER_ML_BITPOS
                             1503 ; 294  |#define HW_MIXVOLUMER_ML_MINUS_10P5_SETMASK 15<<HW_MIXVOLUMER_ML_BITPOS
                             1504 ; 295  |#define HW_MIXVOLUMER_ML_MINUS_12P0_SETMASK 16<<HW_MIXVOLUMER_ML_BITPOS
                             1505 ; 296  |#define HW_MIXVOLUMER_ML_MINUS_13P5_SETMASK 17<<HW_MIXVOLUMER_ML_BITPOS
                             1506 ; 297  |#define HW_MIXVOLUMER_ML_MINUS_15P0_SETMASK 18<<HW_MIXVOLUMER_ML_BITPOS
                             1507 ; 298  |#define HW_MIXVOLUMER_ML_MINUS_16P5_SETMASK 19<<HW_MIXVOLUMER_ML_BITPOS
                             1508 ; 299  |#define HW_MIXVOLUMER_ML_MINUS_18P0_SETMASK 20<<HW_MIXVOLUMER_ML_BITPOS
                             1509 ; 300  |#define HW_MIXVOLUMER_ML_MINUS_19P5_SETMASK 21<<HW_MIXVOLUMER_ML_BITPOS
                             1510 ; 301  |#define HW_MIXVOLUMER_ML_MINUS_21P0_SETMASK 22<<HW_MIXVOLUMER_ML_BITPOS
                             1511 ; 302  |#define HW_MIXVOLUMER_ML_MINUS_22P5_SETMASK 23<<HW_MIXVOLUMER_ML_BITPOS
                             1512 ; 303  |#define HW_MIXVOLUMER_ML_MINUS_24P0_SETMASK 24<<HW_MIXVOLUMER_ML_BITPOS
                             1513 ; 304  |#define HW_MIXVOLUMER_ML_MINUS_25P5_SETMASK 25<<HW_MIXVOLUMER_ML_BITPOS
                             1514 ; 305  |#define HW_MIXVOLUMER_ML_MINUS_27P0_SETMASK 26<<HW_MIXVOLUMER_ML_BITPOS
                             1515 ; 306  |#define HW_MIXVOLUMER_ML_MINUS_28P5_SETMASK 27<<HW_MIXVOLUMER_ML_BITPOS
                             1516 ; 307  |#define HW_MIXVOLUMER_ML_MINUS_30P0_SETMASK 28<<HW_MIXVOLUMER_ML_BITPOS
                             1517 ; 308  |#define HW_MIXVOLUMER_ML_MINUS_31P5_SETMASK 29<<HW_MIXVOLUMER_ML_BITPOS
                             1518 ; 309  |#define HW_MIXVOLUMER_ML_MINUS_33P0_SETMASK 30<<HW_MIXVOLUMER_ML_BITPOS
                             1519 ; 310  |#define HW_MIXVOLUMER_ML_MINUS_34P5_SETMASK 31<<HW_MIXVOLUMER_ML_BITPOS
                             1520 ; 311  |
                             1521 ; 312  |#define HW_MIXVOLUMER_MR_PLUS_12P0_SETMASK 0
                             1522 ; 313  |#define HW_MIXVOLUMER_MR_PLUS_10P5_SETMASK 1
                             1523 ; 314  |#define HW_MIXVOLUMER_MR_PLUS_09P0_SETMASK 2
                             1524 ; 315  |#define HW_MIXVOLUMER_MR_PLUS_07P5_SETMASK 3
                             1525 ; 316  |#define HW_MIXVOLUMER_MR_PLUS_06P0_SETMASK 4
                             1526 ; 317  |#define HW_MIXVOLUMER_MR_PLUS_04P5_SETMASK 5
                             1527 ; 318  |#define HW_MIXVOLUMER_MR_PLUS_03P0_SETMASK 6
                             1528 ; 319  |#define HW_MIXVOLUMER_MR_PLUS_01P5_SETMASK 7
                             1529 ; 320  |#define HW_MIXVOLUMER_MR_ZERO_SETMASK 8
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   7

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1530 ; 321  |#define HW_MIXVOLUMER_MR_MINUS_01P5_SETMASK 9
                             1531 ; 322  |#define HW_MIXVOLUMER_MR_MINUS_03P0_SETMASK 10
                             1532 ; 323  |#define HW_MIXVOLUMER_MR_MINUS_04P5_SETMASK 11
                             1533 ; 324  |#define HW_MIXVOLUMER_MR_MINUS_06P0_SETMASK 12
                             1534 ; 325  |#define HW_MIXVOLUMER_MR_MINUS_07P5_SETMASK 13
                             1535 ; 326  |#define HW_MIXVOLUMER_MR_MINUS_09P0_SETMASK 14
                             1536 ; 327  |#define HW_MIXVOLUMER_MR_MINUS_10P5_SETMASK 15
                             1537 ; 328  |#define HW_MIXVOLUMER_MR_MINUS_12P0_SETMASK 16
                             1538 ; 329  |#define HW_MIXVOLUMER_MR_MINUS_13P5_SETMASK 17
                             1539 ; 330  |#define HW_MIXVOLUMER_MR_MINUS_15P0_SETMASK 18
                             1540 ; 331  |#define HW_MIXVOLUMER_MR_MINUS_16P5_SETMASK 19
                             1541 ; 332  |#define HW_MIXVOLUMER_MR_MINUS_18P0_SETMASK 20
                             1542 ; 333  |#define HW_MIXVOLUMER_MR_MINUS_19P5_SETMASK 21
                             1543 ; 334  |#define HW_MIXVOLUMER_MR_MINUS_21P0_SETMASK 22
                             1544 ; 335  |#define HW_MIXVOLUMER_MR_MINUS_22P5_SETMASK 23
                             1545 ; 336  |#define HW_MIXVOLUMER_MR_MINUS_24P0_SETMASK 24
                             1546 ; 337  |#define HW_MIXVOLUMER_MR_MINUS_25P5_SETMASK 25
                             1547 ; 338  |#define HW_MIXVOLUMER_MR_MINUS_27P0_SETMASK 26
                             1548 ; 339  |#define HW_MIXVOLUMER_MR_MINUS_28P5_SETMASK 27
                             1549 ; 340  |#define HW_MIXVOLUMER_MR_MINUS_30P0_SETMASK 28
                             1550 ; 341  |#define HW_MIXVOLUMER_MR_MINUS_31P5_SETMASK 29
                             1551 ; 342  |#define HW_MIXVOLUMER_MR_MINUS_33P0_SETMASK 30
                             1552 ; 343  |#define HW_MIXVOLUMER_MR_MINUS_34P5_SETMASK 31
                             1553 ; 344  |
                             1554 ; 345  |/////////////////////////////////////////////////////////////////////////////////
                             1555 ; 346  |//   Mixer Master Volume Register (HW_MIXMASTERVR) Bit Definitions
                             1556 ; 347  |#define HW_MIXMASTERVR_MR_BITPOS 0
                             1557 ; 348  |#define HW_MIXMASTERVR_ML_BITPOS 8
                             1558 ; 349  |#define HW_MIXMASTERVR_MUTE_BITPOS 15
                             1559 ; 350  |
                             1560 ; 351  |#define HW_MIXMASTERVR_MR_WIDTH (5)
                             1561 ; 352  |#define HW_MIXMASTERVR_ML_WIDTH (5)
                             1562 ; 353  |#define HW_MIXMASTERVR_MUTE_WIDTH (1)
                             1563 ; 354  |
                             1564 ; 355  |#define HW_MIXMASTERVR_MR_SETMASK 0x1F<<HW_MIXMASTERVR_MR_BITPOS
                             1565 ; 356  |#define HW_MIXMASTERVR_ML_SETMASK 0x1F<<HW_MIXMASTERVR_ML_BITPOS
                             1566 ; 357  |#define HW_MIXMASTERVR_MUTE_SETMASK 1<<HW_MIXMASTERVR_MUTE_BITPOS
                             1567 ; 358  |
                             1568 ; 359  |#define HW_MIXMASTERVR_MR_CLRMASK ~(WORD)HW_MIXMASTERVR_MR_SETMASK
                             1569 ; 360  |#define HW_MIXMASTERVR_ML_CLRMASK ~(WORD)HW_MIXMASTERVR_ML_SETMASK
                             1570 ; 361  |#define HW_MIXMASTERVR_MUTE_CLRMASK ~(WORD)HW_MIXMASTERVR_MUTE_SETMASK
                             1571 ; 362  |
                             1572 ; 363  |
                             1573 ; 364  |typedef union               
                             1574 ; 365  |{
                             1575 ; 366  |    struct
                             1576 ; 367  |    {
                             1577 ; 368  |        unsigned MR :5;
                             1578 ; 369  |        int         :3;
                             1579 ; 370  |        unsigned ML :5;
                             1580 ; 371  |        int         :2;
                             1581 ; 372  |        int MUTE    :1;
                             1582 ; 373  |    } B;
                             1583 ; 374  |    int I;
                             1584 ; 375  |    unsigned int U;
                             1585 ; 376  |} mix_mastervr_type;
                             1586 ; 377  |#define HW_MIXMASTERVR (*(volatile mix_mastervr_type _X*) (HW_CODEC_BASEADDR+4))
                             1587 ; 378  |
                             1588 ; 379  |
                             1589 ; 380  |/////////////////////////////////////////////////////////////////////////////////
                             1590 ; 381  |//   Mixer Mic In Volume Register (HW_MIXMICINVR) Bit Definitions
                             1591 ; 382  |#define HW_MIXMICINVR_GN_BITPOS 0
                             1592 ; 383  |#define HW_MIXMICINVR_P20DB_BITPOS 6
                             1593 ; 384  |#define HW_MIXMICINVR_MUTE_BITPOS 15
                             1594 ; 385  |
                             1595 ; 386  |#define HW_MIXMICINVR_GN_WIDTH 5
                             1596 ; 387  |#define HW_MIXMICINVR_RSVD1_WIDTH 1
                             1597 ; 388  |#define HW_MIXMICINVR_P20DB_WIDTH 1
                             1598 ; 389  |#define HW_MIXMICINVR_RSVD2_WIDTH 8
                             1599 ; 390  |#define HW_MIXMICINVR_MUTE_WIDTH 1
                             1600 ; 391  |#define HW_MIXMICINVR_RSVD3_WIDTH 8
                             1601 ; 392  |
                             1602 ; 393  |#define HW_MIXMICINVR_GN_SETMASK 0x1F<<HW_MIXMICINVR_GN_BITPOS
                             1603 ; 394  |#define HW_MIXMICINVR_P20DB_SETMASK 1<<HW_MIXMICINVR_P20DB_BITPOS
                             1604 ; 395  |#define HW_MIXMICINVR_MUTE_SETMASK 1<<HW_MIXMICINVR_MUTE_BITPOS
                             1605 ; 396  |
                             1606 ; 397  |#define HW_MIXMICINVR_GN_CLRMASK ~(WORD)HW_MIXMICINVR_GN_SETMASK
                             1607 ; 398  |#define HW_MIXMICINVR_P20DB_CLRMASK ~(WORD)HW_MIXMICINVR_P20DB_SETMASK
                             1608 ; 399  |#define HW_MIXMICINVR_MUTE_CLRMASK ~(WORD)HW_MIXMICINVR_MUTE_SETMASK
                             1609 ; 400  |
                             1610 ; 401  |#define HW_MIXMICINVR_GN_PLUS_12P0_SETMASK 0
                             1611 ; 402  |#define HW_MIXMICINVR_GN_PLUS_10P5_SETMASK 1
                             1612 ; 403  |#define HW_MIXMICINVR_GN_PLUS_09P0_SETMASK 2
                             1613 ; 404  |#define HW_MIXMICINVR_GN_PLUS_07P5_SETMASK 3
                             1614 ; 405  |#define HW_MIXMICINVR_GN_PLUS_06P0_SETMASK 4
                             1615 ; 406  |#define HW_MIXMICINVR_GN_PLUS_04P5_SETMASK 5
                             1616 ; 407  |#define HW_MIXMICINVR_GN_PLUS_03P0_SETMASK 6
                             1617 ; 408  |#define HW_MIXMICINVR_GN_PLUS_01P5_SETMASK 7
                             1618 ; 409  |#define HW_MIXMICINVR_GN_ZERO_SETMASK 8
                             1619 ; 410  |#define HW_MIXMICINVR_GN_MINUS_01P5_SETMASK 9
                             1620 ; 411  |#define HW_MIXMICINVR_GN_MINUS_03P0_SETMASK 10
                             1621 ; 412  |#define HW_MIXMICINVR_GN_MINUS_04P5_SETMASK 11
                             1622 ; 413  |#define HW_MIXMICINVR_GN_MINUS_06P0_SETMASK 12
                             1623 ; 414  |#define HW_MIXMICINVR_GN_MINUS_07P5_SETMASK 13
                             1624 ; 415  |#define HW_MIXMICINVR_GN_MINUS_09P0_SETMASK 14
                             1625 ; 416  |#define HW_MIXMICINVR_GN_MINUS_10P5_SETMASK 15
                             1626 ; 417  |#define HW_MIXMICINVR_GN_MINUS_12P0_SETMASK 16
                             1627 ; 418  |#define HW_MIXMICINVR_GN_MINUS_13P5_SETMASK 17
                             1628 ; 419  |#define HW_MIXMICINVR_GN_MINUS_15P0_SETMASK 18
                             1629 ; 420  |#define HW_MIXMICINVR_GN_MINUS_16P5_SETMASK 19
                             1630 ; 421  |#define HW_MIXMICINVR_GN_MINUS_18P0_SETMASK 20
                             1631 ; 422  |#define HW_MIXMICINVR_GN_MINUS_19P5_SETMASK 21
                             1632 ; 423  |#define HW_MIXMICINVR_GN_MINUS_21P0_SETMASK 22
                             1633 ; 424  |#define HW_MIXMICINVR_GN_MINUS_22P5_SETMASK 23
                             1634 ; 425  |#define HW_MIXMICINVR_GN_MINUS_24P0_SETMASK 24
                             1635 ; 426  |#define HW_MIXMICINVR_GN_MINUS_25P5_SETMASK 25
                             1636 ; 427  |#define HW_MIXMICINVR_GN_MINUS_27P0_SETMASK 26
                             1637 ; 428  |#define HW_MIXMICINVR_GN_MINUS_28P5_SETMASK 27
                             1638 ; 429  |#define HW_MIXMICINVR_GN_MINUS_30P0_SETMASK 28
                             1639 ; 430  |#define HW_MIXMICINVR_GN_MINUS_31P5_SETMASK 29
                             1640 ; 431  |#define HW_MIXMICINVR_GN_MINUS_33P0_SETMASK 30
                             1641 ; 432  |#define HW_MIXMICINVR_GN_MINUS_34P5_SETMASK 31
                             1642 ; 433  |
                             1643 ; 434  |typedef union               
                             1644 ; 435  |{
                             1645 ; 436  |    struct {
                             1646 ; 437  |        int GN          : HW_MIXMICINVR_GN_WIDTH;
                             1647 ; 438  |        int RSVD1       : HW_MIXMICINVR_RSVD1_WIDTH;
                             1648 ; 439  |        int P20DB       : HW_MIXMICINVR_P20DB_WIDTH;
                             1649 ; 440  |        int RSVD2       : HW_MIXMICINVR_RSVD2_WIDTH;
                             1650 ; 441  |        int MUTE        : HW_MIXMICINVR_MUTE_WIDTH;
                             1651 ; 442  |        int RSVD3       : HW_MIXMICINVR_RSVD3_WIDTH;
                             1652 ; 443  |    } B;
                             1653 ; 444  |    int I;
                             1654 ; 445  |    unsigned int U;
                             1655 ; 446  |} mix_micinvr_type;
                             1656 ; 447  |#define HW_MIXMICINVR (*(volatile mix_micinvr_type _X*) (HW_CODEC_BASEADDR+5))
                             1657 ; 448  |
                             1658 ; 449  |
                             1659 ; 450  |
                             1660 ; 451  |
                             1661 ; 452  |/////////////////////////////////////////////////////////////////////////////////
                             1662 ; 453  |//   Mixer Line1 In Volume Register (HW_MIXLINE1INVR) Bit Definitions
                             1663 ; 454  |#define HW_MIXLINE1INVR_GR_BITPOS 0
                             1664 ; 455  |#define HW_MIXLINE1INVR_GL_BITPOS 8
                             1665 ; 456  |#define HW_MIXLINE1INVR_MUTE_BITPOS 15
                             1666 ; 457  |
                             1667 ; 458  |#define HW_MIXLINE1INVR_GR_WIDTH 5
                             1668 ; 459  |#define HW_MIXLINE1INVR_RSVD1_WIDTH 3
                             1669 ; 460  |#define HW_MIXLINE1INVR_GL_WIDTH 5
                             1670 ; 461  |#define HW_MIXLINE1INVR_RSVD2_WIDTH 2
                             1671 ; 462  |#define HW_MIXLINE1INVR_MUTE_WIDTH 1
                             1672 ; 463  |#define HW_MIXLINE1INVR_RSVD3_WIDTH 8
                             1673 ; 464  |
                             1674 ; 465  |#define HW_MIXLINE1INVR_GR_SETMASK 0x1F<<HW_MIXLINE1INVR_GR_BITPOS
                             1675 ; 466  |#define HW_MIXLINE1INVR_GL_SETMASK 0x1F<<HW_MIXLINE1INVR_GL_BITPOS
                             1676 ; 467  |#define HW_MIXLINE1INVR_MUTE_SETMASK 1<<HW_MIXLINE1INVR_MUTE_BITPOS
                             1677 ; 468  |
                             1678 ; 469  |#define HW_MIXLINE1INVR_GR_CLRMASK ~(WORD)HW_MIXLINE1INVR_GR_SETMASK
                             1679 ; 470  |#define HW_MIXLINE1INVR_GL_CLRMASK ~(WORD)HW_MIXLINE1INVR_GL_SETMASK
                             1680 ; 471  |#define HW_MIXLINE1INVR_MUTE_CLRMASK ~(WORD)HW_MIXLINE1INVR_MUTE_SETMASK
                             1681 ; 472  |
                             1682 ; 473  |typedef union               
                             1683 ; 474  |{
                             1684 ; 475  |    struct {
                             1685 ; 476  |        int GR          : HW_MIXLINE1INVR_GR_WIDTH;
                             1686 ; 477  |        int RSVD1       : HW_MIXLINE1INVR_RSVD1_WIDTH;
                             1687 ; 478  |        int GL          : HW_MIXLINE1INVR_GL_WIDTH;
                             1688 ; 479  |        int RSVD2       : HW_MIXLINE1INVR_RSVD2_WIDTH;
                             1689 ; 480  |        int MUTE        : HW_MIXLINE1INVR_MUTE_WIDTH;
                             1690 ; 481  |        int RSVD3       : HW_MIXLINE1INVR_RSVD3_WIDTH;
                             1691 ; 482  |    } B;
                             1692 ; 483  |    int I;
                             1693 ; 484  |    unsigned int U;
                             1694 ; 485  |} mix_line1invr_type;
                             1695 ; 486  |#define HW_MIXLINE1INVR (*(volatile mix_line1invr_type _X*) (HW_CODEC_BASEADDR+6))
                             1696 ; 487  |
                             1697 ; 488  |
                             1698 ; 489  |
                             1699 ; 490  |/////////////////////////////////////////////////////////////////////////////////
                             1700 ; 491  |//   Mixer Line2 In Volume Register (HW_MIXLINE2INVR) Bit Definitions
                             1701 ; 492  |#define HW_MIXLINE2INVR_GR_BITPOS 0
                             1702 ; 493  |#define HW_MIXLINE2INVR_GL_BITPOS 8
                             1703 ; 494  |#define HW_MIXLINE2INVR_MUTE_BITPOS 15
                             1704 ; 495  |
                             1705 ; 496  |#define HW_MIXLINE2INVR_GR_WIDTH 5
                             1706 ; 497  |#define HW_MIXLINE2INVR_RSVD1_WIDTH 3
                             1707 ; 498  |#define HW_MIXLINE2INVR_GL_WIDTH 5
                             1708 ; 499  |#define HW_MIXLINE2INVR_RSVD2_WIDTH 2
                             1709 ; 500  |#define HW_MIXLINE2INVR_MUTE_WIDTH 1
                             1710 ; 501  |#define HW_MIXLINE2INVR_RSVD3_WIDTH 8
                             1711 ; 502  |
                             1712 ; 503  |
                             1713 ; 504  |#define HW_MIXLINE2INVR_GR_SETMASK 0x1F<<HW_MIXLINE2INVR_GR_BITPOS
                             1714 ; 505  |#define HW_MIXLINE2INVR_GL_SETMASK 0x1F<<HW_MIXLINE2INVR_GL_BITPOS
                             1715 ; 506  |#define HW_MIXLINE2INVR_MUTE_SETMASK 1<<HW_MIXLINE2INVR_MUTE_BITPOS
                             1716 ; 507  |
                             1717 ; 508  |#define HW_MIXLINE2INVR_GR_CLRMASK ~(WORD)HW_MIXLINE2INVR_GR_SETMASK
                             1718 ; 509  |#define HW_MIXLINE2INVR_GL_CLRMASK ~(WORD)HW_MIXLINE2INVR_GL_SETMASK
                             1719 ; 510  |#define HW_MIXLINE2INVR_MUTE_CLRMASK ~(WORD)HW_MIXLINE2INVR_MUTE_SETMASK
                             1720 ; 511  |
                             1721 ; 512  |typedef union               
                             1722 ; 513  |{
                             1723 ; 514  |    struct {
                             1724 ; 515  |        int GR          : HW_MIXLINE2INVR_GR_WIDTH;
                             1725 ; 516  |        int RSVD1       : HW_MIXLINE2INVR_RSVD1_WIDTH;
                             1726 ; 517  |        int GL          : HW_MIXLINE2INVR_GL_WIDTH;
                             1727 ; 518  |        int RSVD2       : HW_MIXLINE2INVR_RSVD2_WIDTH;
                             1728 ; 519  |        int MUTE        : HW_MIXLINE2INVR_MUTE_WIDTH;
                             1729 ; 520  |        int RSVD3       : HW_MIXLINE2INVR_RSVD3_WIDTH;
                             1730 ; 521  |    } B;
                             1731 ; 522  |    int I;
                             1732 ; 523  |    unsigned int U;
                             1733 ; 524  |} mix_line2invr_type;
                             1734 ; 525  |#define HW_MIXLINE2INVR (*(volatile mix_line2invr_type _X*) (HW_CODEC_BASEADDR+7))
                             1735 ; 526  |
                             1736 ; 527  |
                             1737 ; 528  |
                             1738 ; 529  |/////////////////////////////////////////////////////////////////////////////////
                             1739 ; 530  |//   Mixer DAC In Volume Register (HW_MIXDACINVR) Bit Definitions
                             1740 ; 531  |#define HW_MIXDACINVR_MR_BITPOS 0
                             1741 ; 532  |#define HW_MIXDACINVR_ML_BITPOS 8
                             1742 ; 533  |#define HW_MIXDACINVR_MUTE_BITPOS 15
                             1743 ; 534  |
                             1744 ; 535  |#define HW_MIXDACINVR_MR_WIDTH (5)
                             1745 ; 536  |#define HW_MIXDACINVR_ML_WIDTH (5)
                             1746 ; 537  |#define HW_MIXDACINVR_MUTE_WIDTH (1)
                             1747 ; 538  |
                             1748 ; 539  |#define HW_MIXDACINVR_MR_SETMASK 0x1F<<HW_MIXDACINVR_MR_BITPOS
                             1749 ; 540  |#define HW_MIXDACINVR_ML_SETMASK 0x1F<<HW_MIXDACINVR_ML_BITPOS
                             1750 ; 541  |#define HW_MIXDACINVR_MUTE_SETMASK 1<<HW_MIXDACINVR_MUTE_BITPOS
                             1751 ; 542  |
                             1752 ; 543  |#define HW_MIXDACINVR_MR_CLRMASK ~(WORD)HW_MIXDACINVR_MR_SETMASK
                             1753 ; 544  |#define HW_MIXDACINVR_ML_CLRMASK ~(WORD)HW_MIXDACINVR_ML_SETMASK
                             1754 ; 545  |#define HW_MIXDACINVR_MUTE_CLRMASK ~(WORD)HW_MIXDACINVR_MUTE_SETMASK
                             1755 ; 546  |
                             1756 ; 547  |typedef union               
                             1757 ; 548  |{
                             1758 ; 549  |    struct {
                             1759 ; 550  |        int MR   : HW_MIXDACINVR_MR_WIDTH;
                             1760 ; 551  |        int ML   : HW_MIXDACINVR_ML_WIDTH;
                             1761 ; 552  |        int MUTE : HW_MIXDACINVR_MUTE_WIDTH;
                             1762 ; 553  |    } B;
                             1763 ; 554  |    int I;
                             1764 ; 555  |    unsigned int U;
                             1765 ; 556  |} mix_dacinvr_type;
                             1766 ; 557  |#define HW_MIXDACINVR (*(volatile mix_dacinvr_type _X*) (HW_CODEC_BASEADDR+8))
                             1767 ; 558  |
                             1768 ; 559  |
                             1769 ; 560  |/////////////////////////////////////////////////////////////////////////////////
                             1770 ; 561  |//   Mixer Record Select Register (HW_MIXRECSELR) Bit Definitions
                             1771 ; 562  |#define HW_MIXRECSELR_SR_BITPOS 0
                             1772 ; 563  |#define HW_MIXRECSELR_SL_BITPOS 8
                             1773 ; 564  |#define HW_MIXRECSELR_X_BITPOS 11
                             1774 ; 565  |
                             1775 ; 566  |#define HW_MIXRECSELR_SR_WIDTH 3
                             1776 ; 567  |#define HW_MIXRECSELR_RSVD1_WIDTH 5
                             1777 ; 568  |#define HW_MIXRECSELR_SL_WIDTH 3
                             1778 ; 569  |#define HW_MIXRECSELR_X_WIDTH 1
                             1779 ; 570  |#define HW_MIXRECSELR_RSVD2_WIDTH 12
                             1780 ; 571  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   8

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1781 ; 572  |#define HW_MIXRECSELR_SR_SETMASK 7<<HW_MIXRECSELR_SR_BITPOS
                             1782 ; 573  |#define HW_MIXRECSELR_SL_SETMASK 7<<HW_MIXRECSELR_SL_BITPOS
                             1783 ; 574  |#define HW_MIXRECSELR_X_SETMASK 1<<HW_MIXRECSELR_X_BITPOS
                             1784 ; 575  |
                             1785 ; 576  |#define HW_MIXRECSELR_SR_MIC_SETMASK 0<<HW_MIXRECSELR_SR_BITPOS
                             1786 ; 577  |#define HW_MIXRECSELR_SR_LINEIN2_SETMASK 3<<HW_MIXRECSELR_SR_BITPOS
                             1787 ; 578  |#define HW_MIXRECSELR_SR_LINEIN1_SETMASK 4<<HW_MIXRECSELR_SR_BITPOS
                             1788 ; 579  |#define HW_MIXRECSELR_SR_MIX_SETMASK 5<<HW_MIXRECSELR_SR_BITPOS
                             1789 ; 580  |
                             1790 ; 581  |#define HW_MIXRECSELR_SL_MIC_SETMASK 0<<HW_MIXRECSELR_SL_BITPOS
                             1791 ; 582  |#define HW_MIXRECSELR_SL_LINEIN2_SETMASK 3<<HW_MIXRECSELR_SL_BITPOS
                             1792 ; 583  |#define HW_MIXRECSELR_SL_LINEIN1_SETMASK 4<<HW_MIXRECSELR_SL_BITPOS
                             1793 ; 584  |#define HW_MIXRECSELR_SL_MIX_SETMASK 5<<HW_MIXRECSELR_SL_BITPOS
                             1794 ; 585  |
                             1795 ; 586  |#define HW_MIXRECSELR_SR_CLRMASK ~(WORD)HW_MIXRECSELR_SR_SETMASK
                             1796 ; 587  |#define HW_MIXRECSELR_SL_CLRMASK ~(WORD)HW_MIXRECSELR_SL_SETMASK
                             1797 ; 588  |#define HW_MIXRECSELR_SR_SL_CLRMASK ~(WORD)(HW_MIXRECSELR_SR_SETMASK|HW_MIXRECSELR_SL_SETMASK)
                             1798 ; 589  |#define HW_MIXRECSELR_X_CLRMASK ~(WORD)HW_MIXRECSELR_X_SETMASK
                             1799 ; 590  |
                             1800 ; 591  |typedef union               
                             1801 ; 592  |{
                             1802 ; 593  |    struct {
                             1803 ; 594  |        int SR          : HW_MIXRECSELR_SR_WIDTH;
                             1804 ; 595  |        int RSVD1       : HW_MIXRECSELR_RSVD1_WIDTH;
                             1805 ; 596  |        int SL          : HW_MIXRECSELR_SL_WIDTH;
                             1806 ; 597  |        int X           : HW_MIXRECSELR_X_WIDTH;
                             1807 ; 598  |        int RSVD2       : HW_MIXRECSELR_RSVD2_WIDTH;
                             1808 ; 599  |    } B;
                             1809 ; 600  |    int I;
                             1810 ; 601  |    unsigned int U;
                             1811 ; 602  |} mix_recselr_type;
                             1812 ; 603  |#define HW_MIXRECSELR (*(volatile mix_recselr_type _X*) (HW_CODEC_BASEADDR+9))
                             1813 ; 604  |
                             1814 ; 605  |
                             1815 ; 606  |
                             1816 ; 607  |/////////////////////////////////////////////////////////////////////////////////
                             1817 ; 608  |//   Mixer ADC In Gain Register (HW_MIXADCGAINR) Bit Definitions
                             1818 ; 609  |#define HW_MIXADCGAINR_GR_BITPOS 0
                             1819 ; 610  |#define HW_MIXADCGAINR_GL_BITPOS 8
                             1820 ; 611  |#define HW_MIXADCGAINR_MUTE_BITPOS 15
                             1821 ; 612  |
                             1822 ; 613  |#define HW_MIXADCGAINR_GR_WIDTH 4
                             1823 ; 614  |#define HW_MIXADCGAINR_RSVD1_WIDTH 4
                             1824 ; 615  |#define HW_MIXADCGAINR_GL_WIDTH 4
                             1825 ; 616  |#define HW_MIXADCGAINR_RSVD2_WIDTH 3
                             1826 ; 617  |#define HW_MIXADCGAINR_MUTE_WIDTH 1
                             1827 ; 618  |#define HW_MIXADCGAINR_RSVD3_WIDTH 8
                             1828 ; 619  |
                             1829 ; 620  |#define HW_MIXADCGAINR_GR_SETMASK 0x1F<<HW_MIXADCGAINR_GR_BITPOS
                             1830 ; 621  |#define HW_MIXADCGAINR_GL_SETMASK 0x1F<<HW_MIXADCGAINR_GL_BITPOS
                             1831 ; 622  |#define HW_MIXADCGAINR_MUTE_SETMASK 1<<HW_MIXADCGAINR_MUTE_BITPOS
                             1832 ; 623  |
                             1833 ; 624  |#define HW_MIXADCGAINR_GR_CLRMASK ~(WORD)HW_MIXADCGAINR_GR_SETMASK
                             1834 ; 625  |#define HW_MIXADCGAINR_GL_CLRMASK ~(WORD)HW_MIXADCGAINR_GL_SETMASK
                             1835 ; 626  |#define HW_MIXADCGAINR_MUTE_CLRMASK ~(WORD)HW_MIXADCGAINR_MUTE_SETMASK
                             1836 ; 627  |
                             1837 ; 628  |#define HW_MIXADCGAINR_GL_00P0_SETMASK 0<<HW_MIXADCGAINR_GL_BITPOS
                             1838 ; 629  |#define HW_MIXADCGAINR_GL_01P5_SETMASK 1<<HW_MIXADCGAINR_GL_BITPOS
                             1839 ; 630  |#define HW_MIXADCGAINR_GL_03P0_SETMASK 2<<HW_MIXADCGAINR_GL_BITPOS
                             1840 ; 631  |#define HW_MIXADCGAINR_GL_04P5_SETMASK 3<<HW_MIXADCGAINR_GL_BITPOS
                             1841 ; 632  |#define HW_MIXADCGAINR_GL_06P0_SETMASK 4<<HW_MIXADCGAINR_GL_BITPOS
                             1842 ; 633  |#define HW_MIXADCGAINR_GL_07P5_SETMASK 5<<HW_MIXADCGAINR_GL_BITPOS
                             1843 ; 634  |#define HW_MIXADCGAINR_GL_09P0_SETMASK 6<<HW_MIXADCGAINR_GL_BITPOS
                             1844 ; 635  |#define HW_MIXADCGAINR_GL_10P5_SETMASK 7<<HW_MIXADCGAINR_GL_BITPOS
                             1845 ; 636  |#define HW_MIXADCGAINR_GL_12P0_SETMASK 8<<HW_MIXADCGAINR_GL_BITPOS
                             1846 ; 637  |#define HW_MIXADCGAINR_GL_13P5_SETMASK 9<<HW_MIXADCGAINR_GL_BITPOS
                             1847 ; 638  |#define HW_MIXADCGAINR_GL_15P0_SETMASK 10<<HW_MIXADCGAINR_GL_BITPOS
                             1848 ; 639  |#define HW_MIXADCGAINR_GL_16P5_SETMASK 11<<HW_MIXADCGAINR_GL_BITPOS
                             1849 ; 640  |#define HW_MIXADCGAINR_GL_18P0_SETMASK 12<<HW_MIXADCGAINR_GL_BITPOS
                             1850 ; 641  |#define HW_MIXADCGAINR_GL_19P5_SETMASK 13<<HW_MIXADCGAINR_GL_BITPOS
                             1851 ; 642  |#define HW_MIXADCGAINR_GL_21P0_SETMASK 14<<HW_MIXADCGAINR_GL_BITPOS
                             1852 ; 643  |#define HW_MIXADCGAINR_GL_22P5_SETMASK 15<<HW_MIXADCGAINR_GL_BITPOS
                             1853 ; 644  |
                             1854 ; 645  |#define HW_MIXADCGAINR_GR_00P0_SETMASK 0
                             1855 ; 646  |#define HW_MIXADCGAINR_GR_01P5_SETMASK 1
                             1856 ; 647  |#define HW_MIXADCGAINR_GR_03P0_SETMASK 2
                             1857 ; 648  |#define HW_MIXADCGAINR_GR_04P5_SETMASK 3
                             1858 ; 649  |#define HW_MIXADCGAINR_GR_06P0_SETMASK 4
                             1859 ; 650  |#define HW_MIXADCGAINR_GR_07P5_SETMASK 5
                             1860 ; 651  |#define HW_MIXADCGAINR_GR_09P0_SETMASK 6
                             1861 ; 652  |#define HW_MIXADCGAINR_GR_10P5_SETMASK 7
                             1862 ; 653  |#define HW_MIXADCGAINR_GR_12P0_SETMASK 8
                             1863 ; 654  |#define HW_MIXADCGAINR_GR_13P5_SETMASK 9
                             1864 ; 655  |#define HW_MIXADCGAINR_GR_15P0_SETMASK 10
                             1865 ; 656  |#define HW_MIXADCGAINR_GR_16P5_SETMASK 11
                             1866 ; 657  |#define HW_MIXADCGAINR_GR_18P0_SETMASK 12
                             1867 ; 658  |#define HW_MIXADCGAINR_GR_19P5_SETMASK 13
                             1868 ; 659  |#define HW_MIXADCGAINR_GR_21P0_SETMASK 14
                             1869 ; 660  |#define HW_MIXADCGAINR_GR_22P5_SETMASK 15
                             1870 ; 661  |
                             1871 ; 662  |typedef union               
                             1872 ; 663  |{
                             1873 ; 664  |    struct {
                             1874 ; 665  |        int GR          : HW_MIXADCGAINR_GR_WIDTH;
                             1875 ; 666  |        int RSVD1       : HW_MIXADCGAINR_RSVD1_WIDTH;
                             1876 ; 667  |        int GL          : HW_MIXADCGAINR_GL_WIDTH;
                             1877 ; 668  |        int RSVD2       : HW_MIXADCGAINR_RSVD2_WIDTH;
                             1878 ; 669  |        int MUTE        : HW_MIXADCGAINR_MUTE_WIDTH;
                             1879 ; 670  |        int RSVD3       : HW_MIXADCGAINR_RSVD3_WIDTH;
                             1880 ; 671  |    } B;
                             1881 ; 672  |    int I;
                             1882 ; 673  |    unsigned int U;
                             1883 ; 674  |} mix_adcgainr_type;
                             1884 ; 675  |#define HW_MIXADCGAINR (*(volatile mix_adcgainr_type _X*) (HW_CODEC_BASEADDR+10))
                             1885 ; 676  |
                             1886 ; 677  |
                             1887 ; 678  |
                             1888 ; 679  |/////////////////////////////////////////////////////////////////////////////////
                             1889 ; 680  |//   Mixer Power Down Register (HW_MIXPWRDNR) Bit Definitions
                             1890 ; 681  |#define HW_MIXPWRDNR_PR0_BITPOS 9
                             1891 ; 682  |#define HW_MIXPWRDNR_PR1_BITPOS 10
                             1892 ; 683  |#define HW_MIXPWRDNR_PR2_BITPOS 11
                             1893 ; 684  |
                             1894 ; 685  |#define HW_MIXPWRDNR_PR0_WIDTH (1)
                             1895 ; 686  |#define HW_MIXPWRDNR_PR1_WIDTH (1)
                             1896 ; 687  |#define HW_MIXPWRDNR_PR2_WIDTH (1)
                             1897 ; 688  |#define HW_MIXPWRDNR_RSVD_WIDTH (12)
                             1898 ; 689  |
                             1899 ; 690  |#define HW_MIXPWRDNR_PR_SETMASK 7<<HW_MIXPWRDNR_PR0_BITPOS
                             1900 ; 691  |
                             1901 ; 692  |#define HW_MIXPWRDNR_PR_CLRMASK ~(WORD)HW_MIXPWRDNR_PR_SETMASK
                             1902 ; 693  |
                             1903 ; 694  |typedef union               
                             1904 ; 695  |{
                             1905 ; 696  |    struct {
                             1906 ; 697  |                int                     : 9;
                             1907 ; 698  |       int PR0          : HW_MIXPWRDNR_PR0_WIDTH;
                             1908 ; 699  |       int PR1          : HW_MIXPWRDNR_PR1_WIDTH;
                             1909 ; 700  |       int PR2          : HW_MIXPWRDNR_PR2_WIDTH;
                             1910 ; 701  |       int RSVD         : HW_MIXPWRDNR_RSVD_WIDTH;
                             1911 ; 702  |    } B;
                             1912 ; 703  |    int I;
                             1913 ; 704  |    unsigned int U;
                             1914 ; 705  |} mix_pwrdnr_type;
                             1915 ; 706  |#define HW_MIXPWRDNR (*(volatile mix_pwrdnr_type _X*) (HW_CODEC_BASEADDR+11))
                             1916 ; 707  |
                             1917 ; 708  |
                             1918 ; 709  |/////////////////////////////////////////////////////////////////////////////////
                             1919 ; 710  |
                             1920 ; 711  |//  Mixer Test Register (HW_MIX_TEST) Bit Definitions
                             1921 ; 712  |
                             1922 ; 713  |#define HW_MIX_TEST_DAC_CHOP_CLK_WIDTH (2)
                             1923 ; 714  |
                             1924 ; 715  |#define HW_MIX_TEST_RSVD0_WIDTH (2)
                             1925 ; 716  |
                             1926 ; 717  |#define HW_MIX_TEST_DAC_DISABLE_RTZ_WIDTH (1)
                             1927 ; 718  |
                             1928 ; 719  |#define HW_MIX_TEST_DAC_MORE_AMP_I_WIDTH (1)
                             1929 ; 720  |
                             1930 ; 721  |#define HW_MIX_TEST_RSVD1_WIDTH (2)
                             1931 ; 722  |
                             1932 ; 723  |#define HW_MIX_TEST_TMP_CFG_WIDTH (4)
                             1933 ; 724  |
                             1934 ; 725  |#define HW_MIX_TEST_TMPPWD_WIDTH (1)
                             1935 ; 726  |
                             1936 ; 727  |#define HW_MIX_TEST_RSVD2_WIDTH (11)
                             1937 ; 728  |
                             1938 ; 729  |
                             1939 ; 730  |
                             1940 ; 731  |#define HW_MIX_TEST_DAC_CHOP_CLK_BITPOS (0)
                             1941 ; 732  |
                             1942 ; 733  |#define HW_MIX_TEST_DAC_DISABLE_RTZ_BITPOS (4)
                             1943 ; 734  |
                             1944 ; 735  |#define HW_MIX_TEST_DAC_MORE_AMP_I_BITPOS (5)
                             1945 ; 736  |
                             1946 ; 737  |#define HW_MIX_TEST_TMP_CFG_BITPOS (8)
                             1947 ; 738  |
                             1948 ; 739  |#define HW_MIX_TEST_TMPPWD_BITPOS (12)
                             1949 ; 740  |
                             1950 ; 741  |
                             1951 ; 742  |
                             1952 ; 743  |#define HW_MIX_TEST_DAC_CHOP_CLK_SETMASK (((1<<HW_MIX_TEST_DAC_CHOP_CLK_WIDTH)-1)<<HW_MIX_TEST_DAC_CHOP_CLK_BITPOS)        
                             1953 ; 744  |
                             1954 ; 745  |#define HW_MIX_TEST_DAC_DISABLE_RTZ_SETMASK (((1<<HW_MIX_TEST_DAC_DISABLE_RTZ_WIDTH)-1)<<HW_MIX_TEST_DAC_DISABLE_RTZ_BITPOS)        
                             1955 ; 746  |
                             1956 ; 747  |#define HW_MIX_TEST_DAC_MORE_AMP_I_SETMASK (((1<<HW_MIX_TEST_DAC_MORE_AMP_I_WIDTH)-1)<<HW_MIX_TEST_DAC_MORE_AMP_I_BITPOS) 
                             1957 ; 748  |
                             1958 ; 749  |#define HW_MIX_TEST_TMP_CFG_SETMASK (((1<<HW_MIX_TEST_TMP_CFG_WIDTH)-1)<<HW_MIX_TEST_TMP_CFG_BITPOS) 
                             1959 ; 750  |
                             1960 ; 751  |#define HW_MIX_TEST_TMPPWD_SETMASK (((1<<HW_MIX_TEST_TMPPWD_WIDTH)-1)<<HW_MIX_TEST_TMPPWD_BITPOS) 
                             1961 ; 752  |
                             1962 ; 753  |
                             1963 ; 754  |#define HW_MIX_TEST_DAC_CHOP_CLK_CLRMASK (~(WORD)HW_MIX_TEST_DAC_CHOP_CLK_SETMASK)     
                             1964 ; 755  |
                             1965 ; 756  |#define HW_MIX_TEST_DAC_DISABLE_RTZ_CLRMASK (~(WORD)HW_MIX_TEST_DAC_DISABLE_RTZ_SETMASK)     
                             1966 ; 757  |
                             1967 ; 758  |#define HW_MIX_TEST_DAC_MORE_AMP_I_CLRMASK (~(WORD)HW_MIX_TEST_DAC_MORE_AMP_I_SETMASK) 
                             1968 ; 759  |
                             1969 ; 760  |#define HW_MIX_TEST_TMP_CFG_CLRMASK (~(WORD)HW_MIX_TEST_TMP_CFG_SETMASK) 
                             1970 ; 761  |
                             1971 ; 762  |#define HW_MIX_TEST_TMPPWD_CLRMASK (~(WORD)HW_MIX_TEST_TMPPWD_SETMASK) 
                             1972 ; 763  |
                             1973 ; 764  |
                             1974 ; 765  |typedef union               
                             1975 ; 766  |{
                             1976 ; 767  |    struct {
                             1977 ; 768  |        int DAC_CHOP_CLK                   : HW_MIX_TEST_DAC_CHOP_CLK_WIDTH;
                             1978 ; 769  |        int RSVD0                          : HW_MIX_TEST_RSVD0_WIDTH;
                             1979 ; 770  |        int DAC_DISABLE_RTZ                : HW_MIX_TEST_DAC_DISABLE_RTZ_WIDTH;
                             1980 ; 771  |        int DAC_MORE_AMP_I                 : HW_MIX_TEST_DAC_MORE_AMP_I_WIDTH;
                             1981 ; 772  |        int RSVD1                          : HW_MIX_TEST_RSVD1_WIDTH;
                             1982 ; 773  |        int TMP_CFG                        : HW_MIX_TEST_TMP_CFG_WIDTH;
                             1983 ; 774  |        int TMPPWD                         : HW_MIX_TEST_TMPPWD_WIDTH;
                             1984 ; 775  |        int RSVD2                          : HW_MIX_TEST_RSVD2_WIDTH;
                             1985 ; 776  |    } B;
                             1986 ; 777  |    int I;
                             1987 ; 778  |    unsigned int U;
                             1988 ; 779  |} mix_test_type;
                             1989 ; 780  |#define HW_MIX_TEST      (*(volatile mix_test_type _X*) (HW_CODEC_BASEADDR+28))    /* Analog Persistent Config Register */
                             1990 ; 781  |
                             1991 ; 782  |
                             1992 ; 783  |/////////////////////////////////////////////////////////////////////////////////
                             1993 ; 784  |//   Reference Control Register (HW_REF_CTRL) Bit Definitions
                             1994 ; 785  |#define HW_REF_CTRL_DACVBGVAL_BITPOS 0
                             1995 ; 786  |#define HW_REF_CTRL_ADJDAC_BITPOS 4
                             1996 ; 787  |#define HW_REF_CTRL_VAGVAL_BITPOS 5
                             1997 ; 788  |#define HW_REF_CTRL_ADJV_BITPOS 9
                             1998 ; 789  |#define HW_REF_CTRL_ADCREFV_BITPOS 10
                             1999 ; 790  |#define HW_REF_CTRL_ADJADC_BITPOS 14
                             2000 ; 791  |#define HW_REF_CTRL_PWRDWNS_BITPOS 15
                             2001 ; 792  |#define HW_REF_CTRL_BIASC_BITPOS 16
                             2002 ; 793  |#define HW_REF_CTRL_LWREF_BITPOS 18
                             2003 ; 794  |#define HW_REF_CTRL_LOW_PWR_BITPOS 19 
                             2004 ; 795  |
                             2005 ; 796  |#define HW_REF_CTRL_DACVBGVAL_WIDTH (4)
                             2006 ; 797  |#define HW_REF_CTRL_ADJDAC_WIDTH (1)
                             2007 ; 798  |#define HW_REF_CTRL_VAGVAL_WIDTH (4)
                             2008 ; 799  |#define HW_REF_CTRL_ADJV_WIDTH (1)
                             2009 ; 800  |#define HW_REF_CTRL_ADCREFV_WIDTH (4)
                             2010 ; 801  |#define HW_REF_CTRL_ADJADC_WIDTH (1)
                             2011 ; 802  |#define HW_REF_CTRL_PWRDWNS_WIDTH (1)
                             2012 ; 803  |#define HW_REF_CTRL_BIASC_WIDTH (2)
                             2013 ; 804  |#define HW_REF_CTRL_LWREF_WIDTH (1)
                             2014 ; 805  |#define HW_REF_CTRL_LOW_PWR_WIDTH (1) 
                             2015 ; 806  |#define HW_REF_CTRL_RSVD_WIDTH (4)
                             2016 ; 807  |
                             2017 ; 808  |#define HW_REF_CTRL_DACVBGVAL_SETMASK (((1<<HW_REF_CTRL_DACVBGVAL_WIDTH)-1)<<HW_REF_CTRL_DACVBGVAL_BITPOS)
                             2018 ; 809  |#define HW_REF_CTRL_ADJDAC_SETMASK (((1<<HW_REF_CTRL_ADJDAC_WIDTH)-1)<<HW_REF_CTRL_ADJDAC_BITPOS)
                             2019 ; 810  |#define HW_REF_CTRL_VAGVAL_SETMASK (((1<<HW_REF_CTRL_VAGVAL_WIDTH)-1)<<HW_REF_CTRL_VAGVAL_BITPOS)
                             2020 ; 811  |#define HW_REF_CTRL_ADJV_SETMASK (((1<<HW_REF_CTRL_ADJV_WIDTH)-1)<<HW_REF_CTRL_ADJV_BITPOS)
                             2021 ; 812  |#define HW_REF_CTRL_ADCREFV_SETMASK (((1<<HW_REF_CTRL_ADCREFV_WIDTH)-1)<<HW_REF_CTRL_ADCREFV_BITPOS)
                             2022 ; 813  |#define HW_REF_CTRL_ADJADC_SETMASK (((1<<HW_REF_CTRL_ADJADC_WIDTH)-1)<<HW_REF_CTRL_ADJADC_BITPOS)
                             2023 ; 814  |#define HW_REF_CTRL_PWRDWNS_SETMASK (((1<<HW_REF_CTRL_PWRDWNS_WIDTH)-1)<<HW_REF_CTRL_PWRDWNS_BITPOS)
                             2024 ; 815  |#define HW_REF_CTRL_BIASC_SETMASK (((1<<HW_REF_CTRL_BIASC_WIDTH)-1)<<HW_REF_CTRL_BIASC_BITPOS)
                             2025 ; 816  |#define HW_REF_CTRL_LWREF_SETMASK (((1<<HW_REF_CTRL_LWREF_WIDTH)-1)<<HW_REF_CTRL_LWREF_BITPOS)
                             2026 ; 817  |#define HW_REF_CTRL_LOW_PWR_SETMASK (((1<<HW_REF_CTRL_LOW_PWR_WIDTH)-1)<<HW_REF_CTRL_LOW_PWR_BITPOS)
                             2027 ; 818  |
                             2028 ; 819  |#define HW_REF_CTRL_DACVBGVAL_CLRMASK ~(WORD)HW_REF_CTRL_DACVBGVAL_SETMASK
                             2029 ; 820  |#define HW_REF_CTRL_ADJDAC_CLRMASK ~(WORD)HW_REF_CTRL_ADJDAC_SETMASK
                             2030 ; 821  |#define HW_REF_CTRL_VAGVAL_CLRMASK ~(WORD)HW_REF_CTRL_VAGVAL_SETMASK
                             2031 ; 822  |#define HW_REF_CTRL_ADJV_CLRMASK ~(WORD)HW_REF_CTRL_ADJV_SETMASK
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   9

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2032 ; 823  |#define HW_REF_CTRL_ADCREFV_CLRMASK ~(WORD)HW_REF_CTRL_ADCREFV_SETMASK
                             2033 ; 824  |#define HW_REF_CTRL_ADJADC_CLRMASK ~(WORD)HW_REF_CTRL_ADJADC_SETMASK
                             2034 ; 825  |#define HW_REF_CTRL_PWRDWNS_CLRMASK ~(WORD)HW_REF_CTRL_PWRDWNS_SETMASK
                             2035 ; 826  |#define HW_REF_CTRL_BIASC_CLRMASK ~(WORD)HW_REF_CTRL_BIASC_SETMASK
                             2036 ; 827  |#define HW_REF_CTRL_LWREF_CLRMASK ~(WORD)HW_REF_CTRL_LWREF_SETMASK
                             2037 ; 828  |#define HW_REF_CTRL_LOW_PWR_CLRMASK ~(WORD)HW_REF_CTRL_LOW_PWR_SETMASK
                             2038 ; 829  |
                             2039 ; 830  |typedef union               
                             2040 ; 831  |{
                             2041 ; 832  |    struct {
                             2042 ; 833  |        int DACVBGVAL      : HW_REF_CTRL_DACVBGVAL_WIDTH;
                             2043 ; 834  |        int ADJDAC                 : HW_REF_CTRL_ADJDAC_WIDTH;
                             2044 ; 835  |        int VAGVAL                 : HW_REF_CTRL_VAGVAL_WIDTH;
                             2045 ; 836  |        int ADJV                   : HW_REF_CTRL_ADJV_WIDTH;
                             2046 ; 837  |        int ADCREFV       : HW_REF_CTRL_ADCREFV_WIDTH;
                             2047 ; 838  |        int ADJADC                 : HW_REF_CTRL_ADJADC_WIDTH;
                             2048 ; 839  |        int PWRDWNS       : HW_REF_CTRL_PWRDWNS_WIDTH;
                             2049 ; 840  |        int BIASC         : HW_REF_CTRL_BIASC_WIDTH;
                             2050 ; 841  |        int LWREF         : HW_REF_CTRL_LWREF_WIDTH;
                             2051 ; 842  |        int LOW_PWR       : HW_REF_CTRL_LOW_PWR_WIDTH;
                             2052 ; 843  |        int RSVD               : HW_REF_CTRL_RSVD_WIDTH;
                             2053 ; 844  |    } B;
                             2054 ; 845  |    int I;
                             2055 ; 846  |    unsigned int U;
                             2056 ; 847  |} ref_ctrl_type;
                             2057 ; 848  |#define HW_REF_CTRL (*(volatile ref_ctrl_type _X*) (HW_CODEC_BASEADDR+25))
                             2058 ; 849  |
                             2059 ; 850  |
                             2060 ; 851  |
                             2061 ; 852  |/////////////////////////////////////////////////////////////////////////////////
                             2062 ; 853  |/////////////////////////////////////////////////////////////////////////////////
                             2063 ; 854  |/////////////////////////////////////////////////////////////////////////////////
                             2064 ; 855  |//////  DAC Registers
                             2065 ; 856  |/////////////////////////////////////////////////////////////////////////////////
                             2066 ; 857  |/////////////////////////////////////////////////////////////////////////////////
                             2067 ; 858  |/////////////////////////////////////////////////////////////////////////////////
                             2068 ; 859  |#define HW_DAC_BASEADDR 0xF800
                             2069 ; 860  |
                             2070 ; 861  |
                             2071 ; 862  |
                             2072 ; 863  |/////////////////////////////////////////////////////////////////////////////////
                             2073 ; 864  |//  DAC Control Status Register (HW_DACCSR) Bit Definitions
                             2074 ; 865  |#define HW_DACCSR_TXEN_BITPOS 0
                             2075 ; 866  |#define HW_DACCSR_TXIEN_BITPOS 1
                             2076 ; 867  |#define HW_DACCSR_TXI_BITPOS 2
                             2077 ; 868  |#define HW_DACCSR_TXEXC_BITPOS 3
                             2078 ; 869  |#define HW_DACCSR_LPBK_BITPOS 4
                             2079 ; 870  |#define HW_DACCSR_DMASEL_BITPOS 5
                             2080 ; 871  |#define HW_DACCSR_DAC_HIPPOP_EN_BITPOS 7
                             2081 ; 872  |#define HW_DACCSR_LVUP_BITPOS 8
                             2082 ; 873  |#define HW_DACCSR_RVUP_BITPOS 9
                             2083 ; 874  |#define HW_DACCSR_VUP_BITPOS 10
                             2084 ; 875  |#define HW_DACCSR_RSRVD_BITPOS 11
                             2085 ; 876  |#define HW_DACCSR_CLKGT_BITPOS 23
                             2086 ; 877  |
                             2087 ; 878  |#define HW_DACCSR_TXEN_WIDTH (1)
                             2088 ; 879  |#define HW_DACCSR_TXIEN_WIDTH (1)
                             2089 ; 880  |#define HW_DACCSR_TXI_WIDTH (1)
                             2090 ; 881  |#define HW_DACCSR_TXEXC_WIDTH (1)
                             2091 ; 882  |#define HW_DACCSR_LPBK_WIDTH (1)
                             2092 ; 883  |#define HW_DACCSR_DMASEL_WIDTH (2)
                             2093 ; 884  |#define HW_DACCSR_DAC_HIPPOP_EN_WIDTH (1)
                             2094 ; 885  |#define HW_DACCSR_LVUP_WIDTH (1)
                             2095 ; 886  |#define HW_DACCSR_RVUP_WIDTH (1)
                             2096 ; 887  |#define HW_DACCSR_VUP_WIDTH (1)
                             2097 ; 888  |#define HW_DACCSR_RSRVD_WIDTH (12)
                             2098 ; 889  |#define HW_DACCSR_CLKGT_WIDTH (1)
                             2099 ; 890  |
                             2100 ; 891  |#define HW_DACCSR_TXEN_SETMASK 1<<HW_DACCSR_TXEN_BITPOS
                             2101 ; 892  |#define HW_DACCSR_TXIEN_SETMASK 1<<HW_DACCSR_TXIEN_BITPOS
                             2102 ; 893  |#define HW_DACCSR_TXI_SETMASK 1<<HW_DACCSR_TXI_BITPOS
                             2103 ; 894  |#define HW_DACCSR_TXEXC_SETMASK 1<<HW_DACCSR_TXEXC_BITPOS
                             2104 ; 895  |#define HW_DACCSR_LPBK_SETMASK 1<<HW_DACCSR_LPBK_BITPOS
                             2105 ; 896  |#define HW_DACCSR_DMASEL_P_SETMASK ((2)<<(HW_DACCSR_DMASEL_BITPOS))
                             2106 ; 897  |#define HW_DACCSR_DMASEL_Y_SETMASK (1<<(HW_DACCSR_DMASEL_BITPOS))
                             2107 ; 898  |//         DMASEL_X has no asm setmask since X config value is 00 binary.
                             2108 ; 899  |#define HW_DACCSR_DAC_HIPPOP_EN_SETMASK (1<<HW_DACCSR_DAC_HIPPOP_EN_BITPOS)
                             2109 ; 900  |#define HW_DACCSR_LVUP_SETMASK (1<<HW_DACCSR_LVUP_BITPOS)
                             2110 ; 901  |#define HW_DACCSR_RVUP_SETMASK (1<<HW_DACCSR_RVUP_BITPOS)
                             2111 ; 902  |#define HW_DACCSR_VUP_SETMASK (1<<HW_DACCSR_VUP_BITPOS)
                             2112 ; 903  |#define HW_DACCSR_CLKGT_SETMASK (1<<HW_DACCSR_CLKGT_BITPOS)
                             2113 ; 904  |
                             2114 ; 905  |#define HW_DACCSR_TXEN_CLRMASK ~(WORD)HW_DACCSR_TXEN_SETMASK
                             2115 ; 906  |#define HW_DACCSR_TXIEN_CLRMASK ~(WORD)HW_DACCSR_TXIEN_SETMASK
                             2116 ; 907  |#define HW_DACCSR_TXI_CLRMASK ~(WORD)HW_DACCSR_TXI_SETMASK
                             2117 ; 908  |#define HW_DACCSR_TXEXC_CLRMASK ~(WORD)HW_DACCSR_TXEXC_SETMASK
                             2118 ; 909  |#define HW_DACCSR_LPBK_CLRMASK ~(WORD)HW_DACCSR_LPBK_SETMASK
                             2119 ; 910  |// No asm clrmask for 2 bit bitfield DMASEL
                             2120 ; 911  |#define HW_DACCSR_DAC_HIPPOP_EN_CLRMASK ~(WORD)HW_DACCSR_DAC_HIPPOP_EN_SETMASK
                             2121 ; 912  |#define HW_DACCSR_LVUP_CLRMASK ~(WORD)HW_DACCSR_LVUP_SETMASK
                             2122 ; 913  |#define HW_DACCSR_RVUP_CLRMASK ~(WORD)HW_DACCSR_RVUP_SETMASK
                             2123 ; 914  |#define HW_DACCSR_VUP_CLRMASK ~(WORD)HW_DACCSR_VUP_SETMASK
                             2124 ; 915  |#define HW_DACCSR_CLKGT_CLRMASK ~(WORD)HW_DACCSR_CLKGT_SETMASK 
                             2125 ; 916  |
                             2126 ; 917  |
                             2127 ; 918  |typedef union               
                             2128 ; 919  |{
                             2129 ; 920  |    struct {
                             2130 ; 921  |        int TXEN                        : HW_DACCSR_TXEN_WIDTH;
                             2131 ; 922  |        int TXIEN                       : HW_DACCSR_TXIEN_WIDTH;
                             2132 ; 923  |        int TXI                         : HW_DACCSR_TXI_WIDTH;
                             2133 ; 924  |        int TXEXC                       : HW_DACCSR_TXEXC_WIDTH;
                             2134 ; 925  |        int LPBK                        : HW_DACCSR_LPBK_WIDTH;
                             2135 ; 926  |        int DMASEL                      : HW_DACCSR_DMASEL_WIDTH;
                             2136 ; 927  |             #define HW_DACCSR_DMASEL_X_BITFIELD_VAL    0
                             2137 ; 928  |             #define HW_DACCSR_DMASEL_Y_BITFIELD_VAL    1
                             2138 ; 929  |             #define HW_DACCSR_DMASEL_P_BITFIELD_VAL    2       
                             2139 ; 930  |        int DAC_HIPPOP_EN               : HW_DACCSR_DAC_HIPPOP_EN_WIDTH;
                             2140 ; 931  |        int LVUP                        : HW_DACCSR_LVUP_WIDTH;
                             2141 ; 932  |        int RVUP                        : HW_DACCSR_RVUP_WIDTH;
                             2142 ; 933  |        int VUP                         : HW_DACCSR_VUP_WIDTH;
                             2143 ; 934  |        int RSVD                        : HW_DACCSR_RSRVD_WIDTH;
                             2144 ; 935  |        int CLKGT                       : HW_DACCSR_CLKGT_WIDTH;
                             2145 ; 936  |    } B;
                             2146 ; 937  |    int I;
                             2147 ; 938  |    unsigned int U;
                             2148 ; 939  |} dac_csr_type;
                             2149 ; 940  |#define HW_DACCSR      (*(volatile dac_csr_type _X*) (HW_DAC_BASEADDR))
                             2150 ; 941  |
                             2151 ; 942  |
                             2152 ; 943  |
                             2153 ; 944  |/////////////////////////////////////////////////////////////////////////////////
                             2154 ; 945  |//  DAC Sample Rate Register (HW_DACSRR) Bit Definitions
                             2155 ; 946  |#define HW_DACSRR_SR_BITPOS 0
                             2156 ; 947  |
                             2157 ; 948  |#define HW_DACSRR_SR_WIDTH (23)
                             2158 ; 949  |#define HW_DACSRR_RSVD_WIDTH (1)
                             2159 ; 950  |
                             2160 ; 951  |//HW_DACSRR_SR_SETMASK                    equ     $FFFFFF<<HW_DACSRR_SR_BITPOS
                             2161 ; 952  |#define HW_DACSRR_SR_SETMASK (((1<<HW_DACSRR_SR_WIDTH)-1)<<HW_DACSRR_SR_BITPOS)        
                             2162 ; 953  |
                             2163 ; 954  |#define HW_DACSRR_SR_CLRMASK ~(WORD)HW_DACSRR_SR_SETMASK
                             2164 ; 955  |
                             2165 ; 956  |typedef union               
                             2166 ; 957  |{
                             2167 ; 958  |    struct {
                             2168 ; 959  |        int SR                          : HW_DACSRR_SR_WIDTH;
                             2169 ; 960  |        int RSVD                        : HW_DACSRR_RSVD_WIDTH;
                             2170 ; 961  |    } B;
                             2171 ; 962  |    int I;
                             2172 ; 963  |    unsigned int U;
                             2173 ; 964  |} dac_srr_type;
                             2174 ; 965  |#define HW_DACSRR      (*(volatile dac_srr_type _X*) (HW_DAC_BASEADDR+1))
                             2175 ; 966  |
                             2176 ; 967  |
                             2177 ; 968  |
                             2178 ; 969  |/////////////////////////////////////////////////////////////////////////////////
                             2179 ; 970  |//  DAC Word Count Register (HW_DACWCR) Bit Definitions
                             2180 ; 971  |#define HW_DACWCR_WCR_BITPOS 0
                             2181 ; 972  |
                             2182 ; 973  |#define HW_DACWCR_WCR_WIDTH (10)
                             2183 ; 974  |#define HW_DACWCR_RSVD_WIDTH (12)
                             2184 ; 975  |
                             2185 ; 976  |//HW_DACWCR_WCR_SETMASK                   equ     $3FF<<HW_DACWCR_WCR_BITPOS
                             2186 ; 977  |#define HW_DACWCR_WCR_SETMASK (((1<<HW_DACWCR_WCR_WIDTH)-1)<<HW_DACWCR_WCR_BITPOS)        
                             2187 ; 978  |
                             2188 ; 979  |#define HW_DACWCR_WCR_CLRMASK ~(WORD)HW_DACWCR_WCR_SETMASK
                             2189 ; 980  |
                             2190 ; 981  |typedef union               
                             2191 ; 982  |{
                             2192 ; 983  |    struct {
                             2193 ; 984  |        int WCR                         : HW_DACWCR_WCR_WIDTH;
                             2194 ; 985  |        int RSVD                        : HW_DACWCR_RSVD_WIDTH;
                             2195 ; 986  |    } B;
                             2196 ; 987  |    int I;
                             2197 ; 988  |    unsigned int U;
                             2198 ; 989  |} dac_wcr_type;
                             2199 ; 990  |#define HW_DACWCR      (*(volatile dac_wcr_type _X*) (HW_DAC_BASEADDR+2))
                             2200 ; 991  |
                             2201 ; 992  |
                             2202 ; 993  |
                             2203 ; 994  |/////////////////////////////////////////////////////////////////////////////////
                             2204 ; 995  |//  DAC Current Position Register (HW_DACCPR) Bit Definitions
                             2205 ; 996  |#define HW_DACCPR_CPR_BITPOS 0
                             2206 ; 997  |
                             2207 ; 998  |#define HW_DACCPR_CPR_WIDTH (10)
                             2208 ; 999  |#define HW_DACCPR_RSVD_WIDTH (14)
                             2209 ; 1000 |
                             2210 ; 1001 |//HW_DACCPR_CPR_SETMASK                   equ     $3FF<<HW_DACCPR_CPR_BITPOS
                             2211 ; 1002 |#define HW_DACCPR_CPR_SETMASK (((1<<HW_DACCPR_CPR_WIDTH)-1)<<HW_DACCPR_CPR_BITPOS)        
                             2212 ; 1003 |
                             2213 ; 1004 |#define HW_DACCPR_CPR_CLRMASK ~(WORD)HW_DACCPR_CPR_SETMASK
                             2214 ; 1005 |
                             2215 ; 1006 |typedef union               
                             2216 ; 1007 |{
                             2217 ; 1008 |    struct {
                             2218 ; 1009 |        int CPR                         : HW_DACCPR_CPR_WIDTH;
                             2219 ; 1010 |        int RSVD                        : HW_DACCPR_RSVD_WIDTH;
                             2220 ; 1011 |    } B;
                             2221 ; 1012 |    int I;
                             2222 ; 1013 |    unsigned int U;
                             2223 ; 1014 |} dac_cpr_type;
                             2224 ; 1015 |#define HW_DACCPR      (*(volatile dac_cpr_type _X*) (HW_DAC_BASEADDR+3))
                             2225 ; 1016 |
                             2226 ; 1017 |
                             2227 ; 1018 |
                             2228 ; 1019 |/////////////////////////////////////////////////////////////////////////////////
                             2229 ; 1020 |//  DAC Modulo Register (HW_DACMR) Bit Definitions
                             2230 ; 1021 |#define HW_DACMR_MR_BITPOS 0
                             2231 ; 1022 |#define HW_DACMR_MR_WIDTH (10)
                             2232 ; 1023 |#define HW_DACMR_RSVD_WIDTH (14)
                             2233 ; 1024 |
                             2234 ; 1025 |//HW_DACMR_MR_SETMASK                     equ     $3FF<<HW_DACMR_MR_BITPOS
                             2235 ; 1026 |#define HW_DACMR_MR_SETMASK (((1<<HW_DACMR_MR_WIDTH)-1)<<HW_DACMR_MR_BITPOS)        
                             2236 ; 1027 |
                             2237 ; 1028 |#define HW_DACMR_MR_CLRMASK ~(WORD)HW_DACMR_MR_SETMASK
                             2238 ; 1029 |
                             2239 ; 1030 |typedef union               
                             2240 ; 1031 |{
                             2241 ; 1032 |    struct {
                             2242 ; 1033 |        int MR                         : HW_DACMR_MR_WIDTH;
                             2243 ; 1034 |        int RSVD                       : HW_DACMR_RSVD_WIDTH;
                             2244 ; 1035 |    } B;
                             2245 ; 1036 |    int I;
                             2246 ; 1037 |    unsigned int U;
                             2247 ; 1038 |} dac_mr_type;
                             2248 ; 1039 |#define HW_DACMR      (*(volatile dac_mr_type _X*) (HW_DAC_BASEADDR+4))
                             2249 ; 1040 |
                             2250 ; 1041 |
                             2251 ; 1042 |
                             2252 ; 1043 |/////////////////////////////////////////////////////////////////////////////////
                             2253 ; 1044 |//   DAC Base Address Register (HW_DACBAR) Bit Definitions
                             2254 ; 1045 |#define HW_DACBAR_BAR_BITPOS 0
                             2255 ; 1046 |#define HW_DACBAR_BAR_WIDTH (16)
                             2256 ; 1047 |#define HW_DACBAR_RSVD_WIDTH (8)
                             2257 ; 1048 |
                             2258 ; 1049 |//HW_DACBAR_BAR_SETMASK                   equ     $FFFF<<HW_DACBAR_BAR_BITPOS
                             2259 ; 1050 |#define HW_DACBAR_BAR_SETMASK (((1<<HW_DACBAR_BAR_WIDTH)-1)<<HW_DACBAR_BAR_BITPOS)        
                             2260 ; 1051 |
                             2261 ; 1052 |#define HW_DACBAR_BAR_CLRMASK ~(WORD)HW_DACBAR_BAR_SETMASK
                             2262 ; 1053 |
                             2263 ; 1054 |typedef union               
                             2264 ; 1055 |{
                             2265 ; 1056 |    struct {
                             2266 ; 1057 |        int BAR                        : HW_DACBAR_BAR_WIDTH;
                             2267 ; 1058 |        int RSVD                       : HW_DACBAR_RSVD_WIDTH;
                             2268 ; 1059 |    } B;
                             2269 ; 1060 |    int I;
                             2270 ; 1061 |    unsigned int U;
                             2271 ; 1062 |} dac_bar_type;
                             2272 ; 1063 |#define HW_DACBAR      (*(volatile dac_bar_type _X*) (HW_DAC_BASEADDR+5))
                             2273 ; 1064 |
                             2274 ; 1065 |
                             2275 ; 1066 |
                             2276 ; 1067 |/////////////////////////////////////////////////////////////////////////////////
                             2277 ; 1068 |//  DAC Interrupt Control Register (HW_DACICR) Bit Definitions
                             2278 ; 1069 |#define HW_DACICR_IPT_BITPOS 0
                             2279 ; 1070 |
                             2280 ; 1071 |#define HW_DACICR_IPT_WIDTH (10)
                             2281 ; 1072 |#define HW_DACICR_RSVD_WIDTH (12)
                             2282 ; 1073 |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  10

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2283 ; 1074 |#define HW_DACICR_IPT_SETMASK (((1<<HW_DACICR_IPT_WIDTH)-1)<<HW_DACICR_IPT_BITPOS)        
                             2284 ; 1075 |
                             2285 ; 1076 |#define HW_DACICR_IPT_CLRMASK ~(WORD)HW_DACICR_IPT_SETMASK
                             2286 ; 1077 |
                             2287 ; 1078 |typedef union               
                             2288 ; 1079 |{
                             2289 ; 1080 |    struct {
                             2290 ; 1081 |        int IPT                         : HW_DACICR_IPT_WIDTH;
                             2291 ; 1082 |        int RSVD                        : HW_DACICR_RSVD_WIDTH;
                             2292 ; 1083 |    } B;
                             2293 ; 1084 |    int I;
                             2294 ; 1085 |    unsigned int U;
                             2295 ; 1086 |} dac_icr_type;
                             2296 ; 1087 |#define HW_DACICR      (*(volatile dac_icr_type _X*) (HW_DAC_BASEADDR+6))
                             2297 ; 1088 |
                             2298 ; 1089 |
                             2299 ; 1090 |
                             2300 ; 1091 |
                             2301 ; 1092 |
                             2302 ; 1093 |/////////////////////////////////////////////////////////////////////////////////
                             2303 ; 1094 |/////////////////////////////////////////////////////////////////////////////////
                             2304 ; 1095 |/////////////////////////////////////////////////////////////////////////////////
                             2305 ; 1096 |//////  ADC Registers
                             2306 ; 1097 |/////////////////////////////////////////////////////////////////////////////////
                             2307 ; 1098 |/////////////////////////////////////////////////////////////////////////////////
                             2308 ; 1099 |/////////////////////////////////////////////////////////////////////////////////
                             2309 ; 1100 |#define HW_ADC_BASEADDR 0xFB00
                             2310 ; 1101 |
                             2311 ; 1102 |
                             2312 ; 1103 |
                             2313 ; 1104 |/////////////////////////////////////////////////////////////////////////////////
                             2314 ; 1105 |//  ADC Control Status Register (HW_ADCCSR) Bit Definitions
                             2315 ; 1106 |#define HW_ADCCSR_TXEN_BITPOS 0
                             2316 ; 1107 |#define HW_ADCCSR_TXIEN_BITPOS 1
                             2317 ; 1108 |#define HW_ADCCSR_TXI_BITPOS 2
                             2318 ; 1109 |#define HW_ADCCSR_TXEXC_BITPOS 3
                             2319 ; 1110 |#define HW_ADCCSR_LPBK_BITPOS 4
                             2320 ; 1111 |#define HW_ADCCSR_DMASEL_BITPOS 5
                             2321 ; 1112 |#define HW_ADCCSR_LPFMODE_BITPOS 8
                             2322 ; 1113 |#define HW_ADCCSR_CLKGT_BITPOS 23
                             2323 ; 1114 |
                             2324 ; 1115 |#define HW_ADCCSR_TXEN_WIDTH (1)
                             2325 ; 1116 |#define HW_ADCCSR_TXIEN_WIDTH (1)
                             2326 ; 1117 |#define HW_ADCCSR_TXI_WIDTH (1)
                             2327 ; 1118 |#define HW_ADCCSR_TXEXC_WIDTH (1)
                             2328 ; 1119 |#define HW_ADCCSR_LPBK_WIDTH (1)
                             2329 ; 1120 |#define HW_ADCCSR_DMASEL_WIDTH (2)
                             2330 ; 1121 |#define HW_ADCCSR_RSVD1_WIDTH (1)
                             2331 ; 1122 |#define HW_ADCCSR_LPFMODE_WIDTH (4)
                             2332 ; 1123 |#define HW_ADCCSR_RSVD2_WIDTH (11)
                             2333 ; 1124 |#define HW_ADCCSR_CLKGT_WIDTH (1)
                             2334 ; 1125 |
                             2335 ; 1126 |#define HW_ADCCSR_TXEN_SETMASK 1<<HW_ADCCSR_TXEN_BITPOS
                             2336 ; 1127 |#define HW_ADCCSR_TXIEN_SETMASK 1<<HW_ADCCSR_TXIEN_BITPOS
                             2337 ; 1128 |#define HW_ADCCSR_TXI_SETMASK 1<<HW_ADCCSR_TXI_BITPOS
                             2338 ; 1129 |#define HW_ADCCSR_TXEXC_SETMASK 1<<HW_ADCCSR_TXEXC_BITPOS
                             2339 ; 1130 |#define HW_ADCCSR_LPBK_SETMASK 1<<HW_ADCCSR_LPBK_BITPOS
                             2340 ; 1131 |#define HW_ADCCSR_DMASEL_SETMASK (((1<<HW_ADCCSR_DMASEL_WIDTH)-1)<<HW_ADCCSR_DMASEL_BITPOS)        
                             2341 ; 1132 |#define HW_ADCCSR_LPFMODE_SETMASK (((1<<HW_ADCCSR_LPFMODE_WIDTH)-1)<<HW_ADCCSR_LPFMODE_BITPOS)        
                             2342 ; 1133 |#define HW_ADCCSR_CLKGT_SETMASK 1<<HW_ADCCSR_CLKGT_BITPOS
                             2343 ; 1134 |
                             2344 ; 1135 |#define HW_ADCCSR_TXEN_CLRMASK ~(WORD)HW_ADCCSR_TXEN_SETMASK
                             2345 ; 1136 |#define HW_ADCCSR_TXIEN_CLRMASK ~(WORD)HW_ADCCSR_TXIEN_SETMASK
                             2346 ; 1137 |#define HW_ADCCSR_TXI_CLRMASK ~(WORD)HW_ADCCSR_TXI_SETMASK
                             2347 ; 1138 |#define HW_ADCCSR_TXEXC_CLRMASK ~(WORD)HW_ADCCSR_TXEXC_SETMASK
                             2348 ; 1139 |#define HW_ADCCSR_LPBK_CLRMASK ~(WORD)HW_ADCCSR_LPBK_SETMASK
                             2349 ; 1140 |#define HW_ADCCSR_DMASEL_CLRMASK ~(WORD)HW_ADCCSR_DMASEL_SETMASK
                             2350 ; 1141 |#define HW_ADCCSR_LPFMODE_CLRMASK ~(WORD)HW_ADCCSR_LPFMODE_SETMASK
                             2351 ; 1142 |#define HW_ADCCSR_CLKGT_CLRMASK ~(WORD)HW_ADCCSR_CLKGT_SETMASK
                             2352 ; 1143 |
                             2353 ; 1144 |typedef union               
                             2354 ; 1145 |{
                             2355 ; 1146 |    struct {
                             2356 ; 1147 |        int TXEN                        : HW_ADCCSR_TXEN_WIDTH;
                             2357 ; 1148 |        int TXIEN                       : HW_ADCCSR_TXIEN_WIDTH;
                             2358 ; 1149 |        int TXI                         : HW_ADCCSR_TXI_WIDTH;
                             2359 ; 1150 |        int TXEXC                       : HW_ADCCSR_TXEXC_WIDTH;
                             2360 ; 1151 |        int LPBK                        : HW_ADCCSR_LPBK_WIDTH;
                             2361 ; 1152 |        int RSVD1                       : HW_ADCCSR_RSVD1_WIDTH;
                             2362 ; 1153 |        int DMASEL                      : HW_ADCCSR_DMASEL_WIDTH;
                             2363 ; 1154 |        int LPFMODE                     : HW_ADCCSR_LPFMODE_WIDTH;
                             2364 ; 1155 |        int RSVD2                       : HW_ADCCSR_RSVD2_WIDTH;
                             2365 ; 1156 |        int CLKGT                       : HW_ADCCSR_CLKGT_WIDTH;
                             2366 ; 1157 |    } B;
                             2367 ; 1158 |    int I;
                             2368 ; 1159 |    unsigned int U;
                             2369 ; 1160 |} adc_csr_type;
                             2370 ; 1161 |#define HW_ADCCSR (*(volatile adc_csr_type _X*) (HW_ADC_BASEADDR+0))
                             2371 ; 1162 |
                             2372 ; 1163 |
                             2373 ; 1164 |/////////////////////////////////////////////////////////////////////////////////
                             2374 ; 1165 |//  ADC Word Count Register (HW_ADCWCR) Bit Definitions
                             2375 ; 1166 |#define HW_ADCWCR_WCR_BITPOS 0
                             2376 ; 1167 |
                             2377 ; 1168 |#define HW_ADCWCR_WCR_WIDTH (10)
                             2378 ; 1169 |#define HW_ADCWCR_RSVD_WIDTH (14)
                             2379 ; 1170 |
                             2380 ; 1171 |#define HW_ADCWCR_WCR_SETMASK (((1<<HW_ADCWCR_WCR_WIDTH)-1)<<HW_ADCWCR_WCR_BITPOS)        
                             2381 ; 1172 |
                             2382 ; 1173 |#define HW_ADCWCR_WCR_CLRMASK ~(WORD)HW_ADCWCR_WCR_SETMASK
                             2383 ; 1174 |
                             2384 ; 1175 |typedef union               
                             2385 ; 1176 |{
                             2386 ; 1177 |    struct {
                             2387 ; 1178 |        int WCR                         : HW_ADCWCR_WCR_WIDTH;
                             2388 ; 1179 |        int RSVD                        : HW_ADCWCR_RSVD_WIDTH;
                             2389 ; 1180 |    } B;
                             2390 ; 1181 |    int I;
                             2391 ; 1182 |    unsigned int U;
                             2392 ; 1183 |} adc_wcr_type;
                             2393 ; 1184 |#define HW_ADCWCR (*(volatile adc_wcr_type _X*) (HW_ADC_BASEADDR+2))
                             2394 ; 1185 |
                             2395 ; 1186 |
                             2396 ; 1187 |
                             2397 ; 1188 |/////////////////////////////////////////////////////////////////////////////////
                             2398 ; 1189 |//   ADC Base Address Register (HW_ADCBAR) Bit Definitions
                             2399 ; 1190 |#define HW_ADCBAR_BAR_BITPOS 0
                             2400 ; 1191 |#define HW_ADCBAR_BAR_WIDTH (16)
                             2401 ; 1192 |#define HW_ADCBAR_RSVD_WIDTH (8)
                             2402 ; 1193 |
                             2403 ; 1194 |//HW_ADCBAR_BAR_SETMASK                   equ     $FFFF<<HW_ADCBAR_BAR_BITPOS
                             2404 ; 1195 |#define HW_ADCBAR_BAR_SETMASK (((1<<HW_ADCBAR_BAR_WIDTH)-1)<<HW_ADCBAR_BAR_BITPOS)        
                             2405 ; 1196 |
                             2406 ; 1197 |#define HW_ADCBAR_BAR_CLRMASK ~(WORD)HW_ADCBAR_BAR_SETMASK
                             2407 ; 1198 |
                             2408 ; 1199 |typedef union               
                             2409 ; 1200 |{
                             2410 ; 1201 |    struct {
                             2411 ; 1202 |        int BAR                        : HW_ADCBAR_BAR_WIDTH;
                             2412 ; 1203 |        int RSVD                       : HW_ADCBAR_RSVD_WIDTH;
                             2413 ; 1204 |    } B;
                             2414 ; 1205 |    int I;
                             2415 ; 1206 |    unsigned int U;
                             2416 ; 1207 |} adc_bar_type;
                             2417 ; 1208 |#define HW_ADCBAR (*(volatile adc_bar_type _X*) (HW_ADC_BASEADDR+5))
                             2418 ; 1209 |
                             2419 ; 1210 |
                             2420 ; 1211 |
                             2421 ; 1212 |
                             2422 ; 1213 |
                             2423 ; 1214 |/////////////////////////////////////////////////////////////////////////////////
                             2424 ; 1215 |//  DAC Current Position Register (HW_ADCCPR) Bit Definitions
                             2425 ; 1216 |#define HW_ADCCPR_CPR_BITPOS 0
                             2426 ; 1217 |
                             2427 ; 1218 |#define HW_ADCCPR_CPR_WIDTH (10)
                             2428 ; 1219 |#define HW_ADCCPR_RSVD_WIDTH (14)
                             2429 ; 1220 |
                             2430 ; 1221 |#define HW_ADCCPR_CPR_SETMASK (((1<<HW_ADCCPR_CPR_WIDTH)-1)<<HW_ADCCPR_CPR_BITPOS)        
                             2431 ; 1222 |
                             2432 ; 1223 |#define HW_ADCCPR_CPR_CLRMASK ~(WORD)HW_ADCCPR_CPR_SETMASK
                             2433 ; 1224 |
                             2434 ; 1225 |typedef union               
                             2435 ; 1226 |{
                             2436 ; 1227 |    struct {
                             2437 ; 1228 |        int CPR                         : HW_ADCCPR_CPR_WIDTH;
                             2438 ; 1229 |        int RSVD                        : HW_ADCCPR_RSVD_WIDTH;
                             2439 ; 1230 |    } B;
                             2440 ; 1231 |    int I;
                             2441 ; 1232 |    unsigned int U;
                             2442 ; 1233 |} adc_cpr_type;
                             2443 ; 1234 |#define HW_ADCCPR (*(volatile adc_cpr_type _X*) (HW_ADC_BASEADDR+3))
                             2444 ; 1235 |
                             2445 ; 1236 |
                             2446 ; 1237 |/////////////////////////////////////////////////////////////////////////////////
                             2447 ; 1238 |//  ADC Modulo Register (HW_ADCMR) Bit Definitions
                             2448 ; 1239 |#define HW_ADCMR_MR_BITPOS 0
                             2449 ; 1240 |#define HW_ADCMR_MR_WIDTH (10)
                             2450 ; 1241 |#define HW_ADCMR_RSVD_WIDTH (14)
                             2451 ; 1242 |
                             2452 ; 1243 |//HW_ADCMR_MR_SETMASK                     equ     $3FF<<HW_ADCMR_MR_BITPOS
                             2453 ; 1244 |#define HW_ADCMR_MR_SETMASK (((1<<HW_ADCMR_MR_WIDTH)-1)<<HW_ADCMR_MR_BITPOS)        
                             2454 ; 1245 |
                             2455 ; 1246 |#define HW_ADCMR_MR_CLRMASK ~(WORD)HW_ADCMR_MR_SETMASK
                             2456 ; 1247 |
                             2457 ; 1248 |typedef union               
                             2458 ; 1249 |{
                             2459 ; 1250 |    struct {
                             2460 ; 1251 |        int MR                         : HW_ADCMR_MR_WIDTH;
                             2461 ; 1252 |        int RSVD                       : HW_ADCMR_RSVD_WIDTH;
                             2462 ; 1253 |    } B;
                             2463 ; 1254 |    int I;
                             2464 ; 1255 |    unsigned int U;
                             2465 ; 1256 |} adc_mr_type;
                             2466 ; 1257 |#define HW_ADCMR (*(volatile adc_mr_type _X*) (HW_ADC_BASEADDR+4))
                             2467 ; 1258 |
                             2468 ; 1259 |/////////////////////////////////////////////////////////////////////////////////
                             2469 ; 1260 |//  ADC Sample Rate Register (HW_ADCSRR) Bit Definitions
                             2470 ; 1261 |#define HW_ADCSRR_SR_BITPOS 0
                             2471 ; 1262 |
                             2472 ; 1263 |#define HW_ADCSRR_SR_WIDTH (23)
                             2473 ; 1264 |#define HW_ADCSRR_RSVD_WIDTH (1)
                             2474 ; 1265 |
                             2475 ; 1266 |//HW_ADCSRR_SR_SETMASK                    equ     $FFFFFF<<HW_ADCSRR_SR_BITPOS
                             2476 ; 1267 |#define HW_ADCSRR_SR_SETMASK (((1<<HW_ADCSRR_SR_WIDTH)-1)<<HW_ADCSRR_SR_BITPOS)        
                             2477 ; 1268 |
                             2478 ; 1269 |#define HW_ADCSRR_SR_CLRMASK ~(WORD)HW_ADCSRR_SR_SETMASK
                             2479 ; 1270 |
                             2480 ; 1271 |typedef union               
                             2481 ; 1272 |{
                             2482 ; 1273 |    struct {
                             2483 ; 1274 |        int SR                          : HW_ADCSRR_SR_WIDTH;
                             2484 ; 1275 |        int RSVD                        : HW_ADCSRR_RSVD_WIDTH;
                             2485 ; 1276 |    } B;
                             2486 ; 1277 |    int I;
                             2487 ; 1278 |    unsigned int U;
                             2488 ; 1279 |} adc_srr_type;
                             2489 ; 1280 |#define HW_ADCSRR (*(volatile adc_srr_type _X*) (HW_ADC_BASEADDR+1))
                             2490 ; 1281 |
                             2491 ; 1282 |/////////////////////////////////////////////////////////////////////////////////
                             2492 ; 1283 |//  ADC Interrupt Control Register (HW_ADCICR) Bit Definitions
                             2493 ; 1284 |#define HW_ADCICR_IPT_BITPOS 0
                             2494 ; 1285 |
                             2495 ; 1286 |#define HW_ADCICR_IPT_WIDTH (10)
                             2496 ; 1287 |#define HW_ADCICR_RSVD_WIDTH (12)
                             2497 ; 1288 |
                             2498 ; 1289 |#define HW_ADCICR_IPT_SETMASK (((1<<HW_ADCICR_IPT_WIDTH)-1)<<HW_ADCICR_IPT_BITPOS)        
                             2499 ; 1290 |
                             2500 ; 1291 |#define HW_ADCICR_IPT_CLRMASK ~(WORD)HW_ADCICR_IPT_SETMASK
                             2501 ; 1292 |
                             2502 ; 1293 |typedef union               
                             2503 ; 1294 |{
                             2504 ; 1295 |    struct {
                             2505 ; 1296 |        int IPT                         : HW_ADCICR_IPT_WIDTH;
                             2506 ; 1297 |        int RSVD                        : HW_ADCICR_RSVD_WIDTH;
                             2507 ; 1298 |    } B;
                             2508 ; 1299 |    int I;
                             2509 ; 1300 |    unsigned int U;
                             2510 ; 1301 |} adc_icr_type;
                             2511 ; 1302 |#define HW_ADCICR (*(volatile adc_icr_type _X*) (HW_ADC_BASEADDR+6))
                             2512 ; 1303 |
                             2513 ; 1304 |//*********************  REGISTER ALIAS DEFINES TO MATCH LEGACY CODE *******************************
                             2514 ; 1305 |// The following defines were added to match regs3410.inc definition to build SDK2XXX code without needing 
                             2515 ; 1306 |// to update the actual files. Only the defines needed to build SDK2.400 were added.
                             2516 ; 1307 |
                             2517 ; 1308 |#define HW_MIXTBR_PW_ADC_RIGHT_CH_BITPOS 16
                             2518 ; 1309 |
                             2519 ; 1310 |#define HW_MIXLINE1INVR_GN_ZERO_SETMASK 0x808
                             2520 ; 1311 |
                             2521 ; 1312 |#endif
                             2522 ; 1313 |
                             2523 
                             2525 
                             2526 ; 20   |#include "regsdcdc.h"
                             2527 
                             2529 
                             2530 ; 1    |#if !(defined(regsdcdcinc))
                             2531 ; 2    |
                             2532 ; 3    |#define regssysteminc 1
                             2533 ; 4    |
                             2534 ; 5    |
                             2535 ; 6    |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  11

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2536 ; 7    |#include "types.h"
                             2537 
                             2539 
                             2540 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2541 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             2542 ; 3    |//
                             2543 ; 4    |// Filename: types.h
                             2544 ; 5    |// Description: Standard data types
                             2545 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             2546 ; 7    |
                             2547 ; 8    |#ifndef _TYPES_H
                             2548 ; 9    |#define _TYPES_H
                             2549 ; 10   |
                             2550 ; 11   |// TODO:  move this outta here!
                             2551 ; 12   |#if !defined(NOERROR)
                             2552 ; 13   |#define NOERROR 0
                             2553 ; 14   |#define SUCCESS 0
                             2554 ; 15   |#endif 
                             2555 ; 16   |#if !defined(SUCCESS)
                             2556 ; 17   |#define SUCCESS  0
                             2557 ; 18   |#endif
                             2558 ; 19   |#if !defined(ERROR)
                             2559 ; 20   |#define ERROR   -1
                             2560 ; 21   |#endif
                             2561 ; 22   |#if !defined(FALSE)
                             2562 ; 23   |#define FALSE 0
                             2563 ; 24   |#endif
                             2564 ; 25   |#if !defined(TRUE)
                             2565 ; 26   |#define TRUE  1
                             2566 ; 27   |#endif
                             2567 ; 28   |
                             2568 ; 29   |#if !defined(NULL)
                             2569 ; 30   |#define NULL 0
                             2570 ; 31   |#endif
                             2571 ; 32   |
                             2572 ; 33   |#define MAX_INT     0x7FFFFF
                             2573 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             2574 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             2575 ; 36   |#define MAX_ULONG   (-1) 
                             2576 ; 37   |
                             2577 ; 38   |#define WORD_SIZE   24              // word size in bits
                             2578 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             2579 ; 40   |
                             2580 ; 41   |
                             2581 ; 42   |#define BYTE    unsigned char       // btVarName
                             2582 ; 43   |#define CHAR    signed char         // cVarName
                             2583 ; 44   |#define USHORT  unsigned short      // usVarName
                             2584 ; 45   |#define SHORT   unsigned short      // sVarName
                             2585 ; 46   |#define WORD    unsigned int        // wVarName
                             2586 ; 47   |#define INT     signed int          // iVarName
                             2587 ; 48   |#define DWORD   unsigned long       // dwVarName
                             2588 ; 49   |#define LONG    signed long         // lVarName
                             2589 ; 50   |#define BOOL    unsigned int        // bVarName
                             2590 ; 51   |#define FRACT   _fract              // frVarName
                             2591 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             2592 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             2593 ; 54   |#define FLOAT   float               // fVarName
                             2594 ; 55   |#define DBL     double              // dVarName
                             2595 ; 56   |#define ENUM    enum                // eVarName
                             2596 ; 57   |#define CMX     _complex            // cmxVarName
                             2597 ; 58   |typedef WORD UCS3;                   // 
                             2598 ; 59   |
                             2599 ; 60   |#define UINT16  unsigned short
                             2600 ; 61   |#define UINT8   unsigned char   
                             2601 ; 62   |#define UINT32  unsigned long
                             2602 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             2603 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             2604 ; 65   |#define WCHAR   UINT16
                             2605 ; 66   |
                             2606 ; 67   |//UINT128 is 16 bytes or 6 words
                             2607 ; 68   |typedef struct UINT128_3500 {   
                             2608 ; 69   |    int val[6];     
                             2609 ; 70   |} UINT128_3500;
                             2610 ; 71   |
                             2611 ; 72   |#define UINT128   UINT128_3500
                             2612 ; 73   |
                             2613 ; 74   |// Little endian word packed byte strings:   
                             2614 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2615 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2616 ; 77   |// Little endian word packed byte strings:   
                             2617 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2618 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2619 ; 80   |
                             2620 ; 81   |// Declare Memory Spaces To Use When Coding
                             2621 ; 82   |// A. Sector Buffers
                             2622 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             2623 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             2624 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             2625 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             2626 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             2627 ; 88   |// B. Media DDI Memory
                             2628 ; 89   |#define MEDIA_DDI_MEM _Y
                             2629 ; 90   |
                             2630 ; 91   |
                             2631 ; 92   |
                             2632 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             2633 ; 94   |// Examples of circular pointers:
                             2634 ; 95   |//    INT CIRC cpiVarName
                             2635 ; 96   |//    DWORD CIRC cpdwVarName
                             2636 ; 97   |
                             2637 ; 98   |#define RETCODE INT                 // rcVarName
                             2638 ; 99   |
                             2639 ; 100  |// generic bitfield structure
                             2640 ; 101  |struct Bitfield {
                             2641 ; 102  |    unsigned int B0  :1;
                             2642 ; 103  |    unsigned int B1  :1;
                             2643 ; 104  |    unsigned int B2  :1;
                             2644 ; 105  |    unsigned int B3  :1;
                             2645 ; 106  |    unsigned int B4  :1;
                             2646 ; 107  |    unsigned int B5  :1;
                             2647 ; 108  |    unsigned int B6  :1;
                             2648 ; 109  |    unsigned int B7  :1;
                             2649 ; 110  |    unsigned int B8  :1;
                             2650 ; 111  |    unsigned int B9  :1;
                             2651 ; 112  |    unsigned int B10 :1;
                             2652 ; 113  |    unsigned int B11 :1;
                             2653 ; 114  |    unsigned int B12 :1;
                             2654 ; 115  |    unsigned int B13 :1;
                             2655 ; 116  |    unsigned int B14 :1;
                             2656 ; 117  |    unsigned int B15 :1;
                             2657 ; 118  |    unsigned int B16 :1;
                             2658 ; 119  |    unsigned int B17 :1;
                             2659 ; 120  |    unsigned int B18 :1;
                             2660 ; 121  |    unsigned int B19 :1;
                             2661 ; 122  |    unsigned int B20 :1;
                             2662 ; 123  |    unsigned int B21 :1;
                             2663 ; 124  |    unsigned int B22 :1;
                             2664 ; 125  |    unsigned int B23 :1;
                             2665 ; 126  |};
                             2666 ; 127  |
                             2667 ; 128  |union BitInt {
                             2668 ; 129  |        struct Bitfield B;
                             2669 ; 130  |        int        I;
                             2670 ; 131  |};
                             2671 ; 132  |
                             2672 ; 133  |#define MAX_MSG_LENGTH 10
                             2673 ; 134  |struct CMessage
                             2674 ; 135  |{
                             2675 ; 136  |        unsigned int m_uLength;
                             2676 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             2677 ; 138  |};
                             2678 ; 139  |
                             2679 ; 140  |typedef struct {
                             2680 ; 141  |    WORD m_wLength;
                             2681 ; 142  |    WORD m_wMessage;
                             2682 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             2683 ; 144  |} Message;
                             2684 ; 145  |
                             2685 ; 146  |struct MessageQueueDescriptor
                             2686 ; 147  |{
                             2687 ; 148  |        int *m_pBase;
                             2688 ; 149  |        int m_iModulo;
                             2689 ; 150  |        int m_iSize;
                             2690 ; 151  |        int *m_pHead;
                             2691 ; 152  |        int *m_pTail;
                             2692 ; 153  |};
                             2693 ; 154  |
                             2694 ; 155  |struct ModuleEntry
                             2695 ; 156  |{
                             2696 ; 157  |    int m_iSignaledEventMask;
                             2697 ; 158  |    int m_iWaitEventMask;
                             2698 ; 159  |    int m_iResourceOfCode;
                             2699 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             2700 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             2701 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             2702 ; 163  |    int m_uTimeOutHigh;
                             2703 ; 164  |    int m_uTimeOutLow;
                             2704 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             2705 ; 166  |};
                             2706 ; 167  |
                             2707 ; 168  |union WaitMask{
                             2708 ; 169  |    struct B{
                             2709 ; 170  |        unsigned int m_bNone     :1;
                             2710 ; 171  |        unsigned int m_bMessage  :1;
                             2711 ; 172  |        unsigned int m_bTimer    :1;
                             2712 ; 173  |        unsigned int m_bButton   :1;
                             2713 ; 174  |    } B;
                             2714 ; 175  |    int I;
                             2715 ; 176  |} ;
                             2716 ; 177  |
                             2717 ; 178  |
                             2718 ; 179  |struct Button {
                             2719 ; 180  |        WORD wButtonEvent;
                             2720 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             2721 ; 182  |};
                             2722 ; 183  |
                             2723 ; 184  |struct Message {
                             2724 ; 185  |        WORD wMsgLength;
                             2725 ; 186  |        WORD wMsgCommand;
                             2726 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             2727 ; 188  |};
                             2728 ; 189  |
                             2729 ; 190  |union EventTypes {
                             2730 ; 191  |        struct CMessage msg;
                             2731 ; 192  |        struct Button Button ;
                             2732 ; 193  |        struct Message Message;
                             2733 ; 194  |};
                             2734 ; 195  |
                             2735 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             2736 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             2737 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             2738 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             2739 ; 200  |
                             2740 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             2741 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             2742 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             2743 ; 204  |
                             2744 ; 205  |#if DEBUG
                             2745 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             2746 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             2747 ; 208  |#else 
                             2748 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             2749 ; 210  |#define DebugBuildAssert(x)    
                             2750 ; 211  |#endif
                             2751 ; 212  |
                             2752 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             2753 ; 214  |//  #pragma asm
                             2754 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             2755 ; 216  |//  #pragma endasm
                             2756 ; 217  |
                             2757 ; 218  |
                             2758 ; 219  |#ifdef COLOR_262K
                             2759 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             2760 ; 221  |#elif defined(COLOR_65K)
                             2761 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             2762 ; 223  |#else
                             2763 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             2764 ; 225  |#endif
                             2765 ; 226  |    
                             2766 ; 227  |#endif // #ifndef _TYPES_H
                             2767 
                             2769 
                             2770 ; 8    |
                             2771 ; 9    |
                             2772 ; 10   |
                             2773 ; 11   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             2774 ; 12   |
                             2775 ; 13   |//   SYSTEM STMP Registers 
                             2776 ; 14   |//      Last Edited 2.19.2003 M. May
                             2777 ; 15   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             2778 ; 16   |
                             2779 ; 17   |#define HW_DCDC_BASEADDR (0xFA0C)
                             2780 ; 18   |
                             2781 ; 19   |
                             2782 ; 20   |
                             2783 ; 21   |
                             2784 ; 22   |
                             2785 ; 23   |
                             2786 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                             2787 ; 25   |
                             2788 ; 26   |//  DcDc#1 Control Register (HW_DCDC1_CTRL0) Bit Definitions
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  12

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2789 ; 27   |
                             2790 ; 28   |#define HW_DCDC1_CTRL0_PLEVBU_WIDTH (5)
                             2791 ; 29   |#define HW_DCDC1_CTRL0_RSVD0_WIDTH (3)
                             2792 ; 30   |#define HW_DCDC1_CTRL0_PLEVBO_WIDTH (5)
                             2793 ; 31   |#define HW_DCDC1_CTRL0_RSVD1_WIDTH (3)
                             2794 ; 32   |#define HW_DCDC1_CTRL0_NLEV_WIDTH (5)
                             2795 ; 33   |
                             2796 ; 34   |#define HW_DCDC1_CTRL0_RSVD2_WIDTH (3)
                             2797 ; 35   |
                             2798 ; 36   |
                             2799 ; 37   |
                             2800 ; 38   |#define HW_DCDC1_CTRL0_PLEVBU_BITPOS (0)
                             2801 ; 39   |#define HW_DCDC1_CTRL0_PLEVBO_BITPOS (8)
                             2802 ; 40   |#define HW_DCDC1_CTRL0_NLEV_BITPOS (16)
                             2803 ; 41   |
                             2804 ; 42   |
                             2805 ; 43   |
                             2806 ; 44   |#define HW_DCDC1_CTRL0_PLEVBU_SETMASK (((1<<HW_DCDC1_CTRL0_PLEVBU_WIDTH)-1)<<HW_DCDC1_CTRL0_PLEVBU_BITPOS)        
                             2807 ; 45   |#define HW_DCDC1_CTRL0_PLEVBO_SETMASK (((1<<HW_DCDC1_CTRL0_PLEVBO_WIDTH)-1)<<HW_DCDC1_CTRL0_PLEVBO_BITPOS) 
                             2808 ; 46   |#define HW_DCDC1_CTRL0_NLEV_SETMASK (((1<<HW_DCDC1_CTRL0_NLEV_WIDTH)-1)<<HW_DCDC1_CTRL0_NLEV_BITPOS)  
                             2809 ; 47   |
                             2810 ; 48   |
                             2811 ; 49   |
                             2812 ; 50   |#define HW_DCDC1_CTRL0_PLEVBU_CLRMASK (~(WORD)HW_DCDC1_CTRL0_PLEVBU_SETMASK)     
                             2813 ; 51   |#define HW_DCDC1_CTRL0_PLEVBO_CLRMASK (~(WORD)HW_DCDC1_CTRL0_PLEVBO_SETMASK) 
                             2814 ; 52   |#define HW_DCDC1_CTRL0_NLEV_CLRMASK (~(WORD)HW_DCDC1_CTRL0_NLEV_SETMASK)  
                             2815 ; 53   |
                             2816 ; 54   |
                             2817 ; 55   |
                             2818 ; 56   |
                             2819 ; 57   |
                             2820 ; 58   |typedef union               
                             2821 ; 59   |{
                             2822 ; 60   |    struct {
                             2823 ; 61   |        unsigned int PLEVBU           : HW_DCDC1_CTRL0_PLEVBU_WIDTH;
                             2824 ; 62   |        unsigned int RSVD0            : HW_DCDC1_CTRL0_RSVD0_WIDTH;
                             2825 ; 63   |        unsigned int PLEVBO           : HW_DCDC1_CTRL0_PLEVBO_WIDTH;
                             2826 ; 64   |        unsigned int RSVD1            : HW_DCDC1_CTRL0_RSVD1_WIDTH;
                             2827 ; 65   |        unsigned int NLEV             : HW_DCDC1_CTRL0_NLEV_WIDTH;
                             2828 ; 66   |        unsigned int RSVD2            : HW_DCDC1_CTRL0_RSVD2_WIDTH;
                             2829 ; 67   |    } B;
                             2830 ; 68   |    unsigned int I;
                             2831 ; 69   |} dcdc1_ctrl0_type;
                             2832 ; 70   |#define HW_DCDC1_CTRL0      (*(volatile dcdc1_ctrl0_type _X*) (HW_DCDC_BASEADDR))    /* DcDc#1 Limit Level Register */
                             2833 ; 71   |
                             2834 ; 72   |
                             2835 ; 73   |
                             2836 ; 74   |
                             2837 ; 75   |/////////////////////////////////////////////////////////////////////////////////
                             2838 ; 76   |
                             2839 ; 77   |//  DCDc#1 Control Register1 (HW_DCDC1_CTRL1) Bit Definitions
                             2840 ; 78   |
                             2841 ; 79   |#define HW_DCDC1_CTRL1_C_WIDTH (4)
                             2842 ; 80   |#define HW_DCDC1_CTRL1_R_WIDTH (4)
                             2843 ; 81   |#define HW_DCDC1_CTRL1_FFOR_WIDTH (3)
                             2844 ; 82   |#define HW_DCDC1_CTRL1_RSVD0_WIDTH (1)
                             2845 ; 83   |#define HW_DCDC1_CTRL1_PFMCTRL_WIDTH (12)
                             2846 ; 84   |
                             2847 ; 85   |
                             2848 ; 86   |
                             2849 ; 87   |#define HW_DCDC1_CTRL1_C_BITPOS (0)
                             2850 ; 88   |#define HW_DCDC1_CTRL1_R_BITPOS (4)
                             2851 ; 89   |#define HW_DCDC1_CTRL1_FFOR_BITPOS (8)
                             2852 ; 90   |#define HW_DCDC1_CTRL1_PFMCTRL_BITPOS (12) 
                             2853 ; 91   |
                             2854 ; 92   |#define HW_DCDC1_CTRL1_C_SETMASK (((1<<HW_DCDC1_CTRL1_C_WIDTH)-1)<<HW_DCDC1_CTRL1_C_BITPOS)        
                             2855 ; 93   |#define HW_DCDC1_CTRL1_R_SETMASK (((1<<HW_DCDC1_CTRL1_R_WIDTH)-1)<<HW_DCDC1_CTRL1_R_BITPOS) 
                             2856 ; 94   |#define HW_DCDC1_CTRL1_FFOR_SETMASK (((1<<HW_DCDC1_CTRL1_FFOR_WIDTH)-1)<<HW_DCDC1_CTRL1_FFOR_BITPOS)  
                             2857 ; 95   |#define HW_DCDC1_CTRL1_PFMCTRL_SETMASK (((1<<HW_DCDC1_CTRL1_PFMCTRL_WIDTH)-1)<<HW_DCDC1_CTRL1_PFMCTRL_BITPOS)   
                             2858 ; 96   |
                             2859 ; 97   |#define HW_DCDC1_CTRL1_C_CLRMASK (~(WORD)HW_DCDC1_CTRL1_C_SETMASK)     
                             2860 ; 98   |#define HW_DCDC1_CTRL1_R_CLRMASK (~(WORD)HW_DCDC1_CTRL1_R_SETMASK) 
                             2861 ; 99   |#define HW_DCDC1_CTRL1_FFOR_CLRMASK (~(WORD)HW_DCDC1_CTRL1_FFOR_SETMASK)  
                             2862 ; 100  |#define HW_DCDC1_CTRL1_PFMCTRL_CLRMASK (~(WORD)HW_DCDC1_CTRL1_PFMCTRL_SETMASK)  
                             2863 ; 101  |
                             2864 ; 102  |
                             2865 ; 103  |typedef union               
                             2866 ; 104  |{
                             2867 ; 105  |    struct {
                             2868 ; 106  |        unsigned int C       : HW_DCDC1_CTRL1_C_WIDTH;
                             2869 ; 107  |        unsigned int R                : HW_DCDC1_CTRL1_R_WIDTH;
                             2870 ; 108  |        unsigned int FFOR             : HW_DCDC1_CTRL1_FFOR_WIDTH;
                             2871 ; 109  |        unsigned int RSVD0            : HW_DCDC1_CTRL1_RSVD0_WIDTH;
                             2872 ; 110  |        unsigned int PFMCTRL          : HW_DCDC1_CTRL1_FFOR_WIDTH;
                             2873 ; 111  |    } B;
                             2874 ; 112  |    unsigned int I;
                             2875 ; 113  |} dcdc1_ctrl1_type;
                             2876 ; 114  |#define HW_DCDC1_CTRL1      (*(volatile dcdc1_ctrl1_type _X*) (HW_DCDC_BASEADDR+1))    /* DcDc#1 Ctrl #1 Register */
                             2877 ; 115  |
                             2878 ; 116  |
                             2879 ; 117  |
                             2880 ; 118  |
                             2881 ; 119  |/////////////////////////////////////////////////////////////////////////////////
                             2882 ; 120  |
                             2883 ; 121  |//  DcDc VDDIO Register (HW_DCDC_VDDIO) Bit Definitions
                             2884 ; 122  |
                             2885 ; 123  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_WIDTH (5)
                             2886 ; 124  |#define HW_DCDC_VDDIO_RSVD0_WIDTH (3)
                             2887 ; 125  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_WIDTH (5)
                             2888 ; 126  |#define HW_DCDC_VDDIO_RSVD1_WIDTH (3)
                             2889 ; 127  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_WIDTH (1)
                             2890 ; 128  |#define HW_DCDC_VDDIO_RSVD2_WIDTH (3)
                             2891 ; 129  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_WIDTH (1)
                             2892 ; 130  |#define HW_DCDC_VDDIO_OK_WIDTH (1)
                             2893 ; 131  |#define HW_DCDC_VDDIO_RSVD3_WIDTH (2)
                             2894 ; 132  |
                             2895 ; 133  |
                             2896 ; 134  |
                             2897 ; 135  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_BITPOS (0)
                             2898 ; 136  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_BITPOS (8)
                             2899 ; 137  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_BITPOS (16)
                             2900 ; 138  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_BITPOS (20)
                             2901 ; 139  |#define HW_DCDC_VDDIO_OK_BITPOS (21)
                             2902 ; 140  |
                             2903 ; 141  |
                             2904 ; 142  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_SETMASK (((1<<HW_DCDC_VDDIO_VOLTAGE_LEVEL_WIDTH)-1)<<HW_DCDC_VDDIO_VOLTAGE_LEVEL_BITPOS)        
                             2905 ; 143  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_SETMASK (((1<<HW_DCDC_VDDIO_BROWNOUT_LEVEL_WIDTH)-1)<<HW_DCDC_VDDIO_BROWNOUT_LEVEL_BITPOS) 
                             2906 ; 144  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_SETMASK (((1<<HW_DCDC_VDDIO_BROWNOUT_ENABLE_WIDTH)-1)<<HW_DCDC_VDDIO_BROWNOUT_ENABLE_BITPOS)  
                             2907 ; 145  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_SETMASK (((1<<HW_DCDC_VDDIO_BROWNOUT_STATUS_WIDTH)-1)<<HW_DCDC_VDDIO_BROWNOUT_STATUS_BITPOS)  
                             2908 ; 146  |
                             2909 ; 147  |
                             2910 ; 148  |
                             2911 ; 149  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDIO_VOLTAGE_LEVEL_SETMASK)     
                             2912 ; 150  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDIO_BROWNOUT_LEVEL_SETMASK) 
                             2913 ; 151  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_CLRMASK (~(WORD)HW_DCDC_VDDIO_BROWNOUT_ENABLE_SETMASK)  
                             2914 ; 152  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_CLRMASK (~(WORD)HW_DCDC_VDDIO_BROWNOUT_STATUS_SETMASK)  
                             2915 ; 153  |
                             2916 ; 154  |
                             2917 ; 155  |typedef union               
                             2918 ; 156  |{
                             2919 ; 157  |    struct {
                             2920 ; 158  |        unsigned int VOLTAGE_LEVEL    : HW_DCDC_VDDIO_VOLTAGE_LEVEL_WIDTH;
                             2921 ; 159  |        unsigned int RSVD0            : HW_DCDC_VDDIO_RSVD0_WIDTH;
                             2922 ; 160  |        unsigned int BROWNOUT_LEVEL   : HW_DCDC_VDDIO_BROWNOUT_LEVEL_WIDTH;
                             2923 ; 161  |        unsigned int RSVD1            : HW_DCDC_VDDIO_RSVD1_WIDTH;
                             2924 ; 162  |        unsigned int BROWNOUT_ENABLE  : HW_DCDC_VDDIO_BROWNOUT_ENABLE_WIDTH;
                             2925 ; 163  |        unsigned int RSVD2            : HW_DCDC_VDDIO_RSVD2_WIDTH;
                             2926 ; 164  |        unsigned int BROWNOUT_STATUS  : HW_DCDC_VDDIO_BROWNOUT_STATUS_WIDTH;
                             2927 ; 165  |                 unsigned int VDDIO_OK        : HW_DCDC_VDDIO_OK_WIDTH;
                             2928 ; 166  |        unsigned int RSVD3            : HW_DCDC_VDDIO_RSVD3_WIDTH;
                             2929 ; 167  |    } B;
                             2930 ; 168  |    unsigned int I;
                             2931 ; 169  |} dcdc_vddio_type;
                             2932 ; 170  |#define HW_DCDC_VDDIO      (*(volatile dcdc_vddio_type _X*) (HW_DCDC_BASEADDR+2))    /* DcDc VDDIO Register */
                             2933 ; 171  |
                             2934 ; 172  |
                             2935 ; 173  |
                             2936 ; 174  |/////////////////////////////////////////////////////////////////////////////////
                             2937 ; 175  |//  DcDc VDDD Register (HW_DCDC_VDDD) Bit Definitions
                             2938 ; 176  |
                             2939 ; 177  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_WIDTH (5)
                             2940 ; 178  |#define HW_DCDC_VDDD_RSVD0_WIDTH (3)
                             2941 ; 179  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_WIDTH (5)
                             2942 ; 180  |#define HW_DCDC_VDDD_RSVD1_WIDTH (3)
                             2943 ; 181  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_WIDTH (1)
                             2944 ; 182  |#define HW_DCDC_VDDD_RSVD2_WIDTH (3)
                             2945 ; 183  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_WIDTH (1)
                             2946 ; 184  |#define HW_DCDC_VDDD_OK_WIDTH (1)
                             2947 ; 185  |#define HW_DCDC_VDDD_RSVD3_WIDTH (2)
                             2948 ; 186  |
                             2949 ; 187  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_BITPOS (0)
                             2950 ; 188  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_BITPOS (8)
                             2951 ; 189  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_BITPOS (16)
                             2952 ; 190  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_BITPOS (20)
                             2953 ; 191  |#define HW_DCDC_VDDD_OK_BITPOS (21)
                             2954 ; 192  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_SETMASK (((1<<HW_DCDC_VDDD_VOLTAGE_LEVEL_WIDTH)-1)<<HW_DCDC_VDDD_VOLTAGE_LEVEL_BITPOS)        
                             2955 ; 193  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_SETMASK (((1<<HW_DCDC_VDDD_BROWNOUT_LEVEL_WIDTH)-1)<<HW_DCDC_VDDD_BROWNOUT_LEVEL_BITPOS) 
                             2956 ; 194  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_SETMASK (((1<<HW_DCDC_VDDD_BROWNOUT_ENABLE_WIDTH)-1)<<HW_DCDC_VDDD_BROWNOUT_ENABLE_BITPOS)  
                             2957 ; 195  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_SETMASK (((1<<HW_DCDC_VDDD_BROWNOUT_STATUS_WIDTH)-1)<<HW_DCDC_VDDD_BROWNOUT_STATUS_BITPOS)  
                             2958 ; 196  |
                             2959 ; 197  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDD_VOLTAGE_LEVEL_SETMASK)     
                             2960 ; 198  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDD_BROWNOUT_LEVEL_SETMASK) 
                             2961 ; 199  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_CLRMASK (~(WORD)HW_DCDC_VDDD_BROWNOUT_ENABLE_SETMASK)  
                             2962 ; 200  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_CLRMASK (~(WORD)HW_DCDC_VDDD_BROWNOUT_STATUS_SETMASK)  
                             2963 ; 201  |
                             2964 ; 202  |typedef union               
                             2965 ; 203  |{
                             2966 ; 204  |    struct {
                             2967 ; 205  |        unsigned int VOLTAGE_LEVEL    : HW_DCDC_VDDD_VOLTAGE_LEVEL_WIDTH;
                             2968 ; 206  |        unsigned int RSVD0            : HW_DCDC_VDDD_RSVD0_WIDTH;
                             2969 ; 207  |        unsigned int BROWNOUT_LEVEL   : HW_DCDC_VDDD_BROWNOUT_LEVEL_WIDTH;
                             2970 ; 208  |        unsigned int RSVD1            : HW_DCDC_VDDD_RSVD1_WIDTH;
                             2971 ; 209  |        unsigned int BROWNOUT_ENABLE  : HW_DCDC_VDDD_BROWNOUT_ENABLE_WIDTH;
                             2972 ; 210  |        unsigned int RSVD2            : HW_DCDC_VDDD_RSVD2_WIDTH;
                             2973 ; 211  |        unsigned int BROWNOUT_STATUS  : HW_DCDC_VDDD_BROWNOUT_STATUS_WIDTH;
                             2974 ; 212  |                 unsigned int VDD_OK           : HW_DCDC_VDDD_OK_WIDTH;
                             2975 ; 213  |        unsigned int RSVD3            : HW_DCDC_VDDD_RSVD3_WIDTH;
                             2976 ; 214  |    } B;
                             2977 ; 215  |   unsigned int I;
                             2978 ; 216  |        unsigned U;
                             2979 ; 217  |} dcdc_vddd_type;
                             2980 ; 218  |#define HW_DCDC_VDDD      (*(volatile dcdc_vddd_type _X*) (HW_DCDC_BASEADDR+3))    /* DcDc VDDD Register */
                             2981 ; 219  |
                             2982 ; 220  |
                             2983 ; 221  |
                             2984 ; 222  |
                             2985 ; 223  |/////////////////////////////////////////////////////////////////////////////////
                             2986 ; 224  |
                             2987 ; 225  |//  DcDc Vdda Register (HW_DCDC_VDDA) Bit Definitions
                             2988 ; 226  |
                             2989 ; 227  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_WIDTH (5)
                             2990 ; 228  |#define HW_DCDC_VDDA_RSVD0_WIDTH (3)
                             2991 ; 229  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_WIDTH (5)
                             2992 ; 230  |#define HW_DCDC_VDDA_RSVD1_WIDTH (3)
                             2993 ; 231  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_WIDTH (1)
                             2994 ; 232  |#define HW_DCDC_VDDA_RSVD2_WIDTH (3)
                             2995 ; 233  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_WIDTH (1)
                             2996 ; 234  |#define HW_DCDC_VDDA_OK_WIDTH (1)
                             2997 ; 235  |#define HW_DCDC_VDDA_RSVD3_WIDTH (2)
                             2998 ; 236  |
                             2999 ; 237  |
                             3000 ; 238  |
                             3001 ; 239  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_BITPOS (0)
                             3002 ; 240  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_BITPOS (8)
                             3003 ; 241  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_BITPOS (16)
                             3004 ; 242  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_BITPOS (20)
                             3005 ; 243  |#define HW_DCDC_VDDA_OK_BITPOS (21)
                             3006 ; 244  |
                             3007 ; 245  |
                             3008 ; 246  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_SETMASK (((1<<HW_DCDC_VDDA_VOLTAGE_LEVEL_WIDTH)-1)<<HW_DCDC_VDDA_VOLTAGE_LEVEL_BITPOS)        
                             3009 ; 247  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_SETMASK (((1<<HW_DCDC_VDDA_BROWNOUT_LEVEL_WIDTH)-1)<<HW_DCDC_VDDA_BROWNOUT_LEVEL_BITPOS) 
                             3010 ; 248  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_SETMASK (((1<<HW_DCDC_VDDA_BROWNOUT_ENABLE_WIDTH)-1)<<HW_DCDC_VDDA_BROWNOUT_ENABLE_BITPOS)  
                             3011 ; 249  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_SETMASK (((1<<HW_DCDC_VDDA_BROWNOUT_STATUS_WIDTH)-1)<<HW_DCDC_VDDA_BROWNOUT_STATUS_BITPOS)  
                             3012 ; 250  |
                             3013 ; 251  |
                             3014 ; 252  |
                             3015 ; 253  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDA_VOLTAGE_LEVEL_SETMASK)     
                             3016 ; 254  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDA_BROWNOUT_LEVEL_SETMASK) 
                             3017 ; 255  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_CLRMASK (~(WORD)HW_DCDC_VDDA_BROWNOUT_ENABLE_SETMASK)  
                             3018 ; 256  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_CLRMASK (~(WORD)HW_DCDC_VDDA_BROWNOUT_STATUS_SETMASK)  
                             3019 ; 257  |
                             3020 ; 258  |
                             3021 ; 259  |typedef union               
                             3022 ; 260  |{
                             3023 ; 261  |    struct {
                             3024 ; 262  |        unsigned int VOLTAGE_LEVEL    : HW_DCDC_VDDA_VOLTAGE_LEVEL_WIDTH;
                             3025 ; 263  |        unsigned int RSVD0            : HW_DCDC_VDDA_RSVD0_WIDTH;
                             3026 ; 264  |        unsigned int BROWNOUT_LEVEL   : HW_DCDC_VDDA_BROWNOUT_LEVEL_WIDTH;
                             3027 ; 265  |        unsigned int RSVD1            : HW_DCDC_VDDA_RSVD1_WIDTH;
                             3028 ; 266  |        unsigned int BROWNOUT_ENABLE  : HW_DCDC_VDDA_BROWNOUT_ENABLE_WIDTH;
                             3029 ; 267  |        unsigned int RSVD2            : HW_DCDC_VDDA_RSVD2_WIDTH;
                             3030 ; 268  |        unsigned int BROWNOUT_STATUS  : HW_DCDC_VDDA_BROWNOUT_STATUS_WIDTH;
                             3031 ; 269  |             unsigned int VDDA_OK          : HW_DCDC_VDDA_OK_WIDTH;
                             3032 ; 270  |        unsigned int RSVD3            : HW_DCDC_VDDA_RSVD3_WIDTH;
                             3033 ; 271  |    } B;
                             3034 ; 272  |    unsigned int I;
                             3035 ; 273  |} dcdc_vdda_type;
                             3036 ; 274  |#define HW_DCDC_VDDA      (*(volatile dcdc_vdda_type _X*) (HW_DCDC_BASEADDR+4))    /* DcDc VDDA Register */
                             3037 ; 275  |
                             3038 ; 276  |
                             3039 ; 277  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  13

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3040 ; 278  |
                             3041 ; 279  |/////////////////////////////////////////////////////////////////////////////////
                             3042 ; 280  |
                             3043 ; 281  |//  DcDc#2 Control Register 0 (HW_DCDC2_CTRL0) Bit Definitions
                             3044 ; 282  |
                             3045 ; 283  |#define HW_DCDC2_CTRL0_PLEVBU_WIDTH (5)
                             3046 ; 284  |#define HW_DCDC2_CTRL0_RSVD0_WIDTH (3)
                             3047 ; 285  |#define HW_DCDC2_CTRL0_PLEVBO_WIDTH (5)
                             3048 ; 286  |#define HW_DCDC2_CTRL0_RSVD1_WIDTH (3)
                             3049 ; 287  |#define HW_DCDC2_CTRL0_NLEV_WIDTH (5)
                             3050 ; 288  |#define HW_DCDC2_CTRL0_RSVD2_WIDTH (3)
                             3051 ; 289  |
                             3052 ; 290  |
                             3053 ; 291  |
                             3054 ; 292  |#define HW_DCDC2_CTRL0_PLEVBU_BITPOS (0)
                             3055 ; 293  |#define HW_DCDC2_CTRL0_PLEVBO_BITPOS (8)
                             3056 ; 294  |#define HW_DCDC2_CTRL0_NLEV_BITPOS (16)
                             3057 ; 295  |
                             3058 ; 296  |#define HW_DCDC2_CTRL0_PLEVBU_SETMASK (((1<<HW_DCDC2_CTRL0_PLEVBU_WIDTH)-1)<<HW_DCDC2_CTRL0_PLEVBU_BITPOS)        
                             3059 ; 297  |#define HW_DCDC2_CTRL0_PLEVBO_SETMASK (((1<<HW_DCDC2_CTRL0_PLEVBO_WIDTH)-1)<<HW_DCDC2_CTRL0_PLEVBO_BITPOS) 
                             3060 ; 298  |#define HW_DCDC2_CTRL0_NLEV_SETMASK (((1<<HW_DCDC2_CTRL0_NLEV_WIDTH)-1)<<HW_DCDC2_CTRL0_NLEV_BITPOS)  
                             3061 ; 299  |
                             3062 ; 300  |#define HW_DCDC2_CTRL0_PLEVBU_CLRMASK (~(WORD)HW_DCDC2_CTRL0_PLEVBU_SETMASK)     
                             3063 ; 301  |#define HW_DCDC2_CTRL0_PLEVBO_CLRMASK (~(WORD)HW_DCDC2_CTRL0_PLEVBO_SETMASK) 
                             3064 ; 302  |#define HW_DCDC2_CTRL0_NLEV_CLRMASK (~(WORD)HW_DCDC2_CTRL0_NLEV_SETMASK)  
                             3065 ; 303  |
                             3066 ; 304  |
                             3067 ; 305  |typedef union               
                             3068 ; 306  |{
                             3069 ; 307  |    struct {
                             3070 ; 308  |        unsigned int PLEVBU           : HW_DCDC2_CTRL0_PLEVBU_WIDTH;
                             3071 ; 309  |        unsigned int RSVD0            : HW_DCDC2_CTRL0_RSVD0_WIDTH;
                             3072 ; 310  |        unsigned int PLEVBO           : HW_DCDC2_CTRL0_PLEVBO_WIDTH;
                             3073 ; 311  |        unsigned int RSVD1            : HW_DCDC2_CTRL0_RSVD1_WIDTH;
                             3074 ; 312  |        unsigned int NLEV             : HW_DCDC2_CTRL0_NLEV_WIDTH;
                             3075 ; 313  |        unsigned int RSVD2            : HW_DCDC2_CTRL0_RSVD2_WIDTH;
                             3076 ; 314  |    } B;
                             3077 ; 315  |    unsigned int I;
                             3078 ; 316  |} dcdc2_ctrl0_type; 
                             3079 ; 317  |#define HW_DCDC2_CTRL0      (*(volatile dcdc2_ctrl0_type _X*) (HW_DCDC_BASEADDR+5))    /* DcDc#2 Limit Level Register */
                             3080 ; 318  |
                             3081 ; 319  |
                             3082 ; 320  |
                             3083 ; 321  |
                             3084 ; 322  |/////////////////////////////////////////////////////////////////////////////////
                             3085 ; 323  |
                             3086 ; 324  |//  DcDc#2 Control Register #1 (HW_DCDC2_CTRL1) Bit Definitions
                             3087 ; 325  |
                             3088 ; 326  |#define HW_DCDC2_CTRL1_C_WIDTH (4)
                             3089 ; 327  |#define HW_DCDC2_CTRL1_R_WIDTH (4)
                             3090 ; 328  |#define HW_DCDC2_CTRL1_FFOR_WIDTH (3)
                             3091 ; 329  |#define HW_DCDC2_CTRL1_RSVD0_WIDTH (1)
                             3092 ; 330  |#define HW_DCDC2_CTRL1_PFMCTRL_WIDTH (12)
                             3093 ; 331  |
                             3094 ; 332  |
                             3095 ; 333  |#define HW_DCDC2_CTRL1_C_BITPOS (0)
                             3096 ; 334  |#define HW_DCDC2_CTRL1_R_BITPOS (4)
                             3097 ; 335  |#define HW_DCDC2_CTRL1_FFOR_BITPOS (8)
                             3098 ; 336  |#define HW_DCDC2_CTRL1_PFMCTRL_BITPOS (12)
                             3099 ; 337  |
                             3100 ; 338  |
                             3101 ; 339  |
                             3102 ; 340  |#define HW_DCDC2_CTRL1_C_SETMASK (((1<<HW_DCDC2_CTRL1_C_WIDTH)-1)<<HW_DCDC2_CTRL1_C_BITPOS)        
                             3103 ; 341  |#define HW_DCDC2_CTRL1_R_SETMASK (((1<<HW_DCDC2_CTRL1_R_WIDTH)-1)<<HW_DCDC2_CTRL1_R_BITPOS) 
                             3104 ; 342  |#define HW_DCDC2_CTRL1_FFOR_SETMASK (((1<<HW_DCDC2_CTRL1_FFOR_WIDTH)-1)<<HW_DCDC2_CTRL1_FFOR_BITPOS)  
                             3105 ; 343  |#define HW_DCDC2_CTRL1_PFMCTRL_SETMASK (((1<<HW_DCDC2_CTRL1_PFMCTRL_WIDTH)-1)<<HW_DCDC2_CTRL1_PFMCTRL_BITPOS)  
                             3106 ; 344  |
                             3107 ; 345  |
                             3108 ; 346  |
                             3109 ; 347  |#define HW_DCDC2_CTRL1_C_CLRMASK (~(WORD)HW_DCDC2_CTRL1_C_SETMASK)     
                             3110 ; 348  |#define HW_DCDC2_CTRL1_R_CLRMASK (~(WORD)HW_DCDC2_CTRL1_R_SETMASK) 
                             3111 ; 349  |#define HW_DCDC2_CTRL1_FFOR_CLRMASK (~(WORD)HW_DCDC2_CTRL1_FFOR_SETMASK)  
                             3112 ; 350  |#define HW_DCDC2_CTRL1_PFMCTRL_CLRMASK (~(WORD)HW_DCDC2_CTRL1_PFMCTRL_SETMASK)  
                             3113 ; 351  |
                             3114 ; 352  |
                             3115 ; 353  |typedef union               
                             3116 ; 354  |{
                             3117 ; 355  |    struct {
                             3118 ; 356  |        unsigned int C                : HW_DCDC2_CTRL1_C_WIDTH;
                             3119 ; 357  |        unsigned int R                : HW_DCDC2_CTRL1_R_WIDTH;
                             3120 ; 358  |        unsigned int FFOR             : HW_DCDC2_CTRL1_FFOR_WIDTH;
                             3121 ; 359  |        unsigned int RSVD0            : HW_DCDC2_CTRL1_RSVD0_WIDTH;
                             3122 ; 360  |        unsigned int PFMCTRL          : HW_DCDC2_CTRL1_FFOR_WIDTH;
                             3123 ; 361  |    } B;
                             3124 ; 362  |    unsigned int I;
                             3125 ; 363  |} dcdc2_ctrl1_type;
                             3126 ; 364  |#define HW_DCDC2_CTRL1      (*(volatile dcdc2_ctrl1_type _X*) (HW_DCDC_BASEADDR+6))    /* DcDc#2 Ctrl Register #1 */
                             3127 ; 365  |
                             3128 ; 366  |
                             3129 ; 367  |
                             3130 ; 368  |
                             3131 ; 369  |/////////////////////////////////////////////////////////////////////////////////
                             3132 ; 370  |
                             3133 ; 371  |//  Speed Monitoring Register (HW_SPEED) Bit Definitions
                             3134 ; 372  |
                             3135 ; 373  |#define HW_SPEED_OSC1_PWRUP_WIDTH (1)
                             3136 ; 374  |#define HW_SPEED_OSC1_START_COUNT_WIDTH (1)
                             3137 ; 375  |#define HW_SPEED_RSVD0_WIDTH (2)
                             3138 ; 376  |#define HW_SPEED_RINGOSC1_WIDTH (7)
                             3139 ; 377  |#define HW_SPEED_RSVD1_WIDTH (1)
                             3140 ; 378  |#define HW_SPEED_OSC2_PWRUP_WIDTH (1)
                             3141 ; 379  |#define HW_SPEED_OSC2_START_COUNT_WIDTH (1)
                             3142 ; 380  |#define HW_SPEED_RSVD2_WIDTH (2)
                             3143 ; 381  |#define HW_SPEED_RINGOSC2_WIDTH (7)
                             3144 ; 382  |#define HW_SPEED_RSVD3_WIDTH (1)
                             3145 ; 383  |
                             3146 ; 384  |
                             3147 ; 385  |
                             3148 ; 386  |#define HW_SPEED_OSC1_PWRUP_BITPOS (0)
                             3149 ; 387  |#define HW_SPEED_OSC1_START_COUNT_BITPOS (1)
                             3150 ; 388  |#define HW_SPEED_RINGOSC1_BITPOS (4)
                             3151 ; 389  |#define HW_SPEED_OSC2_PWRUP_BITPOS (12)
                             3152 ; 390  |#define HW_SPEED_OSC2_START_COUNT_BITPOS (13)
                             3153 ; 391  |#define HW_SPEED_RINGOSC2_BITPOS (16)
                             3154 ; 392  |
                             3155 ; 393  |
                             3156 ; 394  |#define HW_SPEED_OSC1_PWRUP_SETMASK (((1<<HW_SPEED_OSC1_PWRUP_WIDTH)-1)<<HW_SPEED_OSC1_PWRUP_BITPOS)        
                             3157 ; 395  |#define HW_SPEED_OSC1_START_COUNT_SETMASK (((1<<HW_SPEED_OSC1_START_COUNT_WIDTH)-1)<<HW_SPEED_OSC1_START_COUNT_BITPOS)        
                             3158 ; 396  |#define HW_SPEED_RINGOSC1_SETMASK (((1<<HW_SPEED_RINGOSC1_WIDTH)-1)<<HW_SPEED_RINGOSC1_BITPOS) 
                             3159 ; 397  |#define HW_SPEED_OSC2_PWRUP_SETMASK (((1<<HW_SPEED_OSC2_PWRUP_WIDTH)-1)<<HW_SPEED_OSC2_PWRUP_BITPOS)        
                             3160 ; 398  |
                             3161 ; 399  |#define HW_SPEED_OSC2_START_COUNT_SETMASK (((1<<HW_SPEED_OSC2_START_COUNT_WIDTH)-1)<<HW_SPEED_OSC2_START_COUNT_BITPOS)        
                             3162 ; 400  |#define HW_SPEED_RINGOSC2_SETMASK (((1<<HW_SPEED_RINGOSC2_WIDTH)-1)<<HW_SPEED_RINGOSC2_BITPOS) 
                             3163 ; 401  |
                             3164 ; 402  |
                             3165 ; 403  |
                             3166 ; 404  |#define HW_SPEED_OSC1_PWRUP_CLRMASK (~(WORD)HW_SPEED_OSC1_PWRUP_SETMASK)     
                             3167 ; 405  |#define HW_SPEED_OSC1_START_COUNT_CLRMASK (~(WORD)HW_SPEED_OSC1_START_COUNT_SETMASK)     
                             3168 ; 406  |#define HW_SPEED_RINGOSC1_CLRMASK (~(WORD)HW_SPEED_RINGOSC1_SETMASK) 
                             3169 ; 407  |#define HW_SPEED_OSC2_PWRUP_CLRMASK (~(WORD)HW_SPEED_OSC2_PWRUP_SETMASK)   
                             3170 ; 408  |#define HW_SPEED_OSC2_START_COUNT_CLRMASK (~(WORD)HW_SPEED_OSC2_START_COUNT_SETMASK)     
                             3171 ; 409  |#define HW_SPEED_RINGOSC2_CLRMASK (~(WORD)HW_SPEED_RINGOSC2_SETMASK) 
                             3172 ; 410  |
                             3173 ; 411  |
                             3174 ; 412  |typedef union               
                             3175 ; 413  |{
                             3176 ; 414  |    struct {
                             3177 ; 415  |        unsigned int OSC1_PWRUP          : HW_SPEED_OSC1_PWRUP_WIDTH;
                             3178 ; 416  |        unsigned int OSC1_START_COUNT    : HW_SPEED_OSC1_START_COUNT_WIDTH;
                             3179 ; 417  |        unsigned int RSVD0               : HW_SPEED_RSVD0_WIDTH;
                             3180 ; 418  |        unsigned int RINGOSC1            : HW_SPEED_RINGOSC1_WIDTH;
                             3181 ; 419  |        unsigned int RSVD1               : HW_SPEED_RSVD1_WIDTH;
                             3182 ; 420  |        unsigned int OSC2_PWRUP          : HW_SPEED_OSC2_PWRUP_WIDTH;
                             3183 ; 421  |        unsigned int OSC2_START_COUNT    : HW_SPEED_OSC2_START_COUNT_WIDTH;
                             3184 ; 422  |        unsigned int RSVD2               : HW_SPEED_RSVD2_WIDTH;
                             3185 ; 423  |        unsigned int RINGOSC2            : HW_SPEED_RINGOSC2_WIDTH;
                             3186 ; 424  |        unsigned int RSVD3               : HW_SPEED_RSVD3_WIDTH;
                             3187 ; 425  |    } B;
                             3188 ; 426  |    unsigned int I;
                             3189 ; 427  |} speed_type;
                             3190 ; 428  |#define HW_SPEED      (*(volatile speed_type _X*) (HW_DCDC_BASEADDR+7))    /* Speed Measurement Register */
                             3191 ; 429  |
                             3192 ; 430  |
                             3193 ; 431  |
                             3194 ; 432  |
                             3195 ; 433  |
                             3196 ; 434  |
                             3197 ; 435  |
                             3198 ; 436  |// DC DC Test Bit Register (HW_DCDCTBR) Definitions
                             3199 ; 437  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_WIDTH 4
                             3200 ; 438  |#define HW_DCDC_TBR_DCDC1_DIS_5BIT_WIDTH 1
                             3201 ; 439  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_WIDTH 1
                             3202 ; 440  |#define HW_DCDC_TBR_DCDC1_CLK4X_WIDTH 1
                             3203 ; 441  |#define HW_DCDC_TBR_DCDC1_CLK2X_WIDTH 1
                             3204 ; 442  |#define HW_DCDC_TBR_DCDC1_NOZERO_WIDTH 1
                             3205 ; 443  |#define HW_DCDC_TBR_DCDC1_VDD5V_ACTIVE_WIDTH 1
                             3206 ; 444  |#define HW_DCDC_TBR_DCDC1_PFM_WIDTH 1
                             3207 ; 445  |#define HW_DCDC_TBR_DCDC1_STOPCLK_WIDTH 1
                             3208 ; 446  |#define HW_DCDC_TBR_PWRUP_VDDIO_BRNOUT_WIDTH 1
                             3209 ; 447  |#define HW_DCDC_TBR_DCDC_ANA_LESSI_WIDTH 1
                             3210 ; 448  |#define HW_DCDC_TBR_DCDC_MORE_CAP_WIDTH 1
                             3211 ; 449  |#define HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_WIDTH 1
                             3212 ; 450  |#define HW_DCDC_TBR_DCDC1_NEW_SCHEME_WIDTH 1
                             3213 ; 451  |#define HW_DCDC_TBR_DCDC1_HALF_FETS_WIDTH 1
                             3214 ; 452  |#define HW_DCDC_TBR_DCDC2_DIS_5BIT_WIDTH 1
                             3215 ; 453  |#define HW_DCDC_TBR_DCDC2_CLK4X_WIDTH 1
                             3216 ; 454  |#define HW_DCDC_TBR_DCDC2_CLK2X_WIDTH 1
                             3217 ; 455  |#define HW_DCDC_TBR_DCDC2_VDD5V_ACTIVE_WIDTH 1
                             3218 ; 456  |#define HW_DCDC_TBR_DCDC2_PFM_WIDTH 1
                             3219 ; 457  |#define HW_DCDC_TBR_DCDC2_STOPCLK_WIDTH 1
                             3220 ; 458  |
                             3221 ; 459  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_BITPOS (0)
                             3222 ; 460  |#define HW_DCDC_TBR_DCDC1_DIS_5BIT_BITPOS (4)
                             3223 ; 461  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_BITPOS (5)
                             3224 ; 462  |#define HW_DCDC_TBR_DCDC1_CLK4X_BITPOS (6)
                             3225 ; 463  |#define HW_DCDC_TBR_DCDC1_CLK2X_BITPOS (7)
                             3226 ; 464  |#define HW_DCDC_TBR_DCDC1_NOZERO_BITPOS (8)
                             3227 ; 465  |#define HW_DCDC_TBR_DCDC1_VDD5V_ACTIVE_BITPOS (9)
                             3228 ; 466  |#define HW_DCDC_TBR_DCDC1_PFM_BITPOS (10)
                             3229 ; 467  |#define HW_DCDC_TBR_DCDC1_STOPCLK_BITPOS (11)
                             3230 ; 468  |#define HW_DCDC_TBR_PWRUP_VDDIO_BRNOUT_BITPOS (12)
                             3231 ; 469  |#define HW_DCDC_TBR_DCDC_ANA_LESSI_BITPOS (13)
                             3232 ; 470  |#define HW_DCDC_TBR_DCDC_MORE_CAP_BITPOS (14)
                             3233 ; 471  |#define HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS (15)
                             3234 ; 472  |#define HW_DCDC_TBR_DCDC1_NEW_SCHEME_BITPOS (16)
                             3235 ; 473  |#define HW_DCDC_TBR_DCDC1_HALF_FETS_BITPOS (17)
                             3236 ; 474  |#define HW_DCDC_TBR_DCDC2_DIS_5BIT_BITPOS (18)
                             3237 ; 475  |#define HW_DCDC_TBR_DCDC2_CLK4X_BITPOS (19)
                             3238 ; 476  |#define HW_DCDC_TBR_DCDC2_CLK2X_BITPOS (20)
                             3239 ; 477  |#define HW_DCDC_TBR_DCDC2_VDD5V_ACTIVE_BITPOS (21)
                             3240 ; 478  |#define HW_DCDC_TBR_DCDC2_PFM_BITPOS (22)
                             3241 ; 479  |#define HW_DCDC_TBR_DCDC2_STOPCLK_BITPOS (23)
                             3242 ; 480  |
                             3243 ; 481  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_SETMASK (((1<<HW_DCDC_TBR_DCDC1_ADJ_TN_WIDTH)-1)<<HW_DCDC_TBR_DCDC1_ADJ_TN_BITPOS)
                             3244 ; 482  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_SETMASK (((1<<HW_DCDC_TBR_DCDC1_BAT_ADJ_WIDTH)-1)<<HW_DCDC_TBR_DCDC1_BAT_ADJ_BITPOS)
                             3245 ; 483  |#define HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_SETMASK (((1<<HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_WIDTH)-1)<<HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS)
                             3246 ; 484  |
                             3247 ; 485  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_CLRMASK (~(WORD)HW_DCDC_TBR_DCDC1_ADJ_TN_SETMASK)
                             3248 ; 486  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_CLRMASK (~(WORD)HW_DCDC_TBR_DCDC1_BAT_ADJ_SETMASK)
                             3249 ; 487  |#define HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_CLRMASK (~(WORD)HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_SETMASK)
                             3250 ; 488  |
                             3251 ; 489  |// Defines for What needs to change to be able to use a higher Core voltage and when the change should happen
                             3252 ; 490  |#define HW_DCDC_VDDD_CHANGE_TBR_CUTOFF_VALUE ((18<<HW_DCDC_VDDD_VOLTAGE_LEVEL_BITPOS)&HW_DCDC_VDDD_VOLTAGE_LEVEL_SETMASK)
                             3253 ; 491  |#define HW_DCDC_TBR_VDDD_HI_VALUE ((1<<HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS)&HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_SETMASK)
                             3254 ; 492  |#define HW_DCDC_TBR_VDDD_LO_VALUE (((1<<HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS)&HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_SETMASK)+((2<<HW_DCDC_TBR_DCDC1_ADJ_TN_BITPOS)&HW_DCDC_TBR_DCDC1_ADJ_TN_SETMASK)+((1<<HW_DCDC_TBR_DC
                                  DC1_BAT_ADJ_BITPOS)&HW_DCDC_TBR_DCDC1_BAT_ADJ_SETMASK))
                             3255 ; 493  |
                             3256 ; 494  |typedef union               
                             3257 ; 495  |{
                             3258 ; 496  |    struct {
                             3259 ; 497  |        unsigned int DCDC1_ADJ_TN               : HW_DCDC_TBR_DCDC1_ADJ_TN_WIDTH;
                             3260 ; 498  |        unsigned int DCDC1_DIS_5BIT             : HW_DCDC_TBR_DCDC1_DIS_5BIT_WIDTH;
                             3261 ; 499  |        unsigned int DCDC1_BAT_ADJ              : HW_DCDC_TBR_DCDC1_BAT_ADJ_WIDTH;
                             3262 ; 500  |        unsigned int DCDC1_CLK4X                : HW_DCDC_TBR_DCDC1_CLK4X_WIDTH;
                             3263 ; 501  |        unsigned int DCDC1_CLK2X                : HW_DCDC_TBR_DCDC1_CLK2X_WIDTH;
                             3264 ; 502  |        unsigned int DCDC1_NOZERO               : HW_DCDC_TBR_DCDC1_NOZERO_WIDTH;
                             3265 ; 503  |        unsigned int DCDC1_VDD5V_ACTIVE         : HW_DCDC_TBR_DCDC1_VDD5V_ACTIVE_WIDTH;
                             3266 ; 504  |        unsigned int DCDC1_PFM                  : HW_DCDC_TBR_DCDC1_PFM_WIDTH;
                             3267 ; 505  |        unsigned int DCDC1_STOPCLK              : HW_DCDC_TBR_DCDC1_STOPCLK_WIDTH;
                             3268 ; 506  |        unsigned int PWRUP_VDDIO_BRNOUT         : HW_DCDC_TBR_PWRUP_VDDIO_BRNOUT_WIDTH;
                             3269 ; 507  |        unsigned int DCDC_ANA_LESSI             : HW_DCDC_TBR_DCDC_ANA_LESSI_WIDTH;
                             3270 ; 508  |        unsigned int DCDC_MORE_CAP              : HW_DCDC_TBR_DCDC_MORE_CAP_WIDTH;
                             3271 ; 509  |        unsigned int DCDC_ANA_BGR_BIAS          : HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_WIDTH;
                             3272 ; 510  |        unsigned int DCDC1_NEW_SCHEME           : HW_DCDC_TBR_DCDC1_NEW_SCHEME_WIDTH;
                             3273 ; 511  |        unsigned int DCDC1_HALF_FETS            : HW_DCDC_TBR_DCDC1_HALF_FETS_WIDTH;
                             3274 ; 512  |        unsigned int DCDC2_DIS_5BIT             : HW_DCDC_TBR_DCDC2_DIS_5BIT_WIDTH;
                             3275 ; 513  |        unsigned int DCDC2_CLK4X                : HW_DCDC_TBR_DCDC2_CLK4X_WIDTH;
                             3276 ; 514  |        unsigned int DCDC2_CLK2X                : HW_DCDC_TBR_DCDC2_CLK2X_WIDTH;
                             3277 ; 515  |        unsigned int DCDC2_VDD5V_ACTIVE         : HW_DCDC_TBR_DCDC2_VDD5V_ACTIVE_WIDTH;
                             3278 ; 516  |        unsigned int DCDC2_PFM                  : HW_DCDC_TBR_DCDC2_PFM_WIDTH;
                             3279 ; 517  |        unsigned int DCDC2_STOPCLK              : HW_DCDC_TBR_DCDC2_STOPCLK_WIDTH;
                             3280 ; 518  |    } B;
                             3281 ; 519  |    unsigned int I;
                             3282 ; 520  |} usb_dcdctbr_type;
                             3283 ; 521  |#define HW_DCDC_TBR                     (*(volatile usb_dcdctbr_type _X*) (HW_DCDC_BASEADDR+8))    /* Analog test bit register*/
                             3284 ; 522  |
                             3285 ; 523  |
                             3286 ; 524  |/////////////////////////////////////////////////////////////////////////////////
                             3287 ; 525  |
                             3288 ; 526  |//  Analog Persistent Config (HW_VDD5V_PWR_CHARGE) Bit Definitions
                             3289 ; 527  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  14

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3290 ; 528  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_WIDTH (6)
                             3291 ; 529  |#define HW_VDD5V_PWR_CHARGE_RSVD0_WIDTH (2)
                             3292 ; 530  |#define HW_VDD5V_PWR_CHARGE_PWD_WIDTH (1)
                             3293 ; 531  |#define HW_VDD5V_PWR_CHARGE_RES_WIDTH (1)
                             3294 ; 532  |#define HW_VDD5V_PWR_CHARGE_NIMH_WIDTH (1)
                             3295 ; 533  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_WIDTH (1)
                             3296 ; 534  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_WIDTH (1)
                             3297 ; 535  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_WIDTH (1)
                             3298 ; 536  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_WIDTH (1)
                             3299 ; 537  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_WIDTH (1)
                             3300 ; 538  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_WIDTH (1)
                             3301 ; 539  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_WIDTH (1)
                             3302 ; 540  |#define HW_VDD5V_PWR_CHARGE_RSVD1_WIDTH (2)
                             3303 ; 541  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_WIDTH (1)
                             3304 ; 542  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_WIDTH (2)
                             3305 ; 543  |#define HW_VDD5V_PWR_CHARGE_RSVD2_WIDTH (3)
                             3306 ; 544  |
                             3307 ; 545  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_BITPOS (0)
                             3308 ; 546  |#define HW_VDD5V_PWR_CHARGE_PWD_BITPOS (8)
                             3309 ; 547  |#define HW_VDD5V_PWR_CHARGE_RES_BITPOS (9)
                             3310 ; 548  |#define HW_VDD5V_PWR_CHARGE_NIMH_BITPOS (10)
                             3311 ; 549  |
                             3312 ; 550  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_BITPOS (11)
                             3313 ; 551  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_BITPOS (12)
                             3314 ; 552  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_BITPOS (13)
                             3315 ; 553  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_BITPOS (14)
                             3316 ; 554  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_BITPOS (15)
                             3317 ; 555  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_BITPOS (16)
                             3318 ; 556  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_BITPOS (17)
                             3319 ; 557  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_BITPOS (20)
                             3320 ; 558  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_BITPOS (21)
                             3321 ; 559  |
                             3322 ; 560  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_BATT_CURRENT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_BATT_CURRENT_BITPOS)        
                             3323 ; 561  |#define HW_VDD5V_PWR_CHARGE_PWD_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_PWD_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_PWD_BITPOS)        
                             3324 ; 562  |#define HW_VDD5V_PWR_CHARGE_RES_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_RES_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_RES_BITPOS) 
                             3325 ; 563  |#define HW_VDD5V_PWR_CHARGE_NIMH_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_NIMH_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_NIMH_BITPOS) 
                             3326 ; 564  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_LI_TYPE_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_LI_TYPE_BITPOS) 
                             3327 ; 565  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_BITPOS)        
                             3328 ; 566  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_BITPOS)        
                             3329 ; 567  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_DCANA_LP_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_DCANA_LP_BITPOS) 
                             3330 ; 568  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_TEST_USBREGS_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_TEST_USBREGS_BITPOS) 
                             3331 ; 569  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_DRV_BATT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_DRV_BATT_BITPOS) 
                             3332 ; 570  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_BITPOS) 
                             3333 ; 571  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_BITPOS) 
                             3334 ; 572  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_BATT_INFO_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_BATT_INFO_BITPOS) 
                             3335 ; 573  |
                             3336 ; 574  |
                             3337 ; 575  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_BATT_CURRENT_SETMASK)     
                             3338 ; 576  |#define HW_VDD5V_PWR_CHARGE_PWD_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_PWD_SETMASK)     
                             3339 ; 577  |#define HW_VDD5V_PWR_CHARGE_RES_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_RES_SETMASK) 
                             3340 ; 578  |#define HW_VDD5V_PWR_CHARGE_NIMH_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_NIMH_SETMASK) 
                             3341 ; 579  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_LI_TYPE_SETMASK) 
                             3342 ; 580  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_SETMASK)     
                             3343 ; 581  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_SETMASK)     
                             3344 ; 582  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_DCANA_LP_SETMASK) 
                             3345 ; 583  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_TEST_USBREGS_SETMASK) 
                             3346 ; 584  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_DRV_BATT_SETMASK) 
                             3347 ; 585  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_SETMASK) 
                             3348 ; 586  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_SETMASK) 
                             3349 ; 587  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_BATT_INFO_SETMASK) 
                             3350 ; 588  |
                             3351 ; 589  |typedef union               
                             3352 ; 590  |{
                             3353 ; 591  |    struct {
                             3354 ; 592  |        unsigned int BATT_CURRENT               : HW_VDD5V_PWR_CHARGE_BATT_CURRENT_WIDTH;
                             3355 ; 593  |        unsigned int RSVD0                      : HW_VDD5V_PWR_CHARGE_RSVD0_WIDTH;
                             3356 ; 594  |        unsigned int PWD                        : HW_VDD5V_PWR_CHARGE_PWD_WIDTH;
                             3357 ; 595  |        unsigned int RES                        : HW_VDD5V_PWR_CHARGE_RES_WIDTH;
                             3358 ; 596  |        unsigned int NIMH                       : HW_VDD5V_PWR_CHARGE_NIMH_WIDTH;
                             3359 ; 597  |        unsigned int LI_TYPE                    : HW_VDD5V_PWR_CHARGE_LI_TYPE_WIDTH;
                             3360 ; 598  |        unsigned int DISABLE_ILIMIT             : HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_WIDTH;
                             3361 ; 599  |        unsigned int PWDN_ON_IOBRNOUT           : HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_WIDTH;
                             3362 ; 600  |        unsigned int DCANA_LP                   : HW_VDD5V_PWR_CHARGE_DCANA_LP_WIDTH;
                             3363 ; 601  |        unsigned int TEST_USBREGS               : HW_VDD5V_PWR_CHARGE_TEST_USBREGS_WIDTH;
                             3364 ; 602  |        unsigned int DRV_BATT                   : HW_VDD5V_PWR_CHARGE_DRV_BATT_WIDTH;
                             3365 ; 603  |        unsigned int SWCHRG_BAT                 : HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_WIDTH;
                             3366 ; 604  |        unsigned int RSVD1                      : HW_VDD5V_PWR_CHARGE_RSVD1_WIDTH;
                             3367 ; 605  |        unsigned int VDD5V_PRESENT              : HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_WIDTH;
                             3368 ; 606  |        unsigned int RSVD2                      : HW_VDD5V_PWR_CHARGE_RSVD2_WIDTH;
                             3369 ; 607  |    } B;
                             3370 ; 608  |    unsigned int I;
                             3371 ; 609  |} usb_pwr_charge_type;
                             3372 ; 610  |#define HW_VDD5V_PWR_CHARGE      (*(volatile usb_pwr_charge_type _X*) (HW_DCDC_BASEADDR+17))    /* Analog Persistent Config Register */
                             3373 ; 611  |
                             3374 ; 612  |#define HW_DCDC_PERSIST_AUTO_RESTART_STAT_WIDTH 1
                             3375 ; 613  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_STAT_WIDTH 1
                             3376 ; 614  |#define HW_DCDC_PERSIST_UPDATE_WIDTH 1
                             3377 ; 615  |#define HW_DCDC_PERSIST_AUTO_RESTART_WIDTH 1
                             3378 ; 616  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_WIDTH 1
                             3379 ; 617  |#define HW_DCDC_PERSIST_LOW_BATT_TYPE_WIDTH 1
                             3380 ; 618  |#define HW_DCDC_PERSIST_LOW_BATTERY_ENABLE_WIDTH 1
                             3381 ; 619  |#define HW_DCDC_PERSIST_SLEEP_XTAL_ENABLE_WIDTH 1
                             3382 ; 620  |#define HW_DCDC_PERSIST_XTAL_TRIM1_WIDTH 1
                             3383 ; 621  |#define HW_DCDC_PERSIST_XTAL_TRIM0_WIDTH 1
                             3384 ; 622  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN1_WIDTH 1
                             3385 ; 623  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN0_WIDTH 1
                             3386 ; 624  |#define HW_DCDC_PERSIST_XTAL_TRM_ENABLE_WIDTH 1
                             3387 ; 625  |#define HW_DCDC_PERSIST_RSRVD_WIDTH 2
                             3388 ; 626  |
                             3389 ; 627  |#define HW_DCDC_PERSIST_AUTO_RESTART_STAT_BITPOS 12
                             3390 ; 628  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_STAT_BITPOS 11
                             3391 ; 629  |#define HW_DCDC_PERSIST_UPDATE_BITPOS 10
                             3392 ; 630  |#define HW_DCDC_PERSIST_AUTO_RESTART_BITPOS 9
                             3393 ; 631  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_BITPOS 8 
                             3394 ; 632  |#define HW_DCDC_PERSIST_LOW_BATT_TYPE_BITPOS 7
                             3395 ; 633  |#define HW_DCDC_PERSIST_LOW_BATTERY_ENABLE_BITPOS 6
                             3396 ; 634  |#define HW_DCDC_PERSIST_SLEEP_XTAL_ENABLE_BITPOS 5
                             3397 ; 635  |#define HW_DCDC_PERSIST_XTAL_TRIM1_BITPOS 4
                             3398 ; 636  |#define HW_DCDC_PERSIST_XTAL_TRIM0_BITPOS 3
                             3399 ; 637  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN1_BITPOS 2
                             3400 ; 638  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN0_BITPOS 1
                             3401 ; 639  |#define HW_DCDC_PERSIST_XTAL_TRM_ENABLE_BITPOS 0
                             3402 ; 640  |
                             3403 ; 641  |typedef union               
                             3404 ; 642  |{
                             3405 ; 643  |    struct {       
                             3406 ; 644  |       int XTAL_TRM_ENABLE             : HW_DCDC_PERSIST_XTAL_TRM_ENABLE_WIDTH;
                             3407 ; 645  |       int XTAL_BIAS_DOWN0             : HW_DCDC_PERSIST_XTAL_BIAS_DOWN0_WIDTH;
                             3408 ; 646  |       int XTAL_BIAS_DOWN1             : HW_DCDC_PERSIST_XTAL_BIAS_DOWN1_WIDTH;
                             3409 ; 647  |       int XTAL_TRIM0                  : HW_DCDC_PERSIST_XTAL_TRIM0_WIDTH;
                             3410 ; 648  |       int XTAL_TRIM1                  : HW_DCDC_PERSIST_XTAL_TRIM1_WIDTH;
                             3411 ; 649  |       int SLEEP_XTAL_ENABLE           : HW_DCDC_PERSIST_SLEEP_XTAL_ENABLE_WIDTH;
                             3412 ; 650  |       int LOW_BATTERY_ENABLE          : HW_DCDC_PERSIST_LOW_BATTERY_ENABLE_WIDTH;
                             3413 ; 651  |       int LOW_BATT_TYPE               : HW_DCDC_PERSIST_LOW_BATT_TYPE_WIDTH;
                             3414 ; 652  |       int DELAY_5V_AUTO_RESTART       : HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_WIDTH;
                             3415 ; 653  |       int AUTO_RESTART                : HW_DCDC_PERSIST_AUTO_RESTART_WIDTH;
                             3416 ; 654  |       int UPDATE                      : HW_DCDC_PERSIST_UPDATE_WIDTH;
                             3417 ; 655  |       int DELAY_5V_AUTO_RESTART_STAT  : HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_STAT_WIDTH;
                             3418 ; 656  |       int AUTO_RESTART_STAT           : HW_DCDC_PERSIST_AUTO_RESTART_STAT_WIDTH;
                             3419 ; 657  |       int RSRVD                       : HW_DCDC_PERSIST_RSRVD_WIDTH;
                             3420 ; 658  |    } B;
                             3421 ; 659  |    int I;
                             3422 ; 660  |} usb_dcdcpersist_type;
                             3423 ; 661  |#define HW_DCDC_PERSIST                (*(volatile usb_dcdcpersist_type _X*) (HW_DCDC_BASEADDR+15))    /* Analog test bit register*/
                             3424 ; 662  |
                             3425 ; 663  |
                             3426 ; 664  |
                             3427 ; 665  |#endif
                             3428 ; 666  |
                             3429 ; 667  |
                             3430 ; 668  |
                             3431 
                             3433 
                             3434 ; 21   |#include "regsemc.h"
                             3435 
                             3437 
                             3438 ; 1    |#if !(defined(__REGS_EMC_INC))
                             3439 ; 2    |#define __REGS_EMC_INC 1
                             3440 ; 3    |
                             3441 ; 4    |/////////////////////////////////////////////////////////////////////////////////
                             3442 ; 5    |//   Module base addresses
                             3443 ; 6    |/////////////////////////////////////////////////////////////////////////////////
                             3444 ; 7    |#define HW_EMC_BASEADDR 0xF000
                             3445 ; 8    |
                             3446 ; 9    |/////////////////////////////////////////////////////////////////////////////////
                             3447 ; 10   |//  EMC Registers
                             3448 ; 11   |/////////////////////////////////////////////////////////////////////////////////
                             3449 ; 12   |
                             3450 ; 13   |
                             3451 ; 14   |/////////////////////////////////////////////////////////////////////////////////
                             3452 ; 15   |//  Flash Control Register (HW_FLCR) Bit Definitions
                             3453 ; 16   |
                             3454 ; 17   |typedef union               /*Flash Control Register*/
                             3455 ; 18   |{
                             3456 ; 19   |    struct
                             3457 ; 20   |    {
                             3458 ; 21   |    int KICK        :1;
                             3459 ; 22   |    int RW          :1;
                             3460 ; 23   |    int TCIE        :1;
                             3461 ; 24   |    int IRQP        :1;
                             3462 ; 25   |    unsigned MMD    :2;
                             3463 ; 26   |    unsigned NB     :11;
                             3464 ; 27   |    unsigned RSVD   :4;
                             3465 ; 28   |    int SRST        :1;
                             3466 ; 29   |    } B;
                             3467 ; 30   |    int I;
                             3468 ; 31   |} flcr_type;
                             3469 ; 32   |
                             3470 ; 33   |#define HW_FLCR_KICK_BITPOS 0
                             3471 ; 34   |#define HW_FLCR_RW_BITPOS 1
                             3472 ; 35   |#define HW_FLCR_TCIE_BITPOS 2
                             3473 ; 36   |#define HW_FLCR_IRQP_BITPOS 3
                             3474 ; 37   |#define HW_FLCR_MMD_BITPOS 4
                             3475 ; 38   |#define HW_FLCR_NB_BITPOS 6
                             3476 ; 39   |#define HW_FLCR_SRST_BITPOS 21
                             3477 ; 40   |
                             3478 ; 41   |#define HW_FLCR_KICK_SETMASK 1<<HW_FLCR_KICK_BITPOS
                             3479 ; 42   |#define HW_FLCR_RW_SETMASK 1<<HW_FLCR_RW_BITPOS
                             3480 ; 43   |#define HW_FLCR_READ_KICK_SETMASK HW_FLCR_KICK_SETMASK|HW_FLCR_RW_SETMASK
                             3481 ; 44   |#define HW_FLCR_WRITE_KICK_SETMASK HW_FLCR_KICK_SETMASK
                             3482 ; 45   |#define HW_FLCR_TCIE_SETMASK 1<<HW_FLCR_TCIE_BITPOS
                             3483 ; 46   |#define HW_FLCR_IRQP_SETMASK 1<<HW_FLCR_IRQP_BITPOS
                             3484 ; 47   |#define HW_FLCR_MMD_SETMASK 3<<HW_FLCR_MMD_BITPOS
                             3485 ; 48   |#define HW_FLCR_NB_SETMASK 0x7FF<<HW_FLCR_NB_BITPOS
                             3486 ; 49   |#define HW_FLCR_SRST_SETMASK 1<<HW_FLCR_SRST_BITPOS
                             3487 ; 50   |
                             3488 ; 51   |#define HW_FLCR_KICK_CLRMASK ~(WORD)HW_FLCR_KICK_SETMASK
                             3489 ; 52   |#define HW_FLCR_RW_CLRMASK ~(WORD)HW_FLCR_RW_SETMASK
                             3490 ; 53   |#define HW_FLCR_TCIE_CLRMASK ~(WORD)HW_FLCR_TCIE_SETMASK
                             3491 ; 54   |#define HW_FLCR_IRQP_CLRMASK ~(WORD)HW_FLCR_IRQP_SETMASK
                             3492 ; 55   |#define HW_FLCR_MMD_CLRMASK ~(WORD)HW_FLCR_MMD_SETMASK
                             3493 ; 56   |#define HW_FLCR_NB_CLRMASK ~(WORD)HW_FLCR_NB_SETMASK
                             3494 ; 57   |#define HW_FLCR_SRST_CLRMASK ~(WORD)HW_FLCR_SRST_SETMASK
                             3495 ; 58   |
                             3496 ; 59   |
                             3497 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                             3498 ; 61   |//  Flash Start Address Low Register (HW_FLSALR) Bit Definitions
                             3499 ; 62   |
                             3500 ; 63   |typedef union           /* Flash Start Address Low*/
                             3501 ; 64   |{
                             3502 ; 65   |    struct
                             3503 ; 66   |    {
                             3504 ; 67   |    unsigned XA     : 24;
                             3505 ; 68   |    } B;
                             3506 ; 69   |    int I;
                             3507 ; 70   |} flsalr_type;
                             3508 ; 71   |
                             3509 ; 72   |#define HW_FLSALR_XA_BITPOS 0
                             3510 ; 73   |
                             3511 ; 74   |#define HW_FLSALR_XA_SETMASK 0xFFFFFF<<HW_FLSALR_XA_BITPOS
                             3512 ; 75   |
                             3513 ; 76   |#define HW_FLSALR_XA_CLRMASK ~(WORD)HW_FLSALR_XA_SETMASK
                             3514 ; 77   |
                             3515 ; 78   |
                             3516 ; 79   |/////////////////////////////////////////////////////////////////////////////////
                             3517 ; 80   |//  Flash Start Address High Register (HW_FLSAHR) Bit Definitions
                             3518 ; 81   |
                             3519 ; 82   |typedef union           /* Flash Start Address High*/
                             3520 ; 83   |{
                             3521 ; 84   |    struct
                             3522 ; 85   |    {
                             3523 ; 86   |    unsigned XA     :8;
                             3524 ; 87   |    unsigned DA     :16;
                             3525 ; 88   |    } B;
                             3526 ; 89   |    int I;
                             3527 ; 90   |} flsahr_type;
                             3528 ; 91   |
                             3529 ; 92   |#define HW_FLSAHR_XA_BITPOS 0
                             3530 ; 93   |
                             3531 ; 94   |#define HW_FLSAHR_XA_SETMASK 0xFFFFFF<<HW_FLSAHR_XA_BITPOS
                             3532 ; 95   |
                             3533 ; 96   |#define HW_FLSAHR_XA_CLRMASK ~(WORD)HW_FLSAHR_XA_SETMASK
                             3534 ; 97   |
                             3535 ; 98   |
                             3536 ; 99   |/////////////////////////////////////////////////////////////////////////////////
                             3537 ; 100  |//  EMC Flash CompactFlash Control Register (HW_FLCFCR) Bit Definitions
                             3538 ; 101  |
                             3539 ; 102  |typedef union           /* Flash CompactFlash Control Register*/
                             3540 ; 103  |{
                             3541 ; 104  |    struct
                             3542 ; 105  |    {
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  15

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3543 ; 106  |        int WP          :1;
                             3544 ; 107  |        int CDP         :1;
                             3545 ; 108  |        unsigned SM     :2;
                             3546 ; 109  |        int XATTR       :1;
                             3547 ; 110  |        int CRST        :1;
                             3548 ; 111  |        int XWT         :1;
                             3549 ; 112  |        int RI          :1;
                             3550 ; 113  |        int IFCE        :1;
                             3551 ; 114  |        int ISCE        :1;
                             3552 ; 115  |        int INCE        :1;
                             3553 ; 116  |        int IFCS        :1;
                             3554 ; 117  |        int ISCS        :1;
                             3555 ; 118  |        int INCS        :1;
                             3556 ; 119  |        unsigned CFAI   :2;
                             3557 ; 120  |        int XDDI        :1;
                             3558 ; 121  |        unsigned CS     :2;
                             3559 ; 122  |        int CRE         :1;
                             3560 ; 123  |        unsigned VS     :2;
                             3561 ; 124  |        int DASP        :1;
                             3562 ; 125  |        int MODE16      :1; 
                             3563 ; 126  |    } B;
                             3564 ; 127  |    int I;
                             3565 ; 128  |} flcfcr_type;
                             3566 ; 129  |
                             3567 ; 130  |#define HW_FLCFCR_WP_BITPOS 0
                             3568 ; 131  |#define HW_FLCFCR_CDP_BITPOS 1
                             3569 ; 132  |#define HW_FLCFCR_SM_BITPOS 2
                             3570 ; 133  |#define HW_FLCFCR_XATTR_BITPOS 4
                             3571 ; 134  |#define HW_FLCFCR_CRST_BITPOS 5
                             3572 ; 135  |#define HW_FLCFCR_XWT_BITPOS 6
                             3573 ; 136  |#define HW_FLCFCR_RI_BITPOS 7
                             3574 ; 137  |#define HW_FLCFCR_IFCE_BITPOS 8
                             3575 ; 138  |#define HW_FLCFCR_ISCE_BITPOS 9
                             3576 ; 139  |#define HW_FLCFCR_INCE_BITPOS 10
                             3577 ; 140  |#define HW_FLCFCR_IFCS_BITPOS 11
                             3578 ; 141  |#define HW_FLCFCR_ISCS_BITPOS 12
                             3579 ; 142  |#define HW_FLCFCR_INCS_BITPOS 13
                             3580 ; 143  |#define HW_FLCFCR_CFAI_BITPOS 14
                             3581 ; 144  |#define HW_FLCFCR_XDDI_BITPOS 16
                             3582 ; 145  |#define HW_FLCFCR_CS_BITPOS 17
                             3583 ; 146  |#define HW_FLCFCR_CRE_BITPOS 19
                             3584 ; 147  |#define HW_FLCFCR_VS_BITPOS 20
                             3585 ; 148  |#define HW_FLCFCR_DASP_BITPOS 22
                             3586 ; 149  |
                             3587 ; 150  |#define HW_FLCFCR_WP_SETMASK 1<<HW_FLCFCR_WP_BITPOS
                             3588 ; 151  |#define HW_FLCFCR_CDP_SETMASK 1<<HW_FLCFCR_CDP_BITPOS
                             3589 ; 152  |#define HW_FLCFCR_SM_SETMASK 3<<HW_FLCFCR_SM_BITPOS
                             3590 ; 153  |#define HW_FLCFCR_XATTR_SETMASK 1<<HW_FLCFCR_XATTR_BITPOS
                             3591 ; 154  |#define HW_FLCFCR_CRST_SETMASK 1<<HW_FLCFCR_CRST_BITPOS
                             3592 ; 155  |#define HW_FLCFCR_XWT_SETMASK 1<<HW_FLCFCR_XWT_BITPOS
                             3593 ; 156  |#define HW_FLCFCR_RI_SETMASK 1<<HW_FLCFCR_RI_BITPOS
                             3594 ; 157  |#define HW_FLCFCR_IFCE_SETMASK 1<<HW_FLCFCR_IFCE_BITPOS
                             3595 ; 158  |#define HW_FLCFCR_ISCE_SETMASK 1<<HW_FLCFCR_ISCE_BITPOS
                             3596 ; 159  |#define HW_FLCFCR_INCE_SETMASK 1<<HW_FLCFCR_INCE_BITPOS
                             3597 ; 160  |#define HW_FLCFCR_IFCS_SETMASK 1<<HW_FLCFCR_IFCS_BITPOS
                             3598 ; 161  |#define HW_FLCFCR_ISCS_SETMASK 1<<HW_FLCFCR_ISCS_BITPOS
                             3599 ; 162  |#define HW_FLCFCR_INCS_SETMASK 1<<HW_FLCFCR_INCS_BITPOS
                             3600 ; 163  |#define HW_FLCFCR_CFAI_SETMASK 3<<HW_FLCFCR_CFAI_BITPOS
                             3601 ; 164  |#define HW_FLCFCR_XDDI_SETMASK 1<<HW_FLCFCR_XDDI_BITPOS
                             3602 ; 165  |#define HW_FLCFCR_CS_SETMASK 3<<HW_FLCFCR_CS_BITPOS
                             3603 ; 166  |#define HW_FLCFCR_CRE_SETMASK 1<<HW_FLCFCR_CRE_BITPOS
                             3604 ; 167  |#define HW_FLCFCR_VS_SETMASK 3<<HW_FLCFCR_VS_BITPOS
                             3605 ; 168  |#define HW_FLCFCR_DASP_SETMASK 1<<HW_FLCFCR_DASP_BITPOS
                             3606 ; 169  |
                             3607 ; 170  |#define HW_FLCFCR_WP_CLRMASK ~(WORD)HW_FLCFCR_WP_SETMASK
                             3608 ; 171  |#define HW_FLCFCR_CDP_CLRMASK ~(WORD)HW_FLCFCR_CDP_SETMASK
                             3609 ; 172  |#define HW_FLCFCR_SM_CLRMASK ~(WORD)HW_FLCFCR_SM_SETMASK
                             3610 ; 173  |#define HW_FLCFCR_XATTR_CLRMASK ~(WORD)HW_FLCFCR_XATTR_SETMASK
                             3611 ; 174  |#define HW_FLCFCR_CRST_CLRMASK ~(WORD)HW_FLCFCR_CRST_SETMASK
                             3612 ; 175  |#define HW_FLCFCR_XWT_CLRMASK ~(WORD)HW_FLCFCR_XWT_SETMASK
                             3613 ; 176  |#define HW_FLCFCR_RI_CLRMASK ~(WORD)HW_FLCFCR_RI_SETMASK
                             3614 ; 177  |#define HW_FLCFCR_IFCE_CLRMASK ~(WORD)HW_FLCFCR_IFCE_SETMASK
                             3615 ; 178  |#define HW_FLCFCR_ISCE_CLRMASK ~(WORD)HW_FLCFCR_ISCE_SETMASK
                             3616 ; 179  |#define HW_FLCFCR_INCE_CLRMASK ~(WORD)HW_FLCFCR_INCE_SETMASK
                             3617 ; 180  |#define HW_FLCFCR_IFCS_CLRMASK ~(WORD)HW_FLCFCR_IFCS_SETMASK
                             3618 ; 181  |#define HW_FLCFCR_ISCS_CLRMASK ~(WORD)HW_FLCFCR_ISCS_SETMASK
                             3619 ; 182  |#define HW_FLCFCR_INCS_CLRMASK ~(WORD)HW_FLCFCR_INCS_SETMASK
                             3620 ; 183  |#define HW_FLCFCR_CFAI_CLRMASK ~(WORD)HW_FLCFCR_CFAI_SETMASK
                             3621 ; 184  |#define HW_FLCFCR_XDDI_CLRMASK ~(WORD)HW_FLCFCR_XDDI_SETMASK
                             3622 ; 185  |#define HW_FLCFCR_CS_CLRMASK ~(WORD)HW_FLCFCR_CS_SETMASK
                             3623 ; 186  |#define HW_FLCFCR_CRE_CLRMASK ~(WORD)HW_FLCFCR_CRE_SETMASK
                             3624 ; 187  |#define HW_FLCFCR_VS_CLRMASK ~(WORD)HW_FLCFCR_VS_SETMASK
                             3625 ; 188  |#define HW_FLCFCR_DASP_CLRMASK ~(WORD)HW_FLCFCR_DASP_SETMASK
                             3626 ; 189  |
                             3627 ; 190  |
                             3628 ; 191  |/////////////////////////////////////////////////////////////////////////////////
                             3629 ; 192  |//  EMC Flash Compact Flash Timer1 Register (HW_FLCFTMR1R) Bit Definitions
                             3630 ; 193  |
                             3631 ; 194  |typedef union           /* Flash CompactFlash Timer1 Register*/
                             3632 ; 195  |{
                             3633 ; 196  |    struct
                             3634 ; 197  |    {
                             3635 ; 198  |        unsigned TRWSU  :5;
                             3636 ; 199  |        unsigned TRPW   :7;
                             3637 ; 200  |        unsigned TWPW   :7;
                             3638 ; 201  |        unsigned TRWH   :5;
                             3639 ; 202  |    } B;
                             3640 ; 203  |    int I;
                             3641 ; 204  |} flcftmr1r_type;
                             3642 ; 205  |
                             3643 ; 206  |#define HW_FLCFTMR1R_TRWSU_BITPOS 0
                             3644 ; 207  |#define HW_FLCFTMR1R_TRPW_BITPOS 5
                             3645 ; 208  |#define HW_FLCFTMR1R_TWPW_BITPOS 12
                             3646 ; 209  |#define HW_FLCFTMR1R_TRWH_BITPOS 19
                             3647 ; 210  |
                             3648 ; 211  |#define HW_FLCFTMR1R_TRWSU_SETMASK 0x1F<<HW_FLCFTMR1R_TRWSU_BITPOS
                             3649 ; 212  |#define HW_FLCFTMR1R_TRPW_SETMASK 0x7F<<HW_FLCFTMR1R_TRPW_BITPOS
                             3650 ; 213  |#define HW_FLCFTMR1R_TWPW_SETMASK 0x7F<<HW_FLCFTMR1R_TWPW_BITPOS
                             3651 ; 214  |#define HW_FLCFTMR1R_TRWH_SETMASK 0x1F<<HW_FLCFTMR1R_TRWH_BITPOS
                             3652 ; 215  |
                             3653 ; 216  |#define HW_FLCFTMR1R_TRWSU_CLRMASK ~(WORD)HW_FLCFTMR1R_TRWSU_SETMASK
                             3654 ; 217  |#define HW_FLCFTMR1R_TRPW_CLRMASK ~(WORD)HW_FLCFTMR1R_TRPW_SETMASK
                             3655 ; 218  |#define HW_FLCFTMR1R_TWPW_CLRMASK ~(WORD)HW_FLCFTMR1R_TWPW_SETMASK
                             3656 ; 219  |#define HW_FLCFTMR1R_TRWH_CLRMASK ~(WORD)HW_FLCFTMR1R_TRWH_SETMASK
                             3657 ; 220  |
                             3658 ; 221  |
                             3659 ; 222  |/////////////////////////////////////////////////////////////////////////////////
                             3660 ; 223  |//  EMC Flash Compact Flash Timer1 Register (HW_FLCFTMR2R) Bit Definitions
                             3661 ; 224  |
                             3662 ; 225  |typedef union           /* Flash CompactFlash Timer2 Register*/
                             3663 ; 226  |{
                             3664 ; 227  |    struct
                             3665 ; 228  |    {
                             3666 ; 229  |        unsigned TWW    :4;
                             3667 ; 230  |        unsigned TWTO   :10;
                             3668 ; 231  |        unsigned THW    :5; 
                             3669 ; 232  |        unsigned TRAQ   :5;
                             3670 ; 233  |    } B;
                             3671 ; 234  |    int I;
                             3672 ; 235  |} flcftmr2r_type;
                             3673 ; 236  |
                             3674 ; 237  |#define HW_FLCFTMR2R_TWW_BITPOS 0
                             3675 ; 238  |#define HW_FLCFTMR2R_TWTO_BITPOS 4
                             3676 ; 239  |#define HW_FLCFTMR2R_THW_BITPOS 14
                             3677 ; 240  |#define HW_FLCFTMR2R_TRAQ_BITPOS 19
                             3678 ; 241  |
                             3679 ; 242  |#define HW_FLCFTMR2R_TWW_SETMASK 0xF<<HW_FLCFTMR2R_TWW_BITPOS
                             3680 ; 243  |#define HW_FLCFTMR2R_TWTO_SETMASK 0x3FF<<HW_FLCFTMR2R_TWTO_BITPOS
                             3681 ; 244  |#define HW_FLCFTMR2R_THW_SETMASK 0x1F<<HW_FLCFTMR2R_THW_BITPOS
                             3682 ; 245  |#define HW_FLCFTMR2R_TRAQ_SETMASK 0x1F<<HW_FLCFTMR2R_TRAQ_BITPOS
                             3683 ; 246  |
                             3684 ; 247  |#define HW_FLCFTMR2R_TWW_CLRMASK ~(WORD)HW_FLCFTMR2R_TWW_SETMASK
                             3685 ; 248  |#define HW_FLCFTMR2R_TWTO_CLRMASK ~(WORD)HW_FLCFTMR2R_TWTO_SETMASK
                             3686 ; 249  |#define HW_FLCFTMR2R_THW_CLRMASK ~(WORD)HW_FLCFTMR2R_THW_SETMASK
                             3687 ; 250  |#define HW_FLCFTMR2R_TRAQ_CLRMASK ~(WORD)HW_FLCFTMR2R_TRAQ_SETMASK
                             3688 ; 251  |
                             3689 ; 252  |
                             3690 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                             3691 ; 254  |//  EMC Flash SmartMedia Control Register (HW_FLSMCR) Bit Definitions
                             3692 ; 255  |
                             3693 ; 256  |typedef union           /* Flash SmartMedia Control Register*/
                             3694 ; 257  |{
                             3695 ; 258  |    struct
                             3696 ; 259  |    {
                             3697 ; 260  |        unsigned CS     :2;
                             3698 ; 261  |        int SE          :1;
                             3699 ; 262  |        int WP          :1;
                             3700 ; 263  |        int SIZE        :1;
                             3701 ; 264  |        int ICMD        :8;
                             3702 ; 265  |        int TOIE        :1;
                             3703 ; 266  |        int BPIE        :1;
                             3704 ; 267  |        int TOIRQ       :1;
                             3705 ; 268  |        int BPIRQ       :1;
                             3706 ; 269  |    } B;
                             3707 ; 270  |    int I;
                             3708 ; 271  |} flsmcr_type;
                             3709 ; 272  |
                             3710 ; 273  |#define HW_FLSMCR_CS_BITPOS 0
                             3711 ; 274  |#define HW_FLSMCR_SE_BITPOS 2
                             3712 ; 275  |#define HW_FLSMCR_WP_BITPOS 3
                             3713 ; 276  |#define HW_FLSMCR_SIZE_BITPOS 4
                             3714 ; 277  |#define HW_FLSMCR_ICMD_BITPOS 5
                             3715 ; 278  |#define HW_FLSMCR_TOIE_BITPOS 13
                             3716 ; 279  |#define HW_FLSMCR_BPIE_BITPOS 14
                             3717 ; 280  |#define HW_FLSMCR_TOIRQ_BITPOS 15
                             3718 ; 281  |#define HW_FLSMCR_BPIRQ_BITPOS 16
                             3719 ; 282  |
                             3720 ; 283  |#define HW_FLSMCR_CS_SETMASK 1<<HW_FLSMCR_CS_BITPOS
                             3721 ; 284  |#define HW_FLSMCR_SE_SETMASK 1<<HW_FLSMCR_SE_BITPOS
                             3722 ; 285  |#define HW_FLSMCR_WP_SETMASK 1<<HW_FLSMCR_WP_BITPOS
                             3723 ; 286  |#define HW_FLSMCR_SIZE_SETMASK 1<<HW_FLSMCR_SIZE_BITPOS
                             3724 ; 287  |#define HW_FLSMCR_ICMD_SETMASK (0xFF)<<HW_FLSMCR_ICMD_BITPOS
                             3725 ; 288  |#define HW_FLSMCR_TOIE_SETMASK 1<<HW_FLSMCR_TOIE_BITPOS
                             3726 ; 289  |#define HW_FLSMCR_BPIE_SETMASK 1<<HW_FLSMCR_BPIE_BITPOS
                             3727 ; 290  |#define HW_FLSMCR_TOIRQ_SETMASK 1<<HW_FLSMCR_TOIRQ_BITPOS
                             3728 ; 291  |#define HW_FLSMCR_BPIRQ_SETMASK 1<<HW_FLSMCR_BPIRQ_BITPOS
                             3729 ; 292  |
                             3730 ; 293  |#define HW_FLSMCR_SE_ASSERT_SETMASK 0x000000
                             3731 ; 294  |#define HW_FLSMCR_SE_DEASSERT_SETMASK 0x000004
                             3732 ; 295  |#define HW_FLSMCR_WP_ASSERT_SETMASK 0x000000
                             3733 ; 296  |#define HW_FLSMCR_WP_DEASSERT_SETMASK 0x000008
                             3734 ; 297  |#define HW_FLSMCR_SIZE_SMALL_SETMASK 0x000000
                             3735 ; 298  |#define HW_FLSMCR_SIZE_LARGE_SETMASK 0x000010
                             3736 ; 299  |#define HW_FLSMCR_ICMD_RESET_SETMASK 0x001FE0
                             3737 ; 300  |#define HW_FLSMCR_ICMD_READ_STATUS_SETMASK 0x000E00
                             3738 ; 301  |#define HW_FLSMCR_ICMD_BLOCK_ERASE_SETMASK 0x000C00
                             3739 ; 302  |#define HW_FLSMCR_ICMD_ERASE_SETMASK 0x001A00
                             3740 ; 303  |#define HW_FLSMCR_ICMD_RP_FIRST_SETMASK 0x000000
                             3741 ; 304  |#define HW_FLSMCR_ICMD_RP_SECOND_SETMASK 0x000020
                             3742 ; 305  |#define HW_FLSMCR_ICMD_RP_SPARE_SETMASK 0x000A00
                             3743 ; 306  |#define HW_FLSMCR_ICMD_READ_ID_SETMASK 0x001200
                             3744 ; 307  |
                             3745 ; 308  |#define HW_FLSMCR_CS_CLRMASK ~(WORD)HW_FLSMCR_CS_SETMASK
                             3746 ; 309  |#define HW_FLSMCR_SE_CLRMASK ~(WORD)HW_FLSMCR_SE_SETMASK
                             3747 ; 310  |#define HW_FLSMCR_WP_CLRMASK ~(WORD)HW_FLSMCR_WP_SETMASK
                             3748 ; 311  |#define HW_FLSMCR_SIZE_CLRMASK ~(WORD)HW_FLSMCR_SIZE_SETMASK
                             3749 ; 312  |#define HW_FLSMCR_ICMD_CLRMASK ~(WORD)HW_FLSMCR_ICMD_SETMASK
                             3750 ; 313  |#define HW_FLSMCR_TOIE_CLRMASK ~(WORD)HW_FLSMCR_TOIE_SETMASK
                             3751 ; 314  |#define HW_FLSMCR_BPIE_CLRMASK ~(WORD)HW_FLSMCR_BPIE_SETMASK
                             3752 ; 315  |#define HW_FLSMCR_TOIRQ_CLRMASK ~(WORD)HW_FLSMCR_TOIRQ_SETMASK
                             3753 ; 316  |#define HW_FLSMCR_BPIRQ_CLRMASK ~(WORD)HW_FLSMCR_BPIRQ_SETMASK
                             3754 ; 317  |
                             3755 ; 318  |
                             3756 ; 319  |/////////////////////////////////////////////////////////////////////////////////
                             3757 ; 320  |//  EMC Flash SmartMedia Timer1 Register (HW_FLSMTMR1R) Bit Definitions
                             3758 ; 321  |
                             3759 ; 322  |typedef union           /* Flash SmartMedia Timer1 Register*/
                             3760 ; 323  |{
                             3761 ; 324  |    struct
                             3762 ; 325  |    {
                             3763 ; 326  |        unsigned TRWSU  :5;
                             3764 ; 327  |        unsigned TRPW   :6;
                             3765 ; 328  |        unsigned TWPW   :6;
                             3766 ; 329  |        unsigned TRWH   :5;
                             3767 ; 330  |    } B;
                             3768 ; 331  |    int I;
                             3769 ; 332  |} flsmtmr1r_type;
                             3770 ; 333  |
                             3771 ; 334  |#define HW_FLSMTMR1R_TRWSU_BITPOS 0
                             3772 ; 335  |#define HW_FLSMTMR1R_TRPW_BITPOS 5
                             3773 ; 336  |#define HW_FLSMTMR1R_TWPW_BITPOS 11
                             3774 ; 337  |#define HW_FLSMTMR1R_TRWH_BITPOS 17
                             3775 ; 338  |
                             3776 ; 339  |#define HW_FLSMTMR1R_TRWSU_SETMASK 0x1F<<HW_FLSMTMR1R_TRWSU_BITPOS
                             3777 ; 340  |#define HW_FLSMTMR1R_TRPW_SETMASK 0x3F<<HW_FLSMTMR1R_TRPW_BITPOS
                             3778 ; 341  |#define HW_FLSMTMR1R_TWPW_SETMASK 0x3F<<HW_FLSMTMR1R_TWPW_BITPOS
                             3779 ; 342  |#define HW_FLSMTMR1R_TRWH_SETMASK 0x1F<<HW_FLSMTMR1R_TRWH_BITPOS
                             3780 ; 343  |
                             3781 ; 344  |#define HW_FLSMTMR1R_TRWSU_CLRMASK ~(WORD)HW_FLSMTMR1R_TRWSU_SETMASK
                             3782 ; 345  |#define HW_FLSMTMR1R_TRPW_CLRMASK ~(WORD)HW_FLSMTMR1R_TRPW_SETMASK
                             3783 ; 346  |#define HW_FLSMTMR1R_TWPW_CLRMASK ~(WORD)HW_FLSMTMR1R_TWPW_SETMASK
                             3784 ; 347  |#define HW_FLSMTMR1R_TRWH_CLRMASK ~(WORD)HW_FLSMTMR1R_TRWH_SETMASK
                             3785 ; 348  |
                             3786 ; 349  |
                             3787 ; 350  |/////////////////////////////////////////////////////////////////////////////////
                             3788 ; 351  |//  EMC Flash SmartMedia Timer2 Register (HW_FLSMTMR2R) Bit Definitions
                             3789 ; 352  |
                             3790 ; 353  |typedef union           /* Flash SmartMedia Timer2 Register*/
                             3791 ; 354  |{
                             3792 ; 355  |    struct
                             3793 ; 356  |    {
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  16

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3794 ; 357  |        unsigned TWT    :6;
                             3795 ; 358  |        unsigned TWTO   :18;
                             3796 ; 359  |    } B;
                             3797 ; 360  |    int I;
                             3798 ; 361  |} flsmtmr2r_type;
                             3799 ; 362  |
                             3800 ; 363  |#define HW_FLSMTMR2R_TWT_BITPOS 0
                             3801 ; 364  |#define HW_FLSMTMR2R_TWTO_BITPOS 6
                             3802 ; 365  |
                             3803 ; 366  |#define HW_FLSMTMR2R_TWT_SETMASK 0x3F<<HW_FLSMTMR2R_TWT_BITPOS
                             3804 ; 367  |#define HW_FLSMTMR2R_TWTO_SETMASK 0x3FF<<HW_FLSMTMR2R_TWTO_BITPOS
                             3805 ; 368  |
                             3806 ; 369  |#define HW_FLSMTMR2R_TWT_CLRMASK ~(WORD)HW_FLSMTMR2R_TWT_SETMASK
                             3807 ; 370  |#define HW_FLSMTMR2R_TWTO_CLRMASK ~(WORD)HW_FLSMTMR2R_TWTO_SETMASK
                             3808 ; 371  |
                             3809 ; 372  |/*//////////////////////////////////////////////////////////////////////////////
                             3810 ; 373  |  //  EMC Flash Control Status Register2 (HW_FLCR2) Bit Definitions     */
                             3811 ; 374  |typedef union 
                             3812 ; 375  |{
                             3813 ; 376  |  struct
                             3814 ; 377  |  {
                             3815 ; 378  |    unsigned ASEL     :2;        /* Memory Select */
                             3816 ; 379  |    unsigned RA       :1;        /* Right Align word into 24bit memory for True IDE  xfers */
                             3817 ; 380  |    unsigned LA       :1;        /* Left  Align word into 24bit memory for True IDE  xfers */
                             3818 ; 381  |    unsigned NEGDMA   :1;        /* Inverts data from Flash to memory */
                             3819 ; 382  |    unsigned NEGFL    :1;        /* Inverts data from memory to Flash */
                             3820 ; 383  |    unsigned CLKOFF   :1;        /* Power down - turns clk off */
                             3821 ; 384  |    int PAD0          :17;    
                             3822 ; 385  |  } B;
                             3823 ; 386  |  int I;
                             3824 ; 387  |} flcr2_type;
                             3825 ; 388  |
                             3826 ; 389  |/////////////////////////////////////////////////////////////////////////////////
                             3827 ; 390  |//  EMC Flash SmartMedia Status Register (HW_FLSMSR) Bit Definitions
                             3828 ; 391  |#define HW_FLSMSR_RDY_BITPOS 0
                             3829 ; 392  |#define HW_FLSMSR_BUSY_BITPOS 7
                             3830 ; 393  |
                             3831 ; 394  |#define HW_FLCR      (*(volatile flcr_type      _X*) (HW_EMC_BASEADDR))    /* EMC Flash Control Register */
                             3832 ; 395  |#define HW_FLSALR    (*(volatile flsalr_type    _X*) (HW_EMC_BASEADDR+1))  /* EMC Flash Start Address Low Register */
                             3833 ; 396  |#define HW_FLSAHR    (*(volatile flsahr_type    _X*) (HW_EMC_BASEADDR+2))  /* EMC Flash Start Address High Register */
                             3834 ; 397  |#define HW_FLSSMPR   (*(volatile flssmpr_type   _X*) (HW_EMC_BASEADDR+3))  /*  */
                             3835 ; 398  |#define HW_FLCR2     (*(volatile flcr2_type     _X*) (HW_EMC_BASEADDR+4))  /* EMC Flash Control Register2 */
                             3836 ; 399  |#define HW_FLCFCR    (*(volatile flcfcr_type    _X*) (HW_EMC_BASEADDR+8))  /* EMC Flash CompactFlash Control Register*/
                             3837 ; 400  |#define HW_FLCFTMR1R (*(volatile flcftmr1r_type _X*) (HW_EMC_BASEADDR+9))  /* EMC Flash Compact Flash Timer1 Register*/
                             3838 ; 401  |#define HW_FLCFTMR2R (*(volatile flcftmr2r_type _X*) (HW_EMC_BASEADDR+10)) /* EMC Flash Compact Flash Timer2 Register*/
                             3839 ; 402  |#define HW_FLSMCR    (*(volatile flsmcr_type    _X*) (HW_EMC_BASEADDR+16)) /* EMC Flash SmartMedia Control Register*/
                             3840 ; 403  |#define HW_FLSMTMR1R (*(volatile flsmtmr1r_type _X*) (HW_EMC_BASEADDR+17)) /* EMC Flash SmartMedia Timer1 Register*/
                             3841 ; 404  |#define HW_FLSMTMR2R (*(volatile flsmtmr2r_type _X*) (HW_EMC_BASEADDR+18)) /* EMC Flash SmartMedia Timer2 Register*/
                             3842 ; 405  |#define HW_FLSMSR    (*(volatile flssmsr_type   _X*) (HW_EMC_BASEADDR+19)) /*  */
                             3843 ; 406  |
                             3844 ; 407  |//*********************  REGISTER ALIAS DEFINES TO MATCH LEGACY CODE *******************************
                             3845 ; 408  |// The following defines were added to match regs3410.inc definition to build SDK2XXX code without needing 
                             3846 ; 409  |// to update the actual files. Only the defines needed to build SDK2.400 were added.
                             3847 ; 410  |
                             3848 ; 411  |#define HW_FLC2R HW_EMC_BASEADDR+4
                             3849 ; 412  |
                             3850 ; 413  |#endif
                             3851 ; 414  |
                             3852 
                             3854 
                             3855 ; 22   |#include "regsgpio.h"
                             3856 
                             3858 
                             3859 ; 1    |#if !(defined(__REGS_GPIO_INC))
                             3860 ; 2    |#define __REGS_GPIO_INC 1
                             3861 ; 3    |
                             3862 ; 4    |#include "types.h"
                             3863 
                             3865 
                             3866 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3867 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             3868 ; 3    |//
                             3869 ; 4    |// Filename: types.h
                             3870 ; 5    |// Description: Standard data types
                             3871 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3872 ; 7    |
                             3873 ; 8    |#ifndef _TYPES_H
                             3874 ; 9    |#define _TYPES_H
                             3875 ; 10   |
                             3876 ; 11   |// TODO:  move this outta here!
                             3877 ; 12   |#if !defined(NOERROR)
                             3878 ; 13   |#define NOERROR 0
                             3879 ; 14   |#define SUCCESS 0
                             3880 ; 15   |#endif 
                             3881 ; 16   |#if !defined(SUCCESS)
                             3882 ; 17   |#define SUCCESS  0
                             3883 ; 18   |#endif
                             3884 ; 19   |#if !defined(ERROR)
                             3885 ; 20   |#define ERROR   -1
                             3886 ; 21   |#endif
                             3887 ; 22   |#if !defined(FALSE)
                             3888 ; 23   |#define FALSE 0
                             3889 ; 24   |#endif
                             3890 ; 25   |#if !defined(TRUE)
                             3891 ; 26   |#define TRUE  1
                             3892 ; 27   |#endif
                             3893 ; 28   |
                             3894 ; 29   |#if !defined(NULL)
                             3895 ; 30   |#define NULL 0
                             3896 ; 31   |#endif
                             3897 ; 32   |
                             3898 ; 33   |#define MAX_INT     0x7FFFFF
                             3899 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             3900 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             3901 ; 36   |#define MAX_ULONG   (-1) 
                             3902 ; 37   |
                             3903 ; 38   |#define WORD_SIZE   24              // word size in bits
                             3904 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             3905 ; 40   |
                             3906 ; 41   |
                             3907 ; 42   |#define BYTE    unsigned char       // btVarName
                             3908 ; 43   |#define CHAR    signed char         // cVarName
                             3909 ; 44   |#define USHORT  unsigned short      // usVarName
                             3910 ; 45   |#define SHORT   unsigned short      // sVarName
                             3911 ; 46   |#define WORD    unsigned int        // wVarName
                             3912 ; 47   |#define INT     signed int          // iVarName
                             3913 ; 48   |#define DWORD   unsigned long       // dwVarName
                             3914 ; 49   |#define LONG    signed long         // lVarName
                             3915 ; 50   |#define BOOL    unsigned int        // bVarName
                             3916 ; 51   |#define FRACT   _fract              // frVarName
                             3917 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             3918 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             3919 ; 54   |#define FLOAT   float               // fVarName
                             3920 ; 55   |#define DBL     double              // dVarName
                             3921 ; 56   |#define ENUM    enum                // eVarName
                             3922 ; 57   |#define CMX     _complex            // cmxVarName
                             3923 ; 58   |typedef WORD UCS3;                   // 
                             3924 ; 59   |
                             3925 ; 60   |#define UINT16  unsigned short
                             3926 ; 61   |#define UINT8   unsigned char   
                             3927 ; 62   |#define UINT32  unsigned long
                             3928 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             3929 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             3930 ; 65   |#define WCHAR   UINT16
                             3931 ; 66   |
                             3932 ; 67   |//UINT128 is 16 bytes or 6 words
                             3933 ; 68   |typedef struct UINT128_3500 {   
                             3934 ; 69   |    int val[6];     
                             3935 ; 70   |} UINT128_3500;
                             3936 ; 71   |
                             3937 ; 72   |#define UINT128   UINT128_3500
                             3938 ; 73   |
                             3939 ; 74   |// Little endian word packed byte strings:   
                             3940 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3941 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3942 ; 77   |// Little endian word packed byte strings:   
                             3943 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3944 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3945 ; 80   |
                             3946 ; 81   |// Declare Memory Spaces To Use When Coding
                             3947 ; 82   |// A. Sector Buffers
                             3948 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             3949 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             3950 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             3951 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             3952 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             3953 ; 88   |// B. Media DDI Memory
                             3954 ; 89   |#define MEDIA_DDI_MEM _Y
                             3955 ; 90   |
                             3956 ; 91   |
                             3957 ; 92   |
                             3958 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             3959 ; 94   |// Examples of circular pointers:
                             3960 ; 95   |//    INT CIRC cpiVarName
                             3961 ; 96   |//    DWORD CIRC cpdwVarName
                             3962 ; 97   |
                             3963 ; 98   |#define RETCODE INT                 // rcVarName
                             3964 ; 99   |
                             3965 ; 100  |// generic bitfield structure
                             3966 ; 101  |struct Bitfield {
                             3967 ; 102  |    unsigned int B0  :1;
                             3968 ; 103  |    unsigned int B1  :1;
                             3969 ; 104  |    unsigned int B2  :1;
                             3970 ; 105  |    unsigned int B3  :1;
                             3971 ; 106  |    unsigned int B4  :1;
                             3972 ; 107  |    unsigned int B5  :1;
                             3973 ; 108  |    unsigned int B6  :1;
                             3974 ; 109  |    unsigned int B7  :1;
                             3975 ; 110  |    unsigned int B8  :1;
                             3976 ; 111  |    unsigned int B9  :1;
                             3977 ; 112  |    unsigned int B10 :1;
                             3978 ; 113  |    unsigned int B11 :1;
                             3979 ; 114  |    unsigned int B12 :1;
                             3980 ; 115  |    unsigned int B13 :1;
                             3981 ; 116  |    unsigned int B14 :1;
                             3982 ; 117  |    unsigned int B15 :1;
                             3983 ; 118  |    unsigned int B16 :1;
                             3984 ; 119  |    unsigned int B17 :1;
                             3985 ; 120  |    unsigned int B18 :1;
                             3986 ; 121  |    unsigned int B19 :1;
                             3987 ; 122  |    unsigned int B20 :1;
                             3988 ; 123  |    unsigned int B21 :1;
                             3989 ; 124  |    unsigned int B22 :1;
                             3990 ; 125  |    unsigned int B23 :1;
                             3991 ; 126  |};
                             3992 ; 127  |
                             3993 ; 128  |union BitInt {
                             3994 ; 129  |        struct Bitfield B;
                             3995 ; 130  |        int        I;
                             3996 ; 131  |};
                             3997 ; 132  |
                             3998 ; 133  |#define MAX_MSG_LENGTH 10
                             3999 ; 134  |struct CMessage
                             4000 ; 135  |{
                             4001 ; 136  |        unsigned int m_uLength;
                             4002 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             4003 ; 138  |};
                             4004 ; 139  |
                             4005 ; 140  |typedef struct {
                             4006 ; 141  |    WORD m_wLength;
                             4007 ; 142  |    WORD m_wMessage;
                             4008 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             4009 ; 144  |} Message;
                             4010 ; 145  |
                             4011 ; 146  |struct MessageQueueDescriptor
                             4012 ; 147  |{
                             4013 ; 148  |        int *m_pBase;
                             4014 ; 149  |        int m_iModulo;
                             4015 ; 150  |        int m_iSize;
                             4016 ; 151  |        int *m_pHead;
                             4017 ; 152  |        int *m_pTail;
                             4018 ; 153  |};
                             4019 ; 154  |
                             4020 ; 155  |struct ModuleEntry
                             4021 ; 156  |{
                             4022 ; 157  |    int m_iSignaledEventMask;
                             4023 ; 158  |    int m_iWaitEventMask;
                             4024 ; 159  |    int m_iResourceOfCode;
                             4025 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             4026 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             4027 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             4028 ; 163  |    int m_uTimeOutHigh;
                             4029 ; 164  |    int m_uTimeOutLow;
                             4030 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             4031 ; 166  |};
                             4032 ; 167  |
                             4033 ; 168  |union WaitMask{
                             4034 ; 169  |    struct B{
                             4035 ; 170  |        unsigned int m_bNone     :1;
                             4036 ; 171  |        unsigned int m_bMessage  :1;
                             4037 ; 172  |        unsigned int m_bTimer    :1;
                             4038 ; 173  |        unsigned int m_bButton   :1;
                             4039 ; 174  |    } B;
                             4040 ; 175  |    int I;
                             4041 ; 176  |} ;
                             4042 ; 177  |
                             4043 ; 178  |
                             4044 ; 179  |struct Button {
                             4045 ; 180  |        WORD wButtonEvent;
                             4046 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             4047 ; 182  |};
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  17

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4048 ; 183  |
                             4049 ; 184  |struct Message {
                             4050 ; 185  |        WORD wMsgLength;
                             4051 ; 186  |        WORD wMsgCommand;
                             4052 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             4053 ; 188  |};
                             4054 ; 189  |
                             4055 ; 190  |union EventTypes {
                             4056 ; 191  |        struct CMessage msg;
                             4057 ; 192  |        struct Button Button ;
                             4058 ; 193  |        struct Message Message;
                             4059 ; 194  |};
                             4060 ; 195  |
                             4061 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             4062 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             4063 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             4064 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             4065 ; 200  |
                             4066 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             4067 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             4068 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             4069 ; 204  |
                             4070 ; 205  |#if DEBUG
                             4071 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             4072 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             4073 ; 208  |#else 
                             4074 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             4075 ; 210  |#define DebugBuildAssert(x)    
                             4076 ; 211  |#endif
                             4077 ; 212  |
                             4078 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             4079 ; 214  |//  #pragma asm
                             4080 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             4081 ; 216  |//  #pragma endasm
                             4082 ; 217  |
                             4083 ; 218  |
                             4084 ; 219  |#ifdef COLOR_262K
                             4085 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             4086 ; 221  |#elif defined(COLOR_65K)
                             4087 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             4088 ; 223  |#else
                             4089 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             4090 ; 225  |#endif
                             4091 ; 226  |    
                             4092 ; 227  |#endif // #ifndef _TYPES_H
                             4093 
                             4095 
                             4096 ; 5    |
                             4097 ; 6    |/////////////////////////////////////////////////////////////////////////////////
                             4098 ; 7    |//  Interrupt Collector Registers
                             4099 ; 8    |/////////////////////////////////////////////////////////////////////////////////
                             4100 ; 9    |
                             4101 ; 10   |#define HW_GPIO_BASEADDR 0xF400
                             4102 ; 11   |
                             4103 ; 12   |#define HW_GPB0_BASEADDR HW_GPIO_BASEADDR
                             4104 ; 13   |#define HW_GPB1_BASEADDR HW_GPIO_BASEADDR+0x10
                             4105 ; 14   |#define HW_GPB2_BASEADDR HW_GPIO_BASEADDR+0x20
                             4106 ; 15   |#define HW_GPB3_BASEADDR HW_GPIO_BASEADDR+0x30
                             4107 ; 16   |
                             4108 ; 17   |#define HW_GPB0_BLOCKNUM 0
                             4109 ; 18   |#define HW_GPB1_BLOCKNUM 1
                             4110 ; 19   |#define HW_GPB2_BLOCKNUM 2
                             4111 ; 20   |#define HW_GPB3_BLOCKNUM 3
                             4112 ; 21   |
                             4113 ; 22   |#define HW_GPB_GPENR 0
                             4114 ; 23   |#define HW_GPB_GPDOR 1
                             4115 ; 24   |#define HW_GPB_GPDIR 2
                             4116 ; 25   |#define HW_GPB_GPDOER 3
                             4117 ; 26   |#define HW_GPB_GPIPENR 4
                             4118 ; 27   |#define HW_GPB_GPIENR 5
                             4119 ; 28   |#define HW_GPB_GPILVLR 6
                             4120 ; 29   |#define HW_GPB_GPIPOLR 7
                             4121 ; 30   |#define HW_GPB_GPISTATR 8
                             4122 ; 31   |#define HW_GPB_GPPWR 9
                             4123 ; 32   |#define HW_GPB_GP8MA 10
                             4124 ; 33   |
                             4125 ; 34   |
                             4126 ; 35   |
                             4127 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                             4128 ; 37   |//  GPIO Register Bit Positions
                             4129 ; 38   |typedef union               /* GPIO Pin Register Bank 0 */
                             4130 ; 39   |{
                             4131 ; 40   |    struct Bitfield B;      // Bitfield is generic structure B0 - B23 in types.h
                             4132 ; 41   |    unsigned int I;
                             4133 ; 42   |    unsigned int U;
                             4134 ; 43   |} gpr_type;
                             4135 ; 44   |
                             4136 ; 45   |#define HW_GP_B0_BITPOS 0
                             4137 ; 46   |#define HW_GP_B1_BITPOS 1
                             4138 ; 47   |#define HW_GP_B2_BITPOS 2
                             4139 ; 48   |#define HW_GP_B3_BITPOS 3
                             4140 ; 49   |#define HW_GP_B4_BITPOS 4
                             4141 ; 50   |#define HW_GP_B5_BITPOS 5
                             4142 ; 51   |#define HW_GP_B6_BITPOS 6
                             4143 ; 52   |#define HW_GP_B7_BITPOS 7
                             4144 ; 53   |#define HW_GP_B8_BITPOS 8
                             4145 ; 54   |#define HW_GP_B9_BITPOS 9
                             4146 ; 55   |#define HW_GP_B10_BITPOS 10
                             4147 ; 56   |#define HW_GP_B11_BITPOS 11
                             4148 ; 57   |#define HW_GP_B12_BITPOS 12
                             4149 ; 58   |#define HW_GP_B13_BITPOS 13
                             4150 ; 59   |#define HW_GP_B14_BITPOS 14
                             4151 ; 60   |#define HW_GP_B15_BITPOS 15
                             4152 ; 61   |#define HW_GP_B16_BITPOS 16
                             4153 ; 62   |#define HW_GP_B17_BITPOS 17
                             4154 ; 63   |#define HW_GP_B18_BITPOS 18
                             4155 ; 64   |#define HW_GP_B19_BITPOS 19
                             4156 ; 65   |#define HW_GP_B20_BITPOS 20
                             4157 ; 66   |#define HW_GP_B21_BITPOS 21
                             4158 ; 67   |#define HW_GP_B22_BITPOS 22
                             4159 ; 68   |#define HW_GP_B23_BITPOS 23
                             4160 ; 69   |
                             4161 ; 70   |#define HW_GP_B0_SETMASK (1<<HW_GP_B0_BITPOS)
                             4162 ; 71   |#define HW_GP_B1_SETMASK (1<<HW_GP_B1_BITPOS)
                             4163 ; 72   |#define HW_GP_B2_SETMASK (1<<HW_GP_B2_BITPOS)
                             4164 ; 73   |#define HW_GP_B3_SETMASK (1<<HW_GP_B3_BITPOS)
                             4165 ; 74   |#define HW_GP_B4_SETMASK (1<<HW_GP_B4_BITPOS)
                             4166 ; 75   |#define HW_GP_B5_SETMASK (1<<HW_GP_B5_BITPOS)
                             4167 ; 76   |#define HW_GP_B6_SETMASK (1<<HW_GP_B6_BITPOS)
                             4168 ; 77   |#define HW_GP_B7_SETMASK (1<<HW_GP_B7_BITPOS)
                             4169 ; 78   |#define HW_GP_B8_SETMASK (1<<HW_GP_B8_BITPOS)
                             4170 ; 79   |#define HW_GP_B9_SETMASK (1<<HW_GP_B9_BITPOS)
                             4171 ; 80   |#define HW_GP_B10_SETMASK (1<<HW_GP_B10_BITPOS)
                             4172 ; 81   |#define HW_GP_B11_SETMASK (1<<HW_GP_B11_BITPOS)
                             4173 ; 82   |#define HW_GP_B12_SETMASK (1<<HW_GP_B12_BITPOS)
                             4174 ; 83   |#define HW_GP_B13_SETMASK (1<<HW_GP_B13_BITPOS)
                             4175 ; 84   |#define HW_GP_B14_SETMASK (1<<HW_GP_B14_BITPOS)
                             4176 ; 85   |#define HW_GP_B15_SETMASK (1<<HW_GP_B15_BITPOS)
                             4177 ; 86   |#define HW_GP_B16_SETMASK (1<<HW_GP_B16_BITPOS)
                             4178 ; 87   |#define HW_GP_B17_SETMASK (1<<HW_GP_B17_BITPOS)
                             4179 ; 88   |#define HW_GP_B18_SETMASK (1<<HW_GP_B18_BITPOS)
                             4180 ; 89   |#define HW_GP_B19_SETMASK (1<<HW_GP_B19_BITPOS)
                             4181 ; 90   |#define HW_GP_B20_SETMASK (1<<HW_GP_B20_BITPOS)
                             4182 ; 91   |#define HW_GP_B21_SETMASK (1<<HW_GP_B21_BITPOS)
                             4183 ; 92   |#define HW_GP_B22_SETMASK (1<<HW_GP_B22_BITPOS)
                             4184 ; 93   |#define HW_GP_B23_SETMASK (1<<HW_GP_B23_BITPOS)
                             4185 ; 94   |
                             4186 ; 95   |#define HW_GP_B0_CLRMASK (~(WORD)HW_GP_B0_SETMASK)
                             4187 ; 96   |#define HW_GP_B1_CLRMASK (~(WORD)HW_GP_B1_SETMASK)
                             4188 ; 97   |#define HW_GP_B2_CLRMASK (~(WORD)HW_GP_B2_SETMASK)
                             4189 ; 98   |#define HW_GP_B3_CLRMASK (~(WORD)HW_GP_B3_SETMASK)
                             4190 ; 99   |#define HW_GP_B4_CLRMASK (~(WORD)HW_GP_B4_SETMASK)
                             4191 ; 100  |#define HW_GP_B5_CLRMASK (~(WORD)HW_GP_B5_SETMASK)
                             4192 ; 101  |#define HW_GP_B6_CLRMASK (~(WORD)HW_GP_B6_SETMASK)
                             4193 ; 102  |#define HW_GP_B7_CLRMASK (~(WORD)HW_GP_B7_SETMASK)
                             4194 ; 103  |#define HW_GP_B8_CLRMASK (~(WORD)HW_GP_B8_SETMASK)
                             4195 ; 104  |#define HW_GP_B9_CLRMASK (~(WORD)HW_GP_B9_SETMASK)
                             4196 ; 105  |#define HW_GP_B10_CLRMASK (~(WORD)HW_GP_B10_SETMASK)
                             4197 ; 106  |#define HW_GP_B11_CLRMASK (~(WORD)HW_GP_B11_SETMASK)
                             4198 ; 107  |#define HW_GP_B12_CLRMASK (~(WORD)HW_GP_B12_SETMASK)
                             4199 ; 108  |#define HW_GP_B13_CLRMASK (~(WORD)HW_GP_B13_SETMASK)
                             4200 ; 109  |#define HW_GP_B14_CLRMASK (~(WORD)HW_GP_B14_SETMASK)
                             4201 ; 110  |#define HW_GP_B15_CLRMASK (~(WORD)HW_GP_B15_SETMASK)
                             4202 ; 111  |#define HW_GP_B16_CLRMASK (~(WORD)HW_GP_B16_SETMASK)
                             4203 ; 112  |#define HW_GP_B17_CLRMASK (~(WORD)HW_GP_B17_SETMASK)
                             4204 ; 113  |#define HW_GP_B18_CLRMASK (~(WORD)HW_GP_B18_SETMASK)
                             4205 ; 114  |#define HW_GP_B19_CLRMASK (~(WORD)HW_GP_B19_SETMASK)
                             4206 ; 115  |#define HW_GP_B20_CLRMASK (~(WORD)HW_GP_B20_SETMASK)
                             4207 ; 116  |#define HW_GP_B21_CLRMASK (~(WORD)HW_GP_B21_SETMASK)
                             4208 ; 117  |#define HW_GP_B22_CLRMASK (~(WORD)HW_GP_B22_SETMASK)
                             4209 ; 118  |#define HW_GP_B23_CLRMASK (~(WORD)HW_GP_B23_SETMASK)
                             4210 ; 119  |
                             4211 ; 120  |/////////////////////////////////////////////////////////////////////////////////
                             4212 ; 121  |//  GPIO 8mA Register Bit Positions
                             4213 ; 122  |#define HW_GP8MA_B7_B0_BITPOS 0
                             4214 ; 123  |#define HW_GP8MA_B15_B8_BITPOS 1
                             4215 ; 124  |#define HW_GP8MA_B23_B16_BITPOS 2
                             4216 ; 125  |#define HW_GP8MA_CLK_GATE_BITPOS 23
                             4217 ; 126  |
                             4218 ; 127  |
                             4219 ; 128  |/////////////////////////////////////////////////////////////////////////////////
                             4220 ; 129  |//  Logical GPIO numbers
                             4221 ; 130  |#define HW_GPIO_000 0
                             4222 ; 131  |#define HW_GPIO_001 1
                             4223 ; 132  |#define HW_GPIO_002 2
                             4224 ; 133  |#define HW_GPIO_003 3
                             4225 ; 134  |#define HW_GPIO_004 4
                             4226 ; 135  |#define HW_GPIO_005 5
                             4227 ; 136  |#define HW_GPIO_006 6
                             4228 ; 137  |#define HW_GPIO_007 7
                             4229 ; 138  |#define HW_GPIO_008 8
                             4230 ; 139  |#define HW_GPIO_009 9
                             4231 ; 140  |#define HW_GPIO_010 10
                             4232 ; 141  |#define HW_GPIO_011 11
                             4233 ; 142  |#define HW_GPIO_012 12
                             4234 ; 143  |#define HW_GPIO_013 13
                             4235 ; 144  |#define HW_GPIO_014 14
                             4236 ; 145  |#define HW_GPIO_015 15
                             4237 ; 146  |#define HW_GPIO_016 16
                             4238 ; 147  |#define HW_GPIO_017 17
                             4239 ; 148  |#define HW_GPIO_018 18
                             4240 ; 149  |#define HW_GPIO_019 19
                             4241 ; 150  |#define HW_GPIO_020 20
                             4242 ; 151  |#define HW_GPIO_021 21
                             4243 ; 152  |#define HW_GPIO_022 22
                             4244 ; 153  |#define HW_GPIO_023 23
                             4245 ; 154  |#define HW_GPIO_024 24
                             4246 ; 155  |#define HW_GPIO_025 25
                             4247 ; 156  |#define HW_GPIO_026 26
                             4248 ; 157  |#define HW_GPIO_027 27
                             4249 ; 158  |#define HW_GPIO_028 28
                             4250 ; 159  |#define HW_GPIO_029 29
                             4251 ; 160  |#define HW_GPIO_030 30
                             4252 ; 161  |#define HW_GPIO_031 31
                             4253 ; 162  |#define HW_GPIO_032 32
                             4254 ; 163  |#define HW_GPIO_033 33
                             4255 ; 164  |#define HW_GPIO_034 34
                             4256 ; 165  |#define HW_GPIO_035 35
                             4257 ; 166  |#define HW_GPIO_036 36
                             4258 ; 167  |#define HW_GPIO_037 37
                             4259 ; 168  |#define HW_GPIO_038 38
                             4260 ; 169  |#define HW_GPIO_039 39
                             4261 ; 170  |#define HW_GPIO_040 40
                             4262 ; 171  |#define HW_GPIO_041 41
                             4263 ; 172  |#define HW_GPIO_042 42
                             4264 ; 173  |#define HW_GPIO_043 43
                             4265 ; 174  |#define HW_GPIO_044 44
                             4266 ; 175  |#define HW_GPIO_045 45
                             4267 ; 176  |#define HW_GPIO_046 46
                             4268 ; 177  |#define HW_GPIO_047 47
                             4269 ; 178  |#define HW_GPIO_048 48
                             4270 ; 179  |#define HW_GPIO_049 49
                             4271 ; 180  |#define HW_GPIO_050 50
                             4272 ; 181  |#define HW_GPIO_051 51
                             4273 ; 182  |#define HW_GPIO_052 52
                             4274 ; 183  |#define HW_GPIO_053 53
                             4275 ; 184  |#define HW_GPIO_054 54
                             4276 ; 185  |#define HW_GPIO_055 55
                             4277 ; 186  |#define HW_GPIO_056 56
                             4278 ; 187  |#define HW_GPIO_057 57
                             4279 ; 188  |#define HW_GPIO_058 58
                             4280 ; 189  |#define HW_GPIO_059 59
                             4281 ; 190  |#define HW_GPIO_060 60
                             4282 ; 191  |#define HW_GPIO_061 61
                             4283 ; 192  |#define HW_GPIO_062 62
                             4284 ; 193  |#define HW_GPIO_063 63
                             4285 ; 194  |#define HW_GPIO_064 64
                             4286 ; 195  |#define HW_GPIO_065 65
                             4287 ; 196  |#define HW_GPIO_066 66
                             4288 ; 197  |#define HW_GPIO_067 67
                             4289 ; 198  |#define HW_GPIO_068 68
                             4290 ; 199  |#define HW_GPIO_069 69
                             4291 ; 200  |#define HW_GPIO_070 70
                             4292 ; 201  |#define HW_GPIO_071 71
                             4293 ; 202  |#define HW_GPIO_072 72
                             4294 ; 203  |#define HW_GPIO_073 73
                             4295 ; 204  |#define HW_GPIO_074 74
                             4296 ; 205  |#define HW_GPIO_075 75
                             4297 ; 206  |#define HW_GPIO_076 76
                             4298 ; 207  |#define HW_GPIO_077 77
                             4299 ; 208  |#define HW_GPIO_078 78
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  18

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4300 ; 209  |#define HW_GPIO_079 79
                             4301 ; 210  |#define HW_GPIO_080 80
                             4302 ; 211  |#define HW_GPIO_081 81
                             4303 ; 212  |#define HW_GPIO_082 82
                             4304 ; 213  |#define HW_GPIO_083 83
                             4305 ; 214  |#define HW_GPIO_084 84
                             4306 ; 215  |#define HW_GPIO_085 85
                             4307 ; 216  |#define HW_GPIO_086 86
                             4308 ; 217  |#define HW_GPIO_087 87
                             4309 ; 218  |#define HW_GPIO_088 88
                             4310 ; 219  |#define HW_GPIO_089 89
                             4311 ; 220  |#define HW_GPIO_090 90
                             4312 ; 221  |#define HW_GPIO_091 91
                             4313 ; 222  |#define HW_GPIO_092 92
                             4314 ; 223  |#define HW_GPIO_093 93
                             4315 ; 224  |#define HW_GPIO_094 94
                             4316 ; 225  |#define HW_GPIO_095 95
                             4317 ; 226  |#define HW_GPIO_LAST HW_GPIO_095
                             4318 ; 227  |
                             4319 ; 228  |#define HW_GP0ENR      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPENR))  /* GPIO 0 Enable Register   */
                             4320 ; 229  |#define HW_GP0DOR      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPDOR)) /* GPIO 0 Data Out Register */
                             4321 ; 230  |#define HW_GP0DIR      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPDIR)) /* GPIO 0 Dait In Register  */
                             4322 ; 231  |#define HW_GP0DOER     (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPDOER)) /* GPIO 0 Dait Out Enable Register  */
                             4323 ; 232  |#define HW_GP0IPENR    (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPIPENR)) /* GPIO 0 Interrupt Pin Enable Register */
                             4324 ; 233  |#define HW_GP0IENR     (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPIENR)) /* GPIO 0 Interrupt Enable Register */
                             4325 ; 234  |#define HW_GP0ILVLR    (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPILVLR)) /* GPIO 0 Interrupt Level Register  */
                             4326 ; 235  |#define HW_GP0IPOLR    (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPIPOLR)) /* GPIO 0 Interrupt Polarity Register   */
                             4327 ; 236  |#define HW_GP0ISTATR   (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPISTATR)) /* GPIO 0 Interrupt Status Register */
                             4328 ; 237  |#define HW_GP0PWR      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPPWR)) /* GPIO 0 Power Register */
                             4329 ; 238  |#define HW_GP08MA      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GP8MA)) 
                             4330 ; 239  |#define HW_GP1ENR      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPENR))     /* GPIO 1 Enable Register   */
                             4331 ; 240  |#define HW_GP1DOR      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPDOR)) /* GPIO 1 Data Out Register */
                             4332 ; 241  |#define HW_GP1DIR      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPDIR)) /* GPIO 1 Dait In Register  */
                             4333 ; 242  |#define HW_GP1DOER     (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPDOER)) /* GPIO 1 Dait Out Enable Register  */
                             4334 ; 243  |#define HW_GP1IPENR    (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPIPENR)) /* GPIO 1 Interrupt Pin Enable Register */
                             4335 ; 244  |#define HW_GP1IENR     (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPIENR)) /* GPIO 1 Interrupt Enable Register */
                             4336 ; 245  |#define HW_GP1ILVLR    (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPILVLR)) /* GPIO 1 Interrupt Level Register  */
                             4337 ; 246  |#define HW_GP1IPOLR    (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPIPOLR)) /* GPIO 1 Interrupt Polarity Register   */
                             4338 ; 247  |#define HW_GP1ISTATR   (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPISTATR)) /* GPIO 1 Interrupt Status Register */
                             4339 ; 248  |#define HW_GP1PWR      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPPWR)) /* GPIO 0 Power Register */
                             4340 ; 249  |#define HW_GP18MA      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GP8MA)) 
                             4341 ; 250  |#define HW_GP2ENR      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPENR))     /* GPIO 2 Enable Register   */
                             4342 ; 251  |#define HW_GP2DOR      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPDOR)) /* GPIO 2 Data Out Register */
                             4343 ; 252  |#define HW_GP2DIR      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPDIR)) /* GPIO 2 Dait In Register  */
                             4344 ; 253  |#define HW_GP2DOER     (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPDOER)) /* GPIO 2 Dait Out Enable Register  */
                             4345 ; 254  |#define HW_GP2IPENR    (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPIPENR)) /* GPIO 2 Interrupt Pin Enable Register */
                             4346 ; 255  |#define HW_GP2IENR     (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPIENR)) /* GPIO 2 Interrupt Enable Register */
                             4347 ; 256  |#define HW_GP2ILVLR    (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPILVLR)) /* GPIO 2 Interrupt Level Register  */
                             4348 ; 257  |#define HW_GP2IPOLR    (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPIPOLR)) /* GPIO 2 Interrupt Polarity Register   */
                             4349 ; 258  |#define HW_GP2ISTATR   (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPISTATR)) /* GPIO 2 Interrupt Status Register */
                             4350 ; 259  |#define HW_GP2PWR      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPPWR)) /* GPIO 0 Power Register */
                             4351 ; 260  |#define HW_GP28MA      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GP8MA)) 
                             4352 ; 261  |#define HW_GP3ENR      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPENR))     /* GPIO 2 Enable Register   */
                             4353 ; 262  |#define HW_GP3DOR      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPDOR)) /* GPIO 2 Data Out Register */
                             4354 ; 263  |#define HW_GP3DIR      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPDIR)) /* GPIO 2 Dait In Register  */
                             4355 ; 264  |#define HW_GP3DOER     (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPDOER)) /* GPIO 2 Dait Out Enable Register  */
                             4356 ; 265  |#define HW_GP3IPENR    (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPIPENR)) /* GPIO 2 Interrupt Pin Enable Register */
                             4357 ; 266  |#define HW_GP3IENR     (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPIENR)) /* GPIO 2 Interrupt Enable Register */
                             4358 ; 267  |#define HW_GP3ILVLR    (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPILVLR)) /* GPIO 2 Interrupt Level Register  */
                             4359 ; 268  |#define HW_GP3IPOLR    (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPIPOLR)) /* GPIO 2 Interrupt Polarity Register   */
                             4360 ; 269  |#define HW_GP3ISTATR   (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPISTATR)) /* GPIO 2 Interrupt Status Register */
                             4361 ; 270  |#define HW_GP3PWR      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPPWR)) /* GPIO 0 Power Register */
                             4362 ; 271  |#define HW_GP38MA      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GP8MA)) 
                             4363 ; 272  |
                             4364 ; 273  |#endif
                             4365 ; 274  |
                             4366 
                             4368 
                             4369 ; 23   |#include "regsi2c.h"
                             4370 
                             4372 
                             4373 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             4374 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2003
                             4375 ; 3    |// Filename: regsI2C.inc
                             4376 ; 4    |// Description: Register definitions for GPFLASH interface
                             4377 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             4378 ; 6    |// The following naming conventions are followed in this file.
                             4379 ; 7    |// All registers are named using the format...
                             4380 ; 8    |//     HW_<module>_<regname>
                             4381 ; 9    |// where <module> is the module name which can be any of the following...
                             4382 ; 10   |//     USB20
                             4383 ; 11   |// (Note that when there is more than one copy of a particular module, the
                             4384 ; 12   |// module name includes a number starting from 0 for the first instance of
                             4385 ; 13   |// that module)
                             4386 ; 14   |// <regname> is the specific register within that module
                             4387 ; 15   |// We also define the following...
                             4388 ; 16   |//     HW_<module>_<regname>_BITPOS
                             4389 ; 17   |// which defines the starting bit (i.e. LSB) of a multi bit field
                             4390 ; 18   |//     HW_<module>_<regname>_SETMASK
                             4391 ; 19   |// which does something else, and
                             4392 ; 20   |//     HW_<module>_<regname>_CLRMASK
                             4393 ; 21   |// which does something else.
                             4394 ; 22   |// Other rules
                             4395 ; 23   |//     All caps
                             4396 ; 24   |//     Numeric identifiers start at 0
                             4397 ; 25   |#if !(defined(regsi2cinc))
                             4398 ; 26   |#define regsi2cinc 1
                             4399 ; 27   |
                             4400 ; 28   |#include "types.h"
                             4401 
                             4403 
                             4404 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             4405 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             4406 ; 3    |//
                             4407 ; 4    |// Filename: types.h
                             4408 ; 5    |// Description: Standard data types
                             4409 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             4410 ; 7    |
                             4411 ; 8    |#ifndef _TYPES_H
                             4412 ; 9    |#define _TYPES_H
                             4413 ; 10   |
                             4414 ; 11   |// TODO:  move this outta here!
                             4415 ; 12   |#if !defined(NOERROR)
                             4416 ; 13   |#define NOERROR 0
                             4417 ; 14   |#define SUCCESS 0
                             4418 ; 15   |#endif 
                             4419 ; 16   |#if !defined(SUCCESS)
                             4420 ; 17   |#define SUCCESS  0
                             4421 ; 18   |#endif
                             4422 ; 19   |#if !defined(ERROR)
                             4423 ; 20   |#define ERROR   -1
                             4424 ; 21   |#endif
                             4425 ; 22   |#if !defined(FALSE)
                             4426 ; 23   |#define FALSE 0
                             4427 ; 24   |#endif
                             4428 ; 25   |#if !defined(TRUE)
                             4429 ; 26   |#define TRUE  1
                             4430 ; 27   |#endif
                             4431 ; 28   |
                             4432 ; 29   |#if !defined(NULL)
                             4433 ; 30   |#define NULL 0
                             4434 ; 31   |#endif
                             4435 ; 32   |
                             4436 ; 33   |#define MAX_INT     0x7FFFFF
                             4437 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             4438 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             4439 ; 36   |#define MAX_ULONG   (-1) 
                             4440 ; 37   |
                             4441 ; 38   |#define WORD_SIZE   24              // word size in bits
                             4442 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             4443 ; 40   |
                             4444 ; 41   |
                             4445 ; 42   |#define BYTE    unsigned char       // btVarName
                             4446 ; 43   |#define CHAR    signed char         // cVarName
                             4447 ; 44   |#define USHORT  unsigned short      // usVarName
                             4448 ; 45   |#define SHORT   unsigned short      // sVarName
                             4449 ; 46   |#define WORD    unsigned int        // wVarName
                             4450 ; 47   |#define INT     signed int          // iVarName
                             4451 ; 48   |#define DWORD   unsigned long       // dwVarName
                             4452 ; 49   |#define LONG    signed long         // lVarName
                             4453 ; 50   |#define BOOL    unsigned int        // bVarName
                             4454 ; 51   |#define FRACT   _fract              // frVarName
                             4455 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             4456 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             4457 ; 54   |#define FLOAT   float               // fVarName
                             4458 ; 55   |#define DBL     double              // dVarName
                             4459 ; 56   |#define ENUM    enum                // eVarName
                             4460 ; 57   |#define CMX     _complex            // cmxVarName
                             4461 ; 58   |typedef WORD UCS3;                   // 
                             4462 ; 59   |
                             4463 ; 60   |#define UINT16  unsigned short
                             4464 ; 61   |#define UINT8   unsigned char   
                             4465 ; 62   |#define UINT32  unsigned long
                             4466 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             4467 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             4468 ; 65   |#define WCHAR   UINT16
                             4469 ; 66   |
                             4470 ; 67   |//UINT128 is 16 bytes or 6 words
                             4471 ; 68   |typedef struct UINT128_3500 {   
                             4472 ; 69   |    int val[6];     
                             4473 ; 70   |} UINT128_3500;
                             4474 ; 71   |
                             4475 ; 72   |#define UINT128   UINT128_3500
                             4476 ; 73   |
                             4477 ; 74   |// Little endian word packed byte strings:   
                             4478 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             4479 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             4480 ; 77   |// Little endian word packed byte strings:   
                             4481 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             4482 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             4483 ; 80   |
                             4484 ; 81   |// Declare Memory Spaces To Use When Coding
                             4485 ; 82   |// A. Sector Buffers
                             4486 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             4487 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             4488 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             4489 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             4490 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             4491 ; 88   |// B. Media DDI Memory
                             4492 ; 89   |#define MEDIA_DDI_MEM _Y
                             4493 ; 90   |
                             4494 ; 91   |
                             4495 ; 92   |
                             4496 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             4497 ; 94   |// Examples of circular pointers:
                             4498 ; 95   |//    INT CIRC cpiVarName
                             4499 ; 96   |//    DWORD CIRC cpdwVarName
                             4500 ; 97   |
                             4501 ; 98   |#define RETCODE INT                 // rcVarName
                             4502 ; 99   |
                             4503 ; 100  |// generic bitfield structure
                             4504 ; 101  |struct Bitfield {
                             4505 ; 102  |    unsigned int B0  :1;
                             4506 ; 103  |    unsigned int B1  :1;
                             4507 ; 104  |    unsigned int B2  :1;
                             4508 ; 105  |    unsigned int B3  :1;
                             4509 ; 106  |    unsigned int B4  :1;
                             4510 ; 107  |    unsigned int B5  :1;
                             4511 ; 108  |    unsigned int B6  :1;
                             4512 ; 109  |    unsigned int B7  :1;
                             4513 ; 110  |    unsigned int B8  :1;
                             4514 ; 111  |    unsigned int B9  :1;
                             4515 ; 112  |    unsigned int B10 :1;
                             4516 ; 113  |    unsigned int B11 :1;
                             4517 ; 114  |    unsigned int B12 :1;
                             4518 ; 115  |    unsigned int B13 :1;
                             4519 ; 116  |    unsigned int B14 :1;
                             4520 ; 117  |    unsigned int B15 :1;
                             4521 ; 118  |    unsigned int B16 :1;
                             4522 ; 119  |    unsigned int B17 :1;
                             4523 ; 120  |    unsigned int B18 :1;
                             4524 ; 121  |    unsigned int B19 :1;
                             4525 ; 122  |    unsigned int B20 :1;
                             4526 ; 123  |    unsigned int B21 :1;
                             4527 ; 124  |    unsigned int B22 :1;
                             4528 ; 125  |    unsigned int B23 :1;
                             4529 ; 126  |};
                             4530 ; 127  |
                             4531 ; 128  |union BitInt {
                             4532 ; 129  |        struct Bitfield B;
                             4533 ; 130  |        int        I;
                             4534 ; 131  |};
                             4535 ; 132  |
                             4536 ; 133  |#define MAX_MSG_LENGTH 10
                             4537 ; 134  |struct CMessage
                             4538 ; 135  |{
                             4539 ; 136  |        unsigned int m_uLength;
                             4540 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             4541 ; 138  |};
                             4542 ; 139  |
                             4543 ; 140  |typedef struct {
                             4544 ; 141  |    WORD m_wLength;
                             4545 ; 142  |    WORD m_wMessage;
                             4546 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             4547 ; 144  |} Message;
                             4548 ; 145  |
                             4549 ; 146  |struct MessageQueueDescriptor
                             4550 ; 147  |{
                             4551 ; 148  |        int *m_pBase;
                             4552 ; 149  |        int m_iModulo;
                             4553 ; 150  |        int m_iSize;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  19

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4554 ; 151  |        int *m_pHead;
                             4555 ; 152  |        int *m_pTail;
                             4556 ; 153  |};
                             4557 ; 154  |
                             4558 ; 155  |struct ModuleEntry
                             4559 ; 156  |{
                             4560 ; 157  |    int m_iSignaledEventMask;
                             4561 ; 158  |    int m_iWaitEventMask;
                             4562 ; 159  |    int m_iResourceOfCode;
                             4563 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             4564 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             4565 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             4566 ; 163  |    int m_uTimeOutHigh;
                             4567 ; 164  |    int m_uTimeOutLow;
                             4568 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             4569 ; 166  |};
                             4570 ; 167  |
                             4571 ; 168  |union WaitMask{
                             4572 ; 169  |    struct B{
                             4573 ; 170  |        unsigned int m_bNone     :1;
                             4574 ; 171  |        unsigned int m_bMessage  :1;
                             4575 ; 172  |        unsigned int m_bTimer    :1;
                             4576 ; 173  |        unsigned int m_bButton   :1;
                             4577 ; 174  |    } B;
                             4578 ; 175  |    int I;
                             4579 ; 176  |} ;
                             4580 ; 177  |
                             4581 ; 178  |
                             4582 ; 179  |struct Button {
                             4583 ; 180  |        WORD wButtonEvent;
                             4584 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             4585 ; 182  |};
                             4586 ; 183  |
                             4587 ; 184  |struct Message {
                             4588 ; 185  |        WORD wMsgLength;
                             4589 ; 186  |        WORD wMsgCommand;
                             4590 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             4591 ; 188  |};
                             4592 ; 189  |
                             4593 ; 190  |union EventTypes {
                             4594 ; 191  |        struct CMessage msg;
                             4595 ; 192  |        struct Button Button ;
                             4596 ; 193  |        struct Message Message;
                             4597 ; 194  |};
                             4598 ; 195  |
                             4599 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             4600 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             4601 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             4602 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             4603 ; 200  |
                             4604 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             4605 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             4606 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             4607 ; 204  |
                             4608 ; 205  |#if DEBUG
                             4609 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             4610 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             4611 ; 208  |#else 
                             4612 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             4613 ; 210  |#define DebugBuildAssert(x)    
                             4614 ; 211  |#endif
                             4615 ; 212  |
                             4616 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             4617 ; 214  |//  #pragma asm
                             4618 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             4619 ; 216  |//  #pragma endasm
                             4620 ; 217  |
                             4621 ; 218  |
                             4622 ; 219  |#ifdef COLOR_262K
                             4623 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             4624 ; 221  |#elif defined(COLOR_65K)
                             4625 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             4626 ; 223  |#else
                             4627 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             4628 ; 225  |#endif
                             4629 ; 226  |    
                             4630 ; 227  |#endif // #ifndef _TYPES_H
                             4631 
                             4633 
                             4634 ; 29   |
                             4635 ; 30   |/////////////////////////////////////////////////////////////////////////////////
                             4636 ; 31   |////   I2C STMP Registers
                             4637 ; 32   |/////////////////////////////////////////////////////////////////////////////////
                             4638 ; 33   |
                             4639 ; 34   |#define HW_I2C_BASEADDR (0xFFE5)
                             4640 ; 35   |
                             4641 ; 36   |
                             4642 ; 37   |/////////////////////////////////////////////////////////////////////////////////
                             4643 ; 38   |////  I2C Clock Divider Register (HW_I2CDIV) Bit Definitions
                             4644 ; 39   |
                             4645 ; 40   |#define HW_I2CDIV_FACT_BITPOS (1)
                             4646 ; 41   |
                             4647 ; 42   |#define HW_I2CDIV_FACT_SETMASK (0xFF<<HW_I2CDIV_FACT_BITPOS)
                             4648 ; 43   |
                             4649 ; 44   |#define HW_I2CDIV_FACT_CLRMASK (~(WORD)HW_I2CDIV_FACT_SETMASK)
                             4650 ; 45   |
                             4651 ; 46   |typedef union               /* I2C Clock Divider Register */
                             4652 ; 47   |{
                             4653 ; 48   |    struct {
                             4654 ; 49   |        int                :1; 
                             4655 ; 50   |        unsigned FACT      :8;
                             4656 ; 51   |    } B;
                             4657 ; 52   |    int I;
                             4658 ; 53   |    unsigned U;
                             4659 ; 54   |} i2cdivr_type;
                             4660 ; 55   |#define HW_I2CDIV (*(volatile i2cdivr_type _X*) (HW_I2C_BASEADDR))       /* I2C Divfact Registers        */
                             4661 ; 56   |
                             4662 ; 57   |
                             4663 ; 58   |/////////////////////////////////////////////////////////////////////////////////
                             4664 ; 59   |////  I2C Data Register (HW_I2CDAT) Bit Definitions
                             4665 ; 60   |
                             4666 ; 61   |#define HW_I2CDAT_DATA_BITPOS (0)
                             4667 ; 62   |
                             4668 ; 63   |#define HW_I2CDAT_DATA_SETMASK (0xFFFFFF)
                             4669 ; 64   |
                             4670 ; 65   |#define HW_I2CDAT_DATA_CLRMASK (~(WORD)HW_I2CDAT_DATA_SETMASK)
                             4671 ; 66   |
                             4672 ; 67   |typedef union               /* I2C Data Register */
                             4673 ; 68   |{
                             4674 ; 69   |    struct {
                             4675 ; 70   |         unsigned DATA :24; 
                             4676 ; 71   |    } B;
                             4677 ; 72   |    int I;
                             4678 ; 73   |    unsigned U;
                             4679 ; 74   |} i2cdatr_type;
                             4680 ; 75   |#define HW_I2CDAT (*(volatile i2cdatr_type _X*) (HW_I2C_BASEADDR+1)) /* I2C Data Registers (I2CDAT)      */
                             4681 ; 76   |
                             4682 ; 77   |
                             4683 ; 78   |/////////////////////////////////////////////////////////////////////////////////
                             4684 ; 79   |////  I2C Control Status Register (HW_I2CCSR) Bit Definitions
                             4685 ; 80   |#define HW_I2CCSR_I2C_EN_BITPOS (0)
                             4686 ; 81   |#define HW_I2CCSR_RIE_BITPOS (1)
                             4687 ; 82   |#define HW_I2CCSR_BUSY_BITPOS (2)
                             4688 ; 83   |#define HW_I2CCSR_ARB_LOST_BITPOS (3)
                             4689 ; 84   |#define HW_I2CCSR_TIE_BITPOS (4)
                             4690 ; 85   |#define HW_I2CCSR_MODE_BITPOS (5)
                             4691 ; 86   |#define HW_I2CCSR_RDR_BITPOS (6)
                             4692 ; 87   |#define HW_I2CCSR_TDE_BITPOS (7)
                             4693 ; 88   |#define HW_I2CCSR_RWN_BITPOS (8)
                             4694 ; 89   |#define HW_I2CCSR_WL_BITPOS (9)
                             4695 ; 90   |#define HW_I2CCSR_WL0_BITPOS (9)
                             4696 ; 91   |#define HW_I2CCSR_WL1_BITPOS (10)
                             4697 ; 92   |#define HW_I2CCSR_TREQ_BITPOS (11)
                             4698 ; 93   |#define HW_I2CCSR_ROFL_BITPOS (12)
                             4699 ; 94   |#define HW_I2CCSR_TUFL_BITPOS (13)
                             4700 ; 95   |#define HW_I2CCSR_ACKF_BITPOS (14)
                             4701 ; 96   |#define HW_I2CCSR_B_CNT_BITPOS (15)
                             4702 ; 97   |#define HW_I2CCSR_B_CNT0_BITPOS (15)
                             4703 ; 98   |#define HW_I2CCSR_B_CNT1_BITPOS (16)
                             4704 ; 99   |#define HW_I2CCSR_L_WORD_BITPOS (17)
                             4705 ; 100  |#define HW_I2CCSR_SUBA_BITPOS (18)
                             4706 ; 101  |#define HW_I2CCSR_ROFLCL_BITPOS (19)
                             4707 ; 102  |#define HW_I2CCSR_TUFLCL_BITPOS (20)
                             4708 ; 103  |#define HW_I2CCSR_ONEBYTE_BITPOS (21)
                             4709 ; 104  |
                             4710 ; 105  |#define HW_I2CCSR_I2C_EN_SETMASK (1<<HW_I2CCSR_I2C_EN_BITPOS)
                             4711 ; 106  |#define HW_I2CCSR_RIE_SETMASK (1<<HW_I2CCSR_RIE_BITPOS)
                             4712 ; 107  |#define HW_I2CCSR_BUSY_SETMASK (1<<HW_I2CCSR_BUSY_BITPOS)
                             4713 ; 108  |#define HW_I2CCSR_ARB_LOST_SETMASK (1<<HW_I2CCSR_ARB_LOST_BITPOS)
                             4714 ; 109  |#define HW_I2CCSR_TIE_SETMASK (1<<HW_I2CCSR_TIE_BITPOS)
                             4715 ; 110  |#define HW_I2CCSR_MODE_SETMASK (1<<HW_I2CCSR_MODE_BITPOS)
                             4716 ; 111  |#define HW_I2CCSR_RDR_SETMASK (1<<HW_I2CCSR_RDR_BITPOS)
                             4717 ; 112  |#define HW_I2CCSR_TDE_SETMASK (1<<HW_I2CCSR_TDE_BITPOS)
                             4718 ; 113  |#define HW_I2CCSR_RWN_SETMASK (1<<HW_I2CCSR_RWN_BITPOS)
                             4719 ; 114  |#define HW_I2CCSR_WL_SETMASK (3<<HW_I2CCSR_WL_BITPOS)
                             4720 ; 115  |#define HW_I2CCSR_WL0_SETMASK (1<<HW_I2CCSR_WL0_BITPOS)
                             4721 ; 116  |#define HW_I2CCSR_WL1_SETMASK (1<<HW_I2CCSR_WL1_BITPOS)
                             4722 ; 117  |#define HW_I2CCSR_TREQ_SETMASK (1<<HW_I2CCSR_TREQ_BITPOS)
                             4723 ; 118  |#define HW_I2CCSR_ROFL_SETMASK (1<<HW_I2CCSR_ROFL_BITPOS)
                             4724 ; 119  |#define HW_I2CCSR_TUFL_SETMASK (1<<HW_I2CCSR_TUFL_BITPOS)
                             4725 ; 120  |#define HW_I2CCSR_ACKF_SETMASK (1<<HW_I2CCSR_ACKF_BITPOS)
                             4726 ; 121  |#define HW_I2CCSR_B_CNT_SETMASK (3<<HW_I2CCSR_B_CNT_BITPOS)
                             4727 ; 122  |#define HW_I2CCSR_B_CNT0_SETMASK (1<<HW_I2CCSR_B_CNT0_BITPOS)
                             4728 ; 123  |#define HW_I2CCSR_B_CNT1_SETMASK (1<<HW_I2CCSR_B_CNT1_BITPOS)
                             4729 ; 124  |#define HW_I2CCSR_L_WORD_SETMASK (1<<HW_I2CCSR_L_WORD_BITPOS)
                             4730 ; 125  |#define HW_I2CCSR_SUBA_SETMASK (1<<HW_I2CCSR_SUBA_BITPOS)
                             4731 ; 126  |#define HW_I2CCSR_ROFLCL_SETMASK (1<<HW_I2CCSR_ROFLCL_BITPOS)
                             4732 ; 127  |#define HW_I2CCSR_TUFLCL_SETMASK (1<<HW_I2CCSR_TUFLCL_BITPOS)
                             4733 ; 128  |#define HW_I2CCSR_ONEBYTE_SETMASK (1<<HW_I2CCSR_ONEBYTE_BITPOS)
                             4734 ; 129  |
                             4735 ; 130  |#define HW_I2CCSR_I2C_EN_CLRMASK (~(WORD)HW_I2CCSR_I2C_EN_SETMASK)
                             4736 ; 131  |#define HW_I2CCSR_RIE_CLRMASK (~(WORD)HW_I2CCSR_RIE_SETMASK)
                             4737 ; 132  |#define HW_I2CCSR_BUSY_CLRMASK (~(WORD)HW_I2CCSR_BUSY_SETMASK)
                             4738 ; 133  |#define HW_I2CCSR_ARB_LOST_CLRMASK (~(WORD)HW_I2CCSR_ARB_LOST_SETMASK)
                             4739 ; 134  |#define HW_I2CCSR_TIE_CLRMASK (~(WORD)HW_I2CCSR_TIE_SETMASK)
                             4740 ; 135  |#define HW_I2CCSR_MODE_CLRMASK (~(WORD)HW_I2CCSR_MODE_SETMASK)
                             4741 ; 136  |#define HW_I2CCSR_RDR_CLRMASK (~(WORD)HW_I2CCSR_RDR_SETMASK)
                             4742 ; 137  |#define HW_I2CCSR_TDE_CLRMASK (~(WORD)HW_I2CCSR_TDE_SETMASK)
                             4743 ; 138  |#define HW_I2CCSR_RWN_CLRMASK (~(WORD)HW_I2CCSR_RWN_SETMASK)
                             4744 ; 139  |#define HW_I2CCSR_WL_CLRMASK (~(WORD)HW_I2CCSR_WL_SETMASK)
                             4745 ; 140  |#define HW_I2CCSR_WL0_CLRMASK (~(WORD)HW_I2CCSR_WL0_SETMASK)
                             4746 ; 141  |#define HW_I2CCSR_WL1_CLRMASK (~(WORD)HW_I2CCSR_WL1_SETMASK)
                             4747 ; 142  |#define HW_I2CCSR_TREQ_CLRMASK (~(WORD)HW_I2CCSR_TREQ_SETMASK)
                             4748 ; 143  |#define HW_I2CCSR_ROFL_CLRMASK (~(WORD)HW_I2CCSR_ROFL_SETMASK)
                             4749 ; 144  |#define HW_I2CCSR_TUFL_CLRMASK (~(WORD)HW_I2CCSR_TUFL_SETMASK)
                             4750 ; 145  |#define HW_I2CCSR_ACKF_CLRMASK (~(WORD)HW_I2CCSR_ACKF_SETMASK)
                             4751 ; 146  |#define HW_I2CCSR_B_CNT_CLRMASK (~(WORD)HW_I2CCSR_B_CNT_SETMASK)
                             4752 ; 147  |#define HW_I2CCSR_B_CNT0_CLRMASK (~(WORD)HW_I2CCSR_B_CNT0_SETMASK)
                             4753 ; 148  |#define HW_I2CCSR_B_CNT1_CLRMASK (~(WORD)HW_I2CCSR_B_CNT1_SETMASK)
                             4754 ; 149  |#define HW_I2CCSR_L_WORD_CLRMASK (~(WORD)HW_I2CCSR_L_WORD_SETMASK)
                             4755 ; 150  |#define HW_I2CCSR_SUBA_CLRMASK (~(WORD)HW_I2CCSR_SUBA_SETMASK)
                             4756 ; 151  |#define HW_I2CCSR_ROFLCL_CLRMASK (~(WORD)HW_I2CCSR_ROFLCL_SETMASK)
                             4757 ; 152  |#define HW_I2CCSR_TUFLCL_CLRMASK (~(WORD)HW_I2CCSR_TUFLCL_SETMASK)
                             4758 ; 153  |#define HW_I2CCSR_ONEBYTE_CLRMASK (~(WORD)HW_I2CCSR_ONEBYTE_SETMASK)
                             4759 ; 154  |
                             4760 ; 155  |typedef union               /* I2C Control Register         */
                             4761 ; 156  |{
                             4762 ; 157  |    struct {
                             4763 ; 158  |        int I2C_EN      :1; /* Peripheral Enable            */
                             4764 ; 159  |        int RIE         :1; /* Receiver Interrupt Enable        */
                             4765 ; 160  |        int BUSY        :1; /* I2C Bus Busy             */
                             4766 ; 161  |        int ARBLOST     :1; /* Aritration lost          */
                             4767 ; 162  |        int TIE         :1; /* Transmitter Interrupt Enable     */
                             4768 ; 163  |        int MODE        :1; /* Operating Mode Bit           */
                             4769 ; 164  |        int RDR         :1; /* Receiver Data Ready          */
                             4770 ; 165  |       int TDE         :1; /* Transmitter Data Empty       */
                             4771 ; 166  |       int RWN         :1; /* Read/Not Write           */
                             4772 ; 167  |       unsigned WL     :2; /* Word Length              */
                             4773 ; 168  |        int TREQ        :1; /* DSP Transmit Request         */
                             4774 ; 169  |        int ROFL        :1; /* Receiver Overflow            */
                             4775 ; 170  |        int TUFL        :1; /* Transmitter Underflow        */
                             4776 ; 171  |        int ACKF        :1; /* Acknowledge Failure          */
                             4777 ; 172  |        unsigned BCNT   :2; /* Byte Count               */
                             4778 ; 173  |        int LWORD       :1; /* Last Word                */
                             4779 ; 174  |        int SUBA        :1; /* Sub Address              */
                             4780 ; 175  |        int ROFLCL      :1; /* Receiver Overflow Clear      */
                             4781 ; 176  |        int TUFLCL      :1; /* Transmitter Underflow Clear      */
                             4782 ; 177  |        int ONEBYTE     :1; /* Special One Data Byte Transmission Mode */
                             4783 ; 178  |    } B;
                             4784 ; 179  |    int I;
                             4785 ; 180  |    unsigned U;
                             4786 ; 181  |} i2ccsr_type;
                             4787 ; 182  |#define HW_I2CCSR (*(volatile i2ccsr_type _X*) (HW_I2C_BASEADDR+2)) /* I2C Control/Status Register (I2CCSR) */
                             4788 ; 183  |
                             4789 ; 184  |#endif
                             4790 
                             4792 
                             4793 ; 24   |#include "regsi2s.h"
                             4794 
                             4796 
                             4797 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             4798 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2003
                             4799 ; 3    |// Filename: regsi2s.inc
                             4800 ; 4    |// Description: Register definitions for I2S interface
                             4801 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             4802 ; 6    |// The following naming conventions are followed in this file.
                             4803 ; 7    |// All registers are named using the format...
                             4804 ; 8    |//     HW_<module>_<regname>
                             4805 ; 9    |// where <module> is the module name which can be any of the following...
                             4806 ; 10   |//     USB20
                             4807 ; 11   |// (Note that when there is more than one copy of a particular module, the
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  20

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4808 ; 12   |// module name includes a number starting from 0 for the first instance of
                             4809 ; 13   |// that module)
                             4810 ; 14   |// <regname> is the specific register within that module
                             4811 ; 15   |// We also define the following...
                             4812 ; 16   |//     HW_<module>_<regname>_BITPOS
                             4813 ; 17   |// which defines the starting bit (i.e. LSB) of a multi bit field
                             4814 ; 18   |//     HW_<module>_<regname>_SETMASK
                             4815 ; 19   |// which does something else, and
                             4816 ; 20   |//     HW_<module>_<regname>_CLRMASK
                             4817 ; 21   |// which does something else.
                             4818 ; 22   |// Other rules
                             4819 ; 23   |//     All caps
                             4820 ; 24   |//     Numeric identifiers start at 0
                             4821 ; 25   |#if !(defined(regsi2sinc))
                             4822 ; 26   |#define regsi2sinc 1
                             4823 ; 27   |
                             4824 ; 28   |#include "types.h"
                             4825 
                             4827 
                             4828 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             4829 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             4830 ; 3    |//
                             4831 ; 4    |// Filename: types.h
                             4832 ; 5    |// Description: Standard data types
                             4833 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             4834 ; 7    |
                             4835 ; 8    |#ifndef _TYPES_H
                             4836 ; 9    |#define _TYPES_H
                             4837 ; 10   |
                             4838 ; 11   |// TODO:  move this outta here!
                             4839 ; 12   |#if !defined(NOERROR)
                             4840 ; 13   |#define NOERROR 0
                             4841 ; 14   |#define SUCCESS 0
                             4842 ; 15   |#endif 
                             4843 ; 16   |#if !defined(SUCCESS)
                             4844 ; 17   |#define SUCCESS  0
                             4845 ; 18   |#endif
                             4846 ; 19   |#if !defined(ERROR)
                             4847 ; 20   |#define ERROR   -1
                             4848 ; 21   |#endif
                             4849 ; 22   |#if !defined(FALSE)
                             4850 ; 23   |#define FALSE 0
                             4851 ; 24   |#endif
                             4852 ; 25   |#if !defined(TRUE)
                             4853 ; 26   |#define TRUE  1
                             4854 ; 27   |#endif
                             4855 ; 28   |
                             4856 ; 29   |#if !defined(NULL)
                             4857 ; 30   |#define NULL 0
                             4858 ; 31   |#endif
                             4859 ; 32   |
                             4860 ; 33   |#define MAX_INT     0x7FFFFF
                             4861 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             4862 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             4863 ; 36   |#define MAX_ULONG   (-1) 
                             4864 ; 37   |
                             4865 ; 38   |#define WORD_SIZE   24              // word size in bits
                             4866 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             4867 ; 40   |
                             4868 ; 41   |
                             4869 ; 42   |#define BYTE    unsigned char       // btVarName
                             4870 ; 43   |#define CHAR    signed char         // cVarName
                             4871 ; 44   |#define USHORT  unsigned short      // usVarName
                             4872 ; 45   |#define SHORT   unsigned short      // sVarName
                             4873 ; 46   |#define WORD    unsigned int        // wVarName
                             4874 ; 47   |#define INT     signed int          // iVarName
                             4875 ; 48   |#define DWORD   unsigned long       // dwVarName
                             4876 ; 49   |#define LONG    signed long         // lVarName
                             4877 ; 50   |#define BOOL    unsigned int        // bVarName
                             4878 ; 51   |#define FRACT   _fract              // frVarName
                             4879 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             4880 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             4881 ; 54   |#define FLOAT   float               // fVarName
                             4882 ; 55   |#define DBL     double              // dVarName
                             4883 ; 56   |#define ENUM    enum                // eVarName
                             4884 ; 57   |#define CMX     _complex            // cmxVarName
                             4885 ; 58   |typedef WORD UCS3;                   // 
                             4886 ; 59   |
                             4887 ; 60   |#define UINT16  unsigned short
                             4888 ; 61   |#define UINT8   unsigned char   
                             4889 ; 62   |#define UINT32  unsigned long
                             4890 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             4891 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             4892 ; 65   |#define WCHAR   UINT16
                             4893 ; 66   |
                             4894 ; 67   |//UINT128 is 16 bytes or 6 words
                             4895 ; 68   |typedef struct UINT128_3500 {   
                             4896 ; 69   |    int val[6];     
                             4897 ; 70   |} UINT128_3500;
                             4898 ; 71   |
                             4899 ; 72   |#define UINT128   UINT128_3500
                             4900 ; 73   |
                             4901 ; 74   |// Little endian word packed byte strings:   
                             4902 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             4903 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             4904 ; 77   |// Little endian word packed byte strings:   
                             4905 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             4906 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             4907 ; 80   |
                             4908 ; 81   |// Declare Memory Spaces To Use When Coding
                             4909 ; 82   |// A. Sector Buffers
                             4910 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             4911 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             4912 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             4913 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             4914 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             4915 ; 88   |// B. Media DDI Memory
                             4916 ; 89   |#define MEDIA_DDI_MEM _Y
                             4917 ; 90   |
                             4918 ; 91   |
                             4919 ; 92   |
                             4920 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             4921 ; 94   |// Examples of circular pointers:
                             4922 ; 95   |//    INT CIRC cpiVarName
                             4923 ; 96   |//    DWORD CIRC cpdwVarName
                             4924 ; 97   |
                             4925 ; 98   |#define RETCODE INT                 // rcVarName
                             4926 ; 99   |
                             4927 ; 100  |// generic bitfield structure
                             4928 ; 101  |struct Bitfield {
                             4929 ; 102  |    unsigned int B0  :1;
                             4930 ; 103  |    unsigned int B1  :1;
                             4931 ; 104  |    unsigned int B2  :1;
                             4932 ; 105  |    unsigned int B3  :1;
                             4933 ; 106  |    unsigned int B4  :1;
                             4934 ; 107  |    unsigned int B5  :1;
                             4935 ; 108  |    unsigned int B6  :1;
                             4936 ; 109  |    unsigned int B7  :1;
                             4937 ; 110  |    unsigned int B8  :1;
                             4938 ; 111  |    unsigned int B9  :1;
                             4939 ; 112  |    unsigned int B10 :1;
                             4940 ; 113  |    unsigned int B11 :1;
                             4941 ; 114  |    unsigned int B12 :1;
                             4942 ; 115  |    unsigned int B13 :1;
                             4943 ; 116  |    unsigned int B14 :1;
                             4944 ; 117  |    unsigned int B15 :1;
                             4945 ; 118  |    unsigned int B16 :1;
                             4946 ; 119  |    unsigned int B17 :1;
                             4947 ; 120  |    unsigned int B18 :1;
                             4948 ; 121  |    unsigned int B19 :1;
                             4949 ; 122  |    unsigned int B20 :1;
                             4950 ; 123  |    unsigned int B21 :1;
                             4951 ; 124  |    unsigned int B22 :1;
                             4952 ; 125  |    unsigned int B23 :1;
                             4953 ; 126  |};
                             4954 ; 127  |
                             4955 ; 128  |union BitInt {
                             4956 ; 129  |        struct Bitfield B;
                             4957 ; 130  |        int        I;
                             4958 ; 131  |};
                             4959 ; 132  |
                             4960 ; 133  |#define MAX_MSG_LENGTH 10
                             4961 ; 134  |struct CMessage
                             4962 ; 135  |{
                             4963 ; 136  |        unsigned int m_uLength;
                             4964 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             4965 ; 138  |};
                             4966 ; 139  |
                             4967 ; 140  |typedef struct {
                             4968 ; 141  |    WORD m_wLength;
                             4969 ; 142  |    WORD m_wMessage;
                             4970 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             4971 ; 144  |} Message;
                             4972 ; 145  |
                             4973 ; 146  |struct MessageQueueDescriptor
                             4974 ; 147  |{
                             4975 ; 148  |        int *m_pBase;
                             4976 ; 149  |        int m_iModulo;
                             4977 ; 150  |        int m_iSize;
                             4978 ; 151  |        int *m_pHead;
                             4979 ; 152  |        int *m_pTail;
                             4980 ; 153  |};
                             4981 ; 154  |
                             4982 ; 155  |struct ModuleEntry
                             4983 ; 156  |{
                             4984 ; 157  |    int m_iSignaledEventMask;
                             4985 ; 158  |    int m_iWaitEventMask;
                             4986 ; 159  |    int m_iResourceOfCode;
                             4987 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             4988 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             4989 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             4990 ; 163  |    int m_uTimeOutHigh;
                             4991 ; 164  |    int m_uTimeOutLow;
                             4992 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             4993 ; 166  |};
                             4994 ; 167  |
                             4995 ; 168  |union WaitMask{
                             4996 ; 169  |    struct B{
                             4997 ; 170  |        unsigned int m_bNone     :1;
                             4998 ; 171  |        unsigned int m_bMessage  :1;
                             4999 ; 172  |        unsigned int m_bTimer    :1;
                             5000 ; 173  |        unsigned int m_bButton   :1;
                             5001 ; 174  |    } B;
                             5002 ; 175  |    int I;
                             5003 ; 176  |} ;
                             5004 ; 177  |
                             5005 ; 178  |
                             5006 ; 179  |struct Button {
                             5007 ; 180  |        WORD wButtonEvent;
                             5008 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             5009 ; 182  |};
                             5010 ; 183  |
                             5011 ; 184  |struct Message {
                             5012 ; 185  |        WORD wMsgLength;
                             5013 ; 186  |        WORD wMsgCommand;
                             5014 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             5015 ; 188  |};
                             5016 ; 189  |
                             5017 ; 190  |union EventTypes {
                             5018 ; 191  |        struct CMessage msg;
                             5019 ; 192  |        struct Button Button ;
                             5020 ; 193  |        struct Message Message;
                             5021 ; 194  |};
                             5022 ; 195  |
                             5023 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             5024 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             5025 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             5026 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             5027 ; 200  |
                             5028 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             5029 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             5030 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             5031 ; 204  |
                             5032 ; 205  |#if DEBUG
                             5033 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             5034 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             5035 ; 208  |#else 
                             5036 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             5037 ; 210  |#define DebugBuildAssert(x)    
                             5038 ; 211  |#endif
                             5039 ; 212  |
                             5040 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             5041 ; 214  |//  #pragma asm
                             5042 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             5043 ; 216  |//  #pragma endasm
                             5044 ; 217  |
                             5045 ; 218  |
                             5046 ; 219  |#ifdef COLOR_262K
                             5047 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             5048 ; 221  |#elif defined(COLOR_65K)
                             5049 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             5050 ; 223  |#else
                             5051 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             5052 ; 225  |#endif
                             5053 ; 226  |    
                             5054 ; 227  |#endif // #ifndef _TYPES_H
                             5055 
                             5057 
                             5058 ; 29   |
                             5059 ; 30   |///////////////////////////////////////////////////////////////////////////////////
                             5060 ; 31   |////  I2S Registers (SAI)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  21

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5061 ; 32   |///////////////////////////////////////////////////////////////////////////////////
                             5062 ; 33   |
                             5063 ; 34   |
                             5064 ; 35   |#define HW_SAI_BASEADDR (0xFFF0)
                             5065 ; 36   |
                             5066 ; 37   |
                             5067 ; 38   |
                             5068 ; 39   |
                             5069 ; 40   |#define HW_SAIRCSR_REN0_BITPOS (0)
                             5070 ; 41   |#define HW_SAIRCSR_REN1_BITPOS (1)
                             5071 ; 42   |#define HW_SAIRCSR_REN2_BITPOS (2)
                             5072 ; 43   |#define HW_SAIRCSR_RMME_BITPOS (3)
                             5073 ; 44   |#define HW_SAIRCSR_RSVD0_BITPOS (4)
                             5074 ; 45   |#define HW_SAIRCSR_RWL_BITPOS (5)
                             5075 ; 46   |#define HW_SAIRCSR_RDIR_BITPOS (7)
                             5076 ; 47   |#define HW_SAIRCSR_RLRS_BITPOS (8)
                             5077 ; 48   |#define HW_SAIRCSR_RCKP_BITPOS (9)
                             5078 ; 49   |#define HW_SAIRCSR_RREL_BITPOS (10)
                             5079 ; 50   |#define HW_SAIRCSR_RDWJ_BITPOS (11)
                             5080 ; 51   |#define HW_SAIRCSR_RXIE_BITPOS (12)
                             5081 ; 52   |#define HW_SAIRCSR_RSVD1_BITPOS (13)
                             5082 ; 53   |#define HW_SAIRCSR_ROFL_BITPOS (14)
                             5083 ; 54   |#define HW_SAIRCSR_RDR_BITPOS (15)
                             5084 ; 55   |#define HW_SAIRCSR_ROFCL_BITPOS (16)
                             5085 ; 56   |#define HW_SAIRCSR_RSVD2_BITPOS (17)
                             5086 ; 57   |
                             5087 ; 58   |
                             5088 ; 59   |#define HW_SAIRCSR_REN0_WIDTH (1)
                             5089 ; 60   |#define HW_SAIRCSR_REN1_WIDTH (1)
                             5090 ; 61   |#define HW_SAIRCSR_REN2_WIDTH (1)
                             5091 ; 62   |#define HW_SAIRCSR_RMME_WIDTH (1)
                             5092 ; 63   |#define HW_SAIRCSR_RSVD0_WIDTH (1)
                             5093 ; 64   |#define HW_SAIRCSR_RWL_WIDTH (2)
                             5094 ; 65   |#define HW_SAIRCSR_RDIR_WIDTH (1)
                             5095 ; 66   |#define HW_SAIRCSR_RLRS_WIDTH (1)
                             5096 ; 67   |#define HW_SAIRCSR_RCKP_WIDTH (1)
                             5097 ; 68   |#define HW_SAIRCSR_RREL_WIDTH (1)
                             5098 ; 69   |#define HW_SAIRCSR_RDWJ_WIDTH (1)
                             5099 ; 70   |#define HW_SAIRCSR_RXIE_WIDTH (1)
                             5100 ; 71   |#define HW_SAIRCSR_RSVD1_WIDTH (1)
                             5101 ; 72   |#define HW_SAIRCSR_ROFL_WIDTH (1)
                             5102 ; 73   |#define HW_SAIRCSR_RDR_WIDTH (1)
                             5103 ; 74   |#define HW_SAIRCSR_ROFCL_WIDTH (1)
                             5104 ; 75   |#define HW_SAIRCSR_RSVD2_WIDTH (7)
                             5105 ; 76   |
                             5106 ; 77   |
                             5107 ; 78   |#define HW_SAIRCSR_REN0_SETMASK (((1<HW_SAIRCSR_REN0_WIDTH)-1)<<HW_SAIRCSR_REN0_BITPOS)
                             5108 ; 79   |#define HW_SAIRCSR_REN1_SETMASK (((1<HW_SAIRCSR_REN1_WIDTH)-1)<<HW_SAIRCSR_REN1_BITPOS)
                             5109 ; 80   |#define HW_SAIRCSR_REN2_SETMASK (((1<HW_SAIRCSR_REN2_WIDTH)-1)<<HW_SAIRCSR_REN2_BITPOS)
                             5110 ; 81   |#define HW_SAIRCSR_RMME_SETMASK (((1<HW_SAIRCSR_RMME_WIDTH)-1)<<HW_SAIRCSR_RMME_BITPOS)
                             5111 ; 82   |#define HW_SAIRCSR_RSVD0_SETMASK (((1<HW_SAIRCSR_RSVD0_WIDTH)-1)<<HW_SAIRCSR_RSVD0_BITPOS)
                             5112 ; 83   |#define HW_SAIRCSR_RWL_SETMASK (((1<HW_SAIRCSR_RWL_WIDTH)-1)<<HW_SAIRCSR_RWL_BITPOS)
                             5113 ; 84   |#define HW_SAIRCSR_RDIR_SETMASK (((1<HW_SAIRCSR_RDIR_WIDTH)-1)<<HW_SAIRCSR_RDIR_BITPOS)
                             5114 ; 85   |#define HW_SAIRCSR_RLRS_SETMASK (((1<HW_SAIRCSR_RLRS_WIDTH)-1)<<HW_SAIRCSR_RLRS_BITPOS)
                             5115 ; 86   |#define HW_SAIRCSR_RCKP_SETMASK (((1<HW_SAIRCSR_RCKP_WIDTH)-1)<<HW_SAIRCSR_RCKP_BITPOS)
                             5116 ; 87   |#define HW_SAIRCSR_RREL_SETMASK (((1<HW_SAIRCSR_RREL_WIDTH)-1)<<HW_SAIRCSR_RREL_BITPOS)
                             5117 ; 88   |#define HW_SAIRCSR_RDWJ_SETMASK (((1<HW_SAIRCSR_RDWJ_WIDTH)-1)<<HW_SAIRCSR_RDWJ_BITPOS)
                             5118 ; 89   |#define HW_SAIRCSR_RXIE_SETMASK (((1<HW_SAIRCSR_RXIE_WIDTH)-1)<<HW_SAIRCSR_RXIE_BITPOS)
                             5119 ; 90   |#define HW_SAIRCSR_RSVD1_SETMASK (((1<HW_SAIRCSR_RSVD1_WIDTH)-1)<<HW_SAIRCSR_RSVD1_BITPOS)
                             5120 ; 91   |#define HW_SAIRCSR_ROFL_SETMASK (((1<HW_SAIRCSR_ROFL_WIDTH)-1)<<HW_SAIRCSR_ROFL_BITPOS)
                             5121 ; 92   |#define HW_SAIRCSR_RDR_SETMASK (((1<HW_SAIRCSR_RDR_WIDTH)-1)<<HW_SAIRCSR_RDR_BITPOS)
                             5122 ; 93   |#define HW_SAIRCSR_ROFCL_SETMASK (((1<HW_SAIRCSR_ROFCL_WIDTH)-1)<<HW_SAIRCSR_ROFCL_BITPOS)
                             5123 ; 94   |#define HW_SAIRCSR_RSVD2_SETMASK (((1<HW_SAIRCSR_RSVD2_WIDTH)-1)<<HW_SAIRCSR_RSVD2_BITPOS)
                             5124 ; 95   |
                             5125 ; 96   |
                             5126 ; 97   |#define HW_SAIRCSR_REN0_CLRMASK (~(WORD)HW_SAIRCSR_REN0_SETMASK)
                             5127 ; 98   |#define HW_SAIRCSR_REN1_CLRMASK (~(WORD)HW_SAIRCSR_REN1_SETMASK)
                             5128 ; 99   |#define HW_SAIRCSR_REN2_CLRMASK (~(WORD)HW_SAIRCSR_REN2_SETMASK)
                             5129 ; 100  |#define HW_SAIRCSR_RMME_CLRMASK (~(WORD)HW_SAIRCSR_RMME_SETMASK)
                             5130 ; 101  |#define HW_SAIRCSR_RSVD0_CLRMASK (~(WORD)HW_SAIRCSR_RSVD0_SETMASK)
                             5131 ; 102  |#define HW_SAIRCSR_RWL_CLRMASK (~(WORD)HW_SAIRCSR_RWL_SETMASK)
                             5132 ; 103  |#define HW_SAIRCSR_RDIR_CLRMASK (~(WORD)HW_SAIRCSR_RDIR_SETMASK)
                             5133 ; 104  |#define HW_SAIRCSR_RLRS_CLRMASK (~(WORD)HW_SAIRCSR_RLRS_SETMASK)
                             5134 ; 105  |#define HW_SAIRCSR_RCKP_CLRMASK (~(WORD)HW_SAIRCSR_RCKP_SETMASK)
                             5135 ; 106  |#define HW_SAIRCSR_RREL_CLRMASK (~(WORD)HW_SAIRCSR_RREL_SETMASK)
                             5136 ; 107  |#define HW_SAIRCSR_RDWJ_CLRMASK (~(WORD)HW_SAIRCSR_RDWJ_SETMASK)
                             5137 ; 108  |#define HW_SAIRCSR_RXIE_CLRMASK (~(WORD)HW_SAIRCSR_RXIE_SETMASK)
                             5138 ; 109  |#define HW_SAIRCSR_RSVD1_CLRMASK (~(WORD)HW_SAIRCSR_RSVD1_SETMASK)
                             5139 ; 110  |#define HW_SAIRCSR_ROFL_CLRMASK (~(WORD)HW_SAIRCSR_ROFL_SETMASK)
                             5140 ; 111  |#define HW_SAIRCSR_RDR_CLRMASK (~(WORD)HW_SAIRCSR_RDR_SETMASK)
                             5141 ; 112  |#define HW_SAIRCSR_ROFCL_CLRMASK (~(WORD)HW_SAIRCSR_ROFCL_SETMASK)
                             5142 ; 113  |#define HW_SAIRCSR_RSVD2_CLRMASK (~(WORD)HW_SAIRCSR_RSVD2_SETMASK)
                             5143 ; 114  |
                             5144 ; 115  |typedef union
                             5145 ; 116  |{
                             5146 ; 117  |    struct {
                             5147 ; 118  |        int REN0        :HW_SAIRCSR_REN0_WIDTH;        // Receiver 0 enable
                             5148 ; 119  |        int REN1        :HW_SAIRCSR_REN1_WIDTH;        // Receiver 1 enable
                             5149 ; 120  |        int REN2        :HW_SAIRCSR_REN2_WIDTH;        // Receiver 2 enable
                             5150 ; 121  |        int RMME        :HW_SAIRCSR_RMME_WIDTH;        // Receiver master mode enable
                             5151 ; 122  |        int RSVD0       :HW_SAIRCSR_RSVD0_WIDTH;       // Reserved
                             5152 ; 123  |        unsigned RWL    :HW_SAIRCSR_RWL_WIDTH;         // Receiver word length control
                             5153 ; 124  |        int RDIR        :HW_SAIRCSR_RDIR_WIDTH;        // Receiver data shift direction 
                             5154 ; 125  |        int RLRS        :HW_SAIRCSR_RLRS_WIDTH;        // Receiver left right select
                             5155 ; 126  |        int RCKP        :HW_SAIRCSR_RCKP_WIDTH;        // Receiver clock polarity
                             5156 ; 127  |        int RREL        :HW_SAIRCSR_RREL_WIDTH;        // Receiver relative timing
                             5157 ; 128  |        int RDWJ        :HW_SAIRCSR_RDWJ_WIDTH;        // Receiver data word justification
                             5158 ; 129  |        int RXIE        :HW_SAIRCSR_RXIE_WIDTH;        // Receiver interrupt enable
                             5159 ; 130  |        int RSVD1       :HW_SAIRCSR_RSVD1_WIDTH;       // Reserved
                             5160 ; 131  |        int ROFL        :HW_SAIRCSR_ROFL_WIDTH;        // Receiver data overflow
                             5161 ; 132  |        int RDR         :HW_SAIRCSR_RDR_WIDTH;         // Receiver data ready flag
                             5162 ; 133  |        int ROFCL       :HW_SAIRCSR_ROFCL_WIDTH;       // Receiver data overflow clear
                             5163 ; 134  |        unsigned RSVD2  :HW_SAIRCSR_RSVD2_WIDTH;       // Reserved
                             5164 ; 135  |    } B;
                             5165 ; 136  |    int I;
                             5166 ; 137  |    unsigned U;
                             5167 ; 138  |} saircsr_type;
                             5168 ; 139  |
                             5169 ; 140  |#define HW_SAIRCSR (*(volatile saircsr_type _X*) (HW_SAI_BASEADDR))       /* I2S Receive CSR         */
                             5170 ; 141  |
                             5171 ; 142  |typedef union
                             5172 ; 143  |{
                             5173 ; 144  |    struct {
                             5174 ; 145  |        unsigned SAI :24;
                             5175 ; 146  |    } B;
                             5176 ; 147  |    int I;
                             5177 ; 148  |    unsigned U;
                             5178 ; 149  |} saixr_type;
                             5179 ; 150  |
                             5180 ; 151  |#define HW_SAIRX0R (*(volatile saixr_type _X*)  (HW_SAI_BASEADDR+1))       /* I2S Received data reg 0 */
                             5181 ; 152  |#define HW_SAIRX1R (*(volatile saixr_type _X*)  (HW_SAI_BASEADDR+2))       /* I2S Received data reg 1 */
                             5182 ; 153  |#define HW_SAIRX2R (*(volatile saixr_type _X*)  (HW_SAI_BASEADDR+3))       /* I2S Received data reg 2 */
                             5183 ; 154  |
                             5184 ; 155  |
                             5185 ; 156  |#define HW_SAITCSR_TEN0_BITPOS (0)
                             5186 ; 157  |#define HW_SAITCSR_TEN1_BITPOS (1)
                             5187 ; 158  |#define HW_SAITCSR_TEN2_BITPOS (2)
                             5188 ; 159  |#define HW_SAITCSR_TMME_BITPOS (3)
                             5189 ; 160  |#define HW_SAITCSR_RSVD0_BITPOS (4)
                             5190 ; 161  |#define HW_SAITCSR_TWL_BITPOS (5)
                             5191 ; 162  |#define HW_SAITCSR_TDIR_BITPOS (7)
                             5192 ; 163  |#define HW_SAITCSR_TLRS_BITPOS (8)
                             5193 ; 164  |#define HW_SAITCSR_TCKP_BITPOS (9)
                             5194 ; 165  |#define HW_SAITCSR_TREL_BITPOS (10)
                             5195 ; 166  |#define HW_SAITCSR_TDWE_BITPOS (11)
                             5196 ; 167  |#define HW_SAITCSR_TXIE_BITPOS (12)
                             5197 ; 168  |#define HW_SAITCSR_RSVD1_BITPOS (13)
                             5198 ; 169  |#define HW_SAITCSR_TUFL_BITPOS (14)
                             5199 ; 170  |#define HW_SAITCSR_TDE_BITPOS (15)
                             5200 ; 171  |#define HW_SAITCSR_TUFCL_BITPOS (16)
                             5201 ; 172  |#define HW_SAITCSR_RSVD2_BITPOS (17)
                             5202 ; 173  |
                             5203 ; 174  |
                             5204 ; 175  |#define HW_SAITCSR_TEN0_WIDTH (1)
                             5205 ; 176  |#define HW_SAITCSR_TEN1_WIDTH (1)
                             5206 ; 177  |#define HW_SAITCSR_TEN2_WIDTH (1)
                             5207 ; 178  |#define HW_SAITCSR_TMME_WIDTH (1)
                             5208 ; 179  |#define HW_SAITCSR_RSVD0_WIDTH (1)
                             5209 ; 180  |#define HW_SAITCSR_TWL_WIDTH (2)
                             5210 ; 181  |#define HW_SAITCSR_TDIR_WIDTH (1)
                             5211 ; 182  |#define HW_SAITCSR_TLRS_WIDTH (1)
                             5212 ; 183  |#define HW_SAITCSR_TCKP_WIDTH (1)
                             5213 ; 184  |#define HW_SAITCSR_TREL_WIDTH (1)
                             5214 ; 185  |#define HW_SAITCSR_TDWE_WIDTH (1)
                             5215 ; 186  |#define HW_SAITCSR_TXIE_WIDTH (1)
                             5216 ; 187  |#define HW_SAITCSR_RSVD1_WIDTH (1)
                             5217 ; 188  |#define HW_SAITCSR_TUFL_WIDTH (1)
                             5218 ; 189  |#define HW_SAITCSR_TDE_WIDTH (1)
                             5219 ; 190  |#define HW_SAITCSR_TUFCL_WIDTH (1)
                             5220 ; 191  |#define HW_SAITCSR_RSVD2_WIDTH (7)
                             5221 ; 192  |
                             5222 ; 193  |
                             5223 ; 194  |#define HW_SAITCSR_TEN0_SETMASK (((1<HW_SAITCSR_TEN0_WIDTH)-1)<<HW_SAITCSR_TEN0_BITPOS)
                             5224 ; 195  |#define HW_SAITCSR_TEN1_SETMASK (((1<HW_SAITCSR_TEN1_WIDTH)-1)<<HW_SAITCSR_TEN1_BITPOS)
                             5225 ; 196  |#define HW_SAITCSR_TEN2_SETMASK (((1<HW_SAITCSR_TEN2_WIDTH)-1)<<HW_SAITCSR_TEN2_BITPOS)
                             5226 ; 197  |#define HW_SAITCSR_TMME_SETMASK (((1<HW_SAITCSR_TMME_WIDTH)-1)<<HW_SAITCSR_TMME_BITPOS)
                             5227 ; 198  |#define HW_SAITCSR_RSVD0_SETMASK (((1<HW_SAITCSR_RSVD0_WIDTH)-1)<<HW_SAITCSR_RSVD0_BITPOS)
                             5228 ; 199  |#define HW_SAITCSR_TWL_SETMASK (((1<HW_SAITCSR_TWL_WIDTH)-1)<<HW_SAITCSR_TWL_BITPOS)
                             5229 ; 200  |#define HW_SAITCSR_TDIR_SETMASK (((1<HW_SAITCSR_TDIR_WIDTH)-1)<<HW_SAITCSR_TDIR_BITPOS)
                             5230 ; 201  |#define HW_SAITCSR_TLRS_SETMASK (((1<HW_SAITCSR_TLRS_WIDTH)-1)<<HW_SAITCSR_TLRS_BITPOS)
                             5231 ; 202  |#define HW_SAITCSR_TCKP_SETMASK (((1<HW_SAITCSR_TCKP_WIDTH)-1)<<HW_SAITCSR_TCKP_BITPOS)
                             5232 ; 203  |#define HW_SAITCSR_TREL_SETMASK (((1<HW_SAITCSR_TREL_WIDTH)-1)<<HW_SAITCSR_TREL_BITPOS)
                             5233 ; 204  |#define HW_SAITCSR_TDWE_SETMASK (((1<HW_SAITCSR_TDWE_WIDTH)-1)<<HW_SAITCSR_TDWE_BITPOS)
                             5234 ; 205  |#define HW_SAITCSR_TXIE_SETMASK (((1<HW_SAITCSR_TXIE_WIDTH)-1)<<HW_SAITCSR_TXIE_BITPOS)
                             5235 ; 206  |#define HW_SAITCSR_RSVD1_SETMASK (((1<HW_SAITCSR_RSVD1_WIDTH)-1)<<HW_SAITCSR_RSVD1_BITPOS)
                             5236 ; 207  |#define HW_SAITCSR_TUFL_SETMASK (((1<HW_SAITCSR_TUFL_WIDTH)-1)<<HW_SAITCSR_TUFL_BITPOS)
                             5237 ; 208  |#define HW_SAITCSR_TDE_SETMASK (((1<HW_SAITCSR_TDE_WIDTH)-1)<<HW_SAITCSR_TDE_BITPOS)
                             5238 ; 209  |#define HW_SAITCSR_TUFCL_SETMASK (((1<HW_SAITCSR_TUFCL_WIDTH)-1)<<HW_SAITCSR_TUFCL_BITPOS)
                             5239 ; 210  |#define HW_SAITCSR_RSVD2_SETMASK (((1<HW_SAITCSR_RSVD2_WIDTH)-1)<<HW_SAITCSR_RSVD2_BITPOS)
                             5240 ; 211  |
                             5241 ; 212  |
                             5242 ; 213  |#define HW_SAITCSR_TEN0_CLRMASK (~(WORD)HW_SAITCSR_TEN0_SETMASK)
                             5243 ; 214  |#define HW_SAITCSR_TEN1_CLRMASK (~(WORD)HW_SAITCSR_TEN1_SETMASK)
                             5244 ; 215  |#define HW_SAITCSR_TEN2_CLRMASK (~(WORD)HW_SAITCSR_TEN2_SETMASK)
                             5245 ; 216  |#define HW_SAITCSR_TMME_CLRMASK (~(WORD)HW_SAITCSR_TMME_SETMASK)
                             5246 ; 217  |#define HW_SAITCSR_RSVD0_CLRMASK (~(WORD)HW_SAITCSR_RSVD0_SETMASK)
                             5247 ; 218  |#define HW_SAITCSR_TWL_CLRMASK (~(WORD)HW_SAITCSR_TWL_SETMASK)
                             5248 ; 219  |#define HW_SAITCSR_TDIR_CLRMASK (~(WORD)HW_SAITCSR_TDIR_SETMASK)
                             5249 ; 220  |#define HW_SAITCSR_TLRS_CLRMASK (~(WORD)HW_SAITCSR_TLRS_SETMASK)
                             5250 ; 221  |#define HW_SAITCSR_TCKP_CLRMASK (~(WORD)HW_SAITCSR_TCKP_SETMASK)
                             5251 ; 222  |#define HW_SAITCSR_TREL_CLRMASK (~(WORD)HW_SAITCSR_TREL_SETMASK)
                             5252 ; 223  |#define HW_SAITCSR_TDWE_CLRMASK (~(WORD)HW_SAITCSR_TDWE_SETMASK)
                             5253 ; 224  |#define HW_SAITCSR_TXIE_CLRMASK (~(WORD)HW_SAITCSR_TXIE_SETMASK)
                             5254 ; 225  |#define HW_SAITCSR_RSVD1_CLRMASK (~(WORD)HW_SAITCSR_RSVD1_SETMASK)
                             5255 ; 226  |#define HW_SAITCSR_TUFL_CLRMASK (~(WORD)HW_SAITCSR_TUFL_SETMASK)
                             5256 ; 227  |#define HW_SAITCSR_TDE_CLRMASK (~(WORD)HW_SAITCSR_TDE_SETMASK)
                             5257 ; 228  |#define HW_SAITCSR_TUFCL_CLRMASK (~(WORD)HW_SAITCSR_TUFCL_SETMASK)
                             5258 ; 229  |#define HW_SAITCSR_RSVD2_CLRMASK (~(WORD)HW_SAITCSR_RSVD2_SETMASK)
                             5259 ; 230  |
                             5260 ; 231  |
                             5261 ; 232  |typedef union
                             5262 ; 233  |{
                             5263 ; 234  |    struct {
                             5264 ; 235  |        int TEN0       :HW_SAITCSR_TEN0_WIDTH;         // Transmitter 0 enable
                             5265 ; 236  |        int TEN1       :HW_SAITCSR_TEN1_WIDTH;         // Transmitter 1 enable
                             5266 ; 237  |        int TEN2       :HW_SAITCSR_TEN2_WIDTH;         // Transmitter 2 enable
                             5267 ; 238  |        int TMME       :HW_SAITCSR_TMME_WIDTH;         // Transmitter master mode enable
                             5268 ; 239  |        int RSVD0      :HW_SAITCSR_RSVD0_WIDTH;        // Reserved
                             5269 ; 240  |        unsigned TWL   :HW_SAITCSR_TWL_WIDTH;          // Transmitter word length control
                             5270 ; 241  |        int TDIR       :HW_SAITCSR_TDIR_WIDTH;         // Transmitter data shift direction 
                             5271 ; 242  |        int TLRS       :HW_SAITCSR_TLRS_WIDTH;         // Transmitter left right select
                             5272 ; 243  |        int TCKP       :HW_SAITCSR_TCKP_WIDTH;         // Transmitter clock polarity
                             5273 ; 244  |        int TREL       :HW_SAITCSR_TREL_WIDTH;         // Transmitter relative timing
                             5274 ; 245  |        int TDWE       :HW_SAITCSR_TDWE_WIDTH;         // Transmitter data word justification
                             5275 ; 246  |        int TXIE       :HW_SAITCSR_TXIE_WIDTH;         // Transmitter interrupt enable
                             5276 ; 247  |        int RSVD1      :HW_SAITCSR_RSVD1_WIDTH;        // Reserved
                             5277 ; 248  |        int TUFL       :HW_SAITCSR_TUFL_WIDTH;         // Transmitter data overflow
                             5278 ; 249  |        int TDE        :HW_SAITCSR_TDE_WIDTH;          // Transmitter data ready flag
                             5279 ; 250  |        int TUFCL      :HW_SAITCSR_TUFCL_WIDTH;        // Transmitter data overflow clear
                             5280 ; 251  |        unsigned RSVD2 :HW_SAITCSR_RSVD2_WIDTH;        // Reserved
                             5281 ; 252  |    } B;
                             5282 ; 253  |    int I;
                             5283 ; 254  |    unsigned U;
                             5284 ; 255  |} saitcsr_type;
                             5285 ; 256  |
                             5286 ; 257  |#define HW_SAITCSR (*(volatile saitcsr_type _X*) (HW_SAI_BASEADDR+5)) /* I2S Transmit CSR      */
                             5287 ; 258  |
                             5288 ; 259  |#define HW_SAITX0R (*(volatile saixr_type _X*)  (HW_SAI_BASEADDR+6))       /* I2S Transmit data reg 0 */
                             5289 ; 260  |#define HW_SAITX1R (*(volatile saixr_type _X*)  (HW_SAI_BASEADDR+7))       /* I2S Transmit data reg 1 */
                             5290 ; 261  |#define HW_SAITX2R (*(volatile saixr_type _X*)  (HW_SAI_BASEADDR+8))       /* I2S Transmit data reg 2 */
                             5291 ; 262  |
                             5292 ; 263  |#endif
                             5293 
                             5295 
                             5296 ; 25   |#include "regsicoll.h"
                             5297 
                             5299 
                             5300 ; 1    |#if !defined(__REGS_ICOLL_INC)
                             5301 ; 2    |#define __REGS_ICOLL_INC 1
                             5302 ; 3    |
                             5303 ; 4    |/////////////////////////////////////////////////////////////////////////////////
                             5304 ; 5    |//  Interrupt Collector Registers
                             5305 ; 6    |/////////////////////////////////////////////////////////////////////////////////
                             5306 ; 7    |
                             5307 ; 8    |#define HW_ICOLL_BASEADDR 0xF300
                             5308 ; 9    |
                             5309 ; 10   |
                             5310 ; 11   |
                             5311 ; 12   |/////////////////////////////////////////////////////////////////////////////////
                             5312 ; 13   |//  Interrupt Collector 0 Enable Register (HW_ICLENABLE0R) Bit Positions
                             5313 ; 14   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  22

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5314 ; 15   |typedef union
                             5315 ; 16   |{
                             5316 ; 17   |    struct {
                             5317 ; 18   |        int SEN0        :1;
                             5318 ; 19   |        int SEN1        :1;
                             5319 ; 20   |        int SEN2        :1;
                             5320 ; 21   |        int SEN3        :1;
                             5321 ; 22   |        int SEN4        :1;
                             5322 ; 23   |        int SEN5        :1;
                             5323 ; 24   |        int SEN6        :1;
                             5324 ; 25   |        int SEN7        :1;
                             5325 ; 26   |        int SEN8        :1;
                             5326 ; 27   |        int SEN9        :1;
                             5327 ; 28   |        int SEN10       :1;
                             5328 ; 29   |        int SEN11       :1;
                             5329 ; 30   |        int SEN12       :1;
                             5330 ; 31   |        int SEN13       :1;
                             5331 ; 32   |        int SEN14       :1;
                             5332 ; 33   |        int SEN15       :1;
                             5333 ; 34   |        int SEN16       :1;
                             5334 ; 35   |        int SEN17       :1;
                             5335 ; 36   |        int SEN18       :1;
                             5336 ; 37   |        int SEN19       :1;
                             5337 ; 38   |        int SEN20       :1;
                             5338 ; 39   |        int SEN21       :1;
                             5339 ; 40   |        int SEN22       :1;
                             5340 ; 41   |        int SEN23       :1;
                             5341 ; 42   |    } B;
                             5342 ; 43   |    int I;
                             5343 ; 44   |} iclenable0_type;
                             5344 ; 45   |#define HW_ICLENABLE0R  (*(volatile iclenable0_type _X*) (HW_ICOLL_BASEADDR)) /* Interrupt Priority Register Core   */
                             5345 ; 46   |
                             5346 ; 47   |
                             5347 ; 48   |#define HW_ICLENABLE0R_SEN0_BITPOS 0
                             5348 ; 49   |#define HW_ICLENABLE0R_SEN1_BITPOS 1
                             5349 ; 50   |#define HW_ICLENABLE0R_SEN2_BITPOS 2
                             5350 ; 51   |#define HW_ICLENABLE0R_SEN3_BITPOS 3
                             5351 ; 52   |#define HW_ICLENABLE0R_SEN4_BITPOS 4
                             5352 ; 53   |#define HW_ICLENABLE0R_SEN5_BITPOS 5
                             5353 ; 54   |#define HW_ICLENABLE0R_SEN6_BITPOS 6
                             5354 ; 55   |#define HW_ICLENABLE0R_SEN7_BITPOS 7
                             5355 ; 56   |#define HW_ICLENABLE0R_SEN8_BITPOS 8
                             5356 ; 57   |#define HW_ICLENABLE0R_SEN9_BITPOS 9
                             5357 ; 58   |#define HW_ICLENABLE0R_SEN10_BITPOS 10
                             5358 ; 59   |#define HW_ICLENABLE0R_SEN11_BITPOS 11
                             5359 ; 60   |#define HW_ICLENABLE0R_SEN12_BITPOS 12
                             5360 ; 61   |#define HW_ICLENABLE0R_SEN13_BITPOS 13
                             5361 ; 62   |#define HW_ICLENABLE0R_SEN14_BITPOS 14
                             5362 ; 63   |#define HW_ICLENABLE0R_SEN15_BITPOS 15
                             5363 ; 64   |#define HW_ICLENABLE0R_SEN16_BITPOS 16
                             5364 ; 65   |#define HW_ICLENABLE0R_SEN17_BITPOS 17
                             5365 ; 66   |#define HW_ICLENABLE0R_SEN18_BITPOS 18
                             5366 ; 67   |#define HW_ICLENABLE0R_SEN19_BITPOS 19
                             5367 ; 68   |#define HW_ICLENABLE0R_SEN20_BITPOS 20
                             5368 ; 69   |#define HW_ICLENABLE0R_SEN21_BITPOS 21
                             5369 ; 70   |#define HW_ICLENABLE0R_SEN22_BITPOS 22
                             5370 ; 71   |#define HW_ICLENABLE0R_SEN23_BITPOS 23
                             5371 ; 72   |
                             5372 ; 73   |#define HW_ICLENABLE0R_SEN0_SETMASK 1<<HW_ICLENABLE0R_SEN0_BITPOS
                             5373 ; 74   |#define HW_ICLENABLE0R_SEN1_SETMASK 1<<HW_ICLENABLE0R_SEN1_BITPOS
                             5374 ; 75   |#define HW_ICLENABLE0R_SEN2_SETMASK 1<<HW_ICLENABLE0R_SEN2_BITPOS
                             5375 ; 76   |#define HW_ICLENABLE0R_SEN3_SETMASK 1<<HW_ICLENABLE0R_SEN3_BITPOS
                             5376 ; 77   |#define HW_ICLENABLE0R_SEN4_SETMASK 1<<HW_ICLENABLE0R_SEN4_BITPOS
                             5377 ; 78   |#define HW_ICLENABLE0R_SEN5_SETMASK 1<<HW_ICLENABLE0R_SEN5_BITPOS
                             5378 ; 79   |#define HW_ICLENABLE0R_SEN6_SETMASK 1<<HW_ICLENABLE0R_SEN6_BITPOS
                             5379 ; 80   |#define HW_ICLENABLE0R_SEN7_SETMASK 1<<HW_ICLENABLE0R_SEN7_BITPOS
                             5380 ; 81   |#define HW_ICLENABLE0R_SEN8_SETMASK 1<<HW_ICLENABLE0R_SEN8_BITPOS
                             5381 ; 82   |#define HW_ICLENABLE0R_SEN9_SETMASK 1<<HW_ICLENABLE0R_SEN9_BITPOS
                             5382 ; 83   |#define HW_ICLENABLE0R_SEN10_SETMASK 1<<HW_ICLENABLE0R_SEN10_BITPOS
                             5383 ; 84   |#define HW_ICLENABLE0R_SEN11_SETMASK 1<<HW_ICLENABLE0R_SEN11_BITPOS
                             5384 ; 85   |#define HW_ICLENABLE0R_SEN12_SETMASK 1<<HW_ICLENABLE0R_SEN12_BITPOS
                             5385 ; 86   |#define HW_ICLENABLE0R_SEN13_SETMASK 1<<HW_ICLENABLE0R_SEN13_BITPOS
                             5386 ; 87   |#define HW_ICLENABLE0R_SEN14_SETMASK 1<<HW_ICLENABLE0R_SEN14_BITPOS
                             5387 ; 88   |#define HW_ICLENABLE0R_SEN15_SETMASK 1<<HW_ICLENABLE0R_SEN15_BITPOS
                             5388 ; 89   |#define HW_ICLENABLE0R_SEN16_SETMASK 1<<HW_ICLENABLE0R_SEN16_BITPOS
                             5389 ; 90   |#define HW_ICLENABLE0R_SEN17_SETMASK 1<<HW_ICLENABLE0R_SEN17_BITPOS
                             5390 ; 91   |#define HW_ICLENABLE0R_SEN18_SETMASK 1<<HW_ICLENABLE0R_SEN18_BITPOS
                             5391 ; 92   |#define HW_ICLENABLE0R_SEN19_SETMASK 1<<HW_ICLENABLE0R_SEN19_BITPOS
                             5392 ; 93   |#define HW_ICLENABLE0R_SEN20_SETMASK 1<<HW_ICLENABLE0R_SEN20_BITPOS
                             5393 ; 94   |#define HW_ICLENABLE0R_SEN21_SETMASK 1<<HW_ICLENABLE0R_SEN21_BITPOS
                             5394 ; 95   |#define HW_ICLENABLE0R_SEN22_SETMASK 1<<HW_ICLENABLE0R_SEN22_BITPOS
                             5395 ; 96   |#define HW_ICLENABLE0R_SEN23_SETMASK 1<<HW_ICLENABLE0R_SEN23_BITPOS
                             5396 ; 97   |
                             5397 ; 98   |#define HW_ICLENABLE0R_SEN0_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN0_SETMASK
                             5398 ; 99   |#define HW_ICLENABLE0R_SEN1_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN1_SETMASK
                             5399 ; 100  |#define HW_ICLENABLE0R_SEN2_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN2_SETMASK
                             5400 ; 101  |#define HW_ICLENABLE0R_SEN3_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN3_SETMASK
                             5401 ; 102  |#define HW_ICLENABLE0R_SEN4_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN4_SETMASK
                             5402 ; 103  |#define HW_ICLENABLE0R_SEN5_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN5_SETMASK
                             5403 ; 104  |#define HW_ICLENABLE0R_SEN6_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN6_SETMASK
                             5404 ; 105  |#define HW_ICLENABLE0R_SEN7_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN7_SETMASK
                             5405 ; 106  |#define HW_ICLENABLE0R_SEN8_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN8_SETMASK
                             5406 ; 107  |#define HW_ICLENABLE0R_SEN9_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN9_SETMASK
                             5407 ; 108  |#define HW_ICLENABLE0R_SEN10_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN10_SETMASK
                             5408 ; 109  |#define HW_ICLENABLE0R_SEN11_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN11_SETMASK
                             5409 ; 110  |#define HW_ICLENABLE0R_SEN12_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN12_SETMASK
                             5410 ; 111  |#define HW_ICLENABLE0R_SEN13_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN13_SETMASK
                             5411 ; 112  |#define HW_ICLENABLE0R_SEN14_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN14_SETMASK
                             5412 ; 113  |#define HW_ICLENABLE0R_SEN15_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN15_SETMASK
                             5413 ; 114  |#define HW_ICLENABLE0R_SEN16_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN16_SETMASK
                             5414 ; 115  |#define HW_ICLENABLE0R_SEN17_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN17_SETMASK
                             5415 ; 116  |#define HW_ICLENABLE0R_SEN18_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN18_SETMASK
                             5416 ; 117  |#define HW_ICLENABLE0R_SEN19_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN19_SETMASK
                             5417 ; 118  |#define HW_ICLENABLE0R_SEN20_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN20_SETMASK
                             5418 ; 119  |#define HW_ICLENABLE0R_SEN21_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN21_SETMASK
                             5419 ; 120  |#define HW_ICLENABLE0R_SEN22_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN22_SETMASK
                             5420 ; 121  |#define HW_ICLENABLE0R_SEN23_CLRMASK ~(WORD)HW_ICLENABLE0R_SEN23_SETMASK
                             5421 ; 122  |
                             5422 ; 123  |
                             5423 ; 124  |/////////////////////////////////////////////////////////////////////////////////
                             5424 ; 125  |//  Interrupt Collector 1 Enable Register (HW_ICLENABLE1R) Bit Positions
                             5425 ; 126  |typedef union
                             5426 ; 127  |{
                             5427 ; 128  |    struct {
                             5428 ; 129  |        
                             5429 ; 130  |        int SEN24       :1;
                             5430 ; 131  |        int SEN25       :1;
                             5431 ; 132  |        int SEN26       :1;
                             5432 ; 133  |        int SEN27       :1;
                             5433 ; 134  |        int SEN28       :1;
                             5434 ; 135  |        int SEN29       :1;
                             5435 ; 136  |        int SEN30       :1;
                             5436 ; 137  |        int SEN31       :1;
                             5437 ; 138  |        int SEN32       :1;
                             5438 ; 139  |        int SEN33       :1;
                             5439 ; 140  |    } B;
                             5440 ; 141  |    int I;
                             5441 ; 142  |} iclenable1_type;
                             5442 ; 143  |
                             5443 ; 144  |#define HW_ICLENABLE1R  (*(volatile iclenable1_type _X*) (HW_ICOLL_BASEADDR+1)) /* Interrupt Priority Register Core    */
                             5444 ; 145  |
                             5445 ; 146  |#define HW_ICLENABLE1R_SEN24_BITPOS 0
                             5446 ; 147  |#define HW_ICLENABLE1R_SEN25_BITPOS 1
                             5447 ; 148  |#define HW_ICLENABLE1R_SEN26_BITPOS 2
                             5448 ; 149  |#define HW_ICLENABLE1R_SEN27_BITPOS 3
                             5449 ; 150  |#define HW_ICLENABLE1R_SEN28_BITPOS 4
                             5450 ; 151  |#define HW_ICLENABLE1R_SEN29_BITPOS 5
                             5451 ; 152  |#define HW_ICLENABLE1R_SEN30_BITPOS 6
                             5452 ; 153  |#define HW_ICLENABLE1R_SEN31_BITPOS 7
                             5453 ; 154  |#define HW_ICLENABLE1R_SEN32_BITPOS 8
                             5454 ; 155  |#define HW_ICLENABLE1R_SEN33_BITPOS 9
                             5455 ; 156  |
                             5456 ; 157  |#define HW_ICLENABLE1R_SEN24_SETMASK 1<<HW_ICLENABLE1R_SEN24_BITPOS
                             5457 ; 158  |#define HW_ICLENABLE1R_SEN25_SETMASK 1<<HW_ICLENABLE1R_SEN25_BITPOS
                             5458 ; 159  |#define HW_ICLENABLE1R_SEN26_SETMASK 1<<HW_ICLENABLE1R_SEN26_BITPOS
                             5459 ; 160  |#define HW_ICLENABLE1R_SEN27_SETMASK 1<<HW_ICLENABLE1R_SEN27_BITPOS
                             5460 ; 161  |#define HW_ICLENABLE1R_SEN28_SETMASK 1<<HW_ICLENABLE1R_SEN28_BITPOS
                             5461 ; 162  |#define HW_ICLENABLE1R_SEN29_SETMASK 1<<HW_ICLENABLE1R_SEN29_BITPOS
                             5462 ; 163  |#define HW_ICLENABLE1R_SEN30_SETMASK 1<<HW_ICLENABLE1R_SEN30_BITPOS
                             5463 ; 164  |#define HW_ICLENABLE1R_SEN31_SETMASK 1<<HW_ICLENABLE1R_SEN31_BITPOS
                             5464 ; 165  |#define HW_ICLENABLE1R_SEN32_SETMASK 1<<HW_ICLENABLE1R_SEN32_BITPOS
                             5465 ; 166  |#define HW_ICLENABLE1R_SEN33_SETMASK 1<<HW_ICLENABLE1R_SEN33_BITPOS
                             5466 ; 167  |
                             5467 ; 168  |#define HW_ICLENABLE1R_SEN24_CLRMASK ~(WORD)HW_ICLENABLE1R_SEN24_SETMASK
                             5468 ; 169  |#define HW_ICLENABLE1R_SEN25_CLRMASK ~(WORD)HW_ICLENABLE1R_SEN25_SETMASK
                             5469 ; 170  |#define HW_ICLENABLE1R_SEN26_CLRMASK ~(WORD)HW_ICLENABLE1R_SEN26_SETMASK
                             5470 ; 171  |#define HW_ICLENABLE1R_SEN27_CLRMASK ~(WORD)HW_ICLENABLE1R_SEN27_SETMASK
                             5471 ; 172  |#define HW_ICLENABLE1R_SEN28_CLRMASK ~(WORD)HW_ICLENABLE1R_SEN28_SETMASK
                             5472 ; 173  |#define HW_ICLENABLE1R_SEN29_CLRMASK ~(WORD)HW_ICLENABLE1R_SEN29_SETMASK
                             5473 ; 174  |#define HW_ICLENABLE1R_SEN30_CLRMASK ~(WORD)HW_ICLENABLE1R_SEN30_SETMASK
                             5474 ; 175  |#define HW_ICLENABLE1R_SEN31_CLRMASK ~(WORD)HW_ICLENABLE1R_SEN31_SETMASK
                             5475 ; 176  |#define HW_ICLENABLE1R_SEN32_CLRMASK ~(WORD)HW_ICLENABLE1R_SEN32_SETMASK
                             5476 ; 177  |#define HW_ICLENABLE1R_SEN33_CLRMASK ~(WORD)HW_ICLENABLE1R_SEN33_SETMASK
                             5477 ; 178  |
                             5478 ; 179  |
                             5479 ; 180  |/////////////////////////////////////////////////////////////////////////////////
                             5480 ; 181  |//  Interrupt Collector Status 0 Register (HW_ICLSTATUS0R) Bit Positions
                             5481 ; 182  |typedef union
                             5482 ; 183  |{
                             5483 ; 184  |    struct {
                             5484 ; 185  |        int SST0        :1;
                             5485 ; 186  |        int SST1        :1;
                             5486 ; 187  |        int SST2        :1;
                             5487 ; 188  |        int SST3        :1;
                             5488 ; 189  |        int SST4        :1;
                             5489 ; 190  |        int SST5        :1;
                             5490 ; 191  |        int SST6        :1;
                             5491 ; 192  |        int SST7        :1;
                             5492 ; 193  |        int SST8        :1;
                             5493 ; 194  |        int SST9        :1;
                             5494 ; 195  |        int SST10       :1;
                             5495 ; 196  |        int SST11       :1;
                             5496 ; 197  |        int SST12       :1;
                             5497 ; 198  |        int SST13       :1;
                             5498 ; 199  |        int SST14       :1;
                             5499 ; 200  |        int SST15       :1;
                             5500 ; 201  |        int SST16       :1;
                             5501 ; 202  |        int SST17       :1;
                             5502 ; 203  |        int SST18       :1;
                             5503 ; 204  |        int SST19       :1;
                             5504 ; 205  |        int SST20       :1;
                             5505 ; 206  |        int SST21       :1;
                             5506 ; 207  |        int SST22       :1;
                             5507 ; 208  |        int SST23       :1;
                             5508 ; 209  |    } B;
                             5509 ; 210  |    int I;
                             5510 ; 211  |} iclstatus0_type;
                             5511 ; 212  |#define HW_ICLSTATUS0R  (*(volatile iclstatus0_type _X*) (HW_ICOLL_BASEADDR+2)) /* Interrupt Priority Register Core */
                             5512 ; 213  |#define HW_ICLSTATUS0R_SST0_BITPOS 0
                             5513 ; 214  |#define HW_ICLSTATUS0R_SST1_BITPOS 1
                             5514 ; 215  |#define HW_ICLSTATUS0R_SST2_BITPOS 2
                             5515 ; 216  |#define HW_ICLSTATUS0R_SST3_BITPOS 3
                             5516 ; 217  |#define HW_ICLSTATUS0R_SST4_BITPOS 4
                             5517 ; 218  |#define HW_ICLSTATUS0R_SST5_BITPOS 5
                             5518 ; 219  |#define HW_ICLSTATUS0R_SST6_BITPOS 6
                             5519 ; 220  |#define HW_ICLSTATUS0R_SST7_BITPOS 7
                             5520 ; 221  |#define HW_ICLSTATUS0R_SST8_BITPOS 8
                             5521 ; 222  |#define HW_ICLSTATUS0R_SST9_BITPOS 9
                             5522 ; 223  |#define HW_ICLSTATUS0R_SST10_BITPOS 10
                             5523 ; 224  |#define HW_ICLSTATUS0R_SST11_BITPOS 11
                             5524 ; 225  |#define HW_ICLSTATUS0R_SST12_BITPOS 12
                             5525 ; 226  |#define HW_ICLSTATUS0R_SST13_BITPOS 13
                             5526 ; 227  |#define HW_ICLSTATUS0R_SST14_BITPOS 14
                             5527 ; 228  |#define HW_ICLSTATUS0R_SST15_BITPOS 15
                             5528 ; 229  |#define HW_ICLSTATUS0R_SST16_BITPOS 16
                             5529 ; 230  |#define HW_ICLSTATUS0R_SST17_BITPOS 17
                             5530 ; 231  |#define HW_ICLSTATUS0R_SST18_BITPOS 18
                             5531 ; 232  |#define HW_ICLSTATUS0R_SST19_BITPOS 19
                             5532 ; 233  |#define HW_ICLSTATUS0R_SST20_BITPOS 20
                             5533 ; 234  |#define HW_ICLSTATUS0R_SST21_BITPOS 21
                             5534 ; 235  |#define HW_ICLSTATUS0R_SST22_BITPOS 22
                             5535 ; 236  |#define HW_ICLSTATUS0R_SST23_BITPOS 23
                             5536 ; 237  |
                             5537 ; 238  |#define HW_ICLSTATUS0R_SST0_SETMASK 1<<HW_ICLSTATUS0R_SST0_BITPOS
                             5538 ; 239  |#define HW_ICLSTATUS0R_SST1_SETMASK 1<<HW_ICLSTATUS0R_SST1_BITPOS
                             5539 ; 240  |#define HW_ICLSTATUS0R_SST2_SETMASK 1<<HW_ICLSTATUS0R_SST2_BITPOS
                             5540 ; 241  |#define HW_ICLSTATUS0R_SST3_SETMASK 1<<HW_ICLSTATUS0R_SST3_BITPOS
                             5541 ; 242  |#define HW_ICLSTATUS0R_SST4_SETMASK 1<<HW_ICLSTATUS0R_SST4_BITPOS
                             5542 ; 243  |#define HW_ICLSTATUS0R_SST5_SETMASK 1<<HW_ICLSTATUS0R_SST5_BITPOS
                             5543 ; 244  |#define HW_ICLSTATUS0R_SST6_SETMASK 1<<HW_ICLSTATUS0R_SST6_BITPOS
                             5544 ; 245  |#define HW_ICLSTATUS0R_SST7_SETMASK 1<<HW_ICLSTATUS0R_SST7_BITPOS
                             5545 ; 246  |#define HW_ICLSTATUS0R_SST8_SETMASK 1<<HW_ICLSTATUS0R_SST8_BITPOS
                             5546 ; 247  |#define HW_ICLSTATUS0R_SST9_SETMASK 1<<HW_ICLSTATUS0R_SST9_BITPOS
                             5547 ; 248  |#define HW_ICLSTATUS0R_SST10_SETMASK 1<<HW_ICLSTATUS0R_SST10_BITPOS
                             5548 ; 249  |#define HW_ICLSTATUS0R_SST11_SETMASK 1<<HW_ICLSTATUS0R_SST11_BITPOS
                             5549 ; 250  |#define HW_ICLSTATUS0R_SST12_SETMASK 1<<HW_ICLSTATUS0R_SST12_BITPOS
                             5550 ; 251  |#define HW_ICLSTATUS0R_SST13_SETMASK 1<<HW_ICLSTATUS0R_SST13_BITPOS
                             5551 ; 252  |#define HW_ICLSTATUS0R_SST14_SETMASK 1<<HW_ICLSTATUS0R_SST14_BITPOS
                             5552 ; 253  |#define HW_ICLSTATUS0R_SST15_SETMASK 1<<HW_ICLSTATUS0R_SST15_BITPOS
                             5553 ; 254  |#define HW_ICLSTATUS0R_SST16_SETMASK 1<<HW_ICLSTATUS0R_SST16_BITPOS
                             5554 ; 255  |#define HW_ICLSTATUS0R_SST17_SETMASK 1<<HW_ICLSTATUS0R_SST17_BITPOS
                             5555 ; 256  |#define HW_ICLSTATUS0R_SST18_SETMASK 1<<HW_ICLSTATUS0R_SST18_BITPOS
                             5556 ; 257  |#define HW_ICLSTATUS0R_SST19_SETMASK 1<<HW_ICLSTATUS0R_SST19_BITPOS
                             5557 ; 258  |#define HW_ICLSTATUS0R_SST20_SETMASK 1<<HW_ICLSTATUS0R_SST20_BITPOS
                             5558 ; 259  |#define HW_ICLSTATUS0R_SST21_SETMASK 1<<HW_ICLSTATUS0R_SST21_BITPOS
                             5559 ; 260  |#define HW_ICLSTATUS0R_SST22_SETMASK 1<<HW_ICLSTATUS0R_SST22_BITPOS
                             5560 ; 261  |#define HW_ICLSTATUS0R_SST23_SETMASK 1<<HW_ICLSTATUS0R_SST23_BITPOS
                             5561 ; 262  |
                             5562 ; 263  |#define HW_ICLSTATUS0R_SST0_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST0_SETMASK
                             5563 ; 264  |#define HW_ICLSTATUS0R_SST1_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST1_SETMASK
                             5564 ; 265  |#define HW_ICLSTATUS0R_SST2_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST2_SETMASK
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  23

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5565 ; 266  |#define HW_ICLSTATUS0R_SST3_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST3_SETMASK
                             5566 ; 267  |#define HW_ICLSTATUS0R_SST4_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST4_SETMASK
                             5567 ; 268  |#define HW_ICLSTATUS0R_SST5_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST5_SETMASK
                             5568 ; 269  |#define HW_ICLSTATUS0R_SST6_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST6_SETMASK
                             5569 ; 270  |#define HW_ICLSTATUS0R_SST7_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST7_SETMASK
                             5570 ; 271  |#define HW_ICLSTATUS0R_SST8_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST8_SETMASK
                             5571 ; 272  |#define HW_ICLSTATUS0R_SST9_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST9_SETMASK
                             5572 ; 273  |#define HW_ICLSTATUS0R_SST10_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST10_SETMASK
                             5573 ; 274  |#define HW_ICLSTATUS0R_SST11_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST11_SETMASK
                             5574 ; 275  |#define HW_ICLSTATUS0R_SST12_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST12_SETMASK
                             5575 ; 276  |#define HW_ICLSTATUS0R_SST13_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST13_SETMASK
                             5576 ; 277  |#define HW_ICLSTATUS0R_SST14_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST14_SETMASK
                             5577 ; 278  |#define HW_ICLSTATUS0R_SST15_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST15_SETMASK
                             5578 ; 279  |#define HW_ICLSTATUS0R_SST16_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST16_SETMASK
                             5579 ; 280  |#define HW_ICLSTATUS0R_SST17_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST17_SETMASK
                             5580 ; 281  |#define HW_ICLSTATUS0R_SST18_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST18_SETMASK
                             5581 ; 282  |#define HW_ICLSTATUS0R_SST19_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST19_SETMASK
                             5582 ; 283  |#define HW_ICLSTATUS0R_SST20_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST20_SETMASK
                             5583 ; 284  |#define HW_ICLSTATUS0R_SST21_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST21_SETMASK
                             5584 ; 285  |#define HW_ICLSTATUS0R_SST22_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST22_SETMASK
                             5585 ; 286  |#define HW_ICLSTATUS0R_SST23_CLRMASK ~(WORD)HW_ICLSTATUS0R_SST23_SETMASK
                             5586 ; 287  |
                             5587 ; 288  |
                             5588 ; 289  |/////////////////////////////////////////////////////////////////////////////////
                             5589 ; 290  |//  Interrupt Collector Status 1 Register (HW_ICLSTATUS1R) Bit Positions
                             5590 ; 291  |typedef union
                             5591 ; 292  |{
                             5592 ; 293  |    struct {
                             5593 ; 294  |        int SST24       :1;
                             5594 ; 295  |        int SST25       :1;
                             5595 ; 296  |        int SST26       :1;
                             5596 ; 297  |        int SST27       :1;
                             5597 ; 298  |        int SST28       :1;
                             5598 ; 299  |        int SST29       :1;
                             5599 ; 300  |        int SST30       :1;
                             5600 ; 301  |        int SST31       :1;
                             5601 ; 302  |        int SST32       :1;
                             5602 ; 303  |        int SST33       :1;
                             5603 ; 304  |    } B;
                             5604 ; 305  |    int I;
                             5605 ; 306  |} iclstatus1_type;
                             5606 ; 307  |#define HW_ICLSTATUS1R  (*(volatile iclstatus1_type _X*) (HW_ICOLL_BASEADDR+3)) /* Interrupt Priority Register Core */
                             5607 ; 308  |#define HW_ICLSTATUS1R_SST24_BITPOS 0
                             5608 ; 309  |#define HW_ICLSTATUS1R_SST25_BITPOS 1
                             5609 ; 310  |#define HW_ICLSTATUS1R_SST26_BITPOS 2
                             5610 ; 311  |#define HW_ICLSTATUS1R_SST27_BITPOS 3
                             5611 ; 312  |#define HW_ICLSTATUS1R_SST28_BITPOS 4
                             5612 ; 313  |#define HW_ICLSTATUS1R_SST29_BITPOS 5
                             5613 ; 314  |#define HW_ICLSTATUS1R_SST30_BITPOS 6
                             5614 ; 315  |#define HW_ICLSTATUS1R_SST31_BITPOS 7
                             5615 ; 316  |#define HW_ICLSTATUS1R_SST32_BITPOS 8
                             5616 ; 317  |#define HW_ICLSTATUS1R_SST33_BITPOS 9
                             5617 ; 318  |
                             5618 ; 319  |#define HW_ICLSTATUS1R_SST24_SETMASK 1<<HW_ICLSTATUS1R_SST24_BITPOS
                             5619 ; 320  |#define HW_ICLSTATUS1R_SST25_SETMASK 1<<HW_ICLSTATUS1R_SST25_BITPOS
                             5620 ; 321  |#define HW_ICLSTATUS1R_SST26_SETMASK 1<<HW_ICLSTATUS1R_SST26_BITPOS
                             5621 ; 322  |#define HW_ICLSTATUS1R_SST27_SETMASK 1<<HW_ICLSTATUS1R_SST27_BITPOS
                             5622 ; 323  |#define HW_ICLSTATUS1R_SST28_SETMASK 1<<HW_ICLSTATUS1R_SST28_BITPOS
                             5623 ; 324  |#define HW_ICLSTATUS1R_SST29_SETMASK 1<<HW_ICLSTATUS1R_SST29_BITPOS
                             5624 ; 325  |#define HW_ICLSTATUS1R_SST30_SETMASK 1<<HW_ICLSTATUS1R_SST30_BITPOS
                             5625 ; 326  |#define HW_ICLSTATUS1R_SST31_SETMASK 1<<HW_ICLSTATUS1R_SST31_BITPOS
                             5626 ; 327  |#define HW_ICLSTATUS1R_SST32_SETMASK 1<<HW_ICLSTATUS1R_SST32_BITPOS
                             5627 ; 328  |#define HW_ICLSTATUS1R_SST33_SETMASK 1<<HW_ICLSTATUS1R_SST33_BITPOS
                             5628 ; 329  |
                             5629 ; 330  |#define HW_ICLSTATUS1R_SST24_CLRMASK ~(WORD)HW_ICLSTATUS1R_SST24_SETMASK
                             5630 ; 331  |#define HW_ICLSTATUS1R_SST25_CLRMASK ~(WORD)HW_ICLSTATUS1R_SST25_SETMASK
                             5631 ; 332  |#define HW_ICLSTATUS1R_SST26_CLRMASK ~(WORD)HW_ICLSTATUS1R_SST26_SETMASK
                             5632 ; 333  |#define HW_ICLSTATUS1R_SST27_CLRMASK ~(WORD)HW_ICLSTATUS1R_SST27_SETMASK
                             5633 ; 334  |#define HW_ICLSTATUS1R_SST28_CLRMASK ~(WORD)HW_ICLSTATUS1R_SST28_SETMASK
                             5634 ; 335  |#define HW_ICLSTATUS1R_SST29_CLRMASK ~(WORD)HW_ICLSTATUS1R_SST29_SETMASK
                             5635 ; 336  |#define HW_ICLSTATUS1R_SST30_CLRMASK ~(WORD)HW_ICLSTATUS1R_SST30_SETMASK
                             5636 ; 337  |#define HW_ICLSTATUS1R_SST31_CLRMASK ~(WORD)HW_ICLSTATUS1R_SST31_SETMASK
                             5637 ; 338  |#define HW_ICLSTATUS1R_SST32_CLRMASK ~(WORD)HW_ICLSTATUS1R_SST32_SETMASK
                             5638 ; 339  |#define HW_ICLSTATUS1R_SST33_CLRMASK ~(WORD)HW_ICLSTATUS1R_SST33_SETMASK
                             5639 ; 340  |
                             5640 ; 341  |
                             5641 ; 342  |/////////////////////////////////////////////////////////////////////////////////
                             5642 ; 343  |//  Interrupt Collector Priority Defs
                             5643 ; 344  |typedef union
                             5644 ; 345  |{
                             5645 ; 346  |    struct {
                             5646 ; 347  |        unsigned S0P    :3;
                             5647 ; 348  |        unsigned S1P    :3;
                             5648 ; 349  |        unsigned S2P    :3;
                             5649 ; 350  |        unsigned S3P    :3;
                             5650 ; 351  |        unsigned S4P    :3;
                             5651 ; 352  |        unsigned S5P    :3;
                             5652 ; 353  |        unsigned S6P    :3;
                             5653 ; 354  |        unsigned S7P    :3;
                             5654 ; 355  |    } B;
                             5655 ; 356  |    int I;
                             5656 ; 357  |
                             5657 ; 358  |} iclprior0_type;
                             5658 ; 359  |
                             5659 ; 360  |#define HW_ICLPRIOR0R   (*(volatile iclprior0_type _X*) (HW_ICOLL_BASEADDR+4)) /* Interrupt Collector Register 0 Priority   */
                             5660 ; 361  |
                             5661 ; 362  |#define HW_ICLPRIORR_SP_0 0
                             5662 ; 363  |#define HW_ICLPRIORR_SP_1 1
                             5663 ; 364  |#define HW_ICLPRIORR_SP_2 2
                             5664 ; 365  |#define HW_ICLPRIORR_SP_3 3
                             5665 ; 366  |#define HW_ICLPRIORR_SP_4 4
                             5666 ; 367  |#define HW_ICLPRIORR_SP_5 5
                             5667 ; 368  |#define HW_ICLPRIORR_SP_6 6
                             5668 ; 369  |#define HW_ICLPRIORR_SP_7 7
                             5669 ; 370  |
                             5670 ; 371  |
                             5671 ; 372  |/////////////////////////////////////////////////////////////////////////////////
                             5672 ; 373  |//  Interrupt Collector Priority 0 Register (HW_ICLPRIOR0R) Bit Positions
                             5673 ; 374  |#define HW_ICLPRIOR0R_S0P_BITPOS 0
                             5674 ; 375  |#define HW_ICLPRIOR0R_S1P_BITPOS 3
                             5675 ; 376  |#define HW_ICLPRIOR0R_S2P_BITPOS 6
                             5676 ; 377  |#define HW_ICLPRIOR0R_S3P_BITPOS 9
                             5677 ; 378  |#define HW_ICLPRIOR0R_S4P_BITPOS 12
                             5678 ; 379  |#define HW_ICLPRIOR0R_S5P_BITPOS 15
                             5679 ; 380  |#define HW_ICLPRIOR0R_S6P_BITPOS 18
                             5680 ; 381  |#define HW_ICLPRIOR0R_S7P_BITPOS 21
                             5681 ; 382  |
                             5682 ; 383  |#define HW_ICLPRIOR0R_S0P_SETMASK 7<<HW_ICLPRIOR0R_S0P_BITPOS
                             5683 ; 384  |#define HW_ICLPRIOR0R_S1P_SETMASK 7<<HW_ICLPRIOR0R_S1P_BITPOS
                             5684 ; 385  |#define HW_ICLPRIOR0R_S2P_SETMASK 7<<HW_ICLPRIOR0R_S2P_BITPOS
                             5685 ; 386  |#define HW_ICLPRIOR0R_S3P_SETMASK 7<<HW_ICLPRIOR0R_S3P_BITPOS
                             5686 ; 387  |#define HW_ICLPRIOR0R_S4P_SETMASK 7<<HW_ICLPRIOR0R_S4P_BITPOS
                             5687 ; 388  |#define HW_ICLPRIOR0R_S5P_SETMASK 7<<HW_ICLPRIOR0R_S5P_BITPOS
                             5688 ; 389  |#define HW_ICLPRIOR0R_S6P_SETMASK 7<<HW_ICLPRIOR0R_S6P_BITPOS
                             5689 ; 390  |#define HW_ICLPRIOR0R_S7P_SETMASK 7<<HW_ICLPRIOR0R_S7P_BITPOS
                             5690 ; 391  |
                             5691 ; 392  |#define HW_ICLPRIOR0R_S0P_CLRMASK ~(WORD)HW_ICLPRIOR0R_S0P_SETMASK
                             5692 ; 393  |#define HW_ICLPRIOR0R_S1P_CLRMASK ~(WORD)HW_ICLPRIOR0R_S1P_SETMASK
                             5693 ; 394  |#define HW_ICLPRIOR0R_S2P_CLRMASK ~(WORD)HW_ICLPRIOR0R_S2P_SETMASK
                             5694 ; 395  |#define HW_ICLPRIOR0R_S3P_CLRMASK ~(WORD)HW_ICLPRIOR0R_S3P_SETMASK
                             5695 ; 396  |#define HW_ICLPRIOR0R_S4P_CLRMASK ~(WORD)HW_ICLPRIOR0R_S4P_SETMASK
                             5696 ; 397  |#define HW_ICLPRIOR0R_S5P_CLRMASK ~(WORD)HW_ICLPRIOR0R_S5P_SETMASK
                             5697 ; 398  |#define HW_ICLPRIOR0R_S6P_CLRMASK ~(WORD)HW_ICLPRIOR0R_S6P_SETMASK
                             5698 ; 399  |#define HW_ICLPRIOR0R_S7P_CLRMASK ~(WORD)HW_ICLPRIOR0R_S7P_SETMASK
                             5699 ; 400  |
                             5700 ; 401  |
                             5701 ; 402  |/////////////////////////////////////////////////////////////////////////////////
                             5702 ; 403  |//  Interrupt Collector Priority 1 Register (HW_ICLPRIOR1R) Bit Positions
                             5703 ; 404  |typedef union
                             5704 ; 405  |{
                             5705 ; 406  |    struct {
                             5706 ; 407  |        unsigned S8P    :3;
                             5707 ; 408  |        unsigned S9P    :3;
                             5708 ; 409  |        unsigned S10P   :3;
                             5709 ; 410  |        unsigned S11P   :3;
                             5710 ; 411  |        unsigned S12P   :3;
                             5711 ; 412  |        unsigned S13P   :3;
                             5712 ; 413  |        unsigned S14P   :3;
                             5713 ; 414  |        unsigned S15P   :3;
                             5714 ; 415  |    } B;
                             5715 ; 416  |    int I;
                             5716 ; 417  |} iclprior1_type;
                             5717 ; 418  |
                             5718 ; 419  |#define HW_ICLPRIOR1R   (*(volatile iclprior1_type _X*) (HW_ICOLL_BASEADDR+5)) /* Interrupt Collector Register 1 Priority   */
                             5719 ; 420  |
                             5720 ; 421  |#define HW_ICLPRIOR1R_S8P_BITPOS 0
                             5721 ; 422  |#define HW_ICLPRIOR1R_S9P_BITPOS 3
                             5722 ; 423  |#define HW_ICLPRIOR1R_S10P_BITPOS 6
                             5723 ; 424  |#define HW_ICLPRIOR1R_S11P_BITPOS 9
                             5724 ; 425  |#define HW_ICLPRIOR1R_S12P_BITPOS 12
                             5725 ; 426  |#define HW_ICLPRIOR1R_S13P_BITPOS 15
                             5726 ; 427  |#define HW_ICLPRIOR1R_S14P_BITPOS 18
                             5727 ; 428  |#define HW_ICLPRIOR1R_S15P_BITPOS 21
                             5728 ; 429  |
                             5729 ; 430  |#define HW_ICLPRIOR1R_S8P_SETMASK 7<<HW_ICLPRIOR1R_S8P_BITPOS
                             5730 ; 431  |#define HW_ICLPRIOR1R_S9P_SETMASK 7<<HW_ICLPRIOR1R_S9P_BITPOS
                             5731 ; 432  |#define HW_ICLPRIOR1R_S10P_SETMASK 7<<HW_ICLPRIOR1R_S10P_BITPOS
                             5732 ; 433  |#define HW_ICLPRIOR1R_S11P_SETMASK 7<<HW_ICLPRIOR1R_S11P_BITPOS
                             5733 ; 434  |#define HW_ICLPRIOR1R_S12P_SETMASK 7<<HW_ICLPRIOR1R_S12P_BITPOS
                             5734 ; 435  |#define HW_ICLPRIOR1R_S13P_SETMASK 7<<HW_ICLPRIOR1R_S13P_BITPOS
                             5735 ; 436  |#define HW_ICLPRIOR1R_S14P_SETMASK 7<<HW_ICLPRIOR1R_S14P_BITPOS
                             5736 ; 437  |#define HW_ICLPRIOR1R_S15P_SETMASK 7<<HW_ICLPRIOR1R_S15P_BITPOS
                             5737 ; 438  |
                             5738 ; 439  |#define HW_ICLPRIOR1R_S8P_CLRMASK ~(WORD)HW_ICLPRIOR1R_S8P_SETMASK
                             5739 ; 440  |#define HW_ICLPRIOR1R_S9P_CLRMASK ~(WORD)HW_ICLPRIOR1R_S9P_SETMASK
                             5740 ; 441  |#define HW_ICLPRIOR1R_S10P_CLRMASK ~(WORD)HW_ICLPRIOR1R_S10P_SETMASK
                             5741 ; 442  |#define HW_ICLPRIOR1R_S11P_CLRMASK ~(WORD)HW_ICLPRIOR1R_S11P_SETMASK
                             5742 ; 443  |#define HW_ICLPRIOR1R_S12P_CLRMASK ~(WORD)HW_ICLPRIOR1R_S12P_SETMASK
                             5743 ; 444  |#define HW_ICLPRIOR1R_S13P_CLRMASK ~(WORD)HW_ICLPRIOR1R_S13P_SETMASK
                             5744 ; 445  |#define HW_ICLPRIOR1R_S14P_CLRMASK ~(WORD)HW_ICLPRIOR1R_S14P_SETMASK
                             5745 ; 446  |#define HW_ICLPRIOR1R_S15P_CLRMASK ~(WORD)HW_ICLPRIOR1R_S15P_SETMASK
                             5746 ; 447  |
                             5747 ; 448  |
                             5748 ; 449  |/////////////////////////////////////////////////////////////////////////////////
                             5749 ; 450  |//  Interrupt Collector Priority 2 Register (HW_ICLPRI2R) Bit Positions
                             5750 ; 451  |typedef union               /* Interrupt Collector Priority 2 Register      */
                             5751 ; 452  |{
                             5752 ; 453  |    struct {
                             5753 ; 454  |        unsigned S16P   :3;
                             5754 ; 455  |        unsigned S17P   :3;
                             5755 ; 456  |        unsigned S18P   :3;
                             5756 ; 457  |        unsigned S19P   :3;
                             5757 ; 458  |        unsigned S20P   :3;
                             5758 ; 459  |        unsigned S21P   :3;
                             5759 ; 460  |        unsigned S22P   :3;
                             5760 ; 461  |        unsigned S23P   :3;
                             5761 ; 462  |    } B;
                             5762 ; 463  |    int I;
                             5763 ; 464  |} iclprior2_type;
                             5764 ; 465  |#define HW_ICLPRIOR2R   (*(volatile iclprior2_type _X*) (HW_ICOLL_BASEADDR+6)) /* Interrupt Collector Register 2 Priority   */
                             5765 ; 466  |#define HW_ICLPRIOR2R_S16P_BITPOS 0
                             5766 ; 467  |#define HW_ICLPRIOR2R_S17P_BITPOS 3
                             5767 ; 468  |#define HW_ICLPRIOR2R_S18P_BITPOS 6
                             5768 ; 469  |#define HW_ICLPRIOR2R_S19P_BITPOS 9
                             5769 ; 470  |#define HW_ICLPRIOR2R_S20P_BITPOS 12
                             5770 ; 471  |#define HW_ICLPRIOR2R_S21P_BITPOS 15
                             5771 ; 472  |#define HW_ICLPRIOR2R_S22P_BITPOS 18
                             5772 ; 473  |#define HW_ICLPRIOR2R_S23P_BITPOS 21
                             5773 ; 474  |
                             5774 ; 475  |#define HW_ICLPRIOR2R_S16P_SETMASK 7<<HW_ICLPRIOR2R_S16P_BITPOS
                             5775 ; 476  |#define HW_ICLPRIOR2R_S17P_SETMASK 7<<HW_ICLPRIOR2R_S17P_BITPOS
                             5776 ; 477  |#define HW_ICLPRIOR2R_S18P_SETMASK 7<<HW_ICLPRIOR2R_S18P_BITPOS
                             5777 ; 478  |#define HW_ICLPRIOR2R_S19P_SETMASK 7<<HW_ICLPRIOR2R_S19P_BITPOS
                             5778 ; 479  |#define HW_ICLPRIOR2R_S20P_SETMASK 7<<HW_ICLPRIOR2R_S20P_BITPOS
                             5779 ; 480  |#define HW_ICLPRIOR2R_S21P_SETMASK 7<<HW_ICLPRIOR2R_S21P_BITPOS
                             5780 ; 481  |#define HW_ICLPRIOR2R_S22P_SETMASK 7<<HW_ICLPRIOR2R_S22P_BITPOS
                             5781 ; 482  |#define HW_ICLPRIOR2R_S23P_SETMASK 7<<HW_ICLPRIOR2R_S23P_BITPOS
                             5782 ; 483  |
                             5783 ; 484  |#define HW_ICLPRIOR2R_S16P_CLRMASK ~(WORD)HW_ICLPRIOR2R_S16P_SETMASK
                             5784 ; 485  |#define HW_ICLPRIOR2R_S17P_CLRMASK ~(WORD)HW_ICLPRIOR2R_S17P_SETMASK
                             5785 ; 486  |#define HW_ICLPRIOR2R_S18P_CLRMASK ~(WORD)HW_ICLPRIOR2R_S18P_SETMASK
                             5786 ; 487  |#define HW_ICLPRIOR2R_S19P_CLRMASK ~(WORD)HW_ICLPRIOR2R_S19P_SETMASK
                             5787 ; 488  |#define HW_ICLPRIOR2R_S20P_CLRMASK ~(WORD)HW_ICLPRIOR2R_S20P_SETMASK
                             5788 ; 489  |#define HW_ICLPRIOR2R_S21P_CLRMASK ~(WORD)HW_ICLPRIOR2R_S21P_SETMASK
                             5789 ; 490  |#define HW_ICLPRIOR2R_S22P_CLRMASK ~(WORD)HW_ICLPRIOR2R_S22P_SETMASK
                             5790 ; 491  |#define HW_ICLPRIOR2R_S23P_CLRMASK ~(WORD)HW_ICLPRIOR2R_S23P_SETMASK
                             5791 ; 492  |
                             5792 ; 493  |
                             5793 ; 494  |/////////////////////////////////////////////////////////////////////////////////
                             5794 ; 495  |//  Interrupt Collector Priority 3 Register (HW_ICLPRI3R) Bit Positions
                             5795 ; 496  |typedef union               /* Interrupt Collector Priority 3 Register      */
                             5796 ; 497  |{
                             5797 ; 498  |    struct {
                             5798 ; 499  |        unsigned S24P   :3;
                             5799 ; 500  |        unsigned S25P   :3;
                             5800 ; 501  |        unsigned S26P   :3;
                             5801 ; 502  |        unsigned S27P   :3;
                             5802 ; 503  |        unsigned S28P   :3;
                             5803 ; 504  |        unsigned S29P   :3;
                             5804 ; 505  |        unsigned S30P   :3;
                             5805 ; 506  |        unsigned S31P   :3;
                             5806 ; 507  |    } B;
                             5807 ; 508  |    int I;
                             5808 ; 509  |} iclprior3_type;
                             5809 ; 510  |#define HW_ICLPRIOR3R   (*(volatile iclprior3_type _X*) (HW_ICOLL_BASEADDR+7)) /* Interrupt Collector Register 3 Priority   */
                             5810 ; 511  |
                             5811 ; 512  |#define HW_ICLPRIOR3R_S24P_BITPOS 0
                             5812 ; 513  |#define HW_ICLPRIOR3R_S25P_BITPOS 3
                             5813 ; 514  |#define HW_ICLPRIOR3R_S26P_BITPOS 6
                             5814 ; 515  |#define HW_ICLPRIOR3R_S27P_BITPOS 9
                             5815 ; 516  |#define HW_ICLPRIOR3R_S28P_BITPOS 12
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  24

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5816 ; 517  |#define HW_ICLPRIOR3R_S29P_BITPOS 15
                             5817 ; 518  |#define HW_ICLPRIOR3R_S30P_BITPOS 18
                             5818 ; 519  |#define HW_ICLPRIOR3R_S31P_BITPOS 21
                             5819 ; 520  |
                             5820 ; 521  |#define HW_ICLPRIOR3R_S24P_SETMASK 7<<HW_ICLPRIOR3R_S24P_BITPOS
                             5821 ; 522  |#define HW_ICLPRIOR3R_S25P_SETMASK 7<<HW_ICLPRIOR3R_S25P_BITPOS
                             5822 ; 523  |#define HW_ICLPRIOR3R_S26P_SETMASK 7<<HW_ICLPRIOR3R_S26P_BITPOS
                             5823 ; 524  |#define HW_ICLPRIOR3R_S27P_SETMASK 7<<HW_ICLPRIOR3R_S27P_BITPOS
                             5824 ; 525  |#define HW_ICLPRIOR3R_S28P_SETMASK 7<<HW_ICLPRIOR3R_S28P_BITPOS
                             5825 ; 526  |#define HW_ICLPRIOR3R_S29P_SETMASK 7<<HW_ICLPRIOR3R_S29P_BITPOS
                             5826 ; 527  |#define HW_ICLPRIOR3R_S30P_SETMASK 7<<HW_ICLPRIOR3R_S30P_BITPOS
                             5827 ; 528  |#define HW_ICLPRIOR3R_S31P_SETMASK 7<<HW_ICLPRIOR3R_S31P_BITPOS
                             5828 ; 529  |
                             5829 ; 530  |#define HW_ICLPRIOR3R_S24P_CLRMASK ~(WORD)HW_ICLPRIOR3R_S24P_SETMASK
                             5830 ; 531  |#define HW_ICLPRIOR3R_S25P_CLRMASK ~(WORD)HW_ICLPRIOR3R_S25P_SETMASK
                             5831 ; 532  |#define HW_ICLPRIOR3R_S26P_CLRMASK ~(WORD)HW_ICLPRIOR3R_S26P_SETMASK
                             5832 ; 533  |#define HW_ICLPRIOR3R_S27P_CLRMASK ~(WORD)HW_ICLPRIOR3R_S27P_SETMASK
                             5833 ; 534  |#define HW_ICLPRIOR3R_S28P_CLRMASK ~(WORD)HW_ICLPRIOR3R_S28P_SETMASK
                             5834 ; 535  |#define HW_ICLPRIOR3R_S29P_CLRMASK ~(WORD)HW_ICLPRIOR3R_S29P_SETMASK
                             5835 ; 536  |#define HW_ICLPRIOR3R_S30P_CLRMASK ~(WORD)HW_ICLPRIOR3R_S30P_SETMASK
                             5836 ; 537  |#define HW_ICLPRIOR3R_S31P_CLRMASK ~(WORD)HW_ICLPRIOR3R_S31P_SETMASK
                             5837 ; 538  |
                             5838 ; 539  |
                             5839 ; 540  |/////////////////////////////////////////////////////////////////////////////////
                             5840 ; 541  |//  Interrupt Collector Priority 4 Register (HW_ICLPRI4R) Bit Positions
                             5841 ; 542  |typedef union               /* Interrupt Collector Priority 3 Register      */
                             5842 ; 543  |{
                             5843 ; 544  |    struct {
                             5844 ; 545  |        unsigned S32P   :3;
                             5845 ; 546  |        unsigned S33P   :3;
                             5846 ; 547  |    } B;
                             5847 ; 548  |    int I;
                             5848 ; 549  |} iclprior4_type;
                             5849 ; 550  |#define HW_ICLPRIOR4R (*(volatile iclprior4_type _X*) (HW_ICOLL_BASEADDR+17)) /* Interrupt Collector Register 4 Priority   */
                             5850 ; 551  |
                             5851 ; 552  |#define HW_ICLPRIOR4R_S32P_BITPOS 0
                             5852 ; 553  |#define HW_ICLPRIOR4R_S33P_BITPOS 3
                             5853 ; 554  |
                             5854 ; 555  |#define HW_ICLPRIOR4R_S32P_SETMASK 7<<HW_ICLPRIOR4R_S32P_BITPOS
                             5855 ; 556  |#define HW_ICLPRIOR4R_S33P_SETMASK 7<<HW_ICLPRIOR4R_S33P_BITPOS
                             5856 ; 557  |
                             5857 ; 558  |#define HW_ICLPRIOR4R_S32P_CLRMASK ~(WORD)HW_ICLPRIOR4R_S32P_SETMASK
                             5858 ; 559  |#define HW_ICLPRIOR4R_S33P_CLRMASK ~(WORD)HW_ICLPRIOR4R_S33P_SETMASK
                             5859 ; 560  |
                             5860 ; 561  |
                             5861 ; 562  |/////////////////////////////////////////////////////////////////////////////////
                             5862 ; 563  |//  Interrupt Collector Steering 0 Register (HW_ICLSTEER0R) Bit Positions
                             5863 ; 564  |typedef union               /* Interrupt Collector Steering 0 Register      */
                             5864 ; 565  |{
                             5865 ; 566  |    struct {
                             5866 ; 567  |        unsigned S0S    :2;
                             5867 ; 568  |        unsigned S1S    :2;
                             5868 ; 569  |        unsigned S2S    :2;
                             5869 ; 570  |        unsigned S3S    :2;
                             5870 ; 571  |        unsigned S4S    :2;
                             5871 ; 572  |        unsigned S5S    :2;
                             5872 ; 573  |        unsigned S6S    :2;
                             5873 ; 574  |        unsigned S7S    :2;
                             5874 ; 575  |        unsigned S8S    :2;
                             5875 ; 576  |        unsigned S9S    :2;
                             5876 ; 577  |        unsigned S10S   :2;
                             5877 ; 578  |        unsigned S11S   :2;
                             5878 ; 579  |    } B;
                             5879 ; 580  |    int I;
                             5880 ; 581  |} iclsteer0_type;
                             5881 ; 582  |#define HW_ICLSTEER0R   (*(volatile iclsteer0_type _X*) (HW_ICOLL_BASEADDR+8)) /* Interrupt Collector Steering Register 0   */
                             5882 ; 583  |
                             5883 ; 584  |#define HW_ICLSTEER0R_S0P_BITPOS 0
                             5884 ; 585  |#define HW_ICLSTEER0R_S1P_BITPOS 2
                             5885 ; 586  |#define HW_ICLSTEER0R_S2P_BITPOS 4
                             5886 ; 587  |#define HW_ICLSTEER0R_S3P_BITPOS 6
                             5887 ; 588  |#define HW_ICLSTEER0R_S4P_BITPOS 8
                             5888 ; 589  |#define HW_ICLSTEER0R_S5P_BITPOS 10
                             5889 ; 590  |#define HW_ICLSTEER0R_S6P_BITPOS 12
                             5890 ; 591  |#define HW_ICLSTEER0R_S7P_BITPOS 14
                             5891 ; 592  |#define HW_ICLSTEER0R_S8P_BITPOS 16
                             5892 ; 593  |#define HW_ICLSTEER0R_S9P_BITPOS 18
                             5893 ; 594  |#define HW_ICLSTEER0R_S10P_BITPOS 20
                             5894 ; 595  |#define HW_ICLSTEER0R_S11P_BITPOS 22
                             5895 ; 596  |
                             5896 ; 597  |#define HW_ICLSTEER0R_S0P_SETMASK 3<<HW_ICLSTEER0R_S0P_BITPOS
                             5897 ; 598  |#define HW_ICLSTEER0R_S1P_SETMASK 3<<HW_ICLSTEER0R_S1P_BITPOS
                             5898 ; 599  |#define HW_ICLSTEER0R_S2P_SETMASK 3<<HW_ICLSTEER0R_S2P_BITPOS
                             5899 ; 600  |#define HW_ICLSTEER0R_S3P_SETMASK 3<<HW_ICLSTEER0R_S3P_BITPOS
                             5900 ; 601  |#define HW_ICLSTEER0R_S4P_SETMASK 3<<HW_ICLSTEER0R_S4P_BITPOS
                             5901 ; 602  |#define HW_ICLSTEER0R_S5P_SETMASK 3<<HW_ICLSTEER0R_S5P_BITPOS
                             5902 ; 603  |#define HW_ICLSTEER0R_S6P_SETMASK 3<<HW_ICLSTEER0R_S6P_BITPOS
                             5903 ; 604  |#define HW_ICLSTEER0R_S7P_SETMASK 3<<HW_ICLSTEER0R_S7P_BITPOS
                             5904 ; 605  |#define HW_ICLSTEER0R_S8P_SETMASK 3<<HW_ICLSTEER0R_S8P_BITPOS
                             5905 ; 606  |#define HW_ICLSTEER0R_S9P_SETMASK 3<<HW_ICLSTEER0R_S9P_BITPOS
                             5906 ; 607  |#define HW_ICLSTEER0R_S10P_SETMASK 3<<HW_ICLSTEER0R_S10P_BITPOS
                             5907 ; 608  |#define HW_ICLSTEER0R_S11P_SETMASK 3<<HW_ICLSTEER0R_S11P_BITPOS
                             5908 ; 609  |
                             5909 ; 610  |#define HW_ICLSTEER0R_S0P_CLRMASK ~(WORD)HW_ICLSTEER0R_S0P_SETMASK
                             5910 ; 611  |#define HW_ICLSTEER0R_S1P_CLRMASK ~(WORD)HW_ICLSTEER0R_S1P_SETMASK
                             5911 ; 612  |#define HW_ICLSTEER0R_S2P_CLRMASK ~(WORD)HW_ICLSTEER0R_S2P_SETMASK
                             5912 ; 613  |#define HW_ICLSTEER0R_S3P_CLRMASK ~(WORD)HW_ICLSTEER0R_S3P_SETMASK
                             5913 ; 614  |#define HW_ICLSTEER0R_S4P_CLRMASK ~(WORD)HW_ICLSTEER0R_S4P_SETMASK
                             5914 ; 615  |#define HW_ICLSTEER0R_S5P_CLRMASK ~(WORD)HW_ICLSTEER0R_S5P_SETMASK
                             5915 ; 616  |#define HW_ICLSTEER0R_S6P_CLRMASK ~(WORD)HW_ICLSTEER0R_S6P_SETMASK
                             5916 ; 617  |#define HW_ICLSTEER0R_S7P_CLRMASK ~(WORD)HW_ICLSTEER0R_S7P_SETMASK
                             5917 ; 618  |#define HW_ICLSTEER0R_S8P_CLRMASK ~(WORD)HW_ICLSTEER0R_S8P_SETMASK
                             5918 ; 619  |#define HW_ICLSTEER0R_S9P_CLRMASK ~(WORD)HW_ICLSTEER0R_S9P_SETMASK
                             5919 ; 620  |#define HW_ICLSTEER0R_S10P_CLRMASK ~(WORD)HW_ICLSTEER0R_S10P_SETMASK
                             5920 ; 621  |#define HW_ICLSTEER0R_S11P_CLRMASK ~(WORD)HW_ICLSTEER0R_S11P_SETMASK
                             5921 ; 622  |
                             5922 ; 623  |
                             5923 ; 624  |/////////////////////////////////////////////////////////////////////////////////
                             5924 ; 625  |//  Interrupt Collector Steering 1 Register (HW_ICLSTEER1R) Bit Positions
                             5925 ; 626  |typedef union               /* Interrupt Collector Steering 1 Register      */
                             5926 ; 627  |{
                             5927 ; 628  |    struct {
                             5928 ; 629  |        unsigned S12S   :2;
                             5929 ; 630  |        unsigned S13S   :2;
                             5930 ; 631  |        unsigned S14S   :2;
                             5931 ; 632  |        unsigned S15S   :2;
                             5932 ; 633  |        unsigned S16S   :2;
                             5933 ; 634  |        unsigned S17S   :2;
                             5934 ; 635  |        unsigned S18S   :2;
                             5935 ; 636  |        unsigned S19S   :2;
                             5936 ; 637  |        unsigned S20S   :2;
                             5937 ; 638  |        unsigned S21S   :2;
                             5938 ; 639  |        unsigned S22S   :2;
                             5939 ; 640  |        unsigned S23S   :2;
                             5940 ; 641  |    } B;
                             5941 ; 642  |    int I;
                             5942 ; 643  |} iclsteer1_type;
                             5943 ; 644  |#define HW_ICLSTEER1R   (*(volatile iclsteer1_type _X*) (HW_ICOLL_BASEADDR+9)) /* Interrupt Collector Steering Register 1   */
                             5944 ; 645  |#define HW_ICLSTEER1R_S12P_BITPOS 0
                             5945 ; 646  |#define HW_ICLSTEER1R_S13P_BITPOS 2
                             5946 ; 647  |#define HW_ICLSTEER1R_S14P_BITPOS 4
                             5947 ; 648  |#define HW_ICLSTEER1R_S15P_BITPOS 6
                             5948 ; 649  |#define HW_ICLSTEER1R_S16P_BITPOS 8
                             5949 ; 650  |#define HW_ICLSTEER1R_S17P_BITPOS 10
                             5950 ; 651  |#define HW_ICLSTEER1R_S18P_BITPOS 12
                             5951 ; 652  |#define HW_ICLSTEER1R_S19P_BITPOS 14
                             5952 ; 653  |#define HW_ICLSTEER1R_S20P_BITPOS 16
                             5953 ; 654  |#define HW_ICLSTEER1R_S21P_BITPOS 18
                             5954 ; 655  |#define HW_ICLSTEER1R_S22P_BITPOS 20
                             5955 ; 656  |#define HW_ICLSTEER1R_S23P_BITPOS 22
                             5956 ; 657  |
                             5957 ; 658  |#define HW_ICLSTEER1R_S12P_SETMASK 3<<HW_ICLSTEER1R_S12P_BITPOS
                             5958 ; 659  |#define HW_ICLSTEER1R_S13P_SETMASK 3<<HW_ICLSTEER1R_S13P_BITPOS
                             5959 ; 660  |#define HW_ICLSTEER1R_S14P_SETMASK 3<<HW_ICLSTEER1R_S14P_BITPOS
                             5960 ; 661  |#define HW_ICLSTEER1R_S15P_SETMASK 3<<HW_ICLSTEER1R_S15P_BITPOS
                             5961 ; 662  |#define HW_ICLSTEER1R_S16P_SETMASK 3<<HW_ICLSTEER1R_S16P_BITPOS
                             5962 ; 663  |#define HW_ICLSTEER1R_S17P_SETMASK 3<<HW_ICLSTEER1R_S17P_BITPOS
                             5963 ; 664  |#define HW_ICLSTEER1R_S18P_SETMASK 3<<HW_ICLSTEER1R_S18P_BITPOS
                             5964 ; 665  |#define HW_ICLSTEER1R_S19P_SETMASK 3<<HW_ICLSTEER1R_S19P_BITPOS
                             5965 ; 666  |#define HW_ICLSTEER1R_S20P_SETMASK 3<<HW_ICLSTEER1R_S20P_BITPOS
                             5966 ; 667  |#define HW_ICLSTEER1R_S21P_SETMASK 3<<HW_ICLSTEER1R_S21P_BITPOS
                             5967 ; 668  |#define HW_ICLSTEER1R_S22P_SETMASK 3<<HW_ICLSTEER1R_S22P_BITPOS
                             5968 ; 669  |#define HW_ICLSTEER1R_S23P_SETMASK 3<<HW_ICLSTEER1R_S23P_BITPOS
                             5969 ; 670  |
                             5970 ; 671  |#define HW_ICLSTEER1R_S12P_CLRMASK ~(WORD)HW_ICLSTEER1R_S12P_SETMASK
                             5971 ; 672  |#define HW_ICLSTEER1R_S13P_CLRMASK ~(WORD)HW_ICLSTEER1R_S13P_SETMASK
                             5972 ; 673  |#define HW_ICLSTEER1R_S14P_CLRMASK ~(WORD)HW_ICLSTEER1R_S14P_SETMASK
                             5973 ; 674  |#define HW_ICLSTEER1R_S15P_CLRMASK ~(WORD)HW_ICLSTEER1R_S15P_SETMASK
                             5974 ; 675  |#define HW_ICLSTEER1R_S16P_CLRMASK ~(WORD)HW_ICLSTEER1R_S16P_SETMASK
                             5975 ; 676  |#define HW_ICLSTEER1R_S17P_CLRMASK ~(WORD)HW_ICLSTEER1R_S17P_SETMASK
                             5976 ; 677  |#define HW_ICLSTEER1R_S18P_CLRMASK ~(WORD)HW_ICLSTEER1R_S18P_SETMASK
                             5977 ; 678  |#define HW_ICLSTEER1R_S19P_CLRMASK ~(WORD)HW_ICLSTEER1R_S19P_SETMASK
                             5978 ; 679  |#define HW_ICLSTEER1R_S20P_CLRMASK ~(WORD)HW_ICLSTEER1R_S20P_SETMASK
                             5979 ; 680  |#define HW_ICLSTEER1R_S21P_CLRMASK ~(WORD)HW_ICLSTEER1R_S21P_SETMASK
                             5980 ; 681  |#define HW_ICLSTEER1R_S22P_CLRMASK ~(WORD)HW_ICLSTEER1R_S22P_SETMASK
                             5981 ; 682  |#define HW_ICLSTEER1R_S23P_CLRMASK ~(WORD)HW_ICLSTEER1R_S23P_SETMASK
                             5982 ; 683  |
                             5983 ; 684  |
                             5984 ; 685  |/////////////////////////////////////////////////////////////////////////////////
                             5985 ; 686  |//  Interrupt Collector Steering 2 Register (HW_ICLSTEER2R) Bit Positions
                             5986 ; 687  |typedef union               /* Interrupt Collector Steering 2 Register      */
                             5987 ; 688  |{
                             5988 ; 689  |    struct {
                             5989 ; 690  |        unsigned S24S   :2;
                             5990 ; 691  |        unsigned S25S   :2;
                             5991 ; 692  |        unsigned S26S   :2;
                             5992 ; 693  |        unsigned S27S   :2;
                             5993 ; 694  |        unsigned S28S   :2;
                             5994 ; 695  |        unsigned S29S   :2;
                             5995 ; 696  |        unsigned S30S   :2;
                             5996 ; 697  |        unsigned S31S   :2;
                             5997 ; 698  |        unsigned S32S   :2;
                             5998 ; 699  |        unsigned S33S   :2;
                             5999 ; 700  |    } B;
                             6000 ; 701  |    int I;
                             6001 ; 702  |} iclsteer2_type;
                             6002 ; 703  |#define HW_ICLSTEER2R   (*(volatile iclsteer2_type _X*) (HW_ICOLL_BASEADDR+10)) /* Interrupt Collector Steering Register 2  */
                             6003 ; 704  |
                             6004 ; 705  |#define HW_ICLSTEER2R_S24P_BITPOS 0
                             6005 ; 706  |#define HW_ICLSTEER2R_S25P_BITPOS 2
                             6006 ; 707  |#define HW_ICLSTEER2R_S26P_BITPOS 4
                             6007 ; 708  |#define HW_ICLSTEER2R_S27P_BITPOS 6
                             6008 ; 709  |#define HW_ICLSTEER2R_S28P_BITPOS 8
                             6009 ; 710  |#define HW_ICLSTEER2R_S29P_BITPOS 10
                             6010 ; 711  |#define HW_ICLSTEER2R_S30P_BITPOS 12
                             6011 ; 712  |#define HW_ICLSTEER2R_S31P_BITPOS 14
                             6012 ; 713  |#define HW_ICLSTEER2R_S32P_BITPOS 16
                             6013 ; 714  |#define HW_ICLSTEER2R_S33P_BITPOS 18
                             6014 ; 715  |
                             6015 ; 716  |#define HW_ICLSTEER2R_S24P_SETMASK 3<<HW_ICLSTEER2R_S24P_BITPOS
                             6016 ; 717  |#define HW_ICLSTEER2R_S25P_SETMASK 3<<HW_ICLSTEER2R_S25P_BITPOS
                             6017 ; 718  |#define HW_ICLSTEER2R_S26P_SETMASK 3<<HW_ICLSTEER2R_S26P_BITPOS
                             6018 ; 719  |#define HW_ICLSTEER2R_S27P_SETMASK 3<<HW_ICLSTEER2R_S27P_BITPOS
                             6019 ; 720  |#define HW_ICLSTEER2R_S28P_SETMASK 3<<HW_ICLSTEER2R_S28P_BITPOS
                             6020 ; 721  |#define HW_ICLSTEER2R_S29P_SETMASK 3<<HW_ICLSTEER2R_S29P_BITPOS
                             6021 ; 722  |#define HW_ICLSTEER2R_S30P_SETMASK 3<<HW_ICLSTEER2R_S30P_BITPOS
                             6022 ; 723  |#define HW_ICLSTEER2R_S31P_SETMASK 3<<HW_ICLSTEER2R_S31P_BITPOS
                             6023 ; 724  |#define HW_ICLSTEER2R_S32P_SETMASK 3<<HW_ICLSTEER2R_S32P_BITPOS
                             6024 ; 725  |#define HW_ICLSTEER2R_S33P_SETMASK 3<<HW_ICLSTEER2R_S33P_BITPOS
                             6025 ; 726  |
                             6026 ; 727  |#define HW_ICLSTEER2R_S24P_CLRMASK ~(WORD)HW_ICLSTEER2R_S24P_SETMASK
                             6027 ; 728  |#define HW_ICLSTEER2R_S25P_CLRMASK ~(WORD)HW_ICLSTEER2R_S25P_SETMASK
                             6028 ; 729  |#define HW_ICLSTEER2R_S26P_CLRMASK ~(WORD)HW_ICLSTEER2R_S26P_SETMASK
                             6029 ; 730  |#define HW_ICLSTEER2R_S27P_CLRMASK ~(WORD)HW_ICLSTEER2R_S27P_SETMASK
                             6030 ; 731  |#define HW_ICLSTEER2R_S28P_CLRMASK ~(WORD)HW_ICLSTEER2R_S28P_SETMASK
                             6031 ; 732  |#define HW_ICLSTEER2R_S29P_CLRMASK ~(WORD)HW_ICLSTEER2R_S29P_SETMASK
                             6032 ; 733  |#define HW_ICLSTEER2R_S30P_CLRMASK ~(WORD)HW_ICLSTEER2R_S30P_SETMASK
                             6033 ; 734  |#define HW_ICLSTEER2R_S31P_CLRMASK ~(WORD)HW_ICLSTEER2R_S31P_SETMASK
                             6034 ; 735  |#define HW_ICLSTEER2R_S32P_CLRMASK ~(WORD)HW_ICLSTEER2R_S32P_SETMASK
                             6035 ; 736  |#define HW_ICLSTEER2R_S33P_CLRMASK ~(WORD)HW_ICLSTEER2R_S33P_SETMASK
                             6036 ; 737  |
                             6037 ; 738  |
                             6038 ; 739  |/////////////////////////////////////////////////////////////////////////////////
                             6039 ; 740  |//  Interrupt Collector Debug Force 0 Register (HW_ICLFORCE0R) Bit Positions
                             6040 ; 741  |typedef union               /* Interrupt Collector Debug Force 0 Register       */
                             6041 ; 742  |{
                             6042 ; 743  |    struct {
                             6043 ; 744  |        int S0FV        :1;
                             6044 ; 745  |        int S1FV        :1;
                             6045 ; 746  |        int S2FV        :1;
                             6046 ; 747  |        int S3FV        :1;
                             6047 ; 748  |        int S4FV        :1;
                             6048 ; 749  |        int S5FV        :1;
                             6049 ; 750  |        int S6FV        :1;
                             6050 ; 751  |        int S7FV        :1;
                             6051 ; 752  |        int S8FV        :1;
                             6052 ; 753  |        int S9FV        :1;
                             6053 ; 754  |        int S10FV       :1;
                             6054 ; 755  |        int S11FV       :1;
                             6055 ; 756  |        int S12FV       :1;
                             6056 ; 757  |        int S13FV       :1;
                             6057 ; 758  |        int S14FV       :1;
                             6058 ; 759  |        int S15FV       :1;
                             6059 ; 760  |        int S16FV       :1;
                             6060 ; 761  |        int S17FV       :1;
                             6061 ; 762  |        int S18FV       :1;
                             6062 ; 763  |        int S19FV       :1;
                             6063 ; 764  |        int S20FV       :1;
                             6064 ; 765  |        int S21FV       :1;
                             6065 ; 766  |        int S22FV       :1;
                             6066 ; 767  |        int S23FV       :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  25

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6067 ; 768  |    } B;
                             6068 ; 769  |    int I;
                             6069 ; 770  |} iclforce0_type;
                             6070 ; 771  |#define HW_ICLFORCE0R   (*(volatile iclforce0_type _X*) (HW_ICOLL_BASEADDR+11)) /* Interrupt Collector Debug Force Register 0   */
                             6071 ; 772  |#define HW_ICLFORCE0R_S0FV_BITPOS 0
                             6072 ; 773  |#define HW_ICLFORCE0R_S1FV_BITPOS 1
                             6073 ; 774  |#define HW_ICLFORCE0R_S2FV_BITPOS 2
                             6074 ; 775  |#define HW_ICLFORCE0R_S3FV_BITPOS 3
                             6075 ; 776  |#define HW_ICLFORCE0R_S4FV_BITPOS 4
                             6076 ; 777  |#define HW_ICLFORCE0R_S5FV_BITPOS 5
                             6077 ; 778  |#define HW_ICLFORCE0R_S6FV_BITPOS 6
                             6078 ; 779  |#define HW_ICLFORCE0R_S7FV_BITPOS 7
                             6079 ; 780  |#define HW_ICLFORCE0R_S8FV_BITPOS 8
                             6080 ; 781  |#define HW_ICLFORCE0R_S9FV_BITPOS 9
                             6081 ; 782  |#define HW_ICLFORCE0R_S10FV_BITPOS 10
                             6082 ; 783  |#define HW_ICLFORCE0R_S11FV_BITPOS 11
                             6083 ; 784  |#define HW_ICLFORCE0R_S12FV_BITPOS 12
                             6084 ; 785  |#define HW_ICLFORCE0R_S13FV_BITPOS 13
                             6085 ; 786  |#define HW_ICLFORCE0R_S14FV_BITPOS 14
                             6086 ; 787  |#define HW_ICLFORCE0R_S15FV_BITPOS 15
                             6087 ; 788  |#define HW_ICLFORCE0R_S16FV_BITPOS 16
                             6088 ; 789  |#define HW_ICLFORCE0R_S17FV_BITPOS 17
                             6089 ; 790  |#define HW_ICLFORCE0R_S18FV_BITPOS 18
                             6090 ; 791  |#define HW_ICLFORCE0R_S19FV_BITPOS 19
                             6091 ; 792  |#define HW_ICLFORCE0R_S20FV_BITPOS 20
                             6092 ; 793  |#define HW_ICLFORCE0R_S21FV_BITPOS 21
                             6093 ; 794  |#define HW_ICLFORCE0R_S22FV_BITPOS 22
                             6094 ; 795  |#define HW_ICLFORCE0R_S23FV_BITPOS 23
                             6095 ; 796  |
                             6096 ; 797  |#define HW_ICLFORCE0R_S0FV_SETMASK 1<<HW_ICLFORCE0R_S0FV_BITPOS
                             6097 ; 798  |#define HW_ICLFORCE0R_S1FV_SETMASK 1<<HW_ICLFORCE0R_S1FV_BITPOS
                             6098 ; 799  |#define HW_ICLFORCE0R_S2FV_SETMASK 1<<HW_ICLFORCE0R_S2FV_BITPOS
                             6099 ; 800  |#define HW_ICLFORCE0R_S3FV_SETMASK 1<<HW_ICLFORCE0R_S3FV_BITPOS
                             6100 ; 801  |#define HW_ICLFORCE0R_S4FV_SETMASK 1<<HW_ICLFORCE0R_S4FV_BITPOS
                             6101 ; 802  |#define HW_ICLFORCE0R_S5FV_SETMASK 1<<HW_ICLFORCE0R_S5FV_BITPOS
                             6102 ; 803  |#define HW_ICLFORCE0R_S6FV_SETMASK 1<<HW_ICLFORCE0R_S6FV_BITPOS
                             6103 ; 804  |#define HW_ICLFORCE0R_S7FV_SETMASK 1<<HW_ICLFORCE0R_S7FV_BITPOS
                             6104 ; 805  |#define HW_ICLFORCE0R_S8FV_SETMASK 1<<HW_ICLFORCE0R_S8FV_BITPOS
                             6105 ; 806  |#define HW_ICLFORCE0R_S9FV_SETMASK 1<<HW_ICLFORCE0R_S9FV_BITPOS
                             6106 ; 807  |#define HW_ICLFORCE0R_S10FV_SETMASK 1<<HW_ICLFORCE0R_S10FV_BITPOS
                             6107 ; 808  |#define HW_ICLFORCE0R_S11FV_SETMASK 1<<HW_ICLFORCE0R_S11FV_BITPOS
                             6108 ; 809  |#define HW_ICLFORCE0R_S12FV_SETMASK 1<<HW_ICLFORCE0R_S12FV_BITPOS
                             6109 ; 810  |#define HW_ICLFORCE0R_S13FV_SETMASK 1<<HW_ICLFORCE0R_S13FV_BITPOS
                             6110 ; 811  |#define HW_ICLFORCE0R_S14FV_SETMASK 1<<HW_ICLFORCE0R_S14FV_BITPOS
                             6111 ; 812  |#define HW_ICLFORCE0R_S15FV_SETMASK 1<<HW_ICLFORCE0R_S15FV_BITPOS
                             6112 ; 813  |#define HW_ICLFORCE0R_S16FV_SETMASK 1<<HW_ICLFORCE0R_S16FV_BITPOS
                             6113 ; 814  |#define HW_ICLFORCE0R_S17FV_SETMASK 1<<HW_ICLFORCE0R_S17FV_BITPOS
                             6114 ; 815  |#define HW_ICLFORCE0R_S18FV_SETMASK 1<<HW_ICLFORCE0R_S18FV_BITPOS
                             6115 ; 816  |#define HW_ICLFORCE0R_S19FV_SETMASK 1<<HW_ICLFORCE0R_S19FV_BITPOS
                             6116 ; 817  |#define HW_ICLFORCE0R_S20FV_SETMASK 1<<HW_ICLFORCE0R_S20FV_BITPOS
                             6117 ; 818  |#define HW_ICLFORCE0R_S21FV_SETMASK 1<<HW_ICLFORCE0R_S21FV_BITPOS
                             6118 ; 819  |#define HW_ICLFORCE0R_S22FV_SETMASK 1<<HW_ICLFORCE0R_S22FV_BITPOS
                             6119 ; 820  |#define HW_ICLFORCE0R_S23FV_SETMASK 1<<HW_ICLFORCE0R_S23FV_BITPOS
                             6120 ; 821  |
                             6121 ; 822  |#define HW_ICLFORCE0R_S0FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S0FV_SETMASK
                             6122 ; 823  |#define HW_ICLFORCE0R_S1FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S1FV_SETMASK
                             6123 ; 824  |#define HW_ICLFORCE0R_S2FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S2FV_SETMASK
                             6124 ; 825  |#define HW_ICLFORCE0R_S3FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S3FV_SETMASK
                             6125 ; 826  |#define HW_ICLFORCE0R_S4FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S4FV_SETMASK
                             6126 ; 827  |#define HW_ICLFORCE0R_S5FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S5FV_SETMASK
                             6127 ; 828  |#define HW_ICLFORCE0R_S6FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S6FV_SETMASK
                             6128 ; 829  |#define HW_ICLFORCE0R_S7FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S7FV_SETMASK
                             6129 ; 830  |#define HW_ICLFORCE0R_S8FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S8FV_SETMASK
                             6130 ; 831  |#define HW_ICLFORCE0R_S9FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S9FV_SETMASK
                             6131 ; 832  |#define HW_ICLFORCE0R_S10FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S10FV_SETMASK
                             6132 ; 833  |#define HW_ICLFORCE0R_S11FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S11FV_SETMASK
                             6133 ; 834  |#define HW_ICLFORCE0R_S12FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S12FV_SETMASK
                             6134 ; 835  |#define HW_ICLFORCE0R_S13FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S13FV_SETMASK
                             6135 ; 836  |#define HW_ICLFORCE0R_S14FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S14FV_SETMASK
                             6136 ; 837  |#define HW_ICLFORCE0R_S15FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S15FV_SETMASK
                             6137 ; 838  |#define HW_ICLFORCE0R_S16FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S16FV_SETMASK
                             6138 ; 839  |#define HW_ICLFORCE0R_S17FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S17FV_SETMASK
                             6139 ; 840  |#define HW_ICLFORCE0R_S18FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S18FV_SETMASK
                             6140 ; 841  |#define HW_ICLFORCE0R_S19FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S19FV_SETMASK
                             6141 ; 842  |#define HW_ICLFORCE0R_S20FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S20FV_SETMASK
                             6142 ; 843  |#define HW_ICLFORCE0R_S21FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S21FV_SETMASK
                             6143 ; 844  |#define HW_ICLFORCE0R_S22FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S22FV_SETMASK
                             6144 ; 845  |#define HW_ICLFORCE0R_S23FV_CLRMASK ~(WORD)HW_ICLFORCE0R_S23FV_SETMASK
                             6145 ; 846  |
                             6146 ; 847  |
                             6147 ; 848  |/////////////////////////////////////////////////////////////////////////////////
                             6148 ; 849  |//  Interrupt Collector Debug Force 1 Register (HW_ICLFORCE1R) Bit Positions
                             6149 ; 850  |typedef union               /* Interrupt Debug Force 1 Register     */
                             6150 ; 851  |{
                             6151 ; 852  |    struct {
                             6152 ; 853  |        int S24FV       :1;
                             6153 ; 854  |        int S25FV       :1;
                             6154 ; 855  |        int S26FV       :1;
                             6155 ; 856  |        int S27FV       :1;
                             6156 ; 857  |        int S28FV       :1;
                             6157 ; 858  |        int S29FV       :1;
                             6158 ; 859  |        int S30FV       :1;
                             6159 ; 860  |        int S31FV       :1;
                             6160 ; 861  |        int S32FV       :1;
                             6161 ; 862  |        int S33FV       :1;
                             6162 ; 863  |    } B;
                             6163 ; 864  |    int I;
                             6164 ; 865  |} iclforce1_type;
                             6165 ; 866  |#define HW_ICLFORCE1R   (*(volatile iclforce1_type _X*) (HW_ICOLL_BASEADDR+12)) /* Interrupt Collector Debug Force Register 1   */
                             6166 ; 867  |
                             6167 ; 868  |#define HW_ICLFORCE1R_S24FV_BITPOS 0
                             6168 ; 869  |#define HW_ICLFORCE1R_S25FV_BITPOS 1
                             6169 ; 870  |#define HW_ICLFORCE1R_S26FV_BITPOS 2
                             6170 ; 871  |#define HW_ICLFORCE1R_S27FV_BITPOS 3
                             6171 ; 872  |#define HW_ICLFORCE1R_S28FV_BITPOS 4
                             6172 ; 873  |#define HW_ICLFORCE1R_S29FV_BITPOS 5
                             6173 ; 874  |#define HW_ICLFORCE1R_S30FV_BITPOS 6
                             6174 ; 875  |#define HW_ICLFORCE1R_S31FV_BITPOS 7
                             6175 ; 876  |#define HW_ICLFORCE1R_S32FV_BITPOS 8
                             6176 ; 877  |#define HW_ICLFORCE1R_S33FV_BITPOS 9
                             6177 ; 878  |
                             6178 ; 879  |#define HW_ICLFORCE1R_S24FV_SETMASK 1<<HW_ICLFORCE1R_S24FV_BITPOS
                             6179 ; 880  |#define HW_ICLFORCE1R_S25FV_SETMASK 1<<HW_ICLFORCE1R_S25FV_BITPOS
                             6180 ; 881  |#define HW_ICLFORCE1R_S26FV_SETMASK 1<<HW_ICLFORCE1R_S26FV_BITPOS
                             6181 ; 882  |#define HW_ICLFORCE1R_S27FV_SETMASK 1<<HW_ICLFORCE1R_S27FV_BITPOS
                             6182 ; 883  |#define HW_ICLFORCE1R_S28FV_SETMASK 1<<HW_ICLFORCE1R_S28FV_BITPOS
                             6183 ; 884  |#define HW_ICLFORCE1R_S29FV_SETMASK 1<<HW_ICLFORCE1R_S29FV_BITPOS
                             6184 ; 885  |#define HW_ICLFORCE1R_S30FV_SETMASK 1<<HW_ICLFORCE1R_S30FV_BITPOS
                             6185 ; 886  |#define HW_ICLFORCE1R_S31FV_SETMASK 1<<HW_ICLFORCE1R_S31FV_BITPOS
                             6186 ; 887  |#define HW_ICLFORCE1R_S32FV_SETMASK 1<<HW_ICLFORCE1R_S32FV_BITPOS
                             6187 ; 888  |#define HW_ICLFORCE1R_S33FV_SETMASK 1<<HW_ICLFORCE1R_S33FV_BITPOS
                             6188 ; 889  |
                             6189 ; 890  |#define HW_ICLFORCE1R_S24FV_CLRMASK ~(WORD)HW_ICLFORCE1R_S24FV_SETMASK
                             6190 ; 891  |#define HW_ICLFORCE1R_S25FV_CLRMASK ~(WORD)HW_ICLFORCE1R_S25FV_SETMASK
                             6191 ; 892  |#define HW_ICLFORCE1R_S26FV_CLRMASK ~(WORD)HW_ICLFORCE1R_S26FV_SETMASK
                             6192 ; 893  |#define HW_ICLFORCE1R_S27FV_CLRMASK ~(WORD)HW_ICLFORCE1R_S27FV_SETMASK
                             6193 ; 894  |#define HW_ICLFORCE1R_S28FV_CLRMASK ~(WORD)HW_ICLFORCE1R_S28FV_SETMASK
                             6194 ; 895  |#define HW_ICLFORCE1R_S29FV_CLRMASK ~(WORD)HW_ICLFORCE1R_S29FV_SETMASK
                             6195 ; 896  |#define HW_ICLFORCE1R_S30FV_CLRMASK ~(WORD)HW_ICLFORCE1R_S30FV_SETMASK
                             6196 ; 897  |#define HW_ICLFORCE1R_S31FV_CLRMASK ~(WORD)HW_ICLFORCE1R_S31FV_SETMASK
                             6197 ; 898  |#define HW_ICLFORCE1R_S32FV_CLRMASK ~(WORD)HW_ICLFORCE1R_S32FV_SETMASK
                             6198 ; 899  |#define HW_ICLFORCE1R_S33FV_CLRMASK ~(WORD)HW_ICLFORCE1R_S33FV_SETMASK
                             6199 ; 900  |
                             6200 ; 901  |
                             6201 ; 902  |/////////////////////////////////////////////////////////////////////////////////
                             6202 ; 903  |//  Interrupt Collector Force Enable 0 Register (HW_ICLFENABLE0R) Bit Positions
                             6203 ; 904  |typedef union               /* Interrupt Collector Force Enable 0 Register      */
                             6204 ; 905  |{
                             6205 ; 906  |    struct {
                             6206 ; 907  |        int S0FE        :1;
                             6207 ; 908  |        int S1FE        :1;
                             6208 ; 909  |        int S2FE        :1;
                             6209 ; 910  |        int S3FE        :1;
                             6210 ; 911  |        int S4FE        :1;
                             6211 ; 912  |        int S5FE        :1;
                             6212 ; 913  |        int S6FE        :1;
                             6213 ; 914  |        int S7FE        :1;
                             6214 ; 915  |        int S8FE        :1;
                             6215 ; 916  |        int S9FE        :1;
                             6216 ; 917  |        int S10FE       :1;
                             6217 ; 918  |        int S11FE       :1;
                             6218 ; 919  |        int S12FE       :1;
                             6219 ; 920  |        int S13FE       :1;
                             6220 ; 921  |        int S14FE       :1;
                             6221 ; 922  |        int S15FE       :1;
                             6222 ; 923  |        int S16FE       :1;
                             6223 ; 924  |        int S17FE       :1;
                             6224 ; 925  |        int S18FE       :1;
                             6225 ; 926  |        int S19FE       :1;
                             6226 ; 927  |        int S20FE       :1;
                             6227 ; 928  |        int S21FE       :1;
                             6228 ; 929  |        int S22FE       :1;
                             6229 ; 930  |        int S23FE       :1;
                             6230 ; 931  |    } B;
                             6231 ; 932  |    int I;
                             6232 ; 933  |} iclfenable0_type;
                             6233 ; 934  |#define HW_ICLFENABLE0R (*(volatile iclfenable0_type _X*) (HW_ICOLL_BASEADDR+13)) /* Interrupt Collector Force Enable Register 0    */
                             6234 ; 935  |
                             6235 ; 936  |#define HW_ICLFENABLE0R_S0FE_BITPOS 0
                             6236 ; 937  |#define HW_ICLFENABLE0R_S1FE_BITPOS 1
                             6237 ; 938  |#define HW_ICLFENABLE0R_S2FE_BITPOS 2
                             6238 ; 939  |#define HW_ICLFENABLE0R_S3FE_BITPOS 3
                             6239 ; 940  |#define HW_ICLFENABLE0R_S4FE_BITPOS 4
                             6240 ; 941  |#define HW_ICLFENABLE0R_S5FE_BITPOS 5
                             6241 ; 942  |#define HW_ICLFENABLE0R_S6FE_BITPOS 6
                             6242 ; 943  |#define HW_ICLFENABLE0R_S7FE_BITPOS 7
                             6243 ; 944  |#define HW_ICLFENABLE0R_S8FE_BITPOS 8
                             6244 ; 945  |#define HW_ICLFENABLE0R_S9FE_BITPOS 9
                             6245 ; 946  |#define HW_ICLFENABLE0R_S10FE_BITPOS 10
                             6246 ; 947  |#define HW_ICLFENABLE0R_S11FE_BITPOS 11
                             6247 ; 948  |#define HW_ICLFENABLE0R_S12FE_BITPOS 12
                             6248 ; 949  |#define HW_ICLFENABLE0R_S13FE_BITPOS 13
                             6249 ; 950  |#define HW_ICLFENABLE0R_S14FE_BITPOS 14
                             6250 ; 951  |#define HW_ICLFENABLE0R_S15FE_BITPOS 15
                             6251 ; 952  |#define HW_ICLFENABLE0R_S16FE_BITPOS 16
                             6252 ; 953  |#define HW_ICLFENABLE0R_S17FE_BITPOS 17
                             6253 ; 954  |#define HW_ICLFENABLE0R_S18FE_BITPOS 18
                             6254 ; 955  |#define HW_ICLFENABLE0R_S19FE_BITPOS 19
                             6255 ; 956  |#define HW_ICLFENABLE0R_S20FE_BITPOS 20
                             6256 ; 957  |#define HW_ICLFENABLE0R_S21FE_BITPOS 21
                             6257 ; 958  |#define HW_ICLFENABLE0R_S22FE_BITPOS 22
                             6258 ; 959  |#define HW_ICLFENABLE0R_S23FE_BITPOS 23
                             6259 ; 960  |
                             6260 ; 961  |#define HW_ICLFENABLE0R_S0FE_SETMASK 1<<HW_ICLFENABLE0R_S0FE_BITPOS
                             6261 ; 962  |#define HW_ICLFENABLE0R_S1FE_SETMASK 1<<HW_ICLFENABLE0R_S1FE_BITPOS
                             6262 ; 963  |#define HW_ICLFENABLE0R_S2FE_SETMASK 1<<HW_ICLFENABLE0R_S2FE_BITPOS
                             6263 ; 964  |#define HW_ICLFENABLE0R_S3FE_SETMASK 1<<HW_ICLFENABLE0R_S3FE_BITPOS
                             6264 ; 965  |#define HW_ICLFENABLE0R_S4FE_SETMASK 1<<HW_ICLFENABLE0R_S4FE_BITPOS
                             6265 ; 966  |#define HW_ICLFENABLE0R_S5FE_SETMASK 1<<HW_ICLFENABLE0R_S5FE_BITPOS
                             6266 ; 967  |#define HW_ICLFENABLE0R_S6FE_SETMASK 1<<HW_ICLFENABLE0R_S6FE_BITPOS
                             6267 ; 968  |#define HW_ICLFENABLE0R_S7FE_SETMASK 1<<HW_ICLFENABLE0R_S7FE_BITPOS
                             6268 ; 969  |#define HW_ICLFENABLE0R_S8FE_SETMASK 1<<HW_ICLFENABLE0R_S8FE_BITPOS
                             6269 ; 970  |#define HW_ICLFENABLE0R_S9FE_SETMASK 1<<HW_ICLFENABLE0R_S9FE_BITPOS
                             6270 ; 971  |#define HW_ICLFENABLE0R_S10FE_SETMASK 1<<HW_ICLFENABLE0R_S10FE_BITPOS
                             6271 ; 972  |#define HW_ICLFENABLE0R_S11FE_SETMASK 1<<HW_ICLFENABLE0R_S11FE_BITPOS
                             6272 ; 973  |#define HW_ICLFENABLE0R_S12FE_SETMASK 1<<HW_ICLFENABLE0R_S12FE_BITPOS
                             6273 ; 974  |#define HW_ICLFENABLE0R_S13FE_SETMASK 1<<HW_ICLFENABLE0R_S13FE_BITPOS
                             6274 ; 975  |#define HW_ICLFENABLE0R_S14FE_SETMASK 1<<HW_ICLFENABLE0R_S14FE_BITPOS
                             6275 ; 976  |#define HW_ICLFENABLE0R_S15FE_SETMASK 1<<HW_ICLFENABLE0R_S15FE_BITPOS
                             6276 ; 977  |#define HW_ICLFENABLE0R_S16FE_SETMASK 1<<HW_ICLFENABLE0R_S16FE_BITPOS
                             6277 ; 978  |#define HW_ICLFENABLE0R_S17FE_SETMASK 1<<HW_ICLFENABLE0R_S17FE_BITPOS
                             6278 ; 979  |#define HW_ICLFENABLE0R_S18FE_SETMASK 1<<HW_ICLFENABLE0R_S18FE_BITPOS
                             6279 ; 980  |#define HW_ICLFENABLE0R_S19FE_SETMASK 1<<HW_ICLFENABLE0R_S19FE_BITPOS
                             6280 ; 981  |#define HW_ICLFENABLE0R_S20FE_SETMASK 1<<HW_ICLFENABLE0R_S20FE_BITPOS
                             6281 ; 982  |#define HW_ICLFENABLE0R_S21FE_SETMASK 1<<HW_ICLFENABLE0R_S21FE_BITPOS
                             6282 ; 983  |#define HW_ICLFENABLE0R_S22FE_SETMASK 1<<HW_ICLFENABLE0R_S22FE_BITPOS
                             6283 ; 984  |#define HW_ICLFENABLE0R_S23FE_SETMASK 1<<HW_ICLFENABLE0R_S23FE_BITPOS
                             6284 ; 985  |
                             6285 ; 986  |#define HW_ICLFENABLE0R_S0FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S0FE_SETMASK
                             6286 ; 987  |#define HW_ICLFENABLE0R_S1FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S1FE_SETMASK
                             6287 ; 988  |#define HW_ICLFENABLE0R_S2FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S2FE_SETMASK
                             6288 ; 989  |#define HW_ICLFENABLE0R_S3FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S3FE_SETMASK
                             6289 ; 990  |#define HW_ICLFENABLE0R_S4FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S4FE_SETMASK
                             6290 ; 991  |#define HW_ICLFENABLE0R_S5FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S5FE_SETMASK
                             6291 ; 992  |#define HW_ICLFENABLE0R_S6FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S6FE_SETMASK
                             6292 ; 993  |#define HW_ICLFENABLE0R_S7FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S7FE_SETMASK
                             6293 ; 994  |#define HW_ICLFENABLE0R_S8FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S8FE_SETMASK
                             6294 ; 995  |#define HW_ICLFENABLE0R_S9FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S9FE_SETMASK
                             6295 ; 996  |#define HW_ICLFENABLE0R_S10FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S10FE_SETMASK
                             6296 ; 997  |#define HW_ICLFENABLE0R_S11FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S11FE_SETMASK
                             6297 ; 998  |#define HW_ICLFENABLE0R_S12FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S12FE_SETMASK
                             6298 ; 999  |#define HW_ICLFENABLE0R_S13FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S13FE_SETMASK
                             6299 ; 1000 |#define HW_ICLFENABLE0R_S14FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S14FE_SETMASK
                             6300 ; 1001 |#define HW_ICLFENABLE0R_S15FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S15FE_SETMASK
                             6301 ; 1002 |#define HW_ICLFENABLE0R_S16FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S16FE_SETMASK
                             6302 ; 1003 |#define HW_ICLFENABLE0R_S17FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S17FE_SETMASK
                             6303 ; 1004 |#define HW_ICLFENABLE0R_S18FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S18FE_SETMASK
                             6304 ; 1005 |#define HW_ICLFENABLE0R_S19FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S19FE_SETMASK
                             6305 ; 1006 |#define HW_ICLFENABLE0R_S20FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S20FE_SETMASK
                             6306 ; 1007 |#define HW_ICLFENABLE0R_S21FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S21FE_SETMASK
                             6307 ; 1008 |#define HW_ICLFENABLE0R_S22FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S22FE_SETMASK
                             6308 ; 1009 |#define HW_ICLFENABLE0R_S23FE_CLRMASK ~(WORD)HW_ICLFENABLE0R_S23FE_SETMASK
                             6309 ; 1010 |
                             6310 ; 1011 |
                             6311 ; 1012 |/////////////////////////////////////////////////////////////////////////////////
                             6312 ; 1013 |//  Interrupt Collector Force Enable 1 Register (HW_ICLFENABLE1R) Bit Positions
                             6313 ; 1014 |typedef union               /* Interrupt Collector Force Enable 1 Register      */
                             6314 ; 1015 |{
                             6315 ; 1016 |    struct {
                             6316 ; 1017 |        int S24FE       :1;
                             6317 ; 1018 |        int S25FE       :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  26

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6318 ; 1019 |        int S26FE       :1;
                             6319 ; 1020 |        int S27FE       :1;
                             6320 ; 1021 |        int S28FE       :1;
                             6321 ; 1022 |        int S29FE       :1;
                             6322 ; 1023 |        int S30FE       :1;
                             6323 ; 1024 |        int S31FE       :1;
                             6324 ; 1025 |        int S32FE       :1;
                             6325 ; 1026 |        int S33FE       :1;
                             6326 ; 1027 |    } B;
                             6327 ; 1028 |    int I;
                             6328 ; 1029 |} iclfenable1_type;
                             6329 ; 1030 |#define HW_ICLFENABLE1R (*(volatile iclfenable1_type _X*) (HW_ICOLL_BASEADDR+14)) /* Interrupt Collector Force Enable Register 1    */
                             6330 ; 1031 |#define HW_ICLFENABLE1R_S24FE_BITPOS 0
                             6331 ; 1032 |#define HW_ICLFENABLE1R_S25FE_BITPOS 1
                             6332 ; 1033 |#define HW_ICLFENABLE1R_S26FE_BITPOS 2
                             6333 ; 1034 |#define HW_ICLFENABLE1R_S27FE_BITPOS 3
                             6334 ; 1035 |#define HW_ICLFENABLE1R_S28FE_BITPOS 4
                             6335 ; 1036 |#define HW_ICLFENABLE1R_S29FE_BITPOS 5
                             6336 ; 1037 |#define HW_ICLFENABLE1R_S30FE_BITPOS 6
                             6337 ; 1038 |#define HW_ICLFENABLE1R_S31FE_BITPOS 7
                             6338 ; 1039 |#define HW_ICLFENABLE1R_S32FE_BITPOS 8
                             6339 ; 1040 |#define HW_ICLFENABLE1R_S33FE_BITPOS 9
                             6340 ; 1041 |
                             6341 ; 1042 |#define HW_ICLFENABLE1R_S24FE_SETMASK 1<<HW_ICLFENABLE1R_S24FE_BITPOS
                             6342 ; 1043 |#define HW_ICLFENABLE1R_S25FE_SETMASK 1<<HW_ICLFENABLE1R_S25FE_BITPOS
                             6343 ; 1044 |#define HW_ICLFENABLE1R_S26FE_SETMASK 1<<HW_ICLFENABLE1R_S26FE_BITPOS
                             6344 ; 1045 |#define HW_ICLFENABLE1R_S27FE_SETMASK 1<<HW_ICLFENABLE1R_S27FE_BITPOS
                             6345 ; 1046 |#define HW_ICLFENABLE1R_S28FE_SETMASK 1<<HW_ICLFENABLE1R_S28FE_BITPOS
                             6346 ; 1047 |#define HW_ICLFENABLE1R_S29FE_SETMASK 1<<HW_ICLFENABLE1R_S29FE_BITPOS
                             6347 ; 1048 |#define HW_ICLFENABLE1R_S30FE_SETMASK 1<<HW_ICLFENABLE1R_S30FE_BITPOS
                             6348 ; 1049 |#define HW_ICLFENABLE1R_S31FE_SETMASK 1<<HW_ICLFENABLE1R_S31FE_BITPOS
                             6349 ; 1050 |#define HW_ICLFENABLE1R_S32FE_SETMASK 1<<HW_ICLFENABLE1R_S32FE_BITPOS
                             6350 ; 1051 |#define HW_ICLFENABLE1R_S33FE_SETMASK 1<<HW_ICLFENABLE1R_S33FE_BITPOS
                             6351 ; 1052 |
                             6352 ; 1053 |#define HW_ICLFENABLE1R_S24FE_CLRMASK ~(WORD)HW_ICLFENABLE1R_S24FE_SETMASK
                             6353 ; 1054 |#define HW_ICLFENABLE1R_S25FE_CLRMASK ~(WORD)HW_ICLFENABLE1R_S25FE_SETMASK
                             6354 ; 1055 |#define HW_ICLFENABLE1R_S26FE_CLRMASK ~(WORD)HW_ICLFENABLE1R_S26FE_SETMASK
                             6355 ; 1056 |#define HW_ICLFENABLE1R_S27FE_CLRMASK ~(WORD)HW_ICLFENABLE1R_S27FE_SETMASK
                             6356 ; 1057 |#define HW_ICLFENABLE1R_S28FE_CLRMASK ~(WORD)HW_ICLFENABLE1R_S28FE_SETMASK
                             6357 ; 1058 |#define HW_ICLFENABLE1R_S29FE_CLRMASK ~(WORD)HW_ICLFENABLE1R_S29FE_SETMASK
                             6358 ; 1059 |#define HW_ICLFENABLE1R_S30FE_CLRMASK ~(WORD)HW_ICLFENABLE1R_S30FE_SETMASK
                             6359 ; 1060 |#define HW_ICLFENABLE1R_S31FE_CLRMASK ~(WORD)HW_ICLFENABLE1R_S31FE_SETMASK
                             6360 ; 1061 |#define HW_ICLFENABLE1R_S32FE_CLRMASK ~(WORD)HW_ICLFENABLE1R_S32FE_SETMASK
                             6361 ; 1062 |#define HW_ICLFENABLE1R_S33FE_CLRMASK ~(WORD)HW_ICLFENABLE1R_S33FE_SETMASK
                             6362 ; 1063 |
                             6363 ; 1064 |
                             6364 ; 1065 |/////////////////////////////////////////////////////////////////////////////////
                             6365 ; 1066 |//  Interrupt Collector Observation Register 0 Register (HW_ICLOBSVZ0R) Bit Positions
                             6366 ; 1067 |typedef union               /* Interrupt Collector Observation Register 0       */
                             6367 ; 1068 |{
                             6368 ; 1069 |    struct {
                             6369 ; 1070 |        unsigned RQ     :7;
                             6370 ; 1071 |        unsigned IVA    :7;
                             6371 ; 1072 |        unsigned IVB    :7;
                             6372 ; 1073 |    } B;
                             6373 ; 1074 |    int I;
                             6374 ; 1075 |} iclobsvz0_type;
                             6375 ; 1076 |#define HW_ICLOBSVZ0R   (*(volatile iclobsvz0_type _X*) (HW_ICOLL_BASEADDR+15)) /* Interrupt Collector Observation Register 0   */
                             6376 ; 1077 |
                             6377 ; 1078 |#define HW_ICLOBSVZ0R_RQ_BITPOS 0
                             6378 ; 1079 |#define HW_ICLOBSVZ0R_IVA_BITPOS 7
                             6379 ; 1080 |#define HW_ICLOBSVZ0R_IVB_BITPOS 14
                             6380 ; 1081 |
                             6381 ; 1082 |#define HW_ICLOBSVZ0R_RQ_SETMASK 0x3F<<HW_ICLOBSVZ0R_RQ_BITPOS
                             6382 ; 1083 |#define HW_ICLOBSVZ0R_IVA_SETMASK 0x3F<<HW_ICLOBSVZ0R_IVA_BITPOS
                             6383 ; 1084 |#define HW_ICLOBSVZ0R_IVB_SETMASK 0x3F<<HW_ICLOBSVZ0R_IVB_BITPOS
                             6384 ; 1085 |
                             6385 ; 1086 |#define HW_ICLOBSVZ0R_RQ_CLRMASK ~(WORD)HW_ICLOBSVZ0R_RQ_SETMASK
                             6386 ; 1087 |#define HW_ICLOBSVZ0R_IVA_CLRMASK ~(WORD)HW_ICLOBSVZ0R_IVA_SETMASK
                             6387 ; 1088 |#define HW_ICLOBSVZ0R_IVB_CLRMASK ~(WORD)HW_ICLOBSVZ0R_IVB_SETMASK
                             6388 ; 1089 |
                             6389 ; 1090 |
                             6390 ; 1091 |/////////////////////////////////////////////////////////////////////////////////
                             6391 ; 1092 |//  Interrupt Collector Observation Register 1 Register (HW_ICL1BSVZ0R) Bit Positions
                             6392 ; 1093 |#define HW_ICL1BSVZ0R_IVC_BITPOS 0
                             6393 ; 1094 |#define HW_ICL1BSVZ0R_IVD_BITPOS 7
                             6394 ; 1095 |
                             6395 ; 1096 |#define HW_ICL1BSVZ0R_IVC_SETMASK 0x3F<<HW_ICL1BSVZ0R_IVC_BITPOS
                             6396 ; 1097 |#define HW_ICL1BSVZ0R_IVD_SETMASK 0x3F<<HW_ICL1BSVZ0R_IVD_BITPOS
                             6397 ; 1098 |
                             6398 ; 1099 |#define HW_ICL1BSVZ0R_IVC_CLRMASK ~(WORD)HW_ICL1BSVZ0R_IVC_SETMASK
                             6399 ; 1100 |#define HW_ICL1BSVZ0R_IVD_CLRMASK ~(WORD)HW_ICL1BSVZ0R_IVD_SETMASK
                             6400 ; 1101 |
                             6401 ; 1102 |
                             6402 ; 1103 |
                             6403 ; 1104 |
                             6404 ; 1105 |/////////////////////////////////////////////////////////////////////////////////
                             6405 ; 1106 |//  Interrupt Vectors
                             6406 ; 1107 |/////////////////////////////////////////////////////////////////////////////////
                             6407 ; 1108 |// Reset Vector
                             6408 ; 1109 |#define HW_IVECRESET 0x0000           
                             6409 ; 1110 |// Stack Error
                             6410 ; 1111 |#define HW_IVECSTERR 0x0002           
                             6411 ; 1112 |// Trace
                             6412 ; 1113 |#define HW_IVECTRAC 0x0004           
                             6413 ; 1114 |// SWI
                             6414 ; 1115 |#define HW_IVECSWI 0x0006           
                             6415 ; 1116 |// ~IRQA
                             6416 ; 1117 |#define HW_IVECIRQA 0x0008           
                             6417 ; 1118 |// ~IRQB - BROWNOUT
                             6418 ; 1119 |#define HW_IVECIRQB 0x000A           
                             6419 ; 1120 |// Fatal Error
                             6420 ; 1121 |#define HW_IVECERROR 0x000C           
                             6421 ; 1122 |// SPI
                             6422 ; 1123 |#define HW_IVECSPI 0x000E           
                             6423 ; 1124 |// I2S TX Data Empty
                             6424 ; 1125 |#define HW_IVECI2STXDE 0x0010           
                             6425 ; 1126 |// I2S TX Underflow
                             6426 ; 1127 |#define HW_IVECI2STXUF 0x0012           
                             6427 ; 1128 |// I2S RX Data Full
                             6428 ; 1129 |#define HW_IVECI2SRXDF 0x0014           
                             6429 ; 1130 |// I2S RX Overflow
                             6430 ; 1131 |#define HW_IVECI2SRXOF 0x0016           
                             6431 ; 1132 |//                                       equ     $0018           ; Error, nothing vectors here
                             6432 ; 1133 |//                                       equ     $001A           ; Error, nothing vectors here
                             6433 ; 1134 |//                                       equ     $001C           ; Error, nothing vectors here
                             6434 ; 1135 |//                                       equ     $001E           ; Non-Maskable Interrupt
                             6435 ; 1136 |// GPIO1
                             6436 ; 1137 |#define HW_IVECGPIO1 0x0020           
                             6437 ; 1138 |// GPIO2
                             6438 ; 1139 |#define HW_IVECGPIO2 0x0022           
                             6439 ; 1140 |// GPIO0
                             6440 ; 1141 |#define HW_IVECGPIO0 0x0024           
                             6441 ; 1142 |// TIMER0
                             6442 ; 1143 |#define HW_IVECTIMER0 0x0026           
                             6443 ; 1144 |// TIMER1
                             6444 ; 1145 |#define HW_IVECTIMER1 0x0028           
                             6445 ; 1146 |// TIMER2
                             6446 ; 1147 |#define HW_IVECTIMER2 0x002A           
                             6447 ; 1148 |//                                       equ     $002C           ; Error, nothing vectors here
                             6448 ; 1149 |//                                       equ     $002E           ; Error, nothing vectors here
                             6449 ; 1150 |// I2C RX Data Ready
                             6450 ; 1151 |#define HW_IVECI2CRXDR 0x0030           
                             6451 ; 1152 |// I2C RX Overflow
                             6452 ; 1153 |#define HW_IVECI2CRXOF 0x0032           
                             6453 ; 1154 |// I2C TX Data Empty
                             6454 ; 1155 |#define HW_IVECI2CTXDE 0x0034           
                             6455 ; 1156 |// I2C TX Underflow
                             6456 ; 1157 |#define HW_IVECI2CTXUF 0x0036           
                             6457 ; 1158 |// Illegal Instruction
                             6458 ; 1159 |#define HW_IVECILI 0x0038           
                             6459 ; 1160 |//                                       equ     $003A           ; Error, nothing vectors here
                             6460 ; 1161 |// DAC Empty ISR (DAC Request to Fill Buffer)
                             6461 ; 1162 |#define HW_IVECDACE 0x003C           
                             6462 ; 1163 |// DAC Underflow ISR
                             6463 ; 1164 |#define HW_IVECDACUF 0x003E           
                             6464 ; 1165 |//                                       equ     $0040           ; Error, nothing vectors here
                             6465 ; 1166 |// ADC Full ISR
                             6466 ; 1167 |#define HW_IVECADCF 0x0042           
                             6467 ; 1168 |// ADC Overflow ISR
                             6468 ; 1169 |#define HW_IVECADCOF 0x0044           
                             6469 ; 1170 |//                                       equ     $0046           ; Error, nothing vectors here
                             6470 ; 1171 |// TIMER3
                             6471 ; 1172 |#define HW_IVECTIMER3 0x0048           
                             6472 ; 1173 |// GPIO3
                             6473 ; 1174 |#define HW_IVECGPIO3 0x004A           
                             6474 ; 1175 |// SDRAM
                             6475 ; 1176 |#define HW_IVECSDRAM 0x004C           
                             6476 ; 1177 |//                                       equ     $004E           ; Error, nothing vectors here
                             6477 ; 1178 |// 5 volt power connected
                             6478 ; 1179 |#define HW_IVECVDD5VCONN 0x0050           
                             6479 ; 1180 |// USB Controller
                             6480 ; 1181 |#define HW_IVECUSBCTLR 0x0052           
                             6481 ; 1182 |// USB Wakeup 
                             6482 ; 1183 |#define HW_IVECUSBWAKEUP 0x0054           
                             6483 ; 1184 |// 5 volt power disconnected
                             6484 ; 1185 |#define HW_IVECVDD5VDISC 0x0056           
                             6485 ; 1186 |// enhanced SPI
                             6486 ; 1187 |#define HW_IVECESPI 0x0058           
                             6487 ; 1188 |// filter coprocessor
                             6488 ; 1189 |#define HW_IVECFILCO 0x005A           
                             6489 ; 1190 |// low res ADC #1
                             6490 ; 1191 |#define HW_IVECLRADC1 0x005C           
                             6491 ; 1192 |// real time clock alarm
                             6492 ; 1193 |#define HW_IVECRTCALARM 0x005E           
                             6493 ; 1194 |// low res ADC #2
                             6494 ; 1195 |#define HW_IVECLRADC2 0x0060           
                             6495 ; 1196 |// flash hardware ECC
                             6496 ; 1197 |#define HW_IVECHWECC 0x0062           
                             6497 ; 1198 |//                                       equ     $0064           ; Error, nothing vectors here
                             6498 ; 1199 |// CDSYNC Interrupt
                             6499 ; 1200 |#define HW_IVECCDSYNC 0x0066           
                             6500 ; 1201 |// CDSYNC Exception
                             6501 ; 1202 |#define HW_IVECCDSYNCEX 0x0068           
                             6502 ; 1203 |// RS
                             6503 ; 1204 |#define HW_IVECRS 0x006A           
                             6504 ; 1205 |//                                       equ     $006C           ; Error, nothing vectors here
                             6505 ; 1206 |// Flash Done ISR
                             6506 ; 1207 |#define HW_IVECFD 0x006E           
                             6507 ; 1208 |// CompactFlash ISR
                             6508 ; 1209 |#define HW_IVECCF 0x0070           
                             6509 ; 1210 |// SmartMedia Timeout ISR
                             6510 ; 1211 |#define HW_IVECSMTO 0x0072           
                             6511 ; 1212 |// SmartMedia Invalid Programming
                             6512 ; 1213 |#define HW_IVECSMIP 0x0074           
                             6513 ; 1214 |// CompactFlash No Card ISR
                             6514 ; 1215 |#define HW_IVECCFNC 0x0076           
                             6515 ; 1216 |// CompactFlash Status Change ISR
                             6516 ; 1217 |#define HW_IVECCFSC 0x0078           
                             6517 ; 1218 |//                                       equ     $007A           ; Error, nothing vectors here
                             6518 ; 1219 |//                                       equ     $007C           ; Error, nothing vectors here
                             6519 ; 1220 |// CDI
                             6520 ; 1221 |#define HW_IVECCDI 0x007E           
                             6521 ; 1222 |
                             6522 ; 1223 |/////////////////////////////////////////////////////////////////////////////////
                             6523 ; 1224 |//  Interrupt Vectors
                             6524 ; 1225 |/////////////////////////////////////////////////////////////////////////////////
                             6525 ; 1226 |// macro to allow setting vectors from C. Hex const below is jsr opcode.
                             6526 ; 1227 |#define VECTOR(address,isr) \ 
                             6527 ; 1228 |    (*(volatile int _P *)(address))=0x0BF080; \ 
                             6528 ; 1229 |    (*(volatile int _P *)(address+1))=(isr)
                             6529 ; 1230 |
                             6530 ; 1231 |
                             6531 ; 1232 |/////////////////////////////////////////////////////////////////////////////////
                             6532 ; 1233 |//  Interrupt Priority Register (HW_IPR) Bit Positions
                             6533 ; 1234 |#define HW_IPR_IRQA_BITPOS 0
                             6534 ; 1235 |#define HW_IPR_IRQA_ET_BITPOS 2
                             6535 ; 1236 |#define HW_IPR_IRQB_BITPOS 3
                             6536 ; 1237 |#define HW_IPR_IRQB_ET_BITPOS 5
                             6537 ; 1238 |#define HW_IPR_L0P_BITPOS 10
                             6538 ; 1239 |#define HW_IPR_L1P_BITPOS 12
                             6539 ; 1240 |#define HW_IPR_L2P_BITPOS 14
                             6540 ; 1241 |#define HW_IPR_L3P_BITPOS 16
                             6541 ; 1242 |#define HW_IPR_L4P_BITPOS 18
                             6542 ; 1243 |#define HW_IPR_L5P_BITPOS 20
                             6543 ; 1244 |#define HW_IPR_L6P_BITPOS 22
                             6544 ; 1245 |
                             6545 ; 1246 |// Interrupt Disabled
                             6546 ; 1247 |#define HW_IPR_LP_0_SETMASK 0   
                             6547 ; 1248 |// Interrupt Priority Level 0
                             6548 ; 1249 |#define HW_IPR_LP_1_SETMASK 1   
                             6549 ; 1250 |// Interrupt Priority Level 1
                             6550 ; 1251 |#define HW_IPR_LP_2_SETMASK 2   
                             6551 ; 1252 |// Interrupt Priority Level 2
                             6552 ; 1253 |#define HW_IPR_LP_3_SETMASK 3   
                             6553 ; 1254 |
                             6554 ; 1255 |#define HW_IPR_IRQA_SETMASK 3<<HW_IPR_IRQA_BITPOS
                             6555 ; 1256 |#define HW_IPR_IRQA_ET_SETMASK 1<<HW_IPR_IRQA_ET_BITPOS
                             6556 ; 1257 |#define HW_IPR_IRQB_SETMASK 3<<HW_IPR_IRQB_BITPOS
                             6557 ; 1258 |#define HW_IPR_IRQB_ET_SETMASK 1<<HW_IPR_IRQB_ET_BITPOS
                             6558 ; 1259 |#define HW_IPR_L0P_SETMASK 3<<HW_IPR_L0P_BITPOS
                             6559 ; 1260 |#define HW_IPR_L1P_SETMASK 3<<HW_IPR_L1P_BITPOS
                             6560 ; 1261 |#define HW_IPR_L2P_SETMASK 3<<HW_IPR_L2P_BITPOS
                             6561 ; 1262 |#define HW_IPR_L3P_SETMASK 3<<HW_IPR_L3P_BITPOS
                             6562 ; 1263 |#define HW_IPR_L4P_SETMASK 3<<HW_IPR_L4P_BITPOS
                             6563 ; 1264 |#define HW_IPR_L5P_SETMASK 3<<HW_IPR_L5P_BITPOS
                             6564 ; 1265 |#define HW_IPR_L6P_SETMASK 3<<HW_IPR_L6P_BITPOS
                             6565 ; 1266 |
                             6566 ; 1267 |#define HW_IPR_IRQA_CLRMASK ~(WORD)HW_IPR_IRQA_SETMASK
                             6567 ; 1268 |#define HW_IPR_IRQA_ET_CLRMASK ~(WORD)HW_IPR_IRQA_ET_SETMASK
                             6568 ; 1269 |#define HW_IPR_IRQB_CLRMASK ~(WORD)HW_IPR_IRQB_SETMASK
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  27

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6569 ; 1270 |#define HW_IPR_IRQB_ET_CLRMASK ~(WORD)HW_IPR_IRQB_ET_SETMASK
                             6570 ; 1271 |#define HW_IPR_L0P_CLRMASK ~(WORD)HW_IPR_L0P_SETMASK
                             6571 ; 1272 |#define HW_IPR_L1P_CLRMASK ~(WORD)HW_IPR_L1P_SETMASK
                             6572 ; 1273 |#define HW_IPR_L2P_CLRMASK ~(WORD)HW_IPR_L2P_SETMASK
                             6573 ; 1274 |#define HW_IPR_L3P_CLRMASK ~(WORD)HW_IPR_L3P_SETMASK
                             6574 ; 1275 |#define HW_IPR_L4P_CLRMASK ~(WORD)HW_IPR_L4P_SETMASK
                             6575 ; 1276 |#define HW_IPR_L5P_CLRMASK ~(WORD)HW_IPR_L5P_SETMASK
                             6576 ; 1277 |#define HW_IPR_L6P_CLRMASK ~(WORD)HW_IPR_L6P_SETMASK
                             6577 ; 1278 |
                             6578 ; 1279 |// Interrupt Priority register
                             6579 ; 1280 |typedef union               
                             6580 ; 1281 |{
                             6581 ; 1282 |    struct {
                             6582 ; 1283 |        unsigned int IRQAP  :2; /* IRQ A Priority: 00 disable, 01 10 11 enable  */
                             6583 ; 1284 |        unsigned int IRQAT  :1; /* IRQ A Type: 0 level, 1 negative edge         */
                             6584 ; 1285 |        unsigned int IRQBP  :2; /* IRQ B Priority: 00 disable, 01 10 11 enable  */
                             6585 ; 1286 |        unsigned int IRQBT  :1; /* IRQ B Type: 0 level, 1 negative edge.        */
                             6586 ; 1287 |        int                 :4; /* Reserved */
                             6587 ; 1288 |        unsigned int L0P    :2; /* Interrupt Priority for priority 0 (SAI)      */
                             6588 ; 1289 |        unsigned int L1P    :2; /* Interrupt Priority for priority 1 (IColl)    */
                             6589 ; 1290 |        unsigned int L2P    :2; /* Interrupt Priority for priority 2 (IColl)    */
                             6590 ; 1291 |        unsigned int L3P    :2; /* Interrupt Priority for priority 3 (IColl)    */
                             6591 ; 1292 |        unsigned int L4P    :2; /* Interrupt Priority for priority 4 (I2C)      */
                             6592 ; 1293 |        unsigned int L5P    :2; /* Interrupt Priority for priority 5 (SPI)      */
                             6593 ; 1294 |        unsigned int L6P    :2; /* Interrupt Priority for priority 6 (IColl)    */
                             6594 ; 1295 |    } B;
                             6595 ; 1296 |
                             6596 ; 1297 |    int I;
                             6597 ; 1298 |
                             6598 ; 1299 |} ipr_type;
                             6599 ; 1300 |#define HW_IPR         (*(volatile ipr_type _X*) 0x00FFFF)
                             6600 ; 1301 |
                             6601 ; 1302 |//*********************  REGISTER ALIAS DEFINES TO MATCH LEGACY CODE *******************************
                             6602 ; 1303 |// The following defines were added to match regs3410.inc definition to build SDK2XXX code without needing 
                             6603 ; 1304 |// to update the actual files. Only the defines needed to build SDK2.400 were added.
                             6604 ; 1305 |
                             6605 ; 1306 |#define HW_IPR_L1P0_BITPOS 12
                             6606 ; 1307 |#define HW_IPR_L2P0_BITPOS 14
                             6607 ; 1308 |#define HW_IPR_L3P0_BITPOS 16
                             6608 ; 1309 |#define HW_IPR_L6P0_BITPOS 22
                             6609 ; 1310 |
                             6610 ; 1311 |/////////////////////////////////////////////////////////////////////////////////
                             6611 ; 1312 |//  Interrupt Collector Steering 0 Register (HW_ICLSTEER0R) Bit Positions
                             6612 ; 1313 |#define HW_ICLSTEERR_SS_1 0
                             6613 ; 1314 |#define HW_ICLSTEERR_SS_2 1
                             6614 ; 1315 |#define HW_ICLSTEERR_SS_3 2
                             6615 ; 1316 |#define HW_ICLSTEERR_SS_6 3
                             6616 ; 1317 |
                             6617 ; 1318 |#endif
                             6618 ; 1319 |
                             6619 
                             6621 
                             6622 ; 26   |#include "regslradc.h"
                             6623 
                             6625 
                             6626 ; 1    |#if !(defined(regslradcinc))
                             6627 ; 2    |
                             6628 ; 3    |#define regslradcinc 1
                             6629 ; 4    |
                             6630 ; 5    |#include "types.h"
                             6631 
                             6633 
                             6634 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             6635 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             6636 ; 3    |//
                             6637 ; 4    |// Filename: types.h
                             6638 ; 5    |// Description: Standard data types
                             6639 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             6640 ; 7    |
                             6641 ; 8    |#ifndef _TYPES_H
                             6642 ; 9    |#define _TYPES_H
                             6643 ; 10   |
                             6644 ; 11   |// TODO:  move this outta here!
                             6645 ; 12   |#if !defined(NOERROR)
                             6646 ; 13   |#define NOERROR 0
                             6647 ; 14   |#define SUCCESS 0
                             6648 ; 15   |#endif 
                             6649 ; 16   |#if !defined(SUCCESS)
                             6650 ; 17   |#define SUCCESS  0
                             6651 ; 18   |#endif
                             6652 ; 19   |#if !defined(ERROR)
                             6653 ; 20   |#define ERROR   -1
                             6654 ; 21   |#endif
                             6655 ; 22   |#if !defined(FALSE)
                             6656 ; 23   |#define FALSE 0
                             6657 ; 24   |#endif
                             6658 ; 25   |#if !defined(TRUE)
                             6659 ; 26   |#define TRUE  1
                             6660 ; 27   |#endif
                             6661 ; 28   |
                             6662 ; 29   |#if !defined(NULL)
                             6663 ; 30   |#define NULL 0
                             6664 ; 31   |#endif
                             6665 ; 32   |
                             6666 ; 33   |#define MAX_INT     0x7FFFFF
                             6667 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             6668 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             6669 ; 36   |#define MAX_ULONG   (-1) 
                             6670 ; 37   |
                             6671 ; 38   |#define WORD_SIZE   24              // word size in bits
                             6672 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             6673 ; 40   |
                             6674 ; 41   |
                             6675 ; 42   |#define BYTE    unsigned char       // btVarName
                             6676 ; 43   |#define CHAR    signed char         // cVarName
                             6677 ; 44   |#define USHORT  unsigned short      // usVarName
                             6678 ; 45   |#define SHORT   unsigned short      // sVarName
                             6679 ; 46   |#define WORD    unsigned int        // wVarName
                             6680 ; 47   |#define INT     signed int          // iVarName
                             6681 ; 48   |#define DWORD   unsigned long       // dwVarName
                             6682 ; 49   |#define LONG    signed long         // lVarName
                             6683 ; 50   |#define BOOL    unsigned int        // bVarName
                             6684 ; 51   |#define FRACT   _fract              // frVarName
                             6685 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             6686 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             6687 ; 54   |#define FLOAT   float               // fVarName
                             6688 ; 55   |#define DBL     double              // dVarName
                             6689 ; 56   |#define ENUM    enum                // eVarName
                             6690 ; 57   |#define CMX     _complex            // cmxVarName
                             6691 ; 58   |typedef WORD UCS3;                   // 
                             6692 ; 59   |
                             6693 ; 60   |#define UINT16  unsigned short
                             6694 ; 61   |#define UINT8   unsigned char   
                             6695 ; 62   |#define UINT32  unsigned long
                             6696 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             6697 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             6698 ; 65   |#define WCHAR   UINT16
                             6699 ; 66   |
                             6700 ; 67   |//UINT128 is 16 bytes or 6 words
                             6701 ; 68   |typedef struct UINT128_3500 {   
                             6702 ; 69   |    int val[6];     
                             6703 ; 70   |} UINT128_3500;
                             6704 ; 71   |
                             6705 ; 72   |#define UINT128   UINT128_3500
                             6706 ; 73   |
                             6707 ; 74   |// Little endian word packed byte strings:   
                             6708 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             6709 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             6710 ; 77   |// Little endian word packed byte strings:   
                             6711 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             6712 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             6713 ; 80   |
                             6714 ; 81   |// Declare Memory Spaces To Use When Coding
                             6715 ; 82   |// A. Sector Buffers
                             6716 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             6717 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             6718 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             6719 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             6720 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             6721 ; 88   |// B. Media DDI Memory
                             6722 ; 89   |#define MEDIA_DDI_MEM _Y
                             6723 ; 90   |
                             6724 ; 91   |
                             6725 ; 92   |
                             6726 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             6727 ; 94   |// Examples of circular pointers:
                             6728 ; 95   |//    INT CIRC cpiVarName
                             6729 ; 96   |//    DWORD CIRC cpdwVarName
                             6730 ; 97   |
                             6731 ; 98   |#define RETCODE INT                 // rcVarName
                             6732 ; 99   |
                             6733 ; 100  |// generic bitfield structure
                             6734 ; 101  |struct Bitfield {
                             6735 ; 102  |    unsigned int B0  :1;
                             6736 ; 103  |    unsigned int B1  :1;
                             6737 ; 104  |    unsigned int B2  :1;
                             6738 ; 105  |    unsigned int B3  :1;
                             6739 ; 106  |    unsigned int B4  :1;
                             6740 ; 107  |    unsigned int B5  :1;
                             6741 ; 108  |    unsigned int B6  :1;
                             6742 ; 109  |    unsigned int B7  :1;
                             6743 ; 110  |    unsigned int B8  :1;
                             6744 ; 111  |    unsigned int B9  :1;
                             6745 ; 112  |    unsigned int B10 :1;
                             6746 ; 113  |    unsigned int B11 :1;
                             6747 ; 114  |    unsigned int B12 :1;
                             6748 ; 115  |    unsigned int B13 :1;
                             6749 ; 116  |    unsigned int B14 :1;
                             6750 ; 117  |    unsigned int B15 :1;
                             6751 ; 118  |    unsigned int B16 :1;
                             6752 ; 119  |    unsigned int B17 :1;
                             6753 ; 120  |    unsigned int B18 :1;
                             6754 ; 121  |    unsigned int B19 :1;
                             6755 ; 122  |    unsigned int B20 :1;
                             6756 ; 123  |    unsigned int B21 :1;
                             6757 ; 124  |    unsigned int B22 :1;
                             6758 ; 125  |    unsigned int B23 :1;
                             6759 ; 126  |};
                             6760 ; 127  |
                             6761 ; 128  |union BitInt {
                             6762 ; 129  |        struct Bitfield B;
                             6763 ; 130  |        int        I;
                             6764 ; 131  |};
                             6765 ; 132  |
                             6766 ; 133  |#define MAX_MSG_LENGTH 10
                             6767 ; 134  |struct CMessage
                             6768 ; 135  |{
                             6769 ; 136  |        unsigned int m_uLength;
                             6770 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             6771 ; 138  |};
                             6772 ; 139  |
                             6773 ; 140  |typedef struct {
                             6774 ; 141  |    WORD m_wLength;
                             6775 ; 142  |    WORD m_wMessage;
                             6776 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             6777 ; 144  |} Message;
                             6778 ; 145  |
                             6779 ; 146  |struct MessageQueueDescriptor
                             6780 ; 147  |{
                             6781 ; 148  |        int *m_pBase;
                             6782 ; 149  |        int m_iModulo;
                             6783 ; 150  |        int m_iSize;
                             6784 ; 151  |        int *m_pHead;
                             6785 ; 152  |        int *m_pTail;
                             6786 ; 153  |};
                             6787 ; 154  |
                             6788 ; 155  |struct ModuleEntry
                             6789 ; 156  |{
                             6790 ; 157  |    int m_iSignaledEventMask;
                             6791 ; 158  |    int m_iWaitEventMask;
                             6792 ; 159  |    int m_iResourceOfCode;
                             6793 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             6794 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             6795 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             6796 ; 163  |    int m_uTimeOutHigh;
                             6797 ; 164  |    int m_uTimeOutLow;
                             6798 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             6799 ; 166  |};
                             6800 ; 167  |
                             6801 ; 168  |union WaitMask{
                             6802 ; 169  |    struct B{
                             6803 ; 170  |        unsigned int m_bNone     :1;
                             6804 ; 171  |        unsigned int m_bMessage  :1;
                             6805 ; 172  |        unsigned int m_bTimer    :1;
                             6806 ; 173  |        unsigned int m_bButton   :1;
                             6807 ; 174  |    } B;
                             6808 ; 175  |    int I;
                             6809 ; 176  |} ;
                             6810 ; 177  |
                             6811 ; 178  |
                             6812 ; 179  |struct Button {
                             6813 ; 180  |        WORD wButtonEvent;
                             6814 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             6815 ; 182  |};
                             6816 ; 183  |
                             6817 ; 184  |struct Message {
                             6818 ; 185  |        WORD wMsgLength;
                             6819 ; 186  |        WORD wMsgCommand;
                             6820 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             6821 ; 188  |};
                             6822 ; 189  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  28

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6823 ; 190  |union EventTypes {
                             6824 ; 191  |        struct CMessage msg;
                             6825 ; 192  |        struct Button Button ;
                             6826 ; 193  |        struct Message Message;
                             6827 ; 194  |};
                             6828 ; 195  |
                             6829 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             6830 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             6831 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             6832 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             6833 ; 200  |
                             6834 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             6835 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             6836 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             6837 ; 204  |
                             6838 ; 205  |#if DEBUG
                             6839 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             6840 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             6841 ; 208  |#else 
                             6842 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             6843 ; 210  |#define DebugBuildAssert(x)    
                             6844 ; 211  |#endif
                             6845 ; 212  |
                             6846 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             6847 ; 214  |//  #pragma asm
                             6848 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             6849 ; 216  |//  #pragma endasm
                             6850 ; 217  |
                             6851 ; 218  |
                             6852 ; 219  |#ifdef COLOR_262K
                             6853 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             6854 ; 221  |#elif defined(COLOR_65K)
                             6855 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             6856 ; 223  |#else
                             6857 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             6858 ; 225  |#endif
                             6859 ; 226  |    
                             6860 ; 227  |#endif // #ifndef _TYPES_H
                             6861 
                             6863 
                             6864 ; 6    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             6865 ; 7    |
                             6866 ; 8    |//   SYSTEM STMP Registers 
                             6867 ; 9    |//  Last Edited 6.26.2003 M. Henson
                             6868 ; 10   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             6869 ; 11   |
                             6870 ; 12   |#define HW_LRADC_BASEADDR (0xFA20)
                             6871 ; 13   |
                             6872 ; 14   |
                             6873 ; 15   |
                             6874 ; 16   |/////////////////////////////////////////////////////////////////////////////////
                             6875 ; 17   |//  Battery LRADC Control Register (HW_BATT_CTRL) Bit Definitions
                             6876 ; 18   |#define HW_BATT_CTRL_INPUT_OFFSET_WIDTH (7)
                             6877 ; 19   |#define HW_BATT_CTRL_RSVD0_WIDTH (1)
                             6878 ; 20   |#define HW_BATT_CTRL_HALF_CMP_PWR_WIDTH (1)
                             6879 ; 21   |#define HW_BATT_CTRL_INPUT_DIV2_WIDTH (1)
                             6880 ; 22   |#define HW_BATT_CTRL_CLEAR_WIDTH (1)
                             6881 ; 23   |#define HW_BATT_CTRL_PWD_WIDTH (1)
                             6882 ; 24   |#define HW_BATT_CTRL_CLK_DIV_WIDTH (2)
                             6883 ; 25   |#define HW_BATT_CTRL_RSVD1_WIDTH (2)
                             6884 ; 26   |#define HW_BATT_CTRL_REF_VAL_WIDTH (2)
                             6885 ; 27   |#define HW_BATT_CTRL_RSVD2_WIDTH (2)
                             6886 ; 28   |#define HW_BATT_CTRL_IRQ_EN_EVENT0_WIDTH (1)
                             6887 ; 29   |#define HW_BATT_CTRL_IRQ_EN_EVENT1_WIDTH (1)
                             6888 ; 30   |#define HW_BATT_CTRL_POLARITY_EVENT0_WIDTH (1)
                             6889 ; 31   |#define HW_BATT_CTRL_POLARITY_EVENT1_WIDTH (1)
                             6890 ; 32   |
                             6891 ; 33   |#define HW_BATT_CTRL_INPUT_OFFSET_BITPOS (0)
                             6892 ; 34   |#define HW_BATT_CTRL_HALF_CMP_PWR_BITPOS (8)
                             6893 ; 35   |#define HW_BATT_CTRL_INPUT_DIV2_BITPOS (9)
                             6894 ; 36   |#define HW_BATT_CTRL_CLEAR_BITPOS (10)
                             6895 ; 37   |#define HW_BATT_CTRL_PWD_BITPOS (11)
                             6896 ; 38   |#define HW_BATT_CTRL_CLK_DIV_BITPOS (12)
                             6897 ; 39   |#define HW_BATT_CTRL_REF_VAL_BITPOS (16)
                             6898 ; 40   |
                             6899 ; 41   |#define HW_BATT_CTRL_INPUT_OFFSET_SETMASK (((1<<HW_BATT_CTRL_INPUT_OFFSET_WIDTH)-1)<<HW_BATT_CTRL_INPUT_OFFSET_BITPOS)        
                             6900 ; 42   |#define HW_BATT_CTRL_HALF_CMP_PWR_SETMASK (((1<<HW_BATT_CTRL_HALF_CMP_PWR_WIDTH)-1)<<HW_BATT_CTRL_HALF_CMP_PWR_BITPOS)        
                             6901 ; 43   |#define HW_BATT_CTRL_INPUT_DIV2_SETMASK (((1<<HW_BATT_CTRL_INPUT_DIV2_WIDTH)-1)<<HW_BATT_CTRL_INPUT_DIV2_BITPOS) 
                             6902 ; 44   |#define HW_BATT_CTRL_CLEAR_SETMASK (((1<<HW_BATT_CTRL_CLEAR_WIDTH)-1)<<HW_BATT_CTRL_CLEAR_BITPOS) 
                             6903 ; 45   |#define HW_BATT_CTRL_PWD_SETMASK (((1<<HW_BATT_CTRL_PWD_WIDTH)-1)<<HW_BATT_CTRL_PWD_BITPOS) 
                             6904 ; 46   |#define HW_BATT_CTRL_CLK_DIV_SETMASK (((1<<HW_BATT_CTRL_CLK_DIV_WIDTH)-1)<<HW_BATT_CTRL_CLK_DIV_BITPOS)        
                             6905 ; 47   |#define HW_BATT_CTRL_REF_VAL_SETMASK (((1<<HW_BATT_CTRL_REF_VAL_WIDTH)-1)<<HW_BATT_CTRL_REF_VAL_BITPOS)        
                             6906 ; 48   |
                             6907 ; 49   |#define HW_BATT_CTRL_INPUT_OFFSET_CLRMASK (~(WORD)HW_BATT_CTRL_INPUT_OFFSET_SETMASK)     
                             6908 ; 50   |#define HW_BATT_CTRL_HALF_CMP_PWR_CLRMASK (~(WORD)HW_BATT_CTRL_HALF_CMP_PWR_SETMASK)     
                             6909 ; 51   |#define HW_BATT_CTRL_INPUT_DIV2_CLRMASK (~(WORD)HW_BATT_CTRL_INPUT_DIV2_SETMASK) 
                             6910 ; 52   |#define HW_BATT_CTRL_CLEAR_CLRMASK (~(WORD)HW_BATT_CTRL_CLEAR_SETMASK) 
                             6911 ; 53   |#define HW_BATT_CTRL_PWD_CLRMASK (~(WORD)HW_BATT_CTRL_PWD_SETMASK) 
                             6912 ; 54   |#define HW_BATT_CTRL_CLK_DIV_CLRMASK (~(WORD)HW_BATT_CTRL_CLK_DIV_SETMASK)     
                             6913 ; 55   |#define HW_BATT_CTRL_REF_VAL_CLRMASK (~(WORD)HW_BATT_CTRL_REF_VAL_SETMASK)
                             6914 ; 56   |
                             6915 ; 57   |typedef union               
                             6916 ; 58   |{
                             6917 ; 59   |    struct {
                             6918 ; 60   |        unsigned int INPUT_OFFSET                 : HW_BATT_CTRL_INPUT_OFFSET_WIDTH;
                             6919 ; 61   |        unsigned int RSVD0                        : HW_BATT_CTRL_RSVD0_WIDTH;
                             6920 ; 62   |        unsigned int HALF_CMP_PWR                 : HW_BATT_CTRL_HALF_CMP_PWR_WIDTH;
                             6921 ; 63   |        unsigned int INPUT_DIV2                   : HW_BATT_CTRL_INPUT_DIV2_WIDTH;
                             6922 ; 64   |        unsigned int CLEAR                        : HW_BATT_CTRL_CLEAR_WIDTH;
                             6923 ; 65   |        unsigned int PWD                          : HW_BATT_CTRL_PWD_WIDTH;
                             6924 ; 66   |        unsigned int CLK_DIV                      : HW_BATT_CTRL_CLK_DIV_WIDTH;
                             6925 ; 67   |        unsigned int RSVD1                        : HW_BATT_CTRL_RSVD1_WIDTH;
                             6926 ; 68   |        unsigned int REF_VAL                      : HW_BATT_CTRL_REF_VAL_WIDTH;
                             6927 ; 69   |        unsigned int RSVD2                        : HW_BATT_CTRL_RSVD2_WIDTH;
                             6928 ; 70   |                 unsigned int IRQ_EN_EVENT0                               : HW_BATT_CTRL_IRQ_EN_EVENT0_WIDTH;
                             6929 ; 71   |                 unsigned int IRQ_EN_EVENT1                               : HW_BATT_CTRL_IRQ_EN_EVENT1_WIDTH;
                             6930 ; 72   |             unsigned int POLARITY_EVENT0              : HW_BATT_CTRL_POLARITY_EVENT0_WIDTH;
                             6931 ; 73   |                 unsigned int POLARITY_EVENT1              : HW_BATT_CTRL_POLARITY_EVENT1_WIDTH;
                             6932 ; 74   |    } B;
                             6933 ; 75   |   unsigned int I;
                             6934 ; 76   |        unsigned int U;
                             6935 ; 77   |} lradc_ctrl_type;
                             6936 ; 78   |#define HW_BATT_CTRL      (*(volatile lradc_ctrl_type _X*) (HW_LRADC_BASEADDR))    /* Battery LRADC Control Register */
                             6937 ; 79   |
                             6938 ; 80   |
                             6939 ; 81   |/////////////////////////////////////////////////////////////////////////////////
                             6940 ; 82   |//  Battery LRADC Threshold Register (HW_BATT_THRSH) Bit Definitions
                             6941 ; 83   |#define HW_BATT_THRSH_THRESHOLD_EVENT0_WIDTH (9)
                             6942 ; 84   |#define HW_BATT_THRSH_RSVD0_WIDTH (3)
                             6943 ; 85   |#define HW_BATT_THRSH_THRESHOLD_EVENT1_WIDTH (9)
                             6944 ; 86   |#define HW_BATT_THRSH_RSVD1_WIDTH (3)
                             6945 ; 87   |
                             6946 ; 88   |#define HW_BATT_THRSH_THRESHOLD_EVENT0_BITPOS (0)
                             6947 ; 89   |#define HW_BATT_THRSH_THRESHOLD_EVENT1_BITPOS (12)
                             6948 ; 90   |
                             6949 ; 91   |#define HW_BATT_THRSH_THRESHOLD_EVENT0_SETMASK (((1<<HW_BATT_THRSH_THRESHOLD_EVENT0_WIDTH)-1)<<HW_BATT_THRSH_THRESHOLD_EVENT0_BITPOS)        
                             6950 ; 92   |#define HW_BATT_THRSH_THRESHOLD_EVENT1_SETMASK (((1<<HW_BATT_THRSH_THRESHOLD_EVENT1_WIDTH)-1)<<HW_BATT_THRSH_THRESHOLD_EVENT1_BITPOS)        
                             6951 ; 93   |
                             6952 ; 94   |#define HW_BATT_THRSH_THRESHOLD_EVENT0_CLRMASK (~(WORD)HW_BATT_THRSH_THRESHOLD_EVENT0_SETMASK)     
                             6953 ; 95   |#define HW_BATT_THRSH_THRESHOLD_EVENT1_CLRMASK (~(WORD)HW_BATT_THRSH_THRESHOLD_EVENT1_SETMASK)     
                             6954 ; 96   |
                             6955 ; 97   |
                             6956 ; 98   |typedef union               
                             6957 ; 99   |{
                             6958 ; 100  |    struct {
                             6959 ; 101  |        unsigned int THRESHOLD_EVENT0   : HW_BATT_THRSH_THRESHOLD_EVENT0_WIDTH;
                             6960 ; 102  |        unsigned int RSVD0                  : HW_BATT_THRSH_RSVD0_WIDTH;
                             6961 ; 103  |        unsigned int THRESHOLD_EVENT1   : HW_BATT_THRSH_THRESHOLD_EVENT1_WIDTH;
                             6962 ; 104  |        unsigned int RSVD1              : HW_BATT_THRSH_RSVD1_WIDTH;
                             6963 ; 105  |    } B;
                             6964 ; 106  |    unsigned int I;
                             6965 ; 107  |} lradc_thrsh_type;
                             6966 ; 108  |#define HW_BATT_THRSH      (*(volatile lradc_thrsh_type _X*) (HW_LRADC_BASEADDR+1))    /* Battery LRADC Threshold Register */
                             6967 ; 109  |
                             6968 ; 110  |
                             6969 ; 111  |/////////////////////////////////////////////////////////////////////////////////
                             6970 ; 112  |//  Battery LRADC Result Register (HW_BATT_RESULT) Bit Definitions
                             6971 ; 113  |#define HW_BATT_RESULT_EQ_EVENT1_WIDTH (1)
                             6972 ; 114  |#define HW_BATT_RESULT_EQ_EVENT0_WIDTH (1)
                             6973 ; 115  |#define HW_BATT_RESULT_GT_EVENT1_WIDTH (1)
                             6974 ; 116  |#define HW_BATT_RESULT_GT_EVENT0_WIDTH (1)
                             6975 ; 117  |#define HW_BATT_RESULT_LT_EVENT1_WIDTH (1)
                             6976 ; 118  |#define HW_BATT_RESULT_LT_EVENT0_WIDTH (1)
                             6977 ; 119  |#define HW_BATT_RESULT_RSVD0_WIDTH (2)
                             6978 ; 120  |#define HW_BATT_RESULT_DATA_OUT_WIDTH (9)
                             6979 ; 121  |#define HW_BATT_RESULT_RSVD1_WIDTH (3)
                             6980 ; 122  |#define HW_BATT_RESULT_IRQ_EVENT0_WIDTH (1)
                             6981 ; 123  |#define HW_BATT_RESULT_IRQ_EVENT1_WIDTH (1)
                             6982 ; 124  |#define HW_BATT_RESULT_RSVD2_WIDTH (2)
                             6983 ; 125  |
                             6984 ; 126  |#define HW_BATT_RESULT_EQ_EVENT1_BITPOS (0)
                             6985 ; 127  |#define HW_BATT_RESULT_EQ_EVENT0_BITPOS (1)
                             6986 ; 128  |#define HW_BATT_RESULT_GT_EVENT1_BITPOS (2)
                             6987 ; 129  |#define HW_BATT_RESULT_GT_EVENT0_BITPOS (3)
                             6988 ; 130  |#define HW_BATT_RESULT_LT_EVENT1_BITPOS (4)
                             6989 ; 131  |#define HW_BATT_RESULT_LT_EVENT0_BITPOS (5)
                             6990 ; 132  |#define HW_BATT_RESULT_RSVD0_BITPOS (6)
                             6991 ; 133  |#define HW_BATT_RESULT_DATA_OUT_BITPOS (8)
                             6992 ; 134  |#define HW_BATT_RESULT_RSVD1_BITPOS (17)
                             6993 ; 135  |#define HW_BATT_RESULT_IRQ_EVENT0_BITPOS (20)
                             6994 ; 136  |#define HW_BATT_RESULT_IRQ_EVENT1_BITPOS (21)
                             6995 ; 137  |#define HW_BATT_RESULT_RSVD2_BITPOS (22)
                             6996 ; 138  |
                             6997 ; 139  |
                             6998 ; 140  |
                             6999 ; 141  |#define HW_BATT_RESULT_EQ_EVENT1_SETMASK (((1<<HW_BATT_RESULT_EQ_EVENT1_WIDTH)-1)<<HW_BATT_RESULT_EQ_EVENT1_BITPOS)
                             7000 ; 142  |#define HW_BATT_RESULT_EQ_EVENT0_SETMASK (((1<<HW_BATT_RESULT_EQ_EVENT0_WIDTH)-1)<<HW_BATT_RESULT_EQ_EVENT0_BITPOS)
                             7001 ; 143  |#define HW_BATT_RESULT_GT_EVENT1_SETMASK (((1<<HW_BATT_RESULT_GT_EVENT1_WIDTH)-1)<<HW_BATT_RESULT_GT_EVENT1_BITPOS)
                             7002 ; 144  |#define HW_BATT_RESULT_GT_EVENT0_SETMASK (((1<<HW_BATT_RESULT_GT_EVENT0_WIDTH)-1)<<HW_BATT_RESULT_GT_EVENT0_BITPOS)
                             7003 ; 145  |#define HW_BATT_RESULT_LT_EVENT1_SETMASK (((1<<HW_BATT_RESULT_LT_EVENT1_WIDTH)-1)<<HW_BATT_RESULT_LT_EVENT1_BITPOS)
                             7004 ; 146  |#define HW_BATT_RESULT_LT_EVENT0_SETMASK (((1<<HW_BATT_RESULT_LT_EVENT0_WIDTH)-1)<<HW_BATT_RESULT_LT_EVENT0_BITPOS)
                             7005 ; 147  |#define HW_BATT_RESULT_RSVD0_SETMASK (((1<<HW_BATT_RESULT_RSVD0_WIDTH)-1)<<HW_BATT_RESULT_RSVD0_BITPOS)
                             7006 ; 148  |#define HW_BATT_RESULT_DATA_OUT_SETMASK (((1<<HW_BATT_RESULT_DATA_OUT_WIDTH)-1)<<HW_BATT_RESULT_DATA_OUT_BITPOS)
                             7007 ; 149  |#define HW_BATT_RESULT_RSVD1_SETMASK (((1<<HW_BATT_RESULT_RSVD1_WIDTH)-1)<<HW_BATT_RESULT_RSVD1_BITPOS)
                             7008 ; 150  |#define HW_BATT_RESULT_IRQ_EVENT0_SETMASK (((1<<HW_BATT_RESULT_IRQ_EVENT0_WIDTH)-1)<<HW_BATT_RESULT_IRQ_EVENT0_BITPOS)
                             7009 ; 151  |#define HW_BATT_RESULT_IRQ_EVENT1_SETMASK (((1<<HW_BATT_RESULT_IRQ_EVENT1_WIDTH)-1)<<HW_BATT_RESULT_IRQ_EVENT1_BITPOS)
                             7010 ; 152  |#define HW_BATT_RESULT_RSVD2_SETMASK (((1<<HW_BATT_RESULT_RSVD2_WIDTH)-1)<<HW_BATT_RESULT_RSVD2_BITPOS)
                             7011 ; 153  |
                             7012 ; 154  |
                             7013 ; 155  |#define HW_BATT_RESULT_EQ_EVENT1_CLRMASK (~(WORD)HW_BATT_RESULT_EQ_EVENT1_SETMASK)
                             7014 ; 156  |#define HW_BATT_RESULT_EQ_EVENT0_CLRMASK (~(WORD)HW_BATT_RESULT_EQ_EVENT0_SETMASK)
                             7015 ; 157  |#define HW_BATT_RESULT_GT_EVENT1_CLRMASK (~(WORD)HW_BATT_RESULT_GT_EVENT1_SETMASK)
                             7016 ; 158  |#define HW_BATT_RESULT_GT_EVENT0_CLRMASK (~(WORD)HW_BATT_RESULT_GT_EVENT0_SETMASK)
                             7017 ; 159  |#define HW_BATT_RESULT_LT_EVENT1_CLRMASK (~(WORD)HW_BATT_RESULT_LT_EVENT1_SETMASK)
                             7018 ; 160  |#define HW_BATT_RESULT_LT_EVENT0_CLRMASK (~(WORD)HW_BATT_RESULT_LT_EVENT0_SETMASK)
                             7019 ; 161  |#define HW_BATT_RESULT_RSVD0_CLRMASK (~(WORD)HW_BATT_RESULT_RSVD0_SETMASK)
                             7020 ; 162  |#define HW_BATT_RESULT_DATA_OUT_CLRMASK (~(WORD)HW_BATT_RESULT_DATA_OUT_SETMASK)
                             7021 ; 163  |#define HW_BATT_RESULT_RSVD1_CLRMASK (~(WORD)HW_BATT_RESULT_RSVD1_SETMASK)
                             7022 ; 164  |#define HW_BATT_RESULT_IRQ_EVENT0_CLRMASK (~(WORD)HW_BATT_RESULT_IRQ_EVENT0_SETMASK)
                             7023 ; 165  |#define HW_BATT_RESULT_IRQ_EVENT1_CLRMASK (~(WORD)HW_BATT_RESULT_IRQ_EVENT1_SETMASK)
                             7024 ; 166  |#define HW_BATT_RESULT_RSVD2_CLRMASK (~(WORD)HW_BATT_RESULT_RSVD2_SETMASK)
                             7025 ; 167  |
                             7026 ; 168  |typedef union               
                             7027 ; 169  |{
                             7028 ; 170  |    struct {
                             7029 ; 171  |        unsigned int EQ_EVENT1                  : HW_BATT_RESULT_EQ_EVENT1_WIDTH;
                             7030 ; 172  |        unsigned int EQ_EVENT0                  : HW_BATT_RESULT_EQ_EVENT0_WIDTH;
                             7031 ; 173  |        unsigned int GT_EVENT1                  : HW_BATT_RESULT_GT_EVENT1_WIDTH;
                             7032 ; 174  |        unsigned int GT_EVENT0                  : HW_BATT_RESULT_GT_EVENT0_WIDTH;
                             7033 ; 175  |        unsigned int LT_EVENT1                  : HW_BATT_RESULT_LT_EVENT1_WIDTH;
                             7034 ; 176  |        unsigned int LT_EVENT0                  : HW_BATT_RESULT_LT_EVENT0_WIDTH;
                             7035 ; 177  |        unsigned int RSVD0                     : HW_BATT_RESULT_RSVD0_WIDTH;
                             7036 ; 178  |        unsigned int DATA_OUT                  : HW_BATT_RESULT_DATA_OUT_WIDTH;
                             7037 ; 179  |        unsigned int RSVD1                     : HW_BATT_RESULT_RSVD1_WIDTH;
                             7038 ; 180  |                 unsigned int IRQ_EVENT0                                : HW_BATT_RESULT_IRQ_EVENT0_WIDTH;
                             7039 ; 181  |                 unsigned int IRQ_EVENT1                                : HW_BATT_RESULT_IRQ_EVENT1_WIDTH;                      
                             7040 ; 182  |                 unsigned int RSVD2                                         : HW_BATT_RESULT_RSVD2_WIDTH;
                             7041 ; 183  |    } B;
                             7042 ; 184  |    unsigned int I;
                             7043 ; 185  |} lradc_result_type;
                             7044 ; 186  |#define HW_BATT_RESULT      (*(volatile lradc_result_type _X*) (HW_LRADC_BASEADDR+2))    /* Battery LRADC Result Register */
                             7045 ; 187  |
                             7046 ; 188  |
                             7047 ; 189  |
                             7048 ; 190  |/////////////////////////////////////////////////////////////////////////////////
                             7049 ; 191  |//  LRADC1 Control Register (HW_LRADC1_CTRL) Bit Definitions
                             7050 ; 192  |#define HW_LRADC1_CTRL_INPUT_OFFSET_WIDTH (7)
                             7051 ; 193  |#define HW_LRADC1_CTRL_RSVD0_WIDTH (1)
                             7052 ; 194  |#define HW_LRADC1_CTRL_HALF_CMP_PWR_WIDTH (1)
                             7053 ; 195  |#define HW_LRADC1_CTRL_INPUT_DIV2_WIDTH (1)
                             7054 ; 196  |#define HW_LRADC1_CTRL_CLEAR_WIDTH (1)
                             7055 ; 197  |#define HW_LRADC1_CTRL_PWD_WIDTH (1)
                             7056 ; 198  |#define HW_LRADC1_CTRL_CLK_DIV_WIDTH (2)
                             7057 ; 199  |#define HW_LRADC1_CTRL_RSVD1_WIDTH (2)
                             7058 ; 200  |#define HW_LRADC1_CTRL_REF_VAL_WIDTH (2)
                             7059 ; 201  |#define HW_LRADC1_CTRL_RSVD2_WIDTH (6)
                             7060 ; 202  |
                             7061 ; 203  |#define HW_LRADC1_CTRL_INPUT_OFFSET_BITPOS (0)
                             7062 ; 204  |#define HW_LRADC1_CTRL_HALF_CMP_PWR_BITPOS (8)
                             7063 ; 205  |#define HW_LRADC1_CTRL_INPUT_DIV2_BITPOS (9)
                             7064 ; 206  |#define HW_LRADC1_CTRL_CLEAR_BITPOS (10)
                             7065 ; 207  |#define HW_LRADC1_CTRL_PWD_BITPOS (11)
                             7066 ; 208  |#define HW_LRADC1_CTRL_CLK_DIV_BITPOS (12)
                             7067 ; 209  |#define HW_LRADC1_CTRL_REF_VAL_BITPOS (16)
                             7068 ; 210  |
                             7069 ; 211  |#define HW_LRADC1_CTRL_INPUT_OFFSET_SETMASK (((1<<HW_LRADC1_CTRL_INPUT_OFFSET_WIDTH)-1)<<HW_LRADC1_CTRL_INPUT_OFFSET_BITPOS)        
                             7070 ; 212  |#define HW_LRADC1_CTRL_HALF_CMP_PWR_SETMASK (((1<<HW_LRADC1_CTRL_HALF_CMP_PWR_WIDTH)-1)<<HW_LRADC1_CTRL_HALF_CMP_PWR_BITPOS)        
                             7071 ; 213  |#define HW_LRADC1_CTRL_INPUT_DIV2_SETMASK (((1<<HW_LRADC1_CTRL_INPUT_DIV2_WIDTH)-1)<<HW_LRADC1_CTRL_INPUT_DIV2_BITPOS) 
                             7072 ; 214  |#define HW_LRADC1_CTRL_CLEAR_SETMASK (((1<<HW_LRADC1_CTRL_CLEAR_WIDTH)-1)<<HW_LRADC1_CTRL_CLEAR_BITPOS) 
                             7073 ; 215  |#define HW_LRADC1_CTRL_PWD_SETMASK (((1<<HW_LRADC1_CTRL_PWD_WIDTH)-1)<<HW_LRADC1_CTRL_PWD_BITPOS) 
                             7074 ; 216  |#define HW_LRADC1_CTRL_CLK_DIV_SETMASK (((1<<HW_LRADC1_CTRL_CLK_DIV_WIDTH)-1)<<HW_LRADC1_CTRL_CLK_DIV_BITPOS)        
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  29

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7075 ; 217  |#define HW_LRADC1_CTRL_REF_VAL_SETMASK (((1<<HW_LRADC1_CTRL_REF_VAL_WIDTH)-1)<<HW_LRADC1_CTRL_REF_VAL_BITPOS)        
                             7076 ; 218  |
                             7077 ; 219  |#define HW_LRADC1_CTRL_INPUT_OFFSET_CLRMASK (~(WORD)HW_LRADC1_CTRL_INPUT_OFFSET_SETMASK)     
                             7078 ; 220  |#define HW_LRADC1_CTRL_HALF_CMP_PWR_CLRMASK (~(WORD)HW_LRADC1_CTRL_HALF_CMP_PWR_SETMASK)     
                             7079 ; 221  |#define HW_LRADC1_CTRL_INPUT_DIV2_CLRMASK (~(WORD)HW_LRADC1_CTRL_INPUT_DIV2_SETMASK) 
                             7080 ; 222  |#define HW_LRADC1_CTRL_CLEAR_CLRMASK (~(WORD)HW_LRADC1_CTRL_CLEAR_SETMASK) 
                             7081 ; 223  |#define HW_LRADC1_CTRL_PWD_CLRMASK (~(WORD)HW_LRADC1_CTRL_PWD_SETMASK) 
                             7082 ; 224  |#define HW_LRADC1_CTRL_CLK_DIV_CLRMASK (~(WORD)HW_LRADC1_CTRL_CLK_DIV_SETMASK)     
                             7083 ; 225  |#define HW_LRADC1_CTRL_REF_VAL_CLRMASK (~(WORD)HW_LRADC1_CTRL_REF_VAL_SETMASK)     
                             7084 ; 226  |
                             7085 ; 227  |#define HW_LRADC1_CTRL      (*(volatile lradc_ctrl_type _X*) (HW_LRADC_BASEADDR+3))    /* LRADC1 Control Register */
                             7086 ; 228  |
                             7087 ; 229  |
                             7088 ; 230  |
                             7089 ; 231  |/////////////////////////////////////////////////////////////////////////////////
                             7090 ; 232  |//  LRADC1 Threshold Register (HW_LRADC1_THRSH) Bit Definitions
                             7091 ; 233  |#define HW_LRADC1_THRSH_MIN_THRESHOLD_WIDTH (9)
                             7092 ; 234  |#define HW_LRADC1_THRSH_RSVD0_WIDTH (3)
                             7093 ; 235  |#define HW_LRADC1_THRSH_MAX_THRESHOLD_WIDTH (9)
                             7094 ; 236  |#define HW_LRADC1_THRSH_RSVD1_WIDTH (3)
                             7095 ; 237  |
                             7096 ; 238  |#define HW_LRADC1_THRSH_MIN_THRESHOLD_BITPOS (0)
                             7097 ; 239  |#define HW_LRADC1_THRSH_MAX_THRESHOLD_BITPOS (12)
                             7098 ; 240  |
                             7099 ; 241  |#define HW_LRADC1_THRSH_MIN_THRESHOLD_SETMASK (((1<<HW_LRADC1_THRSH_MIN_THRESHOLD_WIDTH)-1)<<HW_LRADC1_THRSH_MIN_THRESHOLD_BITPOS)        
                             7100 ; 242  |#define HW_LRADC1_THRSH_MAX_THRESHOLD_SETMASK (((1<<HW_LRADC1_THRSH_MAX_THRESHOLD_WIDTH)-1)<<HW_LRADC1_THRSH_MAX_THRESHOLD_BITPOS)        
                             7101 ; 243  |
                             7102 ; 244  |#define HW_LRADC1_THRSH_MIN_THRESHOLD_CLRMASK (~(WORD)HW_LRADC1_THRSH_MIN_THRESHOLD_SETMASK)     
                             7103 ; 245  |#define HW_LRADC1_THRSH_MAX_THRESHOLD_CLRMASK (~(WORD)HW_LRADC1_THRSH_MAX_THRESHOLD_SETMASK)     
                             7104 ; 246  |
                             7105 ; 247  |#define HW_LRADC1_THRSH      (*(volatile lradc_thrsh_type _X*) (HW_LRADC_BASEADDR+4))    /* LRADC1 Threshold Register */
                             7106 ; 248  |
                             7107 ; 249  |/////////////////////////////////////////////////////////////////////////////////
                             7108 ; 250  |//  LRADC1 Result Register (HW_LRADC1_RESULT) Bit Definitions
                             7109 ; 251  |#define HW_LRADC1_RESULT_EQ_EVENT1_WIDTH (1)
                             7110 ; 252  |#define HW_LRADC1_RESULT_EQ_EVENT0_WIDTH (1)
                             7111 ; 253  |#define HW_LRADC1_RESULT_GT_EVENT1_WIDTH (1)
                             7112 ; 254  |#define HW_LRADC1_RESULT_GT_EVENT0_WIDTH (1)
                             7113 ; 255  |#define HW_LRADC1_RESULT_LT_EVENT1_WIDTH (1)
                             7114 ; 256  |#define HW_LRADC1_RESULT_LT_EVENT0_WIDTH (1)
                             7115 ; 257  |#define HW_LRADC1_RESULT_RSVD0_WIDTH (2)
                             7116 ; 258  |#define HW_LRADC1_RESULT_DATA_OUT_WIDTH (9)
                             7117 ; 259  |#define HW_LRADC1_RESULT_RSVD1_WIDTH (3)
                             7118 ; 260  |#define HW_LRADC1_RESULT_IRQ_EVENT0_WIDTH (1)
                             7119 ; 261  |#define HW_LRADC1_RESULT_IRQ_EVENT1_WIDTH (1)
                             7120 ; 262  |#define HW_LRADC1_RESULT_RSVD2_WIDTH (2)
                             7121 ; 263  |
                             7122 ; 264  |#define HW_LRADC1_RESULT_EQ_EVENT1_BITPOS (0)
                             7123 ; 265  |#define HW_LRADC1_RESULT_EQ_EVENT0_BITPOS (1)
                             7124 ; 266  |#define HW_LRADC1_RESULT_GT_EVENT1_BITPOS (2)
                             7125 ; 267  |#define HW_LRADC1_RESULT_GT_EVENT0_BITPOS (3)
                             7126 ; 268  |#define HW_LRADC1_RESULT_LT_EVENT1_BITPOS (4)
                             7127 ; 269  |#define HW_LRADC1_RESULT_LT_EVENT0_BITPOS (5)
                             7128 ; 270  |#define HW_LRADC1_RESULT_RSVD0_BITPOS (6)
                             7129 ; 271  |#define HW_LRADC1_RESULT_DATA_OUT_BITPOS (8)
                             7130 ; 272  |#define HW_LRADC1_RESULT_RSVD1_BITPOS (17)
                             7131 ; 273  |#define HW_LRADC1_RESULT_IRQ_EVENT0_BITPOS (20)
                             7132 ; 274  |#define HW_LRADC1_RESULT_IRQ_EVENT1_BITPOS (21)
                             7133 ; 275  |#define HW_LRADC1_RESULT_RSVD2_BITPOS (22)
                             7134 ; 276  |
                             7135 ; 277  |#define HW_LRADC1_RESULT_EQ_EVENT1_SETMASK (((1<<HW_LRADC1_RESULT_EQ_EVENT1_WIDTH)-1)<<HW_LRADC1_RESULT_EQ_EVENT1_BITPOS)
                             7136 ; 278  |#define HW_LRADC1_RESULT_EQ_EVENT0_SETMASK (((1<<HW_LRADC1_RESULT_EQ_EVENT0_WIDTH)-1)<<HW_LRADC1_RESULT_EQ_EVENT0_BITPOS)
                             7137 ; 279  |#define HW_LRADC1_RESULT_GT_EVENT1_SETMASK (((1<<HW_LRADC1_RESULT_GT_EVENT1_WIDTH)-1)<<HW_LRADC1_RESULT_GT_EVENT1_BITPOS)
                             7138 ; 280  |#define HW_LRADC1_RESULT_GT_EVENT0_SETMASK (((1<<HW_LRADC1_RESULT_GT_EVENT0_WIDTH)-1)<<HW_LRADC1_RESULT_GT_EVENT0_BITPOS)
                             7139 ; 281  |#define HW_LRADC1_RESULT_LT_EVENT1_SETMASK (((1<<HW_LRADC1_RESULT_LT_EVENT1_WIDTH)-1)<<HW_LRADC1_RESULT_LT_EVENT1_BITPOS)
                             7140 ; 282  |#define HW_LRADC1_RESULT_LT_EVENT0_SETMASK (((1<<HW_LRADC1_RESULT_LT_EVENT0_WIDTH)-1)<<HW_LRADC1_RESULT_LT_EVENT0_BITPOS)
                             7141 ; 283  |#define HW_LRADC1_RESULT_RSVD0_SETMASK (((1<<HW_LRADC1_RESULT_RSVD0_WIDTH)-1)<<HW_LRADC1_RESULT_RSVD0_BITPOS)
                             7142 ; 284  |#define HW_LRADC1_RESULT_DATA_OUT_SETMASK (((1<<HW_LRADC1_RESULT_DATA_OUT_WIDTH)-1)<<HW_LRADC1_RESULT_DATA_OUT_BITPOS)
                             7143 ; 285  |#define HW_LRADC1_RESULT_RSVD1_SETMASK (((1<<HW_LRADC1_RESULT_RSVD1_WIDTH)-1)<<HW_LRADC1_RESULT_RSVD1_BITPOS)
                             7144 ; 286  |#define HW_LRADC1_RESULT_IRQ_EVENT0_SETMASK (((1<<HW_LRADC1_RESULT_IRQ_EVENT0_WIDTH)-1)<<HW_LRADC1_RESULT_IRQ_EVENT0_BITPOS)
                             7145 ; 287  |#define HW_LRADC1_RESULT_IRQ_EVENT1_SETMASK (((1<<HW_LRADC1_RESULT_IRQ_EVENT1_WIDTH)-1)<<HW_LRADC1_RESULT_IRQ_EVENT1_BITPOS)
                             7146 ; 288  |#define HW_LRADC1_RESULT_RSVD2_SETMASK (((1<<HW_LRADC1_RESULT_RSVD2_WIDTH)-1)<<HW_LRADC1_RESULT_RSVD2_BITPOS)
                             7147 ; 289  |
                             7148 ; 290  |
                             7149 ; 291  |#define HW_LRADC1_RESULT_EQ_EVENT1_CLRMASK (~(WORD)HW_LRADC1_RESULT_EQ_EVENT1_SETMASK)
                             7150 ; 292  |#define HW_LRADC1_RESULT_EQ_EVENT0_CLRMASK (~(WORD)HW_LRADC1_RESULT_EQ_EVENT0_SETMASK)
                             7151 ; 293  |#define HW_LRADC1_RESULT_GT_EVENT1_CLRMASK (~(WORD)HW_LRADC1_RESULT_GT_EVENT1_SETMASK)
                             7152 ; 294  |#define HW_LRADC1_RESULT_GT_EVENT0_CLRMASK (~(WORD)HW_LRADC1_RESULT_GT_EVENT0_SETMASK)
                             7153 ; 295  |#define HW_LRADC1_RESULT_LT_EVENT1_CLRMASK (~(WORD)HW_LRADC1_RESULT_LT_EVENT1_SETMASK)
                             7154 ; 296  |#define HW_LRADC1_RESULT_LT_EVENT0_CLRMASK (~(WORD)HW_LRADC1_RESULT_LT_EVENT0_SETMASK)
                             7155 ; 297  |#define HW_LRADC1_RESULT_RSVD0_CLRMASK (~(WORD)HW_LRADC1_RESULT_RSVD0_SETMASK)
                             7156 ; 298  |#define HW_LRADC1_RESULT_DATA_OUT_CLRMASK (~(WORD)HW_LRADC1_RESULT_DATA_OUT_SETMASK)
                             7157 ; 299  |#define HW_LRADC1_RESULT_RSVD1_CLRMASK (~(WORD)HW_LRADC1_RESULT_RSVD1_SETMASK)
                             7158 ; 300  |#define HW_LRADC1_RESULT_IRQ_EVENT0_CLRMASK (~(WORD)HW_LRADC1_RESULT_IRQ_EVENT0_SETMASK)
                             7159 ; 301  |#define HW_LRADC1_RESULT_IRQ_EVENT1_CLRMASK (~(WORD)HW_LRADC1_RESULT_IRQ_EVENT1_SETMASK)
                             7160 ; 302  |#define HW_LRADC1_RESULT_RSVD2_CLRMASK (~(WORD)HW_LRADC1_RESULT_RSVD2_SETMASK)
                             7161 ; 303  |
                             7162 ; 304  |#define HW_LRADC1_RESULT      (*(volatile lradc_result_type _X*) (HW_LRADC_BASEADDR+5))    /* LRADC1 Result Register */
                             7163 ; 305  |
                             7164 ; 306  |/////////////////////////////////////////////////////////////////////////////////
                             7165 ; 307  |//  LRADC2_CTRL Control Register (HW_LRADC2_CTRL_CTRL) Bit Definitions
                             7166 ; 308  |#define HW_LRADC2_CTRL_CTRL_INPUT_OFFSET_WIDTH (7)
                             7167 ; 309  |#define HW_LRADC2_CTRL_CTRL_RSVD0_WIDTH (1)
                             7168 ; 310  |#define HW_LRADC2_CTRL_CTRL_HALF_CMP_PWR_WIDTH (1)
                             7169 ; 311  |#define HW_LRADC2_CTRL_CTRL_INPUT_DIV2_WIDTH (1)
                             7170 ; 312  |#define HW_LRADC2_CTRL_CTRL_CLEAR_WIDTH (1)
                             7171 ; 313  |#define HW_LRADC2_CTRL_CTRL_PWD_WIDTH (1)
                             7172 ; 314  |#define HW_LRADC2_CTRL_CTRL_CLK_DIV_WIDTH (2)
                             7173 ; 315  |#define HW_LRADC2_CTRL_CTRL_RSVD1_WIDTH (2)
                             7174 ; 316  |#define HW_LRADC2_CTRL_CTRL_REF_VAL_WIDTH (2)
                             7175 ; 317  |#define HW_LRADC2_CTRL_CTRL_RSVD2_WIDTH (6)
                             7176 ; 318  |
                             7177 ; 319  |#define HW_LRADC2_CTRL_CTRL_INPUT_OFFSET_BITPOS (0)
                             7178 ; 320  |#define HW_LRADC2_CTRL_CTRL_HALF_CMP_PWR_BITPOS (8)
                             7179 ; 321  |#define HW_LRADC2_CTRL_CTRL_INPUT_DIV2_BITPOS (9)
                             7180 ; 322  |#define HW_LRADC2_CTRL_CTRL_CLEAR_BITPOS (10)
                             7181 ; 323  |#define HW_LRADC2_CTRL_CTRL_PWD_BITPOS (11)
                             7182 ; 324  |#define HW_LRADC2_CTRL_CTRL_CLK_DIV_BITPOS (12)
                             7183 ; 325  |#define HW_LRADC2_CTRL_CTRL_REF_VAL_BITPOS (16)
                             7184 ; 326  |
                             7185 ; 327  |#define HW_LRADC2_CTRL_CTRL_INPUT_OFFSET_SETMASK (((1<<HW_LRADC2_CTRL_CTRL_INPUT_OFFSET_WIDTH)-1)<<HW_LRADC2_CTRL_CTRL_INPUT_OFFSET_BITPOS)        
                             7186 ; 328  |#define HW_LRADC2_CTRL_CTRL_HALF_CMP_PWR_SETMASK (((1<<HW_LRADC2_CTRL_CTRL_HALF_CMP_PWR_WIDTH)-1)<<HW_LRADC2_CTRL_CTRL_HALF_CMP_PWR_BITPOS)        
                             7187 ; 329  |#define HW_LRADC2_CTRL_CTRL_INPUT_DIV2_SETMASK (((1<<HW_LRADC2_CTRL_CTRL_INPUT_DIV2_WIDTH)-1)<<HW_LRADC2_CTRL_CTRL_INPUT_DIV2_BITPOS) 
                             7188 ; 330  |#define HW_LRADC2_CTRL_CTRL_CLEAR_SETMASK (((1<<HW_LRADC2_CTRL_CTRL_CLEAR_WIDTH)-1)<<HW_LRADC2_CTRL_CTRL_CLEAR_BITPOS) 
                             7189 ; 331  |#define HW_LRADC2_CTRL_CTRL_PWD_SETMASK (((1<<HW_LRADC2_CTRL_CTRL_PWD_WIDTH)-1)<<HW_LRADC2_CTRL_CTRL_PWD_BITPOS) 
                             7190 ; 332  |#define HW_LRADC2_CTRL_CTRL_CLK_DIV_SETMASK (((1<<HW_LRADC2_CTRL_CTRL_CLK_DIV_WIDTH)-1)<<HW_LRADC2_CTRL_CTRL_CLK_DIV_BITPOS)        
                             7191 ; 333  |#define HW_LRADC2_CTRL_CTRL_REF_VAL_SETMASK (((1<<HW_LRADC2_CTRL_CTRL_REF_VAL_WIDTH)-1)<<HW_LRADC2_CTRL_CTRL_REF_VAL_BITPOS)        
                             7192 ; 334  |
                             7193 ; 335  |#define HW_LRADC2_CTRL_CTRL_INPUT_OFFSET_CLRMASK (~(WORD)HW_LRADC2_CTRL_CTRL_INPUT_OFFSET_SETMASK)     
                             7194 ; 336  |#define HW_LRADC2_CTRL_CTRL_HALF_CMP_PWR_CLRMASK (~(WORD)HW_LRADC2_CTRL_CTRL_HALF_CMP_PWR_SETMASK)     
                             7195 ; 337  |#define HW_LRADC2_CTRL_CTRL_INPUT_DIV2_CLRMASK (~(WORD)HW_LRADC2_CTRL_CTRL_INPUT_DIV2_SETMASK) 
                             7196 ; 338  |#define HW_LRADC2_CTRL_CTRL_CLEAR_CLRMASK (~(WORD)HW_LRADC2_CTRL_CTRL_CLEAR_SETMASK) 
                             7197 ; 339  |#define HW_LRADC2_CTRL_CTRL_PWD_CLRMASK (~(WORD)HW_LRADC2_CTRL_CTRL_PWD_SETMASK) 
                             7198 ; 340  |#define HW_LRADC2_CTRL_CTRL_CLK_DIV_CLRMASK (~(WORD)HW_LRADC2_CTRL_CTRL_CLK_DIV_SETMASK)     
                             7199 ; 341  |#define HW_LRADC2_CTRL_CTRL_REF_VAL_CLRMASK (~(WORD)HW_LRADC2_CTRL_CTRL_REF_VAL_SETMASK)     
                             7200 ; 342  |
                             7201 ; 343  |
                             7202 ; 344  |#define HW_LRADC2_CTRL      (*(volatile lradc_ctrl_type _X*) (HW_LRADC_BASEADDR+6))    /* LRADC2_CTRL Control Register */
                             7203 ; 345  |
                             7204 ; 346  |
                             7205 ; 347  |
                             7206 ; 348  |/////////////////////////////////////////////////////////////////////////////////
                             7207 ; 349  |//  LRADC2 Threshold Register (HW_LRADC2_THRSH) Bit Definitions
                             7208 ; 350  |#define HW_LRADC2_THRSH_MIN_THRESHOLD_WIDTH (9)
                             7209 ; 351  |#define HW_LRADC2_THRSH_RSVD0_WIDTH (3)
                             7210 ; 352  |#define HW_LRADC2_THRSH_MAX_THRESHOLD_WIDTH (9)
                             7211 ; 353  |#define HW_LRADC2_THRSH_RSVD1_WIDTH (3)
                             7212 ; 354  |
                             7213 ; 355  |#define HW_LRADC2_THRSH_MIN_THRESHOLD_BITPOS (0)
                             7214 ; 356  |#define HW_LRADC2_THRSH_MAX_THRESHOLD_BITPOS (12)
                             7215 ; 357  |
                             7216 ; 358  |#define HW_LRADC2_THRSH_MIN_THRESHOLD_SETMASK (((1<<HW_LRADC2_THRSH_MIN_THRESHOLD_WIDTH)-1)<<HW_LRADC2_THRSH_MIN_THRESHOLD_BITPOS)        
                             7217 ; 359  |#define HW_LRADC2_THRSH_MAX_THRESHOLD_SETMASK (((1<<HW_LRADC2_THRSH_MAX_THRESHOLD_WIDTH)-1)<<HW_LRADC2_THRSH_MAX_THRESHOLD_BITPOS)        
                             7218 ; 360  |
                             7219 ; 361  |#define HW_LRADC2_THRSH_MIN_THRESHOLD_CLRMASK (~(WORD)HW_LRADC2_THRSH_MIN_THRESHOLD_SETMASK)     
                             7220 ; 362  |#define HW_LRADC2_THRSH_MAX_THRESHOLD_CLRMASK (~(WORD)HW_LRADC2_THRSH_MAX_THRESHOLD_SETMASK)     
                             7221 ; 363  |
                             7222 ; 364  |#define HW_LRADC2_THRSH      (*(volatile lradc_thrsh_type _X*) (HW_LRADC_BASEADDR+7))    /* LRADC2 Threshold Register */
                             7223 ; 365  |
                             7224 ; 366  |
                             7225 ; 367  |
                             7226 ; 368  |/////////////////////////////////////////////////////////////////////////////////
                             7227 ; 369  |//  LRADC2 Result Register (HW_LRADC2_RESULT) Bit Definitions
                             7228 ; 370  |#define HW_LRADC2_RESULT_EQ_EVENT1_WIDTH (1)
                             7229 ; 371  |#define HW_LRADC2_RESULT_EQ_EVENT0_WIDTH (1)
                             7230 ; 372  |#define HW_LRADC2_RESULT_GT_EVENT1_WIDTH (1)
                             7231 ; 373  |#define HW_LRADC2_RESULT_GT_EVENT0_WIDTH (1)
                             7232 ; 374  |#define HW_LRADC2_RESULT_LT_EVENT1_WIDTH (1)
                             7233 ; 375  |#define HW_LRADC2_RESULT_LT_EVENT0_WIDTH (1)
                             7234 ; 376  |#define HW_LRADC2_RESULT_RSVD0_WIDTH (2)
                             7235 ; 377  |#define HW_LRADC2_RESULT_DATA_OUT_WIDTH (9)
                             7236 ; 378  |#define HW_LRADC2_RESULT_RSVD1_WIDTH (3)
                             7237 ; 379  |#define HW_LRADC2_RESULT_IRQ_EVENT0_WIDTH (1)
                             7238 ; 380  |#define HW_LRADC2_RESULT_IRQ_EVENT1_WIDTH (1)
                             7239 ; 381  |#define HW_LRADC2_RESULT_RSVD2_WIDTH (2)
                             7240 ; 382  |
                             7241 ; 383  |#define HW_LRADC2_RESULT_EQ_EVENT1_BITPOS (0)
                             7242 ; 384  |#define HW_LRADC2_RESULT_EQ_EVENT0_BITPOS (1)
                             7243 ; 385  |#define HW_LRADC2_RESULT_GT_EVENT1_BITPOS (2)
                             7244 ; 386  |#define HW_LRADC2_RESULT_GT_EVENT0_BITPOS (3)
                             7245 ; 387  |#define HW_LRADC2_RESULT_LT_EVENT1_BITPOS (4)
                             7246 ; 388  |#define HW_LRADC2_RESULT_LT_EVENT0_BITPOS (5)
                             7247 ; 389  |#define HW_LRADC2_RESULT_RSVD0_BITPOS (6)
                             7248 ; 390  |#define HW_LRADC2_RESULT_DATA_OUT_BITPOS (8)
                             7249 ; 391  |#define HW_LRADC2_RESULT_RSVD1_BITPOS (17)
                             7250 ; 392  |#define HW_LRADC2_RESULT_IRQ_EVENT0_BITPOS (20)
                             7251 ; 393  |#define HW_LRADC2_RESULT_IRQ_EVENT1_BITPOS (21)
                             7252 ; 394  |#define HW_LRADC2_RESULT_RSVD2_BITPOS (22)
                             7253 ; 395  |
                             7254 ; 396  |#define HW_LRADC2_RESULT_EQ_EVENT1_SETMASK (((1<<HW_LRADC2_RESULT_EQ_EVENT1_WIDTH)-1)<<HW_LRADC2_RESULT_EQ_EVENT1_BITPOS)
                             7255 ; 397  |#define HW_LRADC2_RESULT_EQ_EVENT0_SETMASK (((1<<HW_LRADC2_RESULT_EQ_EVENT0_WIDTH)-1)<<HW_LRADC2_RESULT_EQ_EVENT0_BITPOS)
                             7256 ; 398  |#define HW_LRADC2_RESULT_GT_EVENT1_SETMASK (((1<<HW_LRADC2_RESULT_GT_EVENT1_WIDTH)-1)<<HW_LRADC2_RESULT_GT_EVENT1_BITPOS)
                             7257 ; 399  |#define HW_LRADC2_RESULT_GT_EVENT0_SETMASK (((1<<HW_LRADC2_RESULT_GT_EVENT0_WIDTH)-1)<<HW_LRADC2_RESULT_GT_EVENT0_BITPOS)
                             7258 ; 400  |#define HW_LRADC2_RESULT_LT_EVENT1_SETMASK (((1<<HW_LRADC2_RESULT_LT_EVENT1_WIDTH)-1)<<HW_LRADC2_RESULT_LT_EVENT1_BITPOS)
                             7259 ; 401  |#define HW_LRADC2_RESULT_LT_EVENT0_SETMASK (((1<<HW_LRADC2_RESULT_LT_EVENT0_WIDTH)-1)<<HW_LRADC2_RESULT_LT_EVENT0_BITPOS)
                             7260 ; 402  |#define HW_LRADC2_RESULT_RSVD0_SETMASK (((1<<HW_LRADC2_RESULT_RSVD0_WIDTH)-1)<<HW_LRADC2_RESULT_RSVD0_BITPOS)
                             7261 ; 403  |#define HW_LRADC2_RESULT_DATA_OUT_SETMASK (((1<<HW_LRADC2_RESULT_DATA_OUT_WIDTH)-1)<<HW_LRADC2_RESULT_DATA_OUT_BITPOS)
                             7262 ; 404  |#define HW_LRADC2_RESULT_RSVD1_SETMASK (((1<<HW_LRADC2_RESULT_RSVD1_WIDTH)-1)<<HW_LRADC2_RESULT_RSVD1_BITPOS)
                             7263 ; 405  |#define HW_LRADC2_RESULT_IRQ_EVENT0_SETMASK (((1<<HW_LRADC2_RESULT_IRQ_EVENT0_WIDTH)-1)<<HW_LRADC2_RESULT_IRQ_EVENT0_BITPOS)
                             7264 ; 406  |#define HW_LRADC2_RESULT_IRQ_EVENT1_SETMASK (((1<<HW_LRADC2_RESULT_IRQ_EVENT1_WIDTH)-1)<<HW_LRADC2_RESULT_IRQ_EVENT1_BITPOS)
                             7265 ; 407  |#define HW_LRADC2_RESULT_RSVD2_SETMASK (((1<<HW_LRADC2_RESULT_RSVD2_WIDTH)-1)<<HW_LRADC2_RESULT_RSVD2_BITPOS)
                             7266 ; 408  |
                             7267 ; 409  |#define HW_LRADC2_RESULT_EQ_EVENT1_CLRMASK (~(WORD)HW_LRADC2_RESULT_EQ_EVENT1_SETMASK)
                             7268 ; 410  |#define HW_LRADC2_RESULT_EQ_EVENT0_CLRMASK (~(WORD)HW_LRADC2_RESULT_EQ_EVENT0_SETMASK)
                             7269 ; 411  |#define HW_LRADC2_RESULT_GT_EVENT1_CLRMASK (~(WORD)HW_LRADC2_RESULT_GT_EVENT1_SETMASK)
                             7270 ; 412  |#define HW_LRADC2_RESULT_GT_EVENT0_CLRMASK (~(WORD)HW_LRADC2_RESULT_GT_EVENT0_SETMASK)
                             7271 ; 413  |#define HW_LRADC2_RESULT_LT_EVENT1_CLRMASK (~(WORD)HW_LRADC2_RESULT_LT_EVENT1_SETMASK)
                             7272 ; 414  |#define HW_LRADC2_RESULT_LT_EVENT0_CLRMASK (~(WORD)HW_LRADC2_RESULT_LT_EVENT0_SETMASK)
                             7273 ; 415  |#define HW_LRADC2_RESULT_RSVD0_CLRMASK (~(WORD)HW_LRADC2_RESULT_RSVD0_SETMASK)
                             7274 ; 416  |#define HW_LRADC2_RESULT_DATA_OUT_CLRMASK (~(WORD)HW_LRADC2_RESULT_DATA_OUT_SETMASK)
                             7275 ; 417  |#define HW_LRADC2_RESULT_RSVD1_CLRMASK (~(WORD)HW_LRADC2_RESULT_RSVD1_SETMASK)
                             7276 ; 418  |#define HW_LRADC2_RESULT_IRQ_EVENT0_CLRMASK (~(WORD)HW_LRADC2_RESULT_IRQ_EVENT0_SETMASK)
                             7277 ; 419  |#define HW_LRADC2_RESULT_IRQ_EVENT1_CLRMASK (~(WORD)HW_LRADC2_RESULT_IRQ_EVENT1_SETMASK)
                             7278 ; 420  |#define HW_LRADC2_RESULT_RSVD2_CLRMASK (~(WORD)HW_LRADC2_RESULT_RSVD2_SETMASK)
                             7279 ; 421  |
                             7280 ; 422  |#define HW_LRADC2_RESULT      (*(volatile lradc_result_type _X*) (HW_LRADC_BASEADDR+8))    /* LRADC2 Result Register */
                             7281 ; 423  |#define HW_LRADC_REF_0_SETMASK                  0x0<<HW_BATT_CTRL_REF_VAL_BITPOS
                             7282 ; 424  |#define HW_LRADC_REF_1_SETMASK                  0x1<<HW_BATT_CTRL_REF_VAL_BITPOS
                             7283 ; 425  |#define HW_LRADC_REF_2_SETMASK                  0x2<<HW_BATT_CTRL_REF_VAL_BITPOS
                             7284 ; 426  |#define HW_LRADC_REF_3_SETMASK                  0x3<<HW_BATT_CTRL_REF_VAL_BITPOS
                             7285 ; 427  |#define HW_LRADC_REF_4_SETMASK                  HW_LRADC_REF_0_SETMASK|HW_BATT_CTRL_INPUT_DIV2_SETMASK
                             7286 ; 428  |#define HW_LRADC_REF_5_SETMASK                  HW_LRADC_REF_1_SETMASK|HW_BATT_CTRL_INPUT_DIV2_SETMASK
                             7287 ; 429  |#define HW_LRADC_REF_6_SETMASK                  HW_LRADC_REF_2_SETMASK|HW_BATT_CTRL_INPUT_DIV2_SETMASK
                             7288 ; 430  |#define HW_LRADC_REF_7_SETMASK                  HW_LRADC_REF_3_SETMASK|HW_BATT_CTRL_INPUT_DIV2_SETMASK
                             7289 ; 431  |#define HW_LRADC_RES_REF_0                              80
                             7290 ; 432  |#define HW_LRADC_RES_REF_1                              77
                             7291 ; 433  |#define HW_LRADC_RES_REF_2                              100
                             7292 ; 434  |#define HW_LRADC_RES_REF_3                              129
                             7293 ; 435  |#define HW_LRADC_RES_REF_4                              160
                             7294 ; 436  |#define HW_LRADC_RES_REF_5                              154
                             7295 ; 437  |#define HW_LRADC_RES_REF_6                              200
                             7296 ; 438  |#define HW_LRADC_RES_REF_7                              258
                             7297 ; 439  |#define LRADC_HALF_POWER_SETMASK                HW_BATT_CTRL_HALF_CMP_PWR_SETMASK          
                             7298 ; 440  |// Translate the generic API enumerations into more meaningful labels for the implementation
                             7299 ; 441  |#define REF_2700MV                      HW_LRADC_REF_0_SETMASK
                             7300 ; 442  |#define REF_2600MV              HW_LRADC_REF_1_SETMASK
                             7301 ; 443  |#define REF_2560MV              HW_LRADC_REF_2_SETMASK
                             7302 ; 444  |#define REF_VDDIO               HW_LRADC_REF_3_SETMASK
                             7303 ; 445  |#define REF_5400MV              HW_LRADC_REF_4_SETMASK
                             7304 ; 446  |#define REF_5200MV              HW_LRADC_REF_5_SETMASK
                             7305 ; 447  |#define REF_5120MV              HW_LRADC_REF_6_SETMASK
                             7306 ; 448  |#define REF_VDDIOx2             HW_LRADC_REF_7_SETMASK
                             7307 ; 449  |#define RES_REF_2700MV  HW_LRADC_RES_REF_0
                             7308 ; 450  |#define RES_REF_2600MV  HW_LRADC_RES_REF_1
                             7309 ; 451  |#define RES_REF_2560MV  HW_LRADC_RES_REF_2
                             7310 ; 452  |#define RES_REF_VDDIO   HW_LRADC_RES_REF_3
                             7311 ; 453  |#define RES_REF_5400MV  HW_LRADC_RES_REF_4
                             7312 ; 454  |#define RES_REF_5200MV  HW_LRADC_RES_REF_5
                             7313 ; 455  |#define RES_REF_5120MV  HW_LRADC_RES_REF_6
                             7314 ; 456  |#define RES_REF_VDDIOx2         HW_LRADC_RES_REF_7
                             7315 ; 457  |
                             7316 ; 458  |//Needed by button.asm
                             7317 ; 459  |#define LOW_RES_ADC_BATT_READ_MASK 0x01FF00
                             7318 ; 460  |#define LOW_RES_ADC_AUX_READ_MASK 0x01FF00
                             7319 ; 461  |#define LOW_RES_ADC_AUX2_READ_MASK 0x01FF00
                             7320 ; 462  |
                             7321 ; 463  |#define HW_LRADC_CTRL_AUXADC_SETMASK 3<<HW_BATT_CTRL_REF_VAL_BITPOS
                             7322 ; 464  |
                             7323 ; 465  |#endif
                             7324 ; 466  |
                             7325 ; 467  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  30

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7326 
                             7328 
                             7329 ; 27   |#include "regspwm.h"
                             7330 
                             7332 
                             7333 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             7334 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             7335 ; 3    |// Filename: regspwm.inc
                             7336 ; 4    |// Description: Register definitions for PWM interface
                             7337 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             7338 ; 6    |// The following naming conventions are followed in this file.
                             7339 ; 7    |// All registers are named using the format...
                             7340 ; 8    |//     HW_<module>_<regname>
                             7341 ; 9    |// where <module> is the module name which can be any of the following...
                             7342 ; 10   |//     USB20
                             7343 ; 11   |// (Note that when there is more than one copy of a particular module, the
                             7344 ; 12   |// module name includes a number starting from 0 for the first instance of
                             7345 ; 13   |// that module)
                             7346 ; 14   |// <regname> is the specific register within that module
                             7347 ; 15   |// We also define the following...
                             7348 ; 16   |//     HW_<module>_<regname>_BITPOS
                             7349 ; 17   |// which defines the starting bit (i.e. LSB) of a multi bit field
                             7350 ; 18   |//     HW_<module>_<regname>_SETMASK
                             7351 ; 19   |// which does something else, and
                             7352 ; 20   |//     HW_<module>_<regname>_CLRMASK
                             7353 ; 21   |// which does something else.
                             7354 ; 22   |// Other rules
                             7355 ; 23   |//     All caps
                             7356 ; 24   |//     Numeric identifiers start at 0
                             7357 ; 25   |#if !(defined(regspwminc))
                             7358 ; 26   |#define regspwminc 1
                             7359 ; 27   |
                             7360 ; 28   |#include "types.h"
                             7361 
                             7363 
                             7364 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             7365 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             7366 ; 3    |//
                             7367 ; 4    |// Filename: types.h
                             7368 ; 5    |// Description: Standard data types
                             7369 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             7370 ; 7    |
                             7371 ; 8    |#ifndef _TYPES_H
                             7372 ; 9    |#define _TYPES_H
                             7373 ; 10   |
                             7374 ; 11   |// TODO:  move this outta here!
                             7375 ; 12   |#if !defined(NOERROR)
                             7376 ; 13   |#define NOERROR 0
                             7377 ; 14   |#define SUCCESS 0
                             7378 ; 15   |#endif 
                             7379 ; 16   |#if !defined(SUCCESS)
                             7380 ; 17   |#define SUCCESS  0
                             7381 ; 18   |#endif
                             7382 ; 19   |#if !defined(ERROR)
                             7383 ; 20   |#define ERROR   -1
                             7384 ; 21   |#endif
                             7385 ; 22   |#if !defined(FALSE)
                             7386 ; 23   |#define FALSE 0
                             7387 ; 24   |#endif
                             7388 ; 25   |#if !defined(TRUE)
                             7389 ; 26   |#define TRUE  1
                             7390 ; 27   |#endif
                             7391 ; 28   |
                             7392 ; 29   |#if !defined(NULL)
                             7393 ; 30   |#define NULL 0
                             7394 ; 31   |#endif
                             7395 ; 32   |
                             7396 ; 33   |#define MAX_INT     0x7FFFFF
                             7397 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             7398 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             7399 ; 36   |#define MAX_ULONG   (-1) 
                             7400 ; 37   |
                             7401 ; 38   |#define WORD_SIZE   24              // word size in bits
                             7402 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             7403 ; 40   |
                             7404 ; 41   |
                             7405 ; 42   |#define BYTE    unsigned char       // btVarName
                             7406 ; 43   |#define CHAR    signed char         // cVarName
                             7407 ; 44   |#define USHORT  unsigned short      // usVarName
                             7408 ; 45   |#define SHORT   unsigned short      // sVarName
                             7409 ; 46   |#define WORD    unsigned int        // wVarName
                             7410 ; 47   |#define INT     signed int          // iVarName
                             7411 ; 48   |#define DWORD   unsigned long       // dwVarName
                             7412 ; 49   |#define LONG    signed long         // lVarName
                             7413 ; 50   |#define BOOL    unsigned int        // bVarName
                             7414 ; 51   |#define FRACT   _fract              // frVarName
                             7415 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             7416 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             7417 ; 54   |#define FLOAT   float               // fVarName
                             7418 ; 55   |#define DBL     double              // dVarName
                             7419 ; 56   |#define ENUM    enum                // eVarName
                             7420 ; 57   |#define CMX     _complex            // cmxVarName
                             7421 ; 58   |typedef WORD UCS3;                   // 
                             7422 ; 59   |
                             7423 ; 60   |#define UINT16  unsigned short
                             7424 ; 61   |#define UINT8   unsigned char   
                             7425 ; 62   |#define UINT32  unsigned long
                             7426 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             7427 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             7428 ; 65   |#define WCHAR   UINT16
                             7429 ; 66   |
                             7430 ; 67   |//UINT128 is 16 bytes or 6 words
                             7431 ; 68   |typedef struct UINT128_3500 {   
                             7432 ; 69   |    int val[6];     
                             7433 ; 70   |} UINT128_3500;
                             7434 ; 71   |
                             7435 ; 72   |#define UINT128   UINT128_3500
                             7436 ; 73   |
                             7437 ; 74   |// Little endian word packed byte strings:   
                             7438 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             7439 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             7440 ; 77   |// Little endian word packed byte strings:   
                             7441 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             7442 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             7443 ; 80   |
                             7444 ; 81   |// Declare Memory Spaces To Use When Coding
                             7445 ; 82   |// A. Sector Buffers
                             7446 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             7447 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             7448 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             7449 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             7450 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             7451 ; 88   |// B. Media DDI Memory
                             7452 ; 89   |#define MEDIA_DDI_MEM _Y
                             7453 ; 90   |
                             7454 ; 91   |
                             7455 ; 92   |
                             7456 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             7457 ; 94   |// Examples of circular pointers:
                             7458 ; 95   |//    INT CIRC cpiVarName
                             7459 ; 96   |//    DWORD CIRC cpdwVarName
                             7460 ; 97   |
                             7461 ; 98   |#define RETCODE INT                 // rcVarName
                             7462 ; 99   |
                             7463 ; 100  |// generic bitfield structure
                             7464 ; 101  |struct Bitfield {
                             7465 ; 102  |    unsigned int B0  :1;
                             7466 ; 103  |    unsigned int B1  :1;
                             7467 ; 104  |    unsigned int B2  :1;
                             7468 ; 105  |    unsigned int B3  :1;
                             7469 ; 106  |    unsigned int B4  :1;
                             7470 ; 107  |    unsigned int B5  :1;
                             7471 ; 108  |    unsigned int B6  :1;
                             7472 ; 109  |    unsigned int B7  :1;
                             7473 ; 110  |    unsigned int B8  :1;
                             7474 ; 111  |    unsigned int B9  :1;
                             7475 ; 112  |    unsigned int B10 :1;
                             7476 ; 113  |    unsigned int B11 :1;
                             7477 ; 114  |    unsigned int B12 :1;
                             7478 ; 115  |    unsigned int B13 :1;
                             7479 ; 116  |    unsigned int B14 :1;
                             7480 ; 117  |    unsigned int B15 :1;
                             7481 ; 118  |    unsigned int B16 :1;
                             7482 ; 119  |    unsigned int B17 :1;
                             7483 ; 120  |    unsigned int B18 :1;
                             7484 ; 121  |    unsigned int B19 :1;
                             7485 ; 122  |    unsigned int B20 :1;
                             7486 ; 123  |    unsigned int B21 :1;
                             7487 ; 124  |    unsigned int B22 :1;
                             7488 ; 125  |    unsigned int B23 :1;
                             7489 ; 126  |};
                             7490 ; 127  |
                             7491 ; 128  |union BitInt {
                             7492 ; 129  |        struct Bitfield B;
                             7493 ; 130  |        int        I;
                             7494 ; 131  |};
                             7495 ; 132  |
                             7496 ; 133  |#define MAX_MSG_LENGTH 10
                             7497 ; 134  |struct CMessage
                             7498 ; 135  |{
                             7499 ; 136  |        unsigned int m_uLength;
                             7500 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             7501 ; 138  |};
                             7502 ; 139  |
                             7503 ; 140  |typedef struct {
                             7504 ; 141  |    WORD m_wLength;
                             7505 ; 142  |    WORD m_wMessage;
                             7506 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             7507 ; 144  |} Message;
                             7508 ; 145  |
                             7509 ; 146  |struct MessageQueueDescriptor
                             7510 ; 147  |{
                             7511 ; 148  |        int *m_pBase;
                             7512 ; 149  |        int m_iModulo;
                             7513 ; 150  |        int m_iSize;
                             7514 ; 151  |        int *m_pHead;
                             7515 ; 152  |        int *m_pTail;
                             7516 ; 153  |};
                             7517 ; 154  |
                             7518 ; 155  |struct ModuleEntry
                             7519 ; 156  |{
                             7520 ; 157  |    int m_iSignaledEventMask;
                             7521 ; 158  |    int m_iWaitEventMask;
                             7522 ; 159  |    int m_iResourceOfCode;
                             7523 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             7524 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             7525 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             7526 ; 163  |    int m_uTimeOutHigh;
                             7527 ; 164  |    int m_uTimeOutLow;
                             7528 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             7529 ; 166  |};
                             7530 ; 167  |
                             7531 ; 168  |union WaitMask{
                             7532 ; 169  |    struct B{
                             7533 ; 170  |        unsigned int m_bNone     :1;
                             7534 ; 171  |        unsigned int m_bMessage  :1;
                             7535 ; 172  |        unsigned int m_bTimer    :1;
                             7536 ; 173  |        unsigned int m_bButton   :1;
                             7537 ; 174  |    } B;
                             7538 ; 175  |    int I;
                             7539 ; 176  |} ;
                             7540 ; 177  |
                             7541 ; 178  |
                             7542 ; 179  |struct Button {
                             7543 ; 180  |        WORD wButtonEvent;
                             7544 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             7545 ; 182  |};
                             7546 ; 183  |
                             7547 ; 184  |struct Message {
                             7548 ; 185  |        WORD wMsgLength;
                             7549 ; 186  |        WORD wMsgCommand;
                             7550 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             7551 ; 188  |};
                             7552 ; 189  |
                             7553 ; 190  |union EventTypes {
                             7554 ; 191  |        struct CMessage msg;
                             7555 ; 192  |        struct Button Button ;
                             7556 ; 193  |        struct Message Message;
                             7557 ; 194  |};
                             7558 ; 195  |
                             7559 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             7560 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             7561 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             7562 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             7563 ; 200  |
                             7564 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             7565 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             7566 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             7567 ; 204  |
                             7568 ; 205  |#if DEBUG
                             7569 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             7570 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             7571 ; 208  |#else 
                             7572 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             7573 ; 210  |#define DebugBuildAssert(x)    
                             7574 ; 211  |#endif
                             7575 ; 212  |
                             7576 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             7577 ; 214  |//  #pragma asm
                             7578 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             7579 ; 216  |//  #pragma endasm
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  31

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7580 ; 217  |
                             7581 ; 218  |
                             7582 ; 219  |#ifdef COLOR_262K
                             7583 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             7584 ; 221  |#elif defined(COLOR_65K)
                             7585 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             7586 ; 223  |#else
                             7587 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             7588 ; 225  |#endif
                             7589 ; 226  |    
                             7590 ; 227  |#endif // #ifndef _TYPES_H
                             7591 
                             7593 
                             7594 ; 29   |
                             7595 ; 30   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             7596 ; 31   |//   Pulse Width Modulator STMP Registers 
                             7597 ; 32   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             7598 ; 33   |#define HW_PWM_BASEADDR (0xFA31)
                             7599 ; 34   |
                             7600 ; 35   |
                             7601 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                             7602 ; 37   |//  PWM CSR register (HW_PWM_CSR) Bit Definitions
                             7603 ; 38   |#define HW_PWM_CSR_PWM0_EN_BITPOS (0)
                             7604 ; 39   |#define HW_PWM_CSR_PWM1_EN_BITPOS (1) 
                             7605 ; 40   |#define HW_PWM_CSR_PWM2_EN_BITPOS (2)
                             7606 ; 41   |#define HW_PWM_CSR_PWM3_EN_BITPOS (3)
                             7607 ; 42   |#define HW_PWM_CSR_CDIV_BITPOS (8)
                             7608 ; 43   |#define HW_PWM_CSR_MSTR_EN_BITPOS (23)
                             7609 ; 44   |
                             7610 ; 45   |#define HW_PWM_CSR_PWM0_EN_WIDTH (1)
                             7611 ; 46   |#define HW_PWM_CSR_PWM1_EN_WIDTH (1) 
                             7612 ; 47   |#define HW_PWM_CSR_PWM2_EN_WIDTH (1)
                             7613 ; 48   |#define HW_PWM_CSR_PWM3_EN_WIDTH (1)
                             7614 ; 49   |#define HW_PWM_CSR_CDIV_WIDTH (2)
                             7615 ; 50   |#define HW_PWM_CSR_MSTR_EN_WIDTH (1)
                             7616 ; 51   |
                             7617 ; 52   |#define HW_PWM_CSR_PWM0_EN_SETMASK (((1<<HW_PWM_CSR_PWM0_EN_WIDTH)-1)<<HW_PWM_CSR_PWM0_EN_BITPOS)
                             7618 ; 53   |#define HW_PWM_CSR_PWM1_EN_SETMASK (((1<<HW_PWM_CSR_PWM1_EN_WIDTH)-1)<<HW_PWM_CSR_PWM1_EN_BITPOS)
                             7619 ; 54   |#define HW_PWM_CSR_PWM2_EN_SETMASK (((1<<HW_PWM_CSR_PWM2_EN_WIDTH)-1)<<HW_PWM_CSR_PWM2_EN_BITPOS)
                             7620 ; 55   |#define HW_PWM_CSR_PWM3_EN_SETMASK (((1<<HW_PWM_CSR_PWM3_EN_WIDTH)-1)<<HW_PWM_CSR_PWM3_EN_BITPOS)
                             7621 ; 56   |#define HW_PWM_CSR_CDIV_SETMASK (((1<<HW_PWM_CSR_CDIV_WIDTH)-1)<<HW_PWM_CSR_CDIV_BITPOS)
                             7622 ; 57   |#define HW_PWM_CSR_MSTR_EN_SETMASK (((1<<HW_PWM_CSR_MSTR_EN_WIDTH)-1)<<HW_PWM_CSR_MSTR_EN_BITPOS)
                             7623 ; 58   |
                             7624 ; 59   |#define HW_PWM_CSR_PWM0_EN_CLRMASK (~(WORD)HW_PWM_CSR_PWM0_EN_SETMASK)
                             7625 ; 60   |#define HW_PWM_CSR_PWM1_EN_CLRMASK (~(WORD)HW_PWM_CSR_PWM1_EN_SETMASK)
                             7626 ; 61   |#define HW_PWM_CSR_PWM2_EN_CLRMASK (~(WORD)HW_PWM_CSR_PWM2_EN_SETMASK)
                             7627 ; 62   |#define HW_PWM_CSR_PWM3_EN_CLRMASK (~(WORD)HW_PWM_CSR_PWM3_EN_SETMASK)
                             7628 ; 63   |#define HW_PWM_CSR_CDIV_CLRMASK (~(WORD)HW_PWM_CSR_CDIV_SETMASK)   
                             7629 ; 64   |#define HW_PWM_CSR_MSTR_EN_CLRMASK (~(WORD)HW_PWM_CSR_MSTR_EN_SETMASK)
                             7630 ; 65   |
                             7631 ; 66   |typedef union               
                             7632 ; 67   |{
                             7633 ; 68   |    struct {
                             7634 ; 69   |        int PWM0_EN                    :1;
                             7635 ; 70   |        int PWM1_EN                    :1;
                             7636 ; 71   |        int PWM2_EN                    :1;
                             7637 ; 72   |        int PWM3_EN                    :1;
                             7638 ; 73   |        int RSVD0                      :4;
                             7639 ; 74   |        int CDIV                       :2;
                             7640 ; 75   |        int RSVD1                      :13;
                             7641 ; 76   |        int MSTR_EN                    :1;
                             7642 ; 77   |    } B;
                             7643 ; 78   |    int I;
                             7644 ; 79   |} pwmcsr_type;
                             7645 ; 80   |#define HW_PWM_CSR        (*(volatile pwmcsr_type _X*) (HW_PWM_BASEADDR))  /* PWM Control Status Register */
                             7646 ; 81   |
                             7647 ; 82   |/////////////////////////////////////////////////////////////////////////////////
                             7648 ; 83   |//  PWM CHANNEL 0 A  (HW_PWM_CH0AR) Bit Definitions
                             7649 ; 84   |#define HW_PWM_CH0AR_ACTIVE_BITPOS (0)
                             7650 ; 85   |#define HW_PWM_CH0AR_INACTIVE_BITPOS (12)
                             7651 ; 86   |
                             7652 ; 87   |#define HW_PWM_CH0AR_ACTIVE_WIDTH (12)
                             7653 ; 88   |#define HW_PWM_CH0AR_INACTIVE_WIDTH (12)
                             7654 ; 89   |
                             7655 ; 90   |#define HW_PWM_CH0AR_ACTIVE_SETMASK (((1<<HW_PWM_CH0AR_ACTIVE_WIDTH)-1)<<HW_PWM_CH0AR_ACTIVE_BITPOS)
                             7656 ; 91   |#define HW_PWM_CH0AR_INACTIVE_SETMASK (((1<<HW_PWM_CH0AR_INACTIVE_WIDTH)-1)<<HW_PWM_CH0AR_INACTIVE_BITPOS)
                             7657 ; 92   |
                             7658 ; 93   |#define HW_PWM_CH0AR_ACTIVE_CLRMASK (~(WORD)HW_PWM_CH0AR_ACTIVE_SETMASK)
                             7659 ; 94   |#define HW_PWM_CH0AR_INACTIVE_CLRMASK (~(WORD)HW_PWM_CH0AR_INACTIVE_SETMASK)
                             7660 ; 95   |
                             7661 ; 96   |/////////////////////////////////////////////////////////////////////////////////
                             7662 ; 97   |//  PWM CHANNEL 0 B  (HW_PWM_CH0BR) Bit Definitions
                             7663 ; 98   |#define HW_PWM_CH0BR_ACTIVE_BITPOS (0)
                             7664 ; 99   |#define HW_PWM_CH0BR_INACTIVE_BITPOS (12)
                             7665 ; 100  |
                             7666 ; 101  |#define HW_PWM_CH0BR_ACTIVE_WIDTH (12)
                             7667 ; 102  |#define HW_PWM_CH0BR_INACTIVE_WIDTH (12)
                             7668 ; 103  |
                             7669 ; 104  |#define HW_PWM_CH0BR_ACTIVE_SETMASK (((1<<HW_PWM_CH0BR_ACTIVE_WIDTH)-1)<<HW_PWM_CH0BR_ACTIVE_BITPOS)
                             7670 ; 105  |#define HW_PWM_CH0BR_INACTIVE_SETMASK (((1<<HW_PWM_CH0BR_INACTIVE_WIDTH)-1)<<HW_PWM_CH0BR_INACTIVE_BITPOS)
                             7671 ; 106  |
                             7672 ; 107  |#define HW_PWM_CH0BR_ACTIVE_CLRMASK (~(WORD)HW_PWM_CH0BR_ACTIVE_SETMASK)
                             7673 ; 108  |#define HW_PWM_CH0BR_INACTIVE_CLRMASK (~(WORD)HW_PWM_CH0BR_INACTIVE_SETMASK)
                             7674 ; 109  |
                             7675 ; 110  |/////////////////////////////////////////////////////////////////////////////////
                             7676 ; 111  |//  PWM CHANNEL 1 A  (HW_PWM_CH1AR) Bit Definitions
                             7677 ; 112  |#define HW_PWM_CH1AR_ACTIVE_BITPOS (0)
                             7678 ; 113  |#define HW_PWM_CH1AR_INACTIVE_BITPOS (12)
                             7679 ; 114  |
                             7680 ; 115  |#define HW_PWM_CH1AR_ACTIVE_WIDTH (12)
                             7681 ; 116  |#define HW_PWM_CH1AR_INACTIVE_WIDTH (12)
                             7682 ; 117  |
                             7683 ; 118  |#define HW_PWM_CH1AR_ACTIVE_SETMASK (((1<<HW_PWM_CH1AR_ACTIVE_WIDTH)-1)<<HW_PWM_CH1AR_ACTIVE_BITPOS)
                             7684 ; 119  |#define HW_PWM_CH1AR_INACTIVE_SETMASK (((1<<HW_PWM_CH1AR_INACTIVE_WIDTH)-1)<<HW_PWM_CH1AR_INACTIVE_BITPOS)
                             7685 ; 120  |
                             7686 ; 121  |#define HW_PWM_CH1AR_ACTIVE_CLRMASK (~(WORD)HW_PWM_CH1AR_ACTIVE_SETMASK)
                             7687 ; 122  |#define HW_PWM_CH1AR_INACTIVE_CLRMASK (~(WORD)HW_PWM_CH1AR_INACTIVE_SETMASK)
                             7688 ; 123  |
                             7689 ; 124  |/////////////////////////////////////////////////////////////////////////////////
                             7690 ; 125  |//  PWM CHANNEL 1 B  (HW_PWM_CH1BR) Bit Definitions
                             7691 ; 126  |#define HW_PWM_CH1BR_ACTIVE_BITPOS (0)
                             7692 ; 127  |#define HW_PWM_CH1BR_INACTIVE_BITPOS (12)
                             7693 ; 128  |
                             7694 ; 129  |#define HW_PWM_CH1BR_ACTIVE_WIDTH (12)
                             7695 ; 130  |#define HW_PWM_CH1BR_INACTIVE_WIDTH (12)
                             7696 ; 131  |
                             7697 ; 132  |#define HW_PWM_CH1BR_ACTIVE_SETMASK (((1<<HW_PWM_CH1BR_ACTIVE_WIDTH)-1)<<HW_PWM_CH1BR_ACTIVE_BITPOS)
                             7698 ; 133  |#define HW_PWM_CH1BR_INACTIVE_SETMASK (((1<<HW_PWM_CH1BR_INACTIVE_WIDTH)-1)<<HW_PWM_CH1BR_INACTIVE_BITPOS)
                             7699 ; 134  |
                             7700 ; 135  |#define HW_PWM_CH1BR_ACTIVE_CLRMASK (~(WORD)HW_PWM_CH1BR_ACTIVE_SETMASK)
                             7701 ; 136  |#define HW_PWM_CH1BR_INACTIVE_CLRMASK (~(WORD)HW_PWM_CH1BR_INACTIVE_SETMASK)
                             7702 ; 137  |
                             7703 ; 138  |/////////////////////////////////////////////////////////////////////////////////
                             7704 ; 139  |//  PWM CHANNEL 2 A  (HW_PWM_CH2AR) Bit Definitions
                             7705 ; 140  |#define HW_PWM_CH2AR_ACTIVE_BITPOS (0)
                             7706 ; 141  |#define HW_PWM_CH2AR_INACTIVE_BITPOS (12)
                             7707 ; 142  |
                             7708 ; 143  |#define HW_PWM_CH2AR_ACTIVE_WIDTH (12)
                             7709 ; 144  |#define HW_PWM_CH2AR_INACTIVE_WIDTH (12)
                             7710 ; 145  |
                             7711 ; 146  |#define HW_PWM_CH2AR_ACTIVE_SETMASK (((1<<HW_PWM_CH2AR_ACTIVE_WIDTH)-1)<<HW_PWM_CH2AR_ACTIVE_BITPOS)
                             7712 ; 147  |#define HW_PWM_CH2AR_INACTIVE_SETMASK (((1<<HW_PWM_CH2AR_INACTIVE_WIDTH)-1)<<HW_PWM_CH2AR_INACTIVE_BITPOS)
                             7713 ; 148  |
                             7714 ; 149  |#define HW_PWM_CH2AR_ACTIVE_CLRMASK (~(WORD)HW_PWM_CH2AR_ACTIVE_SETMASK)
                             7715 ; 150  |#define HW_PWM_CH2AR_INACTIVE_CLRMASK (~(WORD)HW_PWM_CH2AR_INACTIVE_SETMASK)
                             7716 ; 151  |
                             7717 ; 152  |/////////////////////////////////////////////////////////////////////////////////
                             7718 ; 153  |//  PWM CHANNEL 2 B  (HW_PWM_CH2BR) Bit Definitions
                             7719 ; 154  |#define HW_PWM_CH2BR_ACTIVE_BITPOS (0)
                             7720 ; 155  |#define HW_PWM_CH2BR_INACTIVE_BITPOS (12)
                             7721 ; 156  |
                             7722 ; 157  |#define HW_PWM_CH2BR_ACTIVE_WIDTH (12)
                             7723 ; 158  |#define HW_PWM_CH2BR_INACTIVE_WIDTH (12)
                             7724 ; 159  |
                             7725 ; 160  |#define HW_PWM_CH2BR_ACTIVE_SETMASK (((1<<HW_PWM_CH2BR_ACTIVE_WIDTH)-1)<<HW_PWM_CH2BR_ACTIVE_BITPOS)
                             7726 ; 161  |#define HW_PWM_CH2BR_INACTIVE_SETMASK (((1<<HW_PWM_CH2BR_INACTIVE_WIDTH)-1)<<HW_PWM_CH2BR_INACTIVE_BITPOS)
                             7727 ; 162  |
                             7728 ; 163  |#define HW_PWM_CH2BR_ACTIVE_CLRMASK (~(WORD)HW_PWM_CH2BR_ACTIVE_SETMASK)
                             7729 ; 164  |#define HW_PWM_CH2BR_INACTIVE_CLRMASK (~(WORD)HW_PWM_CH2BR_INACTIVE_SETMASK)
                             7730 ; 165  |
                             7731 ; 166  |/////////////////////////////////////////////////////////////////////////////////
                             7732 ; 167  |//  PWM CHANNEL 3 A  (HW_PWM_CH3AR) Bit Definitions
                             7733 ; 168  |#define HW_PWM_CH3AR_ACTIVE_BITPOS (0)
                             7734 ; 169  |#define HW_PWM_CH3AR_INACTIVE_BITPOS (12)
                             7735 ; 170  |
                             7736 ; 171  |#define HW_PWM_CH3AR_ACTIVE_WIDTH (12)
                             7737 ; 172  |#define HW_PWM_CH3AR_INACTIVE_WIDTH (12)
                             7738 ; 173  |
                             7739 ; 174  |#define HW_PWM_CH3AR_ACTIVE_SETMASK (((1<<HW_PWM_CH3AR_ACTIVE_WIDTH)-1)<<HW_PWM_CH3AR_ACTIVE_BITPOS)
                             7740 ; 175  |#define HW_PWM_CH3AR_INACTIVE_SETMASK (((1<<HW_PWM_CH3AR_INACTIVE_WIDTH)-1)<<HW_PWM_CH3AR_INACTIVE_BITPOS)
                             7741 ; 176  |
                             7742 ; 177  |#define HW_PWM_CH3AR_ACTIVE_CLRMASK (~(WORD)HW_PWM_CH3AR_ACTIVE_SETMASK)
                             7743 ; 178  |#define HW_PWM_CH3AR_INACTIVE_CLRMASK (~(WORD)HW_PWM_CH3AR_INACTIVE_SETMASK)
                             7744 ; 179  |
                             7745 ; 180  |/////////////////////////////////////////////////////////////////////////////////
                             7746 ; 181  |//  PWM CHANNEL 3 B  (HW_PWM_CH3BR) Bit Definitions
                             7747 ; 182  |#define HW_PWM_CH3BR_ACTIVE_BITPOS (0)
                             7748 ; 183  |#define HW_PWM_CH3BR_INACTIVE_BITPOS (12)
                             7749 ; 184  |
                             7750 ; 185  |#define HW_PWM_CH3BR_ACTIVE_WIDTH (12)
                             7751 ; 186  |#define HW_PWM_CH3BR_INACTIVE_WIDTH (12)
                             7752 ; 187  |
                             7753 ; 188  |#define HW_PWM_CH3BR_ACTIVE_SETMASK (((1<<HW_PWM_CH3BR_ACTIVE_WIDTH)-1)<<HW_PWM_CH3BR_ACTIVE_BITPOS)
                             7754 ; 189  |#define HW_PWM_CH3BR_INACTIVE_SETMASK (((1<<HW_PWM_CH3BR_INACTIVE_WIDTH)-1)<<HW_PWM_CH3BR_INACTIVE_BITPOS)
                             7755 ; 190  |
                             7756 ; 191  |#define HW_PWM_CH3BR_ACTIVE_CLRMASK (~(WORD)HW_PWM_CH3BR_ACTIVE_SETMASK)
                             7757 ; 192  |#define HW_PWM_CH3BR_INACTIVE_CLRMASK (~(WORD)HW_PWM_CH3BR_INACTIVE_SETMASK)
                             7758 ; 193  |
                             7759 ; 194  |typedef union               
                             7760 ; 195  |{
                             7761 ; 196  |    struct {
                             7762 ; 197  |       int ACTIVE                    :12;
                             7763 ; 198  |       int INACTIVE                  :12;
                             7764 ; 199  |    } B;
                             7765 ; 200  |    int I;
                             7766 ; 201  |} pwmchan_type;
                             7767 ; 202  |#define HW_PWM_CH0AR        (*(volatile pwmchan_type _X*) (HW_PWM_BASEADDR+1))  /* PWM Channel 0 A Register */
                             7768 ; 203  |#define HW_PWM_CH0BR        (*(volatile pwmchan_type _X*) (HW_PWM_BASEADDR+2))  /* PWM Channel 0 B Register */
                             7769 ; 204  |#define HW_PWM_CH1AR        (*(volatile pwmchan_type _X*) (HW_PWM_BASEADDR+3))  /* PWM Channel 1 A Register */
                             7770 ; 205  |#define HW_PWM_CH1BR        (*(volatile pwmchan_type _X*) (HW_PWM_BASEADDR+4))  /* PWM Channel 1 B Register */
                             7771 ; 206  |#define HW_PWM_CH2AR        (*(volatile pwmchan_type _X*) (HW_PWM_BASEADDR+5))  /* PWM Channel 2 A Register */
                             7772 ; 207  |#define HW_PWM_CH2BR        (*(volatile pwmchan_type _X*) (HW_PWM_BASEADDR+6))  /* PWM Channel 2 B Register */
                             7773 ; 208  |#define HW_PWM_CH3AR        (*(volatile pwmchan_type _X*) (HW_PWM_BASEADDR+7))  /* PWM Channel 3 A Register */
                             7774 ; 209  |#define HW_PWM_CH3BR        (*(volatile pwmchan_type _X*) (HW_PWM_BASEADDR+8))  /* PWM Channel 3 B Register */
                             7775 ; 210  |
                             7776 ; 211  |#endif
                             7777 ; 212  |
                             7778 ; 213  |
                             7779 ; 214  |
                             7780 ; 215  |
                             7781 
                             7783 
                             7784 ; 28   |#include "regsrevision.h"
                             7785 
                             7787 
                             7788 ; 1    |#if !(defined(__HW_REVR))
                             7789 ; 2    |#define __HW_REVR 1
                             7790 ; 3    |
                             7791 ; 4    |
                             7792 ; 5    |#define HW_GLUE_BASEADDR 0xFA00
                             7793 ; 6    |
                             7794 ; 7    |#define HW_REVR_RMN_BITPOS (0)
                             7795 ; 8    |#define HW_REVR_DCDCMODE_BITPOS (5)
                             7796 ; 9    |#define HW_REVR_RMJ_BITPOS (8)
                             7797 ; 10   |
                             7798 ; 11   |#define HW_REVR_RMN_WIDTH (5)
                             7799 ; 12   |#define HW_REVR_DCDCMODE_WIDTH (3)
                             7800 ; 13   |
                             7801 ; 14   |#define HW_REVR_DCDCMODE_SETMASK (((1<<HW_REVR_DCDCMODE_WIDTH)-1)<<HW_REVR_DCDCMODE_BITPOS)
                             7802 ; 15   |
                             7803 ; 16   |#define HW_REVR_DCDCMODE_CLRMASK (~(WORD)HW_REVR_DCDCMODE_SETMASK)
                             7804 ; 17   |
                             7805 ; 18   |
                             7806 ; 19   |/////////////////////////////////////////////////////////////////////////////////
                             7807 ; 20   |//  Revision Register (HW_REVR) bitfields and values. (read only)
                             7808 ; 21   |//  June15 2004: C struct updated to be correct: 
                             7809 ; 22   |//   Added DCDCMODE bitfield. Removed RMP bitfield. Reduced size of RMN bitfield to 5 bits.
                             7810 ; 23   |typedef union               
                             7811 ; 24   |{
                             7812 ; 25   |    struct {
                             7813 ; 26   |        unsigned RMN    :5;     //Minor Revision
                             7814 ; 27   |        unsigned DCDCMODE : 3;  //DCDC mode field function depends on DCDC mode pin strapping
                             7815 ; 28   |           #define DCDCMODE_7_CONVERTER1_2CH_BOOST_CONVERTER2_OFF      7
                             7816 ; 29   |           #define DCDCMODE_6_RESERVED                                 6
                             7817 ; 30   |           #define DCDCMODE_5_CONVERTER1_3CH_BOOST_CONVERTER2_OFF      5
                             7818 ; 31   |           #define DCDCMODE_4_RESERVED                                 4
                             7819 ; 32   |           #define DCDCMODE_3_CONVERTER1_1CH_BUCK_CONVERTER2_OFF       3
                             7820 ; 33   |           #define DCDCMODE_2_CONVERTER1_OFF_CONVERTER2_OFF            2
                             7821 ; 34   |           #define DCDCMODE_1_CONVERTER1_1CH_BUCK_CONVERTER2_1CH_BOOST 1
                             7822 ; 35   |           #define DCDCMODE_0_CONVERTER1_1CH_BUCK_CONVERTER2_1CH_BUCK  0
                             7823 ; 36   |           #define DCDCMODE_X_BUCK_MASKED_SETMASK 0x4
                             7824 ; 37   |        unsigned RMJ    :16;    //Major Revision
                             7825 ; 38   |    } B;
                             7826 ; 39   |
                             7827 ; 40   |    int I;
                             7828 ; 41   |
                             7829 ; 42   |} revr_type;
                             7830 ; 43   |#define HW_REVR (*(volatile revr_type _X*) (HW_GLUE_BASEADDR+2))
                             7831 ; 44   |
                             7832 ; 45   |#define HW_REVR_DCDCMODE_B0_BITPOS 5
                             7833 ; 46   |#define HW_REVR_DCDCMODE_B1_BITPOS 6
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  32

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7834 ; 47   |#define HW_REVR_DCDCMODE_B2_BITPOS 7
                             7835 ; 48   |
                             7836 ; 49   |#define HW_REVR_DCDCMODE_BUCK_MASK_POS HW_REVR_DCDCMODE_B2_BITPOS
                             7837 ; 50   |// 3 bit bitfield: (HW_REVR_DCDCMODE_B2_BITPOS|HW_REVR_DCDCMODE_B1_BITPOS|HW_REVR_DCDCMODE_B0_BITPOS)
                             7838 ; 51   |#define HW_REVR_DCDC_MODE_SETMASK 0x0000E0
                             7839 ; 52   |#define HW_REVR_RMN_SETMASK 0xFF<<HW_REVR_RMN_BITPOS
                             7840 ; 53   |#define HW_REVR_RMJ_SETMASK 0xFFFF<<HW_REVR_RMJ_BITPOS
                             7841 ; 54   |
                             7842 ; 55   |#define HW_REVR_RMN_CLRMASK ~(WORD)HW_REVR_RMN_SETMASK
                             7843 ; 56   |#define HW_REVR_RMJ_CLRMASK ~(WORD)HW_REVR_RMJ_SETMASK
                             7844 ; 57   |
                             7845 ; 58   |#endif //!@def(__HW_REVR)
                             7846 ; 59   |
                             7847 
                             7849 
                             7850 ; 29   |#include "regsrtc.h"
                             7851 
                             7853 
                             7854 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             7855 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             7856 ; 3    |// Filename: regsrtc.inc
                             7857 ; 4    |// Description: Register definitions for RTC interface
                             7858 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             7859 ; 6    |// The following naming conventions are followed in this file.
                             7860 ; 7    |// All registers are named using the format...
                             7861 ; 8    |//     HW_<module>_<regname>
                             7862 ; 9    |// where <module> is the module name which can be any of the following...
                             7863 ; 10   |//     USB20
                             7864 ; 11   |// (Note that when there is more than one copy of a particular module, the
                             7865 ; 12   |// module name includes a number starting from 0 for the first instance of
                             7866 ; 13   |// that module)
                             7867 ; 14   |// <regname> is the specific register within that module
                             7868 ; 15   |// We also define the following...
                             7869 ; 16   |//     HW_<module>_<regname>_BITPOS
                             7870 ; 17   |// which defines the starting bit (i.e. LSB) of a multi bit field
                             7871 ; 18   |//     HW_<module>_<regname>_SETMASK
                             7872 ; 19   |// which does something else, and
                             7873 ; 20   |//     HW_<module>_<regname>_CLRMASK
                             7874 ; 21   |// which does something else.
                             7875 ; 22   |// Other rules
                             7876 ; 23   |//     All caps
                             7877 ; 24   |//     Numeric identifiers start at 0
                             7878 ; 25   |#if !(defined(regsrtcinc))
                             7879 ; 26   |#define regsrtcinc 1
                             7880 ; 27   |
                             7881 ; 28   |#include "types.h"
                             7882 
                             7884 
                             7885 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             7886 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             7887 ; 3    |//
                             7888 ; 4    |// Filename: types.h
                             7889 ; 5    |// Description: Standard data types
                             7890 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             7891 ; 7    |
                             7892 ; 8    |#ifndef _TYPES_H
                             7893 ; 9    |#define _TYPES_H
                             7894 ; 10   |
                             7895 ; 11   |// TODO:  move this outta here!
                             7896 ; 12   |#if !defined(NOERROR)
                             7897 ; 13   |#define NOERROR 0
                             7898 ; 14   |#define SUCCESS 0
                             7899 ; 15   |#endif 
                             7900 ; 16   |#if !defined(SUCCESS)
                             7901 ; 17   |#define SUCCESS  0
                             7902 ; 18   |#endif
                             7903 ; 19   |#if !defined(ERROR)
                             7904 ; 20   |#define ERROR   -1
                             7905 ; 21   |#endif
                             7906 ; 22   |#if !defined(FALSE)
                             7907 ; 23   |#define FALSE 0
                             7908 ; 24   |#endif
                             7909 ; 25   |#if !defined(TRUE)
                             7910 ; 26   |#define TRUE  1
                             7911 ; 27   |#endif
                             7912 ; 28   |
                             7913 ; 29   |#if !defined(NULL)
                             7914 ; 30   |#define NULL 0
                             7915 ; 31   |#endif
                             7916 ; 32   |
                             7917 ; 33   |#define MAX_INT     0x7FFFFF
                             7918 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             7919 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             7920 ; 36   |#define MAX_ULONG   (-1) 
                             7921 ; 37   |
                             7922 ; 38   |#define WORD_SIZE   24              // word size in bits
                             7923 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             7924 ; 40   |
                             7925 ; 41   |
                             7926 ; 42   |#define BYTE    unsigned char       // btVarName
                             7927 ; 43   |#define CHAR    signed char         // cVarName
                             7928 ; 44   |#define USHORT  unsigned short      // usVarName
                             7929 ; 45   |#define SHORT   unsigned short      // sVarName
                             7930 ; 46   |#define WORD    unsigned int        // wVarName
                             7931 ; 47   |#define INT     signed int          // iVarName
                             7932 ; 48   |#define DWORD   unsigned long       // dwVarName
                             7933 ; 49   |#define LONG    signed long         // lVarName
                             7934 ; 50   |#define BOOL    unsigned int        // bVarName
                             7935 ; 51   |#define FRACT   _fract              // frVarName
                             7936 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             7937 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             7938 ; 54   |#define FLOAT   float               // fVarName
                             7939 ; 55   |#define DBL     double              // dVarName
                             7940 ; 56   |#define ENUM    enum                // eVarName
                             7941 ; 57   |#define CMX     _complex            // cmxVarName
                             7942 ; 58   |typedef WORD UCS3;                   // 
                             7943 ; 59   |
                             7944 ; 60   |#define UINT16  unsigned short
                             7945 ; 61   |#define UINT8   unsigned char   
                             7946 ; 62   |#define UINT32  unsigned long
                             7947 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             7948 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             7949 ; 65   |#define WCHAR   UINT16
                             7950 ; 66   |
                             7951 ; 67   |//UINT128 is 16 bytes or 6 words
                             7952 ; 68   |typedef struct UINT128_3500 {   
                             7953 ; 69   |    int val[6];     
                             7954 ; 70   |} UINT128_3500;
                             7955 ; 71   |
                             7956 ; 72   |#define UINT128   UINT128_3500
                             7957 ; 73   |
                             7958 ; 74   |// Little endian word packed byte strings:   
                             7959 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             7960 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             7961 ; 77   |// Little endian word packed byte strings:   
                             7962 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             7963 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             7964 ; 80   |
                             7965 ; 81   |// Declare Memory Spaces To Use When Coding
                             7966 ; 82   |// A. Sector Buffers
                             7967 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             7968 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             7969 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             7970 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             7971 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             7972 ; 88   |// B. Media DDI Memory
                             7973 ; 89   |#define MEDIA_DDI_MEM _Y
                             7974 ; 90   |
                             7975 ; 91   |
                             7976 ; 92   |
                             7977 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             7978 ; 94   |// Examples of circular pointers:
                             7979 ; 95   |//    INT CIRC cpiVarName
                             7980 ; 96   |//    DWORD CIRC cpdwVarName
                             7981 ; 97   |
                             7982 ; 98   |#define RETCODE INT                 // rcVarName
                             7983 ; 99   |
                             7984 ; 100  |// generic bitfield structure
                             7985 ; 101  |struct Bitfield {
                             7986 ; 102  |    unsigned int B0  :1;
                             7987 ; 103  |    unsigned int B1  :1;
                             7988 ; 104  |    unsigned int B2  :1;
                             7989 ; 105  |    unsigned int B3  :1;
                             7990 ; 106  |    unsigned int B4  :1;
                             7991 ; 107  |    unsigned int B5  :1;
                             7992 ; 108  |    unsigned int B6  :1;
                             7993 ; 109  |    unsigned int B7  :1;
                             7994 ; 110  |    unsigned int B8  :1;
                             7995 ; 111  |    unsigned int B9  :1;
                             7996 ; 112  |    unsigned int B10 :1;
                             7997 ; 113  |    unsigned int B11 :1;
                             7998 ; 114  |    unsigned int B12 :1;
                             7999 ; 115  |    unsigned int B13 :1;
                             8000 ; 116  |    unsigned int B14 :1;
                             8001 ; 117  |    unsigned int B15 :1;
                             8002 ; 118  |    unsigned int B16 :1;
                             8003 ; 119  |    unsigned int B17 :1;
                             8004 ; 120  |    unsigned int B18 :1;
                             8005 ; 121  |    unsigned int B19 :1;
                             8006 ; 122  |    unsigned int B20 :1;
                             8007 ; 123  |    unsigned int B21 :1;
                             8008 ; 124  |    unsigned int B22 :1;
                             8009 ; 125  |    unsigned int B23 :1;
                             8010 ; 126  |};
                             8011 ; 127  |
                             8012 ; 128  |union BitInt {
                             8013 ; 129  |        struct Bitfield B;
                             8014 ; 130  |        int        I;
                             8015 ; 131  |};
                             8016 ; 132  |
                             8017 ; 133  |#define MAX_MSG_LENGTH 10
                             8018 ; 134  |struct CMessage
                             8019 ; 135  |{
                             8020 ; 136  |        unsigned int m_uLength;
                             8021 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             8022 ; 138  |};
                             8023 ; 139  |
                             8024 ; 140  |typedef struct {
                             8025 ; 141  |    WORD m_wLength;
                             8026 ; 142  |    WORD m_wMessage;
                             8027 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             8028 ; 144  |} Message;
                             8029 ; 145  |
                             8030 ; 146  |struct MessageQueueDescriptor
                             8031 ; 147  |{
                             8032 ; 148  |        int *m_pBase;
                             8033 ; 149  |        int m_iModulo;
                             8034 ; 150  |        int m_iSize;
                             8035 ; 151  |        int *m_pHead;
                             8036 ; 152  |        int *m_pTail;
                             8037 ; 153  |};
                             8038 ; 154  |
                             8039 ; 155  |struct ModuleEntry
                             8040 ; 156  |{
                             8041 ; 157  |    int m_iSignaledEventMask;
                             8042 ; 158  |    int m_iWaitEventMask;
                             8043 ; 159  |    int m_iResourceOfCode;
                             8044 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             8045 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             8046 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             8047 ; 163  |    int m_uTimeOutHigh;
                             8048 ; 164  |    int m_uTimeOutLow;
                             8049 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             8050 ; 166  |};
                             8051 ; 167  |
                             8052 ; 168  |union WaitMask{
                             8053 ; 169  |    struct B{
                             8054 ; 170  |        unsigned int m_bNone     :1;
                             8055 ; 171  |        unsigned int m_bMessage  :1;
                             8056 ; 172  |        unsigned int m_bTimer    :1;
                             8057 ; 173  |        unsigned int m_bButton   :1;
                             8058 ; 174  |    } B;
                             8059 ; 175  |    int I;
                             8060 ; 176  |} ;
                             8061 ; 177  |
                             8062 ; 178  |
                             8063 ; 179  |struct Button {
                             8064 ; 180  |        WORD wButtonEvent;
                             8065 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             8066 ; 182  |};
                             8067 ; 183  |
                             8068 ; 184  |struct Message {
                             8069 ; 185  |        WORD wMsgLength;
                             8070 ; 186  |        WORD wMsgCommand;
                             8071 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             8072 ; 188  |};
                             8073 ; 189  |
                             8074 ; 190  |union EventTypes {
                             8075 ; 191  |        struct CMessage msg;
                             8076 ; 192  |        struct Button Button ;
                             8077 ; 193  |        struct Message Message;
                             8078 ; 194  |};
                             8079 ; 195  |
                             8080 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             8081 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             8082 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             8083 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             8084 ; 200  |
                             8085 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             8086 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             8087 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  33

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8088 ; 204  |
                             8089 ; 205  |#if DEBUG
                             8090 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             8091 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             8092 ; 208  |#else 
                             8093 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             8094 ; 210  |#define DebugBuildAssert(x)    
                             8095 ; 211  |#endif
                             8096 ; 212  |
                             8097 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             8098 ; 214  |//  #pragma asm
                             8099 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             8100 ; 216  |//  #pragma endasm
                             8101 ; 217  |
                             8102 ; 218  |
                             8103 ; 219  |#ifdef COLOR_262K
                             8104 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             8105 ; 221  |#elif defined(COLOR_65K)
                             8106 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             8107 ; 223  |#else
                             8108 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             8109 ; 225  |#endif
                             8110 ; 226  |    
                             8111 ; 227  |#endif // #ifndef _TYPES_H
                             8112 
                             8114 
                             8115 ; 29   |
                             8116 ; 30   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             8117 ; 31   |
                             8118 ; 32   |//   RTC STMP Registers 
                             8119 ; 33   |//   Edited 2/26/2002 J. Ferrara
                             8120 ; 34   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             8121 ; 35   |
                             8122 ; 36   |#define HW_RTC_BASEADDR (0xF500)
                             8123 ; 37   |
                             8124 ; 38   |
                             8125 ; 39   |
                             8126 ; 40   |
                             8127 ; 41   |
                             8128 ; 42   |/////////////////////////////////////////////////////////////////////////////////
                             8129 ; 43   |
                             8130 ; 44   |////  RTC Control Status Register (HW_RTC_CSR) Bit Definitions
                             8131 ; 45   |
                             8132 ; 46   |#define HW_RTC_CSR_ALARMINTEN_BITPOS (0)
                             8133 ; 47   |#define HW_RTC_CSR_ALARMINT_BITPOS (1)
                             8134 ; 48   |#define HW_RTC_CSR_WATCHDOGEN_BITPOS (2)
                             8135 ; 49   |#define HW_RTC_CSR_RSVD0_BITPOS (3)
                             8136 ; 50   |#define HW_RTC_CSR_STALEREGS_BITPOS (4)
                             8137 ; 51   |#define HW_RTC_CSR_RSVD1_BITPOS (9)
                             8138 ; 52   |#define HW_RTC_CSR_NEWREGS_BITPOS (12)
                             8139 ; 53   |#define HW_RTC_CSR_NEWREGS_XTALDIV_BITPOS (12)
                             8140 ; 54   |#define HW_RTC_CSR_NEWREGS_MSCOUNT_BITPOS (13)
                             8141 ; 55   |#define HW_RTC_CSR_NEWREGS_ALRMCOUNT_BITPOS (14)
                             8142 ; 56   |#define HW_RTC_CSR_NEWREGS_PERSIST0_BITPOS (15)
                             8143 ; 57   |#define HW_RTC_CSR_NEWREGS_PERSIST1_BITPOS (16)
                             8144 ; 58   |#define HW_RTC_CSR_RSVD2_BITPOS (17)
                             8145 ; 59   |#define HW_RTC_CSR_FORCE_BITPOS (20)
                             8146 ; 60   |#define HW_RTC_CSR_RSVD3_BITPOS (21)
                             8147 ; 61   |#define HW_RTC_CSR_SFTRST_BITPOS (23)                                                                           
                             8148 ; 62   |#define HW_RTC_CSR_ALARMINTEN_WIDTH (1)
                             8149 ; 63   |#define HW_RTC_CSR_ALARMINT_WIDTH (1)
                             8150 ; 64   |#define HW_RTC_CSR_WATCHDOGEN_WIDTH (1)
                             8151 ; 65   |#define HW_RTC_CSR_RSVD0_WIDTH (1)
                             8152 ; 66   |#define HW_RTC_CSR_STALEREGS_WIDTH (5)
                             8153 ; 67   |#define HW_RTC_CSR_RSVD1_WIDTH (3)
                             8154 ; 68   |#define HW_RTC_CSR_NEWREGS_WIDTH (5)
                             8155 ; 69   |#define HW_RTC_CSR_NEWREGS_XTALDIV_WIDTH (1)
                             8156 ; 70   |#define HW_RTC_CSR_NEWREGS_MSCOUNT_WIDTH (1)
                             8157 ; 71   |#define HW_RTC_CSR_NEWREGS_ALRMCOUNT_WIDTH (1)
                             8158 ; 72   |#define HW_RTC_CSR_NEWREGS_PERSIST0_WIDTH (1)
                             8159 ; 73   |#define HW_RTC_CSR_NEWREGS_PERSIST1_WIDTH (1)
                             8160 ; 74   |#define HW_RTC_CSR_RSVD2_WIDTH (3)
                             8161 ; 75   |#define HW_RTC_CSR_FORCE_WIDTH (1)
                             8162 ; 76   |#define HW_RTC_CSR_RSVD3_WIDTH (2)
                             8163 ; 77   |#define HW_RTC_CSR_SFTRST_WIDTH (1)
                             8164 ; 78   |
                             8165 ; 79   |#define HW_RTC_CSR_ALARMINT_SETMASK (((1<<HW_RTC_CSR_ALARMINT_WIDTH)-1)<<HW_RTC_CSR_ALARMINT_BITPOS) 
                             8166 ; 80   |#define HW_RTC_CSR_ALARMINTEN_SETMASK (((1<<HW_RTC_CSR_ALARMINTEN_WIDTH)-1)<<HW_RTC_CSR_ALARMINTEN_BITPOS) 
                             8167 ; 81   |#define HW_RTC_CSR_WATCHDOGEN_SETMASK (((1<<HW_RTC_CSR_WATCHDOGEN_WIDTH)-1)<<HW_RTC_CSR_WATCHDOGEN_BITPOS) 
                             8168 ; 82   |#define HW_RTC_CSR_RSVD0_SETMASK (((1<<HW_RTC_CSR_RSVD0_WIDTH)-1)<<HW_RTC_CSR_RSVD0_BITPOS) 
                             8169 ; 83   |#define HW_RTC_CSR_STALEREGS_SETMASK (((1<<HW_RTC_CSR_STALEREGS_WIDTH)-1)<<HW_RTC_CSR_STALEREGS_BITPOS) 
                             8170 ; 84   |#define HW_RTC_CSR_RSVD1_SETMASK (((1<<HW_RTC_CSR_RSVD1_WIDTH)-1)<<HW_RTC_CSR_RSVD1_BITPOS) 
                             8171 ; 85   |#define HW_RTC_CSR_NEWREGS_SETMASK (((1<<HW_RTC_CSR_NEWREGS_WIDTH)-1)<<HW_RTC_CSR_NEWREGS_BITPOS) 
                             8172 ; 86   |#define HW_RTC_CSR_NEWREGS_XTALDIV_SETMASK (((1<<HW_RTC_CSR_NEWREGS_XTALDIV_WIDTH)-1)<<HW_RTC_CSR_NEWREGS_XTALDIV_BITPOS)   
                             8173 ; 87   |#define HW_RTC_CSR_NEWREGS_MSCOUNT_SETMASK (((1<<HW_RTC_CSR_NEWREGS_MSCOUNT_WIDTH)-1)<<HW_RTC_CSR_NEWREGS_MSCOUNT_BITPOS)
                             8174 ; 88   |#define HW_RTC_CSR_NEWREGS_ALRMCOUNT_SETMASK (((1<<HW_RTC_CSR_NEWREGS_ALRMCOUNT_WIDTH)-1)<<HW_RTC_CSR_NEWREGS_ALRMCOUNT_BITPOS)
                             8175 ; 89   |#define HW_RTC_CSR_NEWREGS_PERSIST0_SETMASK (((1<<HW_RTC_CSR_NEWREGS_PERSIST0_WIDTH)-1)<<HW_RTC_CSR_NEWREGS_PERSIST0_BITPOS)
                             8176 ; 90   |#define HW_RTC_CSR_NEWREGS_PERSIST1_SETMASK (((1<<HW_RTC_CSR_NEWREGS_PERSIST1_WIDTH)-1)<<HW_RTC_CSR_NEWREGS_PERSIST1_BITPOS)
                             8177 ; 91   |#define HW_RTC_CSR_RSVD2_SETMASK (((1<<HW_RTC_CSR_RSVD2_WIDTH)-1)<<HW_RTC_CSR_RSVD2_BITPOS) 
                             8178 ; 92   |#define HW_RTC_CSR_FORCE_SETMASK (((1<<HW_RTC_CSR_FORCE_WIDTH)-1)<<HW_RTC_CSR_FORCE_BITPOS) 
                             8179 ; 93   |#define HW_RTC_CSR_RSVD3_SETMASK (((1<<HW_RTC_CSR_RSVD3_WIDTH)-1)<<HW_RTC_CSR_RSVD3_BITPOS) 
                             8180 ; 94   |#define HW_RTC_CSR_SFTRST_SETMASK (((1<<HW_RTC_CSR_SFTRST_WIDTH)-1)<<HW_RTC_CSR_SFTRST_BITPOS) 
                             8181 ; 95   |
                             8182 ; 96   |#define HW_RTC_CSR_ALARMINTEN_CLRMASK (~(WORD)HW_RTC_CSR_ALARMINTEN_SETMASK)
                             8183 ; 97   |#define HW_RTC_CSR_ALARMINT_CLRMASK (~(WORD)HW_RTC_CSR_ALARMINT_SETMASK)
                             8184 ; 98   |#define HW_RTC_CSR_WATCHDOGEN_CLRMASK (~(WORD)HW_RTC_CSR_WATCHDOGEN_SETMASK)
                             8185 ; 99   |#define HW_RTC_CSR_RSVD0_CLRMASK (~(WORD)HW_RTC_CSR_RSVD0_SETMASK)
                             8186 ; 100  |#define HW_RTC_CSR_STALEREGS_CLRMASK (~(WORD)HW_RTC_CSR_STALEREGS_SETMASK)
                             8187 ; 101  |#define HW_RTC_CSR_RSVD1_CLRMASK (~(WORD)HW_RTC_CSR_RSVD1_SETMASK)
                             8188 ; 102  |#define HW_RTC_CSR_NEWREGS_CLRMASK (~(WORD)HW_RTC_CSR_NEWREGS_SETMASK)
                             8189 ; 103  |#define HW_RTC_CSR_NEWREGS_XTALDIV_CLRMASK (~(WORD)HW_RTC_CSR_NEWREGS_XTALDIV_SETMASK)   
                             8190 ; 104  |#define HW_RTC_CSR_NEWREGS_MSCOUNT_CLRMASK (~(WORD)HW_RTC_CSR_NEWREGS_MSCOUNT_SETMASK)
                             8191 ; 105  |#define HW_RTC_CSR_NEWREGS_ALRMCOUNT_CLRMASK (~(WORD)HW_RTC_CSR_NEWREGS_ALRMCOUNT_SETMASK)
                             8192 ; 106  |#define HW_RTC_CSR_NEWREGS_PERSIST0_CLRMASK (~(WORD)HW_RTC_CSR_NEWREGS_PERSIST0_SETMASK)
                             8193 ; 107  |#define HW_RTC_CSR_NEWREGS_PERSIST1_CLRMASK (~(WORD)HW_RTC_CSR_NEWREGS_PERSIST1_SETMASK)
                             8194 ; 108  |
                             8195 ; 109  |#define HW_RTC_CSR_RSVD2_CLRMASK (~(WORD)HW_RTC_CSR_RSVD2_SETMASK)
                             8196 ; 110  |#define HW_RTC_CSR_FORCE_CLRMASK (~(WORD)HW_RTC_CSR_FORCE_SETMASK)
                             8197 ; 111  |#define HW_RTC_CSR_RSVD3_CLRMASK (~(WORD)HW_RTC_CSR_RSVD3_SETMASK)
                             8198 ; 112  |#define HW_RTC_CSR_SFTRST_CLRMASK (~(WORD)HW_RTC_CSR_SFTRST_SETMASK)
                             8199 ; 113  |
                             8200 ; 114  |
                             8201 ; 115  |typedef union               
                             8202 ; 116  |{
                             8203 ; 117  |    struct {
                             8204 ; 118  |         int ALARMINTEN         : HW_RTC_CSR_ALARMINTEN_WIDTH;
                             8205 ; 119  |         int ALARMINT           : HW_RTC_CSR_ALARMINT_WIDTH;
                             8206 ; 120  |         int WATCHDOGEN         : HW_RTC_CSR_WATCHDOGEN_WIDTH;
                             8207 ; 121  |         int RSVD0              : HW_RTC_CSR_RSVD0_WIDTH;
                             8208 ; 122  |         unsigned int STALEREGS : HW_RTC_CSR_STALEREGS_WIDTH;
                             8209 ; 123  |         int RSVD1              : HW_RTC_CSR_RSVD1_WIDTH;
                             8210 ; 124  |         unsigned int NEWREGS   : HW_RTC_CSR_NEWREGS_WIDTH;
                             8211 ; 125  |         int RSVD2              : HW_RTC_CSR_RSVD2_WIDTH;
                             8212 ; 126  |         int FORCE             : HW_RTC_CSR_FORCE_WIDTH;
                             8213 ; 127  |         int RSVD3              : HW_RTC_CSR_RSVD3_WIDTH;
                             8214 ; 128  |         unsigned int SFTRST    : HW_RTC_CSR_SFTRST_WIDTH;
                             8215 ; 129  |    } B;
                             8216 ; 130  |    int I;
                             8217 ; 131  |    unsigned int U;
                             8218 ; 132  |} rtc_csr_type;
                             8219 ; 133  |#define HW_RTC_CSR      (*(volatile rtc_csr_type _X*) (HW_RTC_BASEADDR+0))    /* RTC Control / Status Register */
                             8220 ; 134  |
                             8221 ; 135  |/////////////////////////////////////////////////////////////////////////////////
                             8222 ; 136  |
                             8223 ; 137  |//  RTC Milliseconds Register0 (HW_RTC_MSECONDS0) Bit Definitions
                             8224 ; 138  |
                             8225 ; 139  |#define HW_RTC_MSECONDS0_MSECONDSLOW_BITPOS (0)
                             8226 ; 140  |
                             8227 ; 141  |#define HW_RTC_MSECONDS0_MSECONDSLOW_WIDTH (24)
                             8228 ; 142  |
                             8229 ; 143  |#define HW_RTC_MSECONDS0_MSECONDSLOW_SETMASK (((1<<HW_RTC_MSECONDS0_MSECONDSLOW_WIDTH)-1)<<HW_RTC_MSECONDS0_MSECONDSLOW_BITPOS) 
                             8230 ; 144  |
                             8231 ; 145  |#define HW_RTC_MSECONDS0_MSECONDSLOW_CLRMASK (~(WORD)HW_RTC_MSECONDS0_MSECONDSLOW_SETMASK)
                             8232 ; 146  |
                             8233 ; 147  |typedef union               
                             8234 ; 148  |{
                             8235 ; 149  |    struct {
                             8236 ; 150  |         int MSECONDSLOW        : HW_RTC_MSECONDS0_MSECONDSLOW_WIDTH;
                             8237 ; 151  |    } B;
                             8238 ; 152  |    int I;
                             8239 ; 153  |    unsigned int U;
                             8240 ; 154  |} rtc_mseconds0_type;
                             8241 ; 155  |#define HW_RTC_MSECONDS0      (*(volatile rtc_mseconds0_type _X*) (HW_RTC_BASEADDR+1))    /* RTC MSECONDS Lower Word Register */
                             8242 ; 156  |#define HW_RTCLOWR            HW_RTC_MSECONDS0
                             8243 ; 157  |/////////////////////////////////////////////////////////////////////////////////
                             8244 ; 158  |
                             8245 ; 159  |//  RTC Milliseconds Register1 (HW_RTC_MSECONDS1) Bit Definitions
                             8246 ; 160  |
                             8247 ; 161  |#define HW_RTC_MSECONDS1_MSECONDSHIGH_BITPOS (0)
                             8248 ; 162  |
                             8249 ; 163  |#define HW_RTC_MSECONDS1_MSECONDSHIGH_WIDTH (24)
                             8250 ; 164  |
                             8251 ; 165  |#define HW_RTC_MSECONDS1_MSECONDSHIGH_SETMASK (((1<<HW_RTC_MSECONDS1_MSECONDSHIGH_WIDTH)-1)<<HW_RTC_MSECONDS1_MSECONDSHIGH_BITPOS) 
                             8252 ; 166  |
                             8253 ; 167  |#define HW_RTC_MSECONDS1_MSECONDSHIGH_CLRMASK (~(WORD)HW_RTC_MSECONDS1_MSECONDSHIGH_SETMASK)
                             8254 ; 168  |
                             8255 ; 169  |typedef union               
                             8256 ; 170  |{
                             8257 ; 171  |    struct {
                             8258 ; 172  |         int MSECONDSHIGH       : HW_RTC_MSECONDS1_MSECONDSHIGH_WIDTH;
                             8259 ; 173  |    } B;
                             8260 ; 174  |    int I;
                             8261 ; 175  |    unsigned int U;
                             8262 ; 176  |} rtc_mseconds1_type;
                             8263 ; 177  |#define HW_RTC_MSECONDS1      (*(volatile rtc_mseconds1_type _X*) (HW_RTC_BASEADDR+2))    /* RTC MSECONDS Upper Word Register */
                             8264 ; 178  |#define HW_RTCUPR             HW_RTC_MSECONDS1
                             8265 ; 179  |
                             8266 ; 180  |#define HW_RTC_LOWER_OFFSET 1
                             8267 ; 181  |#define HW_RTC_UP_OFFSET 2
                             8268 ; 182  |
                             8269 ; 183  |
                             8270 ; 184  |/////////////////////////////////////////////////////////////////////////////////
                             8271 ; 185  |
                             8272 ; 186  |//  RTC Watchdog Count (HW_RTC_WATCHDOG) Bit Definitions
                             8273 ; 187  |
                             8274 ; 188  |#define HW_RTC_WATCHDOG_TIMEOUTCNT_BITPOS (0)
                             8275 ; 189  |
                             8276 ; 190  |#define HW_RTC_WATCHDOG_TIMEOUTCNT_WIDTH (24)
                             8277 ; 191  |
                             8278 ; 192  |#define HW_RTC_WATCHDOG_TIMEOUTCNT_SETMASK (((1<<HW_RTC_WATCHDOG_TIMEOUTCNT_WIDTH)-1)<<HW_RTC_WATCHDOG_TIMEOUTCNT_BITPOS) 
                             8279 ; 193  |
                             8280 ; 194  |#define HW_RTC_WATCHDOG_TIMEOUTCNT_CLRMASK (~(WORD)HW_RTC_WATCHDOG_TIMEOUTCNT_SETMASK)
                             8281 ; 195  |
                             8282 ; 196  |typedef union               
                             8283 ; 197  |{
                             8284 ; 198  |    struct {
                             8285 ; 199  |         int TIMEOUTCNT         : HW_RTC_WATCHDOG_TIMEOUTCNT_WIDTH;
                             8286 ; 200  |    } B;
                             8287 ; 201  |    int I;
                             8288 ; 202  |    unsigned int U;
                             8289 ; 203  |} rtc_watchdog_type;
                             8290 ; 204  |#define HW_RTC_WATCHDOG     (*(volatile rtc_watchdog_type _X*) (HW_RTC_BASEADDR+3))    /* RTC Watchdog Timeout Register */
                             8291 ; 205  |/////////////////////////////////////////////////////////////////////////////////
                             8292 ; 206  |
                             8293 ; 207  |//  RTC Alarm Register0 (HW_RTC_ALARM0) Bit Definitions
                             8294 ; 208  |
                             8295 ; 209  |#define HW_RTC_ALARM0_ALARMLOW_BITPOS (0)
                             8296 ; 210  |
                             8297 ; 211  |#define HW_RTC_ALARM0_ALARMLOW_WIDTH (24)
                             8298 ; 212  |
                             8299 ; 213  |#define HW_RTC_ALARM0_ALARMLOW_SETMASK (((1<<HW_RTC_ALARM0_ALARMLOW_WIDTH)-1)<<HW_RTC_ALARM0_ALARMLOW_BITPOS) 
                             8300 ; 214  |
                             8301 ; 215  |#define HW_RTC_ALARM0_ALARMLOW_CLRMASK (~(WORD)HW_RTC_ALARM0_ALARMLOW_SETMASK)
                             8302 ; 216  |
                             8303 ; 217  |typedef union               
                             8304 ; 218  |{
                             8305 ; 219  |    struct {
                             8306 ; 220  |         int ALARMLOW   : HW_RTC_ALARM0_ALARMLOW_WIDTH;
                             8307 ; 221  |    } B;
                             8308 ; 222  |    int I;
                             8309 ; 223  |    unsigned int U;
                             8310 ; 224  |} rtc_alarm0_type;
                             8311 ; 225  |#define HW_RTC_ALARM0      (*(volatile rtc_alarm0_type _X*) (HW_RTC_BASEADDR+4))    /* RTC ALARM Lower Word Register */
                             8312 ; 226  |/////////////////////////////////////////////////////////////////////////////////
                             8313 ; 227  |
                             8314 ; 228  |//  RTC Alarm Register1 (HW_RTC_ALARM1) Bit Definitions
                             8315 ; 229  |
                             8316 ; 230  |#define HW_RTC_ALARM1_ALARMHIGH_BITPOS (0)
                             8317 ; 231  |
                             8318 ; 232  |#define HW_RTC_ALARM1_ALARMHIGH_WIDTH (24)
                             8319 ; 233  |
                             8320 ; 234  |#define HW_RTC_ALARM1_ALARMHIGH_SETMASK (((1<<HW_RTC_ALARM1_ALARMHIGH_WIDTH)-1)<<HW_RTC_ALARM1_ALARMHIGH_BITPOS) 
                             8321 ; 235  |
                             8322 ; 236  |#define HW_RTC_ALARM1_ALARMHIGH_CLRMASK (~(WORD)HW_RTC_ALARM1_ALARMHIGH_SETMASK)
                             8323 ; 237  |
                             8324 ; 238  |typedef union               
                             8325 ; 239  |{
                             8326 ; 240  |    struct {
                             8327 ; 241  |         int ALARMHIGH  : HW_RTC_ALARM1_ALARMHIGH_WIDTH;
                             8328 ; 242  |    } B;
                             8329 ; 243  |    int I;
                             8330 ; 244  |    unsigned int U;
                             8331 ; 245  |} rtc_alarm1_type;
                             8332 ; 246  |#define HW_RTC_ALARM1      (*(volatile rtc_alarm1_type _X*) (HW_RTC_BASEADDR+5))    /* RTC ALARM Upper Word Register */
                             8333 ; 247  |/////////////////////////////////////////////////////////////////////////////////
                             8334 ; 248  |
                             8335 ; 249  |//  RTC Xtal-Clock Divide Register (HW_RTC_XTALDIVIDE) Bit Definitions
                             8336 ; 250  |
                             8337 ; 251  |#define HW_RTC_XTALDIVIDE_DIVCOUNT_BITPOS (0)
                             8338 ; 252  |#define HW_RTC_XTALDIVIDE_RSVD0_BITPOS (16)
                             8339 ; 253  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  34

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8340 ; 254  |#define HW_RTC_XTALDIVIDE_DIVCOUNT_WIDTH (16)
                             8341 ; 255  |#define HW_RTC_XTALDIVIDE_RSVD0_WIDTH (8)
                             8342 ; 256  |
                             8343 ; 257  |#define HW_RTC_XTALDIVIDE_DIVCOUNT_SETMASK (((1<<HW_RTC_XTALDIVIDE_DIVCOUNT_WIDTH)-1)<<HW_RTC_XTALDIVIDE_DIVCOUNT_BITPOS) 
                             8344 ; 258  |#define HW_RTC_XTALDIVIDE_RSVD0_SETMASK (((1<<HW_RTC_XTALDIVIDE_RSVD0_BITPOS)-1)<<HW_RTC_XTALDIVIDE_RSVD0_BITPOS) 
                             8345 ; 259  |
                             8346 ; 260  |#define HW_RTC_XTALDIVIDE_DIVCOUNT_CLRMASK (~(WORD)HW_RTC_XTALDIVIDE_DIVCOUNT_SETMASK)
                             8347 ; 261  |#define HW_RTC_XTALDIVIDE_RSVD0_CLRMASK (~(WORD)HW_RTC_XTALDIVIDE_RSVD0_SETMASK)
                             8348 ; 262  |
                             8349 ; 263  |typedef union               
                             8350 ; 264  |{
                             8351 ; 265  |    struct {
                             8352 ; 266  |         int DIVCOUNT   : HW_RTC_XTALDIVIDE_DIVCOUNT_WIDTH;
                             8353 ; 267  |         int RSVD0      : HW_RTC_XTALDIVIDE_RSVD0_WIDTH;
                             8354 ; 268  |    } B;
                             8355 ; 269  |    int I;
                             8356 ; 270  |    unsigned int U;
                             8357 ; 271  |} rtc_xtaldivide_type;
                             8358 ; 272  |#define HW_RTC_XTALDIVIDE   (*(volatile rtc_xtaldivide_type _X*) (HW_RTC_BASEADDR+6))  /* RTC Xtal-clock Pre-Divider Word Register */
                             8359 ; 273  |/////////////////////////////////////////////////////////////////////////////////
                             8360 ; 274  |
                             8361 ; 275  |//  RTC PERSISTENT Register0 (HW_RTC_PERSISTENT0) Bit Definitions
                             8362 ; 276  |
                             8363 ; 277  |#define HW_RTC_PERSISTENT0_ALARMEN_BITPOS (0)
                             8364 ; 278  |#define HW_RTC_PERSISTENT0_ALARMWAKE_EN_BITPOS (1)
                             8365 ; 279  |#define HW_RTC_PERSISTENT0_ALARMWAKE_BITPOS (2)
                             8366 ; 280  |#define HW_RTC_PERSISTENT0_XTALPDOWN_BITPOS (3)
                             8367 ; 281  |#define HW_RTC_PERSISTENT0_RSVD0_BITPOS (4)
                             8368 ; 282  |
                             8369 ; 283  |#define HW_RTC_PERSISTENT0_ALARMEN_WIDTH (1)
                             8370 ; 284  |#define HW_RTC_PERSISTENT0_ALARMWAKE_EN_WIDTH (1)
                             8371 ; 285  |#define HW_RTC_PERSISTENT0_ALARMWAKE_WIDTH (1)
                             8372 ; 286  |#define HW_RTC_PERSISTENT0_XTALPDOWN_WIDTH (1)
                             8373 ; 287  |#define HW_RTC_PERSISTENT0_RSVD0_WIDTH (21)
                             8374 ; 288  |
                             8375 ; 289  |#define HW_RTC_PERSISTENT0_ALARMEN_SETMASK (((1<<HW_RTC_PERSISTENT0_ALARMEN_WIDTH)-1)<<HW_RTC_PERSISTENT0_ALARMEN_BITPOS) 
                             8376 ; 290  |#define HW_RTC_PERSISTENT0_ALARMWAKE_EN_SETMASK (((1<<HW_RTC_PERSISTENT0_ALARMWAKE_EN_WIDTH)-1)<<HW_RTC_PERSISTENT0_ALARMWAKE_EN_BITPOS)
                             8377 ; 291  |#define HW_RTC_PERSISTENT0_ALARMWAKE_SETMASK (((1<<HW_RTC_PERSISTENT0_ALARMWAKE_WIDTH)-1)<<HW_RTC_PERSISTENT0_ALARMWAKE_BITPOS) 
                             8378 ; 292  |#define HW_RTC_PERSISTENT0_XTALPDOWN_SETMASK (((1<<HW_RTC_PERSISTENT0_XTALPDOWN_WIDTH)-1)<<HW_RTC_PERSISTENT0_XTALPDOWN_BITPOS) 
                             8379 ; 293  |#define HW_RTC_PERSISTENT0_RSVD0_SETMASK (((1<<HW_RTC_PERSISTENT0_RSVD0_WIDTH)-1)<<HW_RTC_PERSISTENT0_RSVD0_BITPOS) 
                             8380 ; 294  |
                             8381 ; 295  |#define HW_RTC_PERSISTENT0_ALARMEN_CLRMASK (~(WORD)HW_RTC_PERSISTENT0_ALARMEN_SETMASK)
                             8382 ; 296  |#define HW_RTC_PERSISTENT0_ALARMWAKE_EN_CLRMASK (~(WORD)HW_RTC_PERSISTENT0_ALARMWAKE_EN_SETMASK)
                             8383 ; 297  |#define HW_RTC_PERSISTENT0_ALARMWAKE_CLRMASK (~(WORD)HW_RTC_PERSISTENT0_ALARMWAKE_SETMASK)
                             8384 ; 298  |#define HW_RTC_PERSISTENT0_XTALPDOWN_CLRMASK (~(WORD)HW_RTC_PERSISTENT0_XTALPDOWN_SETMASK)
                             8385 ; 299  |#define HW_RTC_PERSISTENT0_RSVD0_CLRMASK (~(WORD)HW_RTC_PERSISTENT0_RSVD0_SETMASK)
                             8386 ; 300  |
                             8387 ; 301  |typedef union               
                             8388 ; 302  |{
                             8389 ; 303  |   struct {
                             8390 ; 304  |      int ALARMEN   : HW_RTC_PERSISTENT0_ALARMEN_WIDTH;
                             8391 ; 305  |           int ALARMWAKE_EN  :  HW_RTC_PERSISTENT0_ALARMWAKE_EN_WIDTH;
                             8392 ; 306  |      int ALARMWAKE : HW_RTC_PERSISTENT0_ALARMWAKE_WIDTH;
                             8393 ; 307  |      int XTALPDOWN : HW_RTC_PERSISTENT0_XTALPDOWN_WIDTH;
                             8394 ; 308  |      int RSVD0     : HW_RTC_PERSISTENT0_RSVD0_WIDTH;
                             8395 ; 309  |   } B;
                             8396 ; 310  |    int I;
                             8397 ; 311  |    unsigned int U;
                             8398 ; 312  |} rtc_PERSISTENT0_type;
                             8399 ; 313  |#define HW_RTC_PERSISTENT0   (*(volatile rtc_PERSISTENT0_type _X*) (HW_RTC_BASEADDR+7))  /* RTC PERSISTENT Register0 */
                             8400 ; 314  |
                             8401 ; 315  |/////////////////////////////////////////////////////////////////////////////////
                             8402 ; 316  |
                             8403 ; 317  |//  RTC PERSISTENT Register1 (HW_RTC_PERSISTENT1) Bit Definitions
                             8404 ; 318  |
                             8405 ; 319  |#define HW_RTC_PERSISTENT1_RSVD0_BITPOS (0)
                             8406 ; 320  |
                             8407 ; 321  |#define HW_RTC_PERSISTENT1_RSVD0_WIDTH (24)
                             8408 ; 322  |
                             8409 ; 323  |#define HW_RTC_PERSISTENT1_RSVD0_SETMASK (((1<<HW_RTC_PERSISTENT1_RSVD0_WIDTH)-1)<<HW_RTC_PERSISTENT1_RSVD0_BITPOS) 
                             8410 ; 324  |
                             8411 ; 325  |#define HW_RTC_PERSISTENT1_RSVD0_CLRMASK (~(WORD)HW_RTC_PERSISTENT1_RSVD0_SETMASK)
                             8412 ; 326  |
                             8413 ; 327  |
                             8414 ; 328  |typedef union               
                             8415 ; 329  |{
                             8416 ; 330  |    struct {
                             8417 ; 331  |         int RSVD0      : HW_RTC_PERSISTENT1_RSVD0_WIDTH;
                             8418 ; 332  |    } B;
                             8419 ; 333  |    int I;
                             8420 ; 334  |    unsigned int U;
                             8421 ; 335  |} rtc_PERSISTENT1_type;
                             8422 ; 336  |#define HW_RTC_PERSISTENT1   (*(volatile rtc_PERSISTENT1_type _X*) (HW_RTC_BASEADDR+8))  /* RTC PERSISTENT Register1 */
                             8423 ; 337  |
                             8424 ; 338  |
                             8425 ; 339  |#endif
                             8426 ; 340  |
                             8427 ; 341  |
                             8428 ; 342  |
                             8429 ; 343  |
                             8430 ; 344  |
                             8431 ; 345  |
                             8432 ; 346  |
                             8433 ; 347  |
                             8434 ; 348  |
                             8435 ; 349  |
                             8436 ; 350  |
                             8437 ; 351  |
                             8438 ; 352  |
                             8439 ; 353  |
                             8440 
                             8442 
                             8443 ; 30   |#include "regsspare.h"
                             8444 
                             8446 
                             8447 ; 1    |#if !(defined(RESGSSPARE_INC))
                             8448 ; 2    |#define RESGSSPARE_INC 1
                             8449 ; 3    |
                             8450 ; 4    |#define HW_SPARER_BASEADDR (0xFA16)
                             8451 ; 5    |
                             8452 ; 6    |
                             8453 ; 7    |#define HW_SPARER_I2SS_BITPOS 0
                             8454 ; 8    |#define HW_SPARER_USB_SELECT_BITPOS 1
                             8455 ; 9    |#define HW_SPARER_USB_PLUGIN_BITPOS 8
                             8456 ; 10   |#define HW_SPARER_PSWITCH_BITPOS 9
                             8457 ; 11   |
                             8458 ; 12   |#define HW_SPARER_I2SS_SETMASK 1<<HW_SPARER_I2SS_BITPOS
                             8459 ; 13   |#define HW_SPARER_USB_SELECT_SETMASK 1<<HW_SPARER_USB_SELECT_BITPOS
                             8460 ; 14   |
                             8461 ; 15   |#define HW_SPARER_I2SS_CLRMASK ~(WORD)HW_SPARER_I2SS_SETMASK
                             8462 ; 16   |#define HW_SPARER_USB_SELECT_CLRMASK ~(WORD)HW_SPARER_USB_SELECT_SETMASK
                             8463 ; 17   |
                             8464 ; 18   |
                             8465 ; 19   |
                             8466 ; 20   |typedef union               
                             8467 ; 21   |{
                             8468 ; 22   |    struct {
                             8469 ; 23   |        int      I2SS       :1;     
                             8470 ; 24   |        int      USBSELECT  :1;     
                             8471 ; 25   |        unsigned            :6;
                             8472 ; 26   |        int      USBPLUGIN  :1;     
                             8473 ; 27   |        int      PSWITCH    :1;     
                             8474 ; 28   |    } B;
                             8475 ; 29   |
                             8476 ; 30   |    int I;
                             8477 ; 31   |
                             8478 ; 32   |} spare_type;
                             8479 ; 33   |#define HW_SPARER      (*(volatile spare_type _X*) (HW_SPARER_BASEADDR))
                             8480 ; 34   |
                             8481 ; 35   |
                             8482 ; 36   |
                             8483 ; 37   |#endif
                             8484 
                             8486 
                             8487 ; 31   |#include "regsspi.h"
                             8488 
                             8490 
                             8491 ; 1    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             8492 ; 2    |//;; Copyright(C) SigmaTel, Inc. 2002-2003
                             8493 ; 3    |//;; Filename    : regsspi.inc
                             8494 ; 4    |//;; Description : Register definitions for SPI interface
                             8495 ; 5    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             8496 ; 6    |
                             8497 ; 7    |/////////////////////////////////////////////////////////////////////////////////
                             8498 ; 8    |// The following naming conventions are followed in this file.
                             8499 ; 9    |// All registers are named using the format...
                             8500 ; 10   |//     HW_<module>_<regname>
                             8501 ; 11   |// where <module> is the module name which can be any of the following...
                             8502 ; 12   |//     USB20
                             8503 ; 13   |// (Note that when there is more than one copy of a particular module, the
                             8504 ; 14   |// module name includes a number starting from 0 for the first instance of
                             8505 ; 15   |// that module)
                             8506 ; 16   |// <regname> is the specific register within that module
                             8507 ; 17   |// We also define the following...
                             8508 ; 18   |//     HW_<module>_<regname>_BITPOS
                             8509 ; 19   |// which defines the starting bit (i.e. LSB) of a multi bit field
                             8510 ; 20   |//     HW_<module>_<regname>_SETMASK
                             8511 ; 21   |// which does something else, and
                             8512 ; 22   |//     HW_<module>_<regname>_CLRMASK
                             8513 ; 23   |// which does something else.
                             8514 ; 24   |// Other rules
                             8515 ; 25   |//     All caps
                             8516 ; 26   |//     Numeric identifiers start at 0
                             8517 ; 27   |#if !(defined(regsspiinc))
                             8518 ; 28   |#define regsspiinc 1
                             8519 ; 29   |
                             8520 ; 30   |#include "types.h"
                             8521 
                             8523 
                             8524 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             8525 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             8526 ; 3    |//
                             8527 ; 4    |// Filename: types.h
                             8528 ; 5    |// Description: Standard data types
                             8529 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             8530 ; 7    |
                             8531 ; 8    |#ifndef _TYPES_H
                             8532 ; 9    |#define _TYPES_H
                             8533 ; 10   |
                             8534 ; 11   |// TODO:  move this outta here!
                             8535 ; 12   |#if !defined(NOERROR)
                             8536 ; 13   |#define NOERROR 0
                             8537 ; 14   |#define SUCCESS 0
                             8538 ; 15   |#endif 
                             8539 ; 16   |#if !defined(SUCCESS)
                             8540 ; 17   |#define SUCCESS  0
                             8541 ; 18   |#endif
                             8542 ; 19   |#if !defined(ERROR)
                             8543 ; 20   |#define ERROR   -1
                             8544 ; 21   |#endif
                             8545 ; 22   |#if !defined(FALSE)
                             8546 ; 23   |#define FALSE 0
                             8547 ; 24   |#endif
                             8548 ; 25   |#if !defined(TRUE)
                             8549 ; 26   |#define TRUE  1
                             8550 ; 27   |#endif
                             8551 ; 28   |
                             8552 ; 29   |#if !defined(NULL)
                             8553 ; 30   |#define NULL 0
                             8554 ; 31   |#endif
                             8555 ; 32   |
                             8556 ; 33   |#define MAX_INT     0x7FFFFF
                             8557 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             8558 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             8559 ; 36   |#define MAX_ULONG   (-1) 
                             8560 ; 37   |
                             8561 ; 38   |#define WORD_SIZE   24              // word size in bits
                             8562 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             8563 ; 40   |
                             8564 ; 41   |
                             8565 ; 42   |#define BYTE    unsigned char       // btVarName
                             8566 ; 43   |#define CHAR    signed char         // cVarName
                             8567 ; 44   |#define USHORT  unsigned short      // usVarName
                             8568 ; 45   |#define SHORT   unsigned short      // sVarName
                             8569 ; 46   |#define WORD    unsigned int        // wVarName
                             8570 ; 47   |#define INT     signed int          // iVarName
                             8571 ; 48   |#define DWORD   unsigned long       // dwVarName
                             8572 ; 49   |#define LONG    signed long         // lVarName
                             8573 ; 50   |#define BOOL    unsigned int        // bVarName
                             8574 ; 51   |#define FRACT   _fract              // frVarName
                             8575 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             8576 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             8577 ; 54   |#define FLOAT   float               // fVarName
                             8578 ; 55   |#define DBL     double              // dVarName
                             8579 ; 56   |#define ENUM    enum                // eVarName
                             8580 ; 57   |#define CMX     _complex            // cmxVarName
                             8581 ; 58   |typedef WORD UCS3;                   // 
                             8582 ; 59   |
                             8583 ; 60   |#define UINT16  unsigned short
                             8584 ; 61   |#define UINT8   unsigned char   
                             8585 ; 62   |#define UINT32  unsigned long
                             8586 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             8587 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             8588 ; 65   |#define WCHAR   UINT16
                             8589 ; 66   |
                             8590 ; 67   |//UINT128 is 16 bytes or 6 words
                             8591 ; 68   |typedef struct UINT128_3500 {   
                             8592 ; 69   |    int val[6];     
                             8593 ; 70   |} UINT128_3500;
                             8594 ; 71   |
                             8595 ; 72   |#define UINT128   UINT128_3500
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  35

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8596 ; 73   |
                             8597 ; 74   |// Little endian word packed byte strings:   
                             8598 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             8599 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             8600 ; 77   |// Little endian word packed byte strings:   
                             8601 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             8602 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             8603 ; 80   |
                             8604 ; 81   |// Declare Memory Spaces To Use When Coding
                             8605 ; 82   |// A. Sector Buffers
                             8606 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             8607 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             8608 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             8609 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             8610 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             8611 ; 88   |// B. Media DDI Memory
                             8612 ; 89   |#define MEDIA_DDI_MEM _Y
                             8613 ; 90   |
                             8614 ; 91   |
                             8615 ; 92   |
                             8616 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             8617 ; 94   |// Examples of circular pointers:
                             8618 ; 95   |//    INT CIRC cpiVarName
                             8619 ; 96   |//    DWORD CIRC cpdwVarName
                             8620 ; 97   |
                             8621 ; 98   |#define RETCODE INT                 // rcVarName
                             8622 ; 99   |
                             8623 ; 100  |// generic bitfield structure
                             8624 ; 101  |struct Bitfield {
                             8625 ; 102  |    unsigned int B0  :1;
                             8626 ; 103  |    unsigned int B1  :1;
                             8627 ; 104  |    unsigned int B2  :1;
                             8628 ; 105  |    unsigned int B3  :1;
                             8629 ; 106  |    unsigned int B4  :1;
                             8630 ; 107  |    unsigned int B5  :1;
                             8631 ; 108  |    unsigned int B6  :1;
                             8632 ; 109  |    unsigned int B7  :1;
                             8633 ; 110  |    unsigned int B8  :1;
                             8634 ; 111  |    unsigned int B9  :1;
                             8635 ; 112  |    unsigned int B10 :1;
                             8636 ; 113  |    unsigned int B11 :1;
                             8637 ; 114  |    unsigned int B12 :1;
                             8638 ; 115  |    unsigned int B13 :1;
                             8639 ; 116  |    unsigned int B14 :1;
                             8640 ; 117  |    unsigned int B15 :1;
                             8641 ; 118  |    unsigned int B16 :1;
                             8642 ; 119  |    unsigned int B17 :1;
                             8643 ; 120  |    unsigned int B18 :1;
                             8644 ; 121  |    unsigned int B19 :1;
                             8645 ; 122  |    unsigned int B20 :1;
                             8646 ; 123  |    unsigned int B21 :1;
                             8647 ; 124  |    unsigned int B22 :1;
                             8648 ; 125  |    unsigned int B23 :1;
                             8649 ; 126  |};
                             8650 ; 127  |
                             8651 ; 128  |union BitInt {
                             8652 ; 129  |        struct Bitfield B;
                             8653 ; 130  |        int        I;
                             8654 ; 131  |};
                             8655 ; 132  |
                             8656 ; 133  |#define MAX_MSG_LENGTH 10
                             8657 ; 134  |struct CMessage
                             8658 ; 135  |{
                             8659 ; 136  |        unsigned int m_uLength;
                             8660 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             8661 ; 138  |};
                             8662 ; 139  |
                             8663 ; 140  |typedef struct {
                             8664 ; 141  |    WORD m_wLength;
                             8665 ; 142  |    WORD m_wMessage;
                             8666 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             8667 ; 144  |} Message;
                             8668 ; 145  |
                             8669 ; 146  |struct MessageQueueDescriptor
                             8670 ; 147  |{
                             8671 ; 148  |        int *m_pBase;
                             8672 ; 149  |        int m_iModulo;
                             8673 ; 150  |        int m_iSize;
                             8674 ; 151  |        int *m_pHead;
                             8675 ; 152  |        int *m_pTail;
                             8676 ; 153  |};
                             8677 ; 154  |
                             8678 ; 155  |struct ModuleEntry
                             8679 ; 156  |{
                             8680 ; 157  |    int m_iSignaledEventMask;
                             8681 ; 158  |    int m_iWaitEventMask;
                             8682 ; 159  |    int m_iResourceOfCode;
                             8683 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             8684 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             8685 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             8686 ; 163  |    int m_uTimeOutHigh;
                             8687 ; 164  |    int m_uTimeOutLow;
                             8688 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             8689 ; 166  |};
                             8690 ; 167  |
                             8691 ; 168  |union WaitMask{
                             8692 ; 169  |    struct B{
                             8693 ; 170  |        unsigned int m_bNone     :1;
                             8694 ; 171  |        unsigned int m_bMessage  :1;
                             8695 ; 172  |        unsigned int m_bTimer    :1;
                             8696 ; 173  |        unsigned int m_bButton   :1;
                             8697 ; 174  |    } B;
                             8698 ; 175  |    int I;
                             8699 ; 176  |} ;
                             8700 ; 177  |
                             8701 ; 178  |
                             8702 ; 179  |struct Button {
                             8703 ; 180  |        WORD wButtonEvent;
                             8704 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             8705 ; 182  |};
                             8706 ; 183  |
                             8707 ; 184  |struct Message {
                             8708 ; 185  |        WORD wMsgLength;
                             8709 ; 186  |        WORD wMsgCommand;
                             8710 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             8711 ; 188  |};
                             8712 ; 189  |
                             8713 ; 190  |union EventTypes {
                             8714 ; 191  |        struct CMessage msg;
                             8715 ; 192  |        struct Button Button ;
                             8716 ; 193  |        struct Message Message;
                             8717 ; 194  |};
                             8718 ; 195  |
                             8719 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             8720 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             8721 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             8722 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             8723 ; 200  |
                             8724 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             8725 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             8726 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             8727 ; 204  |
                             8728 ; 205  |#if DEBUG
                             8729 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             8730 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             8731 ; 208  |#else 
                             8732 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             8733 ; 210  |#define DebugBuildAssert(x)    
                             8734 ; 211  |#endif
                             8735 ; 212  |
                             8736 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             8737 ; 214  |//  #pragma asm
                             8738 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             8739 ; 216  |//  #pragma endasm
                             8740 ; 217  |
                             8741 ; 218  |
                             8742 ; 219  |#ifdef COLOR_262K
                             8743 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             8744 ; 221  |#elif defined(COLOR_65K)
                             8745 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             8746 ; 223  |#else
                             8747 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             8748 ; 225  |#endif
                             8749 ; 226  |    
                             8750 ; 227  |#endif // #ifndef _TYPES_H
                             8751 
                             8753 
                             8754 ; 31   |
                             8755 ; 32   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             8756 ; 33   |
                             8757 ; 34   |//   SPI STMP3500 Registers 
                             8758 ; 35   |//   Last Updated 7.7.2003 Dave Dyches
                             8759 ; 36   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             8760 ; 37   |
                             8761 ; 38   |#define HW_SPI_BASEADDR (0xFFF9)
                             8762 ; 39   |
                             8763 ; 40   |
                             8764 ; 41   |
                             8765 ; 42   |// /////////////////////////////////////////////
                             8766 ; 43   |// //  SPI Control/Status Register Bit Definitions
                             8767 ; 44   |#define HW_SPCSR_SPE_BITPOS (0)
                             8768 ; 45   |#define HW_SPCSR_MSTR_BITPOS (1)
                             8769 ; 46   |#define HW_SPCSR_SPIE_BITPOS (2)
                             8770 ; 47   |#define HW_SPCSR_CPOL_BITPOS (3)
                             8771 ; 48   |#define HW_SPCSR_CPHA_BITPOS (4)
                             8772 ; 49   |#define HW_SPCSR_SPIF_BITPOS (5)
                             8773 ; 50   |#define HW_SPCSR_WCOL_BITPOS (6)
                             8774 ; 51   |#define HW_SPCSR_MODF_BITPOS (7)
                             8775 ; 52   |#define HW_SPCSR_DIV_BITPOS (8)
                             8776 ; 53   |#define HW_SPCSR_RSVD_BITPOS (16)
                             8777 ; 54   |
                             8778 ; 55   |#define HW_SPCSR_SPE_WIDTH (1)
                             8779 ; 56   |#define HW_SPCSR_MSTR_WIDTH (1)
                             8780 ; 57   |#define HW_SPCSR_SPIE_WIDTH (1)
                             8781 ; 58   |#define HW_SPCSR_CPOL_WIDTH (1)
                             8782 ; 59   |#define HW_SPCSR_CPHA_WIDTH (1)
                             8783 ; 60   |#define HW_SPCSR_SPIF_WIDTH (1)
                             8784 ; 61   |#define HW_SPCSR_WCOL_WIDTH (1)
                             8785 ; 62   |#define HW_SPCSR_MODF_WIDTH (1)
                             8786 ; 63   |#define HW_SPCSR_DIV_WIDTH (8)
                             8787 ; 64   |#define HW_SPCSR_RSVD_WIDTH (8)
                             8788 ; 65   |
                             8789 ; 66   |#define HW_SPCSR_SPE_SETMASK (((1<<HW_SPCSR_SPE_WIDTH)-1)<<HW_SPCSR_SPE_BITPOS)
                             8790 ; 67   |#define HW_SPCSR_MSTR_SETMASK (((1<<HW_SPCSR_MSTR_WIDTH)-1)<<HW_SPCSR_MSTR_BITPOS)
                             8791 ; 68   |#define HW_SPCSR_SPIE_SETMASK (((1<<HW_SPCSR_SPIE_WIDTH)-1)<<HW_SPCSR_SPIE_BITPOS)
                             8792 ; 69   |#define HW_SPCSR_CPOL_SETMASK (((1<<HW_SPCSR_CPOL_WIDTH)-1)<<HW_SPCSR_CPOL_BITPOS)
                             8793 ; 70   |#define HW_SPCSR_CPHA_SETMASK (((1<<HW_SPCSR_CPHA_WIDTH)-1)<<HW_SPCSR_CPHA_BITPOS)
                             8794 ; 71   |#define HW_SPCSR_SPIF_SETMASK (((1<<HW_SPCSR_SPIF_WIDTH)-1)<<HW_SPCSR_SPIF_BITPOS)
                             8795 ; 72   |#define HW_SPCSR_WCOL_SETMASK (((1<<HW_SPCSR_WCOL_WIDTH)-1)<<HW_SPCSR_WCOL_BITPOS)
                             8796 ; 73   |#define HW_SPCSR_MODF_SETMASK (((1<<HW_SPCSR_MODF_WIDTH)-1)<<HW_SPCSR_MODF_BITPOS)
                             8797 ; 74   |#define HW_SPCSR_DIV_SETMASK (((1<<HW_SPCSR_DIV_WIDTH)-1)<<HW_SPCSR_DIV_BITPOS)
                             8798 ; 75   |#define HW_SPCSR_RSVD_SETMASK (((1<<HW_SPCSR_RSVD_WIDTH)-1)<<HW_SPCSR_RSVD_BITPOS)
                             8799 ; 76   |
                             8800 ; 77   |#define HW_SPCSR_SPE_CLRMASK (~(WORD)HW_SPCSR_SPE_SETMASK)
                             8801 ; 78   |#define HW_SPCSR_MSTR_CLRMASK (~(WORD)HW_SPCSR_MSTR_SETMASK)
                             8802 ; 79   |#define HW_SPCSR_SPIE_CLRMASK (~(WORD)HW_SPCSR_SPIE_SETMASK)
                             8803 ; 80   |#define HW_SPCSR_CPOL_CLRMASK (~(WORD)HW_SPCSR_CPOL_SETMASK)
                             8804 ; 81   |#define HW_SPCSR_CPHA_CLRMASK (~(WORD)HW_SPCSR_CPHA_SETMASK)
                             8805 ; 82   |#define HW_SPCSR_SPIF_CLRMASK (~(WORD)HW_SPCSR_SPIF_SETMASK)
                             8806 ; 83   |#define HW_SPCSR_WCOL_CLRMASK (~(WORD)HW_SPCSR_WCOL_SETMASK)
                             8807 ; 84   |#define HW_SPCSR_MODF_CLRMASK (~(WORD)HW_SPCSR_MODF_SETMASK)
                             8808 ; 85   |#define HW_SPCSR_DIV_CLRMASK (~(WORD)HW_SPCSR_DIV_SETMASK)
                             8809 ; 86   |#define HW_SPCSR_RSVD_CLRMASK (~(WORD)HW_SPCSR_RSVD_SETMASK)
                             8810 ; 87   |
                             8811 ; 88   |typedef union               
                             8812 ; 89   |{
                             8813 ; 90   |    struct {
                             8814 ; 91   |        int SPE                 : HW_SPCSR_SPE_WIDTH;    
                             8815 ; 92   |        int MSTR                : HW_SPCSR_MSTR_WIDTH;
                             8816 ; 93   |        int SPIE                    : HW_SPCSR_SPIE_WIDTH;
                             8817 ; 94   |        int CPOL                : HW_SPCSR_CPOL_WIDTH;
                             8818 ; 95   |        int CPHA                : HW_SPCSR_CPHA_WIDTH;
                             8819 ; 96   |        int SPIF                : HW_SPCSR_SPIF_WIDTH;
                             8820 ; 97   |        int WCOL                    : HW_SPCSR_WCOL_WIDTH;
                             8821 ; 98   |        int MODF                : HW_SPCSR_MODF_WIDTH;
                             8822 ; 99   |        int DIV                 : HW_SPCSR_DIV_WIDTH;
                             8823 ; 100  |    } B;
                             8824 ; 101  |
                             8825 ; 102  |    int I;
                             8826 ; 103  |    unsigned int U;
                             8827 ; 104  |} spcsr_type;
                             8828 ; 105  |#define HW_SPCSR      (*(volatile spcsr_type _X*) (HW_SPI_BASEADDR))    /* SPI Control / Status Register */
                             8829 ; 106  |
                             8830 ; 107  |// /////////////////////////////////////////////
                             8831 ; 108  |// //  SPI Data Register Bit Definitions
                             8832 ; 109  |#define HW_SPDR_SPIDATA_BITPOS (0)
                             8833 ; 110  |#define HW_SPDR_RSVD_BITPOS (8)
                             8834 ; 111  |
                             8835 ; 112  |#define HW_SPDR_SPIDATA_WIDTH (8)
                             8836 ; 113  |#define HW_SPDR_RSVD_WIDTH (16)
                             8837 ; 114  |
                             8838 ; 115  |#define HW_SPDR_SPIDATA_SETMASK (((1<<HW_SPDR_SPIDATA_WIDTH)-1)<<HW_SPDR_SPIDATA_BITPOS)
                             8839 ; 116  |#define HW_SPDR_RSVD_SETMASK (((1<<HW_SPDR_RSVD_WIDTH)-1)<<HW_SPDR_RSVD_BITPOS)
                             8840 ; 117  |
                             8841 ; 118  |#define HW_SPDR_SPIDATA_CLRMASK (~(WORD)HW_SPDR_SPIDATA_SETMASK) 
                             8842 ; 119  |#define HW_SPDR_RSVD_CLRMASK (~(WORD)HW_SPDR_RSVD_SETMASK)
                             8843 ; 120  |
                             8844 ; 121  |typedef union               
                             8845 ; 122  |{
                             8846 ; 123  |    struct {
                             8847 ; 124  |        int SPIDATA                     : HW_SPDR_SPIDATA_WIDTH;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  36

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8848 ; 125  |    } B;
                             8849 ; 126  |
                             8850 ; 127  |    int I;
                             8851 ; 128  |    unsigned int U;
                             8852 ; 129  |} spdr_type;
                             8853 ; 130  |#define HW_SPDR      (*(volatile spdr_type _X*) (HW_SPI_BASEADDR+1))    /* SPI Data Register */
                             8854 ; 131  |
                             8855 ; 132  |
                             8856 ; 133  |#endif
                             8857 ; 134  |
                             8858 ; 135  |
                             8859 
                             8861 
                             8862 ; 32   |#include "regsswizzle.h"
                             8863 
                             8865 
                             8866 ; 1    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             8867 ; 2    |//;; Copyright(C) SigmaTel, Inc. 2002-2003
                             8868 ; 3    |//;; Filename    : regsswizzle.inc
                             8869 ; 4    |//;; Description : Register definitions for Swizzle interface
                             8870 ; 5    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             8871 ; 6    |
                             8872 ; 7    |/////////////////////////////////////////////////////////////////////////////////
                             8873 ; 8    |// The following naming conventions are followed in this file.
                             8874 ; 9    |// All registers are named using the format...
                             8875 ; 10   |//     HW_<module>_<regname>
                             8876 ; 11   |// where <module> is the module name which can be any of the following...
                             8877 ; 12   |//     USB20
                             8878 ; 13   |// (Note that when there is more than one copy of a particular module, the
                             8879 ; 14   |// module name includes a number starting from 0 for the first instance of
                             8880 ; 15   |// that module)
                             8881 ; 16   |// <regname> is the specific register within that module
                             8882 ; 17   |// We also define the following...
                             8883 ; 18   |//     HW_<module>_<regname>_BITPOS
                             8884 ; 19   |// which defines the starting bit (i.e. LSB) of a multi bit field
                             8885 ; 20   |//     HW_<module>_<regname>_SETMASK
                             8886 ; 21   |// which does something else, and
                             8887 ; 22   |//     HW_<module>_<regname>_CLRMASK
                             8888 ; 23   |// which does something else.
                             8889 ; 24   |// Other rules
                             8890 ; 25   |//     All caps
                             8891 ; 26   |//     Numeric identifiers start at 0
                             8892 ; 27   |#if !(defined(regsswizzleinc))
                             8893 ; 28   |#define regsswizzleinc 1
                             8894 ; 29   |
                             8895 ; 30   |#include "types.h"
                             8896 
                             8898 
                             8899 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             8900 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             8901 ; 3    |//
                             8902 ; 4    |// Filename: types.h
                             8903 ; 5    |// Description: Standard data types
                             8904 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             8905 ; 7    |
                             8906 ; 8    |#ifndef _TYPES_H
                             8907 ; 9    |#define _TYPES_H
                             8908 ; 10   |
                             8909 ; 11   |// TODO:  move this outta here!
                             8910 ; 12   |#if !defined(NOERROR)
                             8911 ; 13   |#define NOERROR 0
                             8912 ; 14   |#define SUCCESS 0
                             8913 ; 15   |#endif 
                             8914 ; 16   |#if !defined(SUCCESS)
                             8915 ; 17   |#define SUCCESS  0
                             8916 ; 18   |#endif
                             8917 ; 19   |#if !defined(ERROR)
                             8918 ; 20   |#define ERROR   -1
                             8919 ; 21   |#endif
                             8920 ; 22   |#if !defined(FALSE)
                             8921 ; 23   |#define FALSE 0
                             8922 ; 24   |#endif
                             8923 ; 25   |#if !defined(TRUE)
                             8924 ; 26   |#define TRUE  1
                             8925 ; 27   |#endif
                             8926 ; 28   |
                             8927 ; 29   |#if !defined(NULL)
                             8928 ; 30   |#define NULL 0
                             8929 ; 31   |#endif
                             8930 ; 32   |
                             8931 ; 33   |#define MAX_INT     0x7FFFFF
                             8932 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             8933 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             8934 ; 36   |#define MAX_ULONG   (-1) 
                             8935 ; 37   |
                             8936 ; 38   |#define WORD_SIZE   24              // word size in bits
                             8937 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             8938 ; 40   |
                             8939 ; 41   |
                             8940 ; 42   |#define BYTE    unsigned char       // btVarName
                             8941 ; 43   |#define CHAR    signed char         // cVarName
                             8942 ; 44   |#define USHORT  unsigned short      // usVarName
                             8943 ; 45   |#define SHORT   unsigned short      // sVarName
                             8944 ; 46   |#define WORD    unsigned int        // wVarName
                             8945 ; 47   |#define INT     signed int          // iVarName
                             8946 ; 48   |#define DWORD   unsigned long       // dwVarName
                             8947 ; 49   |#define LONG    signed long         // lVarName
                             8948 ; 50   |#define BOOL    unsigned int        // bVarName
                             8949 ; 51   |#define FRACT   _fract              // frVarName
                             8950 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             8951 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             8952 ; 54   |#define FLOAT   float               // fVarName
                             8953 ; 55   |#define DBL     double              // dVarName
                             8954 ; 56   |#define ENUM    enum                // eVarName
                             8955 ; 57   |#define CMX     _complex            // cmxVarName
                             8956 ; 58   |typedef WORD UCS3;                   // 
                             8957 ; 59   |
                             8958 ; 60   |#define UINT16  unsigned short
                             8959 ; 61   |#define UINT8   unsigned char   
                             8960 ; 62   |#define UINT32  unsigned long
                             8961 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             8962 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             8963 ; 65   |#define WCHAR   UINT16
                             8964 ; 66   |
                             8965 ; 67   |//UINT128 is 16 bytes or 6 words
                             8966 ; 68   |typedef struct UINT128_3500 {   
                             8967 ; 69   |    int val[6];     
                             8968 ; 70   |} UINT128_3500;
                             8969 ; 71   |
                             8970 ; 72   |#define UINT128   UINT128_3500
                             8971 ; 73   |
                             8972 ; 74   |// Little endian word packed byte strings:   
                             8973 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             8974 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             8975 ; 77   |// Little endian word packed byte strings:   
                             8976 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             8977 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             8978 ; 80   |
                             8979 ; 81   |// Declare Memory Spaces To Use When Coding
                             8980 ; 82   |// A. Sector Buffers
                             8981 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             8982 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             8983 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             8984 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             8985 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             8986 ; 88   |// B. Media DDI Memory
                             8987 ; 89   |#define MEDIA_DDI_MEM _Y
                             8988 ; 90   |
                             8989 ; 91   |
                             8990 ; 92   |
                             8991 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             8992 ; 94   |// Examples of circular pointers:
                             8993 ; 95   |//    INT CIRC cpiVarName
                             8994 ; 96   |//    DWORD CIRC cpdwVarName
                             8995 ; 97   |
                             8996 ; 98   |#define RETCODE INT                 // rcVarName
                             8997 ; 99   |
                             8998 ; 100  |// generic bitfield structure
                             8999 ; 101  |struct Bitfield {
                             9000 ; 102  |    unsigned int B0  :1;
                             9001 ; 103  |    unsigned int B1  :1;
                             9002 ; 104  |    unsigned int B2  :1;
                             9003 ; 105  |    unsigned int B3  :1;
                             9004 ; 106  |    unsigned int B4  :1;
                             9005 ; 107  |    unsigned int B5  :1;
                             9006 ; 108  |    unsigned int B6  :1;
                             9007 ; 109  |    unsigned int B7  :1;
                             9008 ; 110  |    unsigned int B8  :1;
                             9009 ; 111  |    unsigned int B9  :1;
                             9010 ; 112  |    unsigned int B10 :1;
                             9011 ; 113  |    unsigned int B11 :1;
                             9012 ; 114  |    unsigned int B12 :1;
                             9013 ; 115  |    unsigned int B13 :1;
                             9014 ; 116  |    unsigned int B14 :1;
                             9015 ; 117  |    unsigned int B15 :1;
                             9016 ; 118  |    unsigned int B16 :1;
                             9017 ; 119  |    unsigned int B17 :1;
                             9018 ; 120  |    unsigned int B18 :1;
                             9019 ; 121  |    unsigned int B19 :1;
                             9020 ; 122  |    unsigned int B20 :1;
                             9021 ; 123  |    unsigned int B21 :1;
                             9022 ; 124  |    unsigned int B22 :1;
                             9023 ; 125  |    unsigned int B23 :1;
                             9024 ; 126  |};
                             9025 ; 127  |
                             9026 ; 128  |union BitInt {
                             9027 ; 129  |        struct Bitfield B;
                             9028 ; 130  |        int        I;
                             9029 ; 131  |};
                             9030 ; 132  |
                             9031 ; 133  |#define MAX_MSG_LENGTH 10
                             9032 ; 134  |struct CMessage
                             9033 ; 135  |{
                             9034 ; 136  |        unsigned int m_uLength;
                             9035 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             9036 ; 138  |};
                             9037 ; 139  |
                             9038 ; 140  |typedef struct {
                             9039 ; 141  |    WORD m_wLength;
                             9040 ; 142  |    WORD m_wMessage;
                             9041 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             9042 ; 144  |} Message;
                             9043 ; 145  |
                             9044 ; 146  |struct MessageQueueDescriptor
                             9045 ; 147  |{
                             9046 ; 148  |        int *m_pBase;
                             9047 ; 149  |        int m_iModulo;
                             9048 ; 150  |        int m_iSize;
                             9049 ; 151  |        int *m_pHead;
                             9050 ; 152  |        int *m_pTail;
                             9051 ; 153  |};
                             9052 ; 154  |
                             9053 ; 155  |struct ModuleEntry
                             9054 ; 156  |{
                             9055 ; 157  |    int m_iSignaledEventMask;
                             9056 ; 158  |    int m_iWaitEventMask;
                             9057 ; 159  |    int m_iResourceOfCode;
                             9058 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             9059 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             9060 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             9061 ; 163  |    int m_uTimeOutHigh;
                             9062 ; 164  |    int m_uTimeOutLow;
                             9063 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             9064 ; 166  |};
                             9065 ; 167  |
                             9066 ; 168  |union WaitMask{
                             9067 ; 169  |    struct B{
                             9068 ; 170  |        unsigned int m_bNone     :1;
                             9069 ; 171  |        unsigned int m_bMessage  :1;
                             9070 ; 172  |        unsigned int m_bTimer    :1;
                             9071 ; 173  |        unsigned int m_bButton   :1;
                             9072 ; 174  |    } B;
                             9073 ; 175  |    int I;
                             9074 ; 176  |} ;
                             9075 ; 177  |
                             9076 ; 178  |
                             9077 ; 179  |struct Button {
                             9078 ; 180  |        WORD wButtonEvent;
                             9079 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             9080 ; 182  |};
                             9081 ; 183  |
                             9082 ; 184  |struct Message {
                             9083 ; 185  |        WORD wMsgLength;
                             9084 ; 186  |        WORD wMsgCommand;
                             9085 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             9086 ; 188  |};
                             9087 ; 189  |
                             9088 ; 190  |union EventTypes {
                             9089 ; 191  |        struct CMessage msg;
                             9090 ; 192  |        struct Button Button ;
                             9091 ; 193  |        struct Message Message;
                             9092 ; 194  |};
                             9093 ; 195  |
                             9094 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             9095 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             9096 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             9097 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             9098 ; 200  |
                             9099 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             9100 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             9101 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  37

M:ADDR CODE           CYCLES LINE SOURCELINE
                             9102 ; 204  |
                             9103 ; 205  |#if DEBUG
                             9104 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             9105 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             9106 ; 208  |#else 
                             9107 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             9108 ; 210  |#define DebugBuildAssert(x)    
                             9109 ; 211  |#endif
                             9110 ; 212  |
                             9111 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             9112 ; 214  |//  #pragma asm
                             9113 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             9114 ; 216  |//  #pragma endasm
                             9115 ; 217  |
                             9116 ; 218  |
                             9117 ; 219  |#ifdef COLOR_262K
                             9118 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             9119 ; 221  |#elif defined(COLOR_65K)
                             9120 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             9121 ; 223  |#else
                             9122 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             9123 ; 225  |#endif
                             9124 ; 226  |    
                             9125 ; 227  |#endif // #ifndef _TYPES_H
                             9126 
                             9128 
                             9129 ; 31   |
                             9130 ; 32   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             9131 ; 33   |
                             9132 ; 34   |//   SWIZZLE STMP3500 Registers 
                             9133 ; 35   |//   Last Updated 7.11.2003 Dave Dyches
                             9134 ; 36   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             9135 ; 37   |
                             9136 ; 38   |
                             9137 ; 39   |
                             9138 ; 40   |
                             9139 ; 41   |
                             9140 ; 42   |#define HW_SWIZZLE_BASEADDR 0xF380
                             9141 ; 43   |
                             9142 ; 44   |
                             9143 ; 45   |
                             9144 ; 46   |////  Swizzle CSR1 (HW_SWIZZLECSR1) Bit Definitions
                             9145 ; 47   |#define HW_SWIZZLECSR1_EN_BITPOS (0)
                             9146 ; 48   |#define HW_SWIZZLECSR1_LA_BITPOS (1)
                             9147 ; 49   |#define HW_SWIZZLECSR1_LNR_BITPOS (2)
                             9148 ; 50   |#define HW_SWIZZLECSR1_SIGN_BITPOS (3)
                             9149 ; 51   |#define HW_SWIZZLECSR1_SHIFT_BITPOS (4)
                             9150 ; 52   |#define HW_SWIZZLECSR1_MEM_BITPOS (8)
                             9151 ; 53   |#define HW_SWIZZLECSR1_CLK_OFF_BITPOS (9)
                             9152 ; 54   |#define HW_SWIZZLECSR1_NEWADD_BITPOS (10)
                             9153 ; 55   |#define HW_SWIZZLECSR1_RSVD_BITPOS (11)
                             9154 ; 56   |
                             9155 ; 57   |#define HW_SWIZZLECSR1_EN_WIDTH (1)
                             9156 ; 58   |#define HW_SWIZZLECSR1_LA_WIDTH (1)
                             9157 ; 59   |#define HW_SWIZZLECSR1_LNR_WIDTH (1)
                             9158 ; 60   |#define HW_SWIZZLECSR1_SIGN_WIDTH (1)
                             9159 ; 61   |#define HW_SWIZZLECSR1_SHIFT_WIDTH (4)
                             9160 ; 62   |#define HW_SWIZZLECSR1_MEM_WIDTH (1)
                             9161 ; 63   |#define HW_SWIZZLECSR1_CLK_OFF_WIDTH (1)
                             9162 ; 64   |#define HW_SWIZZLECSR1_NEWADD_WIDTH (1)
                             9163 ; 65   |#define HW_SWIZZLECSR1_RSVD_WIDTH (13)
                             9164 ; 66   |
                             9165 ; 67   |#define HW_SWIZZLECSR1_EN_SETMASK (((1<HW_SWIZZLECSR1_EN_WIDTH)-1)<<HW_SWIZZLECSR1_EN_BITPOS)
                             9166 ; 68   |#define HW_SWIZZLECSR1_LA_SETMASK (((1<HW_SWIZZLECSR1_LA_WIDTH)-1)<<HW_SWIZZLECSR1_LA_BITPOS)
                             9167 ; 69   |#define HW_SWIZZLECSR1_LNR_SETMASK (((1<HW_SWIZZLECSR1_LNR_WIDTH)-1)<<HW_SWIZZLECSR1_LNR_BITPOS)
                             9168 ; 70   |#define HW_SWIZZLECSR1_SIGN_SETMASK (((1<HW_SWIZZLECSR1_SIGN_WIDTH)-1)<<HW_SWIZZLECSR1_SIGN_BITPOS)
                             9169 ; 71   |#define HW_SWIZZLECSR1_SHIFT_SETMASK (((1<HW_SWIZZLECSR1_SHIFT_WIDTH)-1)<<HW_SWIZZLECSR1_SHIFT_BITPOS)
                             9170 ; 72   |#define HW_SWIZZLECSR1_MEM_SETMASK (((1<HW_SWIZZLECSR1_MEM_WIDTH)-1)<<HW_SWIZZLECSR1_MEM_BITPOS)
                             9171 ; 73   |#define HW_SWIZZLECSR1_CLK_OFF_SETMASK (((1<HW_SWIZZLECSR1_CLK_OFF_WIDTH)-1)<<HW_SWIZZLECSR1_CLK_OFF_BITPOS)
                             9172 ; 74   |#define HW_SWIZZLECSR1_NEWADD_SETMASK (((1<HW_SWIZZLECSR1_NEWADD_WIDTH)-1)<<HW_SWIZZLECSR1_NEWADD_BITPOS)
                             9173 ; 75   |#define HW_SWIZZLECSR1_RSVD_SETMASK (((1<HW_SWIZZLECSR1_RSVD_WIDTH)-1)<<HW_SWIZZLECSR1_RSVD_BITPOS)
                             9174 ; 76   |
                             9175 ; 77   |#define HW_SWIZZLECSR1_EN_CLRMASK (~(WORD)HW_SWIZZLECSR1_EN_SETMASK)
                             9176 ; 78   |#define HW_SWIZZLECSR1_LA_CLRMASK (~(WORD)HW_SWIZZLECSR1_LA_SETMASK)
                             9177 ; 79   |#define HW_SWIZZLECSR1_LNR_CLRMASK (~(WORD)HW_SWIZZLECSR1_LNR_SETMASK)
                             9178 ; 80   |#define HW_SWIZZLECSR1_SIGN_CLRMASK (~(WORD)HW_SWIZZLECSR1_SIGN_SETMASK)
                             9179 ; 81   |#define HW_SWIZZLECSR1_SHIFT_CLRMASK (~(WORD)HW_SWIZZLECSR1_SHIFT_SETMASK)
                             9180 ; 82   |#define HW_SWIZZLECSR1_MEM_CLRMASK (~(WORD)HW_SWIZZLECSR1_MEM_SETMASK)
                             9181 ; 83   |#define HW_SWIZZLECSR1_CLK_OFF_CLRMASK (~(WORD)HW_SWIZZLECSR1_CLK_OFF_SETMASK)
                             9182 ; 84   |#define HW_SWIZZLECSR1_NEWADD_CLRMASK (~(WORD)HW_SWIZZLECSR1_NEWADD_SETMASK)
                             9183 ; 85   |#define HW_SWIZZLECSR1_RSVD_CLRMASK (~(WORD)HW_SWIZZLECSR1_RSVD_SETMASK)
                             9184 ; 86   |
                             9185 ; 87   |////////////////////////////////////////////////////////////////////////////////
                             9186 ; 88   |//  Bit Manipulation Unit Registers
                             9187 ; 89   |////////////////////////////////////////////////////////////////////////////////
                             9188 ; 90   |typedef union
                             9189 ; 91   |{
                             9190 ; 92   |    struct
                             9191 ; 93   |    {
                             9192 ; 94   |    int EN      :1;     /* Swizzle Enable                           */
                             9193 ; 95   |    int LA      :1;     /* Left Align Data                          */
                             9194 ; 96   |    int LNR     :1;     /* Left Barrel Shift                        */
                             9195 ; 97   |    int SIGN    :1;     /* Sign Extend Data                         */
                             9196 ; 98   |    unsigned SHIFT :4;          /* Number of positions to shift (0 to 23)   */
                             9197 ; 99   |    int MEM     :1;     /* Manipulate in Memory (not in registers)  */
                             9198 ; 100  |    int CLK_OFF :1;     /* Gate the Clock, Power Off                */
                             9199 ; 101  |    int NEWADD  :1;     /* Place the data into a new location       */     
                             9200 ; 102  |    } B;
                             9201 ; 103  |    int I;
                             9202 ; 104  |    unsigned U;
                             9203 ; 105  |} swizzlecsr1_type;
                             9204 ; 106  |////////////////////////////////////////////////////////////////////////////////
                             9205 ; 107  |#define HW_SWIZZLECS1R (*(volatile swizzlecsr1_type _X*) (HW_SWIZZLE_BASEADDR))       /* Swizzle Control & Status Register 1 */
                             9206 ; 108  |
                             9207 ; 109  |////  Swizzle CSR2 (HW_SWIZZLECSR2) Bit Definitions
                             9208 ; 110  |#define HW_SWIZZLECSR2_KICK_BITPOS (0)
                             9209 ; 111  |#define HW_SWIZZLECSR2_SASEL_BITPOS (1)
                             9210 ; 112  |#define HW_SWIZZLECSR2_DESASEL_BITPOS (3)
                             9211 ; 113  |#define HW_SWIZZLECSR2_BIGE_BITPOS (5)
                             9212 ; 114  |#define HW_SWIZZLECSR2_BITREV_BITPOS (6)
                             9213 ; 115  |#define HW_SWIZZLECSR2_PLSB_BITPOS (7)
                             9214 ; 116  |#define HW_SWIZZLECSR2_PISB_OFF_BITPOS (8)
                             9215 ; 117  |#define HW_SWIZZLECSR2_PMSB_BITPOS (9)
                             9216 ; 118  |#define HW_SWIZZLECSR2_P16L_BITPOS (10)
                             9217 ; 119  |#define HW_SWIZZLECSR2_P16I_BITPOS (11)
                             9218 ; 120  |#define HW_SWIZZLECSR2_BS_EN_BITPOS (12)
                             9219 ; 121  |#define HW_SWIZZLECSR2_SBYTEDEST_BITPOS (13)
                             9220 ; 122  |#define HW_SWIZZLECSR2_UNKICK_BITPOS (15)
                             9221 ; 123  |#define HW_SWIZZLECSR2_RSVD_BITPOS (16)
                             9222 ; 124  |
                             9223 ; 125  |#define HW_SWIZZLECSR2_KICK_WIDTH (1)
                             9224 ; 126  |#define HW_SWIZZLECSR2_SASEL_WIDTH (2)
                             9225 ; 127  |#define HW_SWIZZLECSR2_DESASEL_WIDTH (2)
                             9226 ; 128  |#define HW_SWIZZLECSR2_BIGE_WIDTH (1)
                             9227 ; 129  |#define HW_SWIZZLECSR2_BITREV_WIDTH (1)
                             9228 ; 130  |#define HW_SWIZZLECSR2_PLSB_WIDTH (1)
                             9229 ; 131  |#define HW_SWIZZLECSR2_PMSB_WIDTH (1)
                             9230 ; 132  |#define HW_SWIZZLECSR2_P16L_WIDTH (1)
                             9231 ; 133  |#define HW_SWIZZLECSR2_P16I_WIDTH (1)
                             9232 ; 134  |#define HW_SWIZZLECSR2_BS_EN_WIDTH (1)
                             9233 ; 135  |#define HW_SWIZZLECSR2_SBYTEDEST_WIDTH (2)
                             9234 ; 136  |#define HW_SWIZZLECSR2_UNKICK_WIDTH (1)
                             9235 ; 137  |#define HW_SWIZZLECSR2_RSVD_WIDTH (8)
                             9236 ; 138  |
                             9237 ; 139  |#define HW_SWIZZLECSR2_KICK_SETMASK (((1<HW_SWIZZLECSR2_KICK_WIDTH)-1)<<HW_SWIZZLECSR2_KICK_BITPOS)
                             9238 ; 140  |#define HW_SWIZZLECSR2_SASEL_SETMASK (((1<HW_SWIZZLECSR2_SASEL_WIDTH)-1)<<HW_SWIZZLECSR2_SASEL_BITPOS)
                             9239 ; 141  |#define HW_SWIZZLECSR2_DESASEL_SETMASK (((1<HW_SWIZZLECSR2_DESASEL_WIDTH)-1)<<HW_SWIZZLECSR2_DESASEL_BITPOS)
                             9240 ; 142  |#define HW_SWIZZLECSR2_BIGE_SETMASK (((1<HW_SWIZZLECSR2_BIGE_WIDTH)-1)<<HW_SWIZZLECSR2_BIGE_BITPOS)
                             9241 ; 143  |#define HW_SWIZZLECSR2_BITREV_SETMASK (((1<HW_SWIZZLECSR2_BITREV_WIDTH)-1)<<HW_SWIZZLECSR2_BITREV_BITPOS)
                             9242 ; 144  |#define HW_SWIZZLECSR2_PLSB_SETMASK (((1<HW_SWIZZLECSR2_PLSB_WIDTH)-1)<<HW_SWIZZLECSR2_PLSB_BITPOS)
                             9243 ; 145  |#define HW_SWIZZLECSR2_PMSB_SETMASK (((1<HW_SWIZZLECSR2_PMSB_WIDTH)-1)<<HW_SWIZZLECSR2_PMSB_BITPOS)
                             9244 ; 146  |#define HW_SWIZZLECSR2_P16L_SETMASK (((1<HW_SWIZZLECSR2_P16L_WIDTH)-1)<<HW_SWIZZLECSR2_P16L_BITPOS)
                             9245 ; 147  |#define HW_SWIZZLECSR2_P16I_SETMASK (((1<HW_SWIZZLECSR2_P16I_WIDTH)-1)<<HW_SWIZZLECSR2_P16I_BITPOS)
                             9246 ; 148  |#define HW_SWIZZLECSR2_BS_EN_SETMASK (((1<HW_SWIZZLECSR2_BS_EN_WIDTH)-1)<<HW_SWIZZLECSR2_BS_EN_BITPOS)
                             9247 ; 149  |#define HW_SWIZZLECSR2_SBYTEDEST_SETMASK (((1<HW_SWIZZLECSR2_SBYTEDEST_WIDTH)-1)<<HW_SWIZZLECSR2_SBYTEDEST_BITPOS)
                             9248 ; 150  |#define HW_SWIZZLECSR2_UNKICK_SETMASK (((1<HW_SWIZZLECSR2_UNKICK_WIDTH)-1)<<HW_SWIZZLECSR2_UNKICK_BITPOS)
                             9249 ; 151  |#define HW_SWIZZLECSR2_RSVD_SETMASK (((1<HW_SWIZZLECSR2_RSVD_WIDTH)-1)<<HW_SWIZZLECSR2_RSVD_BITPOS)
                             9250 ; 152  |
                             9251 ; 153  |#define HW_SWIZZLECSR2_KICK_CLRMASK (~(WORD)HW_SWIZZLECSR2_KICK_SETMASK)
                             9252 ; 154  |#define HW_SWIZZLECSR2_SASEL_CLRMASK (~(WORD)HW_SWIZZLECSR2_SASEL_SETMASK)
                             9253 ; 155  |#define HW_SWIZZLECSR2_DESASEL_CLRMASK (~(WORD)HW_SWIZZLECSR2_DESASEL_SETMASK)
                             9254 ; 156  |#define HW_SWIZZLECSR2_BIGE_CLRMASK (~(WORD)HW_SWIZZLECSR2_BIGE_SETMASK)
                             9255 ; 157  |#define HW_SWIZZLECSR2_BITREV_CLRMASK (~(WORD)HW_SWIZZLECSR2_BITREV_SETMASK)
                             9256 ; 158  |#define HW_SWIZZLECSR2_PLSB_CLRMASK (~(WORD)HW_SWIZZLECSR2_PLSB_SETMASK)
                             9257 ; 159  |#define HW_SWIZZLECSR2_PMSB_CLRMASK (~(WORD)HW_SWIZZLECSR2_PMSB_SETMASK)
                             9258 ; 160  |#define HW_SWIZZLECSR2_P16L_CLRMASK (~(WORD)HW_SWIZZLECSR2_P16L_SETMASK)
                             9259 ; 161  |#define HW_SWIZZLECSR2_P16I_CLRMASK (~(WORD)HW_SWIZZLECSR2_P16I_SETMASK)
                             9260 ; 162  |#define HW_SWIZZLECSR2_BS_EN_CLRMASK (~(WORD)HW_SWIZZLECSR2_BS_EN_SETMASK)
                             9261 ; 163  |#define HW_SWIZZLECSR2_SBYTEDEST_CLRMASK (~(WORD)HW_SWIZZLECSR2_SBYTEDEST_SETMASK)
                             9262 ; 164  |#define HW_SWIZZLECSR2_UNKICK_CLRMASK (~(WORD)HW_SWIZZLECSR2_UNKICK_SETMASK)
                             9263 ; 165  |#define HW_SWIZZLECSR2_RSVD_CLRMASK (~(WORD)HW_SWIZZLECSR2_RSVD_SETMASK)
                             9264 ; 166  |
                             9265 ; 167  |///////////////////////////////////////////////////////////////////////////////
                             9266 ; 168  |typedef union
                             9267 ; 169  |{
                             9268 ; 170  |    struct
                             9269 ; 171  |    {
                             9270 ; 172  |    int KICK    :1;         /* Start transfer                      */
                             9271 ; 173  |    unsigned SASEL :2;              /* Source memory Select                */
                             9272 ; 174  |    unsigned DESASEL :2;                    /* Destination memory Select           */
                             9273 ; 175  |    int BIGE        :1;             /* Big Endian Enable                   */
                             9274 ; 176  |    int BITREV      :1;     /* Bit reverse the data                */
                             9275 ; 177  |    int PLSB        :1;             /* Pass Least Significant Byte         */
                             9276 ; 178  |    int PISB        :1;     /* Pass Intermediate Byte              */
                             9277 ; 179  |    int PMSB        :1;     /* Pass Most Significant Byte          */
                             9278 ; 180  |    int P16L        :1;     /* Pass Least Significant word         */
                             9279 ; 181  |    int P16I        :1;     /* Pass Intermediate significant word  */
                             9280 ; 182  |    int BS_EN       :1;     /* Barrel Shift Enable                 */
                             9281 ; 183  |    unsigned SBYTE  :2;                     /* Start byte                          */
                             9282 ; 184  |    int UNKICK      :1;     /* Halt transfer                       */  
                             9283 ; 185  |    } B;
                             9284 ; 186  |    unsigned int I;
                             9285 ; 187  |    unsigned int U;
                             9286 ; 188  |} swizzlecsr2_type;
                             9287 ; 189  |///////////////////////////////////////////////////////////////////////////////
                             9288 ; 190  |#define HW_SWIZZLECS2R (*(volatile swizzlecsr2_type _X*) (HW_SWIZZLE_BASEADDR+1))     /* Swizzle Control & Status Register 2 */
                             9289 ; 191  |
                             9290 ; 192  |////  Swizzle SIZER (HW_SWIZZLESIZER) Bit Definitions
                             9291 ; 193  |#define HW_SWIZZLESIZER_SIZE_BITPOS (0)
                             9292 ; 194  |#define HW_SWIZZLESIZER_NEW_SHIFT_BITPOS (16)
                             9293 ; 195  |#define HW_SWIZZLESIZER_RSVD_BITPOS (21)
                             9294 ; 196  |
                             9295 ; 197  |#define HW_SWIZZLESIZER_SIZE_WIDTH (16)
                             9296 ; 198  |#define HW_SWIZZLESIZER_NEW_SHIFT_WIDTH (5)
                             9297 ; 199  |#define HW_SWIZZLESIZER_RSVD_WIDTH (3)
                             9298 ; 200  |
                             9299 ; 201  |#define HW_SWIZZLESIZER_SIZE_SETMASK (((1<HW_SWIZZLESIZER_SIZE_WIDTH)-1)<<HW_SWIZZLESIZER_SIZE_BITPOS)
                             9300 ; 202  |#define HW_SWIZZLESIZER_NEW_SHIFT_SETMASK (((1<HW_SWIZZLESIZER_NEW_SHIFT_WIDTH)-1)<<HW_SWIZZLESIZER_NEW_SHIFT_BITPOS)
                             9301 ; 203  |#define HW_SWIZZLESIZER_RSVD_SETMASK (((1<HW_SWIZZLESIZER_RSVD_WIDTH)-1)<<HW_SWIZZLESIZER_RSVD_BITPOS)
                             9302 ; 204  |
                             9303 ; 205  |#define HW_SWIZZLESIZER_SIZE_CLRMASK (~(WORD)HW_SWIZZLESIZER_SIZE_SETMASK)
                             9304 ; 206  |#define HW_SWIZZLESIZER_NEW_SHIFT_CLRMASK (~(WORD)HW_SWIZZLESIZER_NEW_SHIFT_SETMASK)
                             9305 ; 207  |#define HW_SWIZZLESIZER_RSVD_CLRMASK (~(WORD)HW_SWIZZLESIZER_RSVD_SETMASK)
                             9306 ; 208  |
                             9307 ; 209  |///////////////////////////////////////////////////////////////////////////////
                             9308 ; 210  |typedef union
                             9309 ; 211  |{
                             9310 ; 212  |    struct
                             9311 ; 213  |    {
                             9312 ; 214  |    unsigned SIZE      :16;        /* Number of memory words to manipulate */
                             9313 ; 215  |    unsigned NEW_SHIFT :5;         /* Source memory Select                 */
                             9314 ; 216  |    } B;
                             9315 ; 217  |    int I;
                             9316 ; 218  |    unsigned U;
                             9317 ; 219  |} swizzlesizer_type;
                             9318 ; 220  |///////////////////////////////////////////////////////////////////////////////
                             9319 ; 221  |#define HW_SWIZZLESIZER (*(volatile swizzlesizer_type _X*) (HW_SWIZZLE_BASEADDR+2))        /* Swizzle Transfer Size Register */
                             9320 ; 222  |#define HW_SWIZZLESOURCER (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+3))      /* Swizzle Source Address Register */
                             9321 ; 223  |#define HW_SWIZZLEDATA1R (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+4))       /* Swizzle Data1 Register */
                             9322 ; 224  |#define HW_SWIZZLEDATA2R (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+5))       /* Swizzle Data2 Register */
                             9323 ; 225  |#define HW_SWIZZLEDESTADDRR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+6))    /* Swizzle Destination Address Register */
                             9324 ; 226  |#define HW_SWIZZLEBIGENDIANR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+7))   /* Swizzle Big Endian Register */
                             9325 ; 227  |#define HW_SWIZZLEBITREVR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+8))      /* Swizzle BITREV Register */
                             9326 ; 228  |#define HW_SWIZZLEPASSLSBR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+9))     /* Swizzle Pass Least Significant Byte Register */
                             9327 ; 229  |#define HW_SWIZZLEPASSISBR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+10))    /* Swizzle Pass Intermediate Byte Register */
                             9328 ; 230  |#define HW_SWIZZLEPASSMSBR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+11))    /* Swizzle Pass Most Significant Byte Register */
                             9329 ; 231  |#define HW_SWIZZLEPASSLSWR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+12))    /* Swizzle Pass Least Significant Word Register */
                             9330 ; 232  |#define HW_SWIZZLEPASSISWR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+13))    /* Swizzle Pass Intermediate Significant Word Register */
                             9331 ; 233  |#define HW_SWIZZLEPASSMSWR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+14))    /* Swizzle Pass Most Significant Word Register */
                             9332 ; 234  |#define HW_SWIZZLEBARRELR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+15))    /* Swizzle Barrel Shift Register */
                             9333 ; 235  |#define HW_SWIZZLEDIV3LR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+16))    /* Swizzle Divide By 3 Lower Register */
                             9334 ; 236  |
                             9335 ; 237  |
                             9336 ; 238  |////  Swizzle DIV3UR (HW_SWIZZLEDIV3UR) Bit Definitions
                             9337 ; 239  |#define HW_SWIZZLEDIV3UR_DIV3_UPPER_BITPOS (0)
                             9338 ; 240  |#define HW_SWIZZLEDIV3UR_RSVD0_BITPOS (8)
                             9339 ; 241  |#define HW_SWIZZLEDIV3UR_REMAINDER_BITPOS (20)
                             9340 ; 242  |#define HW_SWIZZLEDIV3UR_RSVD1_BITPOS (22)
                             9341 ; 243  |
                             9342 ; 244  |#define HW_SWIZZLEDIV3UR_DIV3_UPPER_WIDTH (8)
                             9343 ; 245  |#define HW_SWIZZLEDIV3UR_RSVD0_WIDTH (12)
                             9344 ; 246  |#define HW_SWIZZLEDIV3UR_REMAINDER_WIDTH (2)
                             9345 ; 247  |#define HW_SWIZZLEDIV3UR_RSVD1_WIDTH (2)
                             9346 ; 248  |
                             9347 ; 249  |#define HW_SWIZZLEDIV3UR_DIV3_UPPER_SETMASK (((1<HW_SWIZZLEDIV3UR_DIV3_UPPER_WIDTH)-1)<<HW_SWIZZLEDIV3UR_DIV3_UPPER_BITPOS)
                             9348 ; 250  |#define HW_SWIZZLEDIV3UR_RSVD0_SETMASK (((1<HW_SWIZZLEDIV3UR_RSVD0_WIDTH)-1)<<HW_SWIZZLEDIV3UR_RSVD0_BITPOS)
                             9349 ; 251  |#define HW_SWIZZLEDIV3UR_REMAINDER_SETMASK (((1<HW_SWIZZLEDIV3UR_REMAINDER_WIDTH)-1)<<HW_SWIZZLEDIV3UR_REMAINDER_BITPOS)
                             9350 ; 252  |#define HW_SWIZZLEDIV3UR_RSVD1_SETMASK (((1<HW_SWIZZLEDIV3UR_RSVD1_WIDTH)-1)<<HW_SWIZZLEDIV3UR_RSVD1_BITPOS)
                             9351 ; 253  |
                             9352 ; 254  |#define HW_SWIZZLEDIV3UR_DIV3_UPPER_CLRMASK (~(WORD)HW_SWIZZLEDIV3UR_DIV3_UPPER_SETMASK)
                             9353 ; 255  |#define HW_SWIZZLEDIV3UR_RSVD0_CLRMASK (~(WORD)HW_SWIZZLEDIV3UR_RSVD0_SETMASK)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  38

M:ADDR CODE           CYCLES LINE SOURCELINE
                             9354 ; 256  |#define HW_SWIZZLEDIV3UR_REMAINDER_CLRMASK (~(WORD)HW_SWIZZLEDIV3UR_REMAINDER_SETMASK)
                             9355 ; 257  |#define HW_SWIZZLEDIV3UR_RSVD1_CLRMASK (~(WORD)HW_SWIZZLEDIV3UR_RSVD1_SETMASK)
                             9356 ; 258  |
                             9357 ; 259  |///////////////////////////////////////////////////////////////////////////////
                             9358 ; 260  |typedef union
                             9359 ; 261  |{
                             9360 ; 262  |    struct
                             9361 ; 263  |    {
                             9362 ; 264  |    unsigned DIV3_UPPER    :8;     /* Number of memory words to manipulate */
                             9363 ; 265  |    unsigned RSVD0         :12;         /* Source memory Select                 */
                             9364 ; 266  |    unsigned REMAINDER     :2;         /* Source memory Select                 */
                             9365 ; 267  |    } B;
                             9366 ; 268  |    int I;
                             9367 ; 269  |    unsigned U;
                             9368 ; 270  |} swizzlediv3ur_type;
                             9369 ; 271  |///////////////////////////////////////////////////////////////////////////////
                             9370 ; 272  |#define HW_SWIZZLEDIV3UR (*(volatile swizzlediv3ur_type _X*) (HW_SWIZZLE_BASEADDR+17))    /* Swizzle Divide By 3 Upper Register */
                             9371 ; 273  |
                             9372 ; 274  |#endif
                             9373 ; 275  |
                             9374 
                             9376 
                             9377 ; 33   |#include "regssdram.h"
                             9378 
                             9380 
                             9381 ; 1    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             9382 ; 2    |//;  Copyright(C) SigmaTel, Inc. 2002-2003
                             9383 ; 3    |//;  File        : regssdram.inc
                             9384 ; 4    |//;  Description : Mixed Signal IP Register definition
                             9385 ; 5    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             9386 ; 6    |
                             9387 ; 7    |// The following naming conventions are followed in this file.
                             9388 ; 8    |// All registers are named using the format...
                             9389 ; 9    |//     HW_<module>_<regname>
                             9390 ; 10   |// where <module> is the module name which can be any of the following...
                             9391 ; 11   |//     SYSTEM
                             9392 ; 12   |// (Note that when there is more than one copy of a particular module, the
                             9393 ; 13   |// module name includes a number starting from 0 for the first instance of
                             9394 ; 14   |// that module)
                             9395 ; 15   |// <regname> is the specific register within that module
                             9396 ; 16   |// We also define the following...
                             9397 ; 17   |//     HW_<module>_<regname>_BITPOS
                             9398 ; 18   |// which defines the starting bit (i.e. LSB) of a multi bit field
                             9399 ; 19   |//     HW_<module>_<regname>_SETMASK
                             9400 ; 20   |// which does something else, and
                             9401 ; 21   |//     HW_<module>_<regname>_CLRMASK
                             9402 ; 22   |// which does something else.
                             9403 ; 23   |// Other rules
                             9404 ; 24   |//     All caps
                             9405 ; 25   |//     Numeric identifiers start at 0
                             9406 ; 26   |
                             9407 ; 27   |#if !(defined(regssdraminc))
                             9408 ; 28   |#define regssdraminc 1
                             9409 ; 29   |
                             9410 ; 30   |#include "types.h"
                             9411 
                             9413 
                             9414 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             9415 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             9416 ; 3    |//
                             9417 ; 4    |// Filename: types.h
                             9418 ; 5    |// Description: Standard data types
                             9419 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             9420 ; 7    |
                             9421 ; 8    |#ifndef _TYPES_H
                             9422 ; 9    |#define _TYPES_H
                             9423 ; 10   |
                             9424 ; 11   |// TODO:  move this outta here!
                             9425 ; 12   |#if !defined(NOERROR)
                             9426 ; 13   |#define NOERROR 0
                             9427 ; 14   |#define SUCCESS 0
                             9428 ; 15   |#endif 
                             9429 ; 16   |#if !defined(SUCCESS)
                             9430 ; 17   |#define SUCCESS  0
                             9431 ; 18   |#endif
                             9432 ; 19   |#if !defined(ERROR)
                             9433 ; 20   |#define ERROR   -1
                             9434 ; 21   |#endif
                             9435 ; 22   |#if !defined(FALSE)
                             9436 ; 23   |#define FALSE 0
                             9437 ; 24   |#endif
                             9438 ; 25   |#if !defined(TRUE)
                             9439 ; 26   |#define TRUE  1
                             9440 ; 27   |#endif
                             9441 ; 28   |
                             9442 ; 29   |#if !defined(NULL)
                             9443 ; 30   |#define NULL 0
                             9444 ; 31   |#endif
                             9445 ; 32   |
                             9446 ; 33   |#define MAX_INT     0x7FFFFF
                             9447 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             9448 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             9449 ; 36   |#define MAX_ULONG   (-1) 
                             9450 ; 37   |
                             9451 ; 38   |#define WORD_SIZE   24              // word size in bits
                             9452 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             9453 ; 40   |
                             9454 ; 41   |
                             9455 ; 42   |#define BYTE    unsigned char       // btVarName
                             9456 ; 43   |#define CHAR    signed char         // cVarName
                             9457 ; 44   |#define USHORT  unsigned short      // usVarName
                             9458 ; 45   |#define SHORT   unsigned short      // sVarName
                             9459 ; 46   |#define WORD    unsigned int        // wVarName
                             9460 ; 47   |#define INT     signed int          // iVarName
                             9461 ; 48   |#define DWORD   unsigned long       // dwVarName
                             9462 ; 49   |#define LONG    signed long         // lVarName
                             9463 ; 50   |#define BOOL    unsigned int        // bVarName
                             9464 ; 51   |#define FRACT   _fract              // frVarName
                             9465 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             9466 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             9467 ; 54   |#define FLOAT   float               // fVarName
                             9468 ; 55   |#define DBL     double              // dVarName
                             9469 ; 56   |#define ENUM    enum                // eVarName
                             9470 ; 57   |#define CMX     _complex            // cmxVarName
                             9471 ; 58   |typedef WORD UCS3;                   // 
                             9472 ; 59   |
                             9473 ; 60   |#define UINT16  unsigned short
                             9474 ; 61   |#define UINT8   unsigned char   
                             9475 ; 62   |#define UINT32  unsigned long
                             9476 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             9477 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             9478 ; 65   |#define WCHAR   UINT16
                             9479 ; 66   |
                             9480 ; 67   |//UINT128 is 16 bytes or 6 words
                             9481 ; 68   |typedef struct UINT128_3500 {   
                             9482 ; 69   |    int val[6];     
                             9483 ; 70   |} UINT128_3500;
                             9484 ; 71   |
                             9485 ; 72   |#define UINT128   UINT128_3500
                             9486 ; 73   |
                             9487 ; 74   |// Little endian word packed byte strings:   
                             9488 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             9489 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             9490 ; 77   |// Little endian word packed byte strings:   
                             9491 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             9492 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             9493 ; 80   |
                             9494 ; 81   |// Declare Memory Spaces To Use When Coding
                             9495 ; 82   |// A. Sector Buffers
                             9496 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             9497 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             9498 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             9499 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             9500 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             9501 ; 88   |// B. Media DDI Memory
                             9502 ; 89   |#define MEDIA_DDI_MEM _Y
                             9503 ; 90   |
                             9504 ; 91   |
                             9505 ; 92   |
                             9506 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             9507 ; 94   |// Examples of circular pointers:
                             9508 ; 95   |//    INT CIRC cpiVarName
                             9509 ; 96   |//    DWORD CIRC cpdwVarName
                             9510 ; 97   |
                             9511 ; 98   |#define RETCODE INT                 // rcVarName
                             9512 ; 99   |
                             9513 ; 100  |// generic bitfield structure
                             9514 ; 101  |struct Bitfield {
                             9515 ; 102  |    unsigned int B0  :1;
                             9516 ; 103  |    unsigned int B1  :1;
                             9517 ; 104  |    unsigned int B2  :1;
                             9518 ; 105  |    unsigned int B3  :1;
                             9519 ; 106  |    unsigned int B4  :1;
                             9520 ; 107  |    unsigned int B5  :1;
                             9521 ; 108  |    unsigned int B6  :1;
                             9522 ; 109  |    unsigned int B7  :1;
                             9523 ; 110  |    unsigned int B8  :1;
                             9524 ; 111  |    unsigned int B9  :1;
                             9525 ; 112  |    unsigned int B10 :1;
                             9526 ; 113  |    unsigned int B11 :1;
                             9527 ; 114  |    unsigned int B12 :1;
                             9528 ; 115  |    unsigned int B13 :1;
                             9529 ; 116  |    unsigned int B14 :1;
                             9530 ; 117  |    unsigned int B15 :1;
                             9531 ; 118  |    unsigned int B16 :1;
                             9532 ; 119  |    unsigned int B17 :1;
                             9533 ; 120  |    unsigned int B18 :1;
                             9534 ; 121  |    unsigned int B19 :1;
                             9535 ; 122  |    unsigned int B20 :1;
                             9536 ; 123  |    unsigned int B21 :1;
                             9537 ; 124  |    unsigned int B22 :1;
                             9538 ; 125  |    unsigned int B23 :1;
                             9539 ; 126  |};
                             9540 ; 127  |
                             9541 ; 128  |union BitInt {
                             9542 ; 129  |        struct Bitfield B;
                             9543 ; 130  |        int        I;
                             9544 ; 131  |};
                             9545 ; 132  |
                             9546 ; 133  |#define MAX_MSG_LENGTH 10
                             9547 ; 134  |struct CMessage
                             9548 ; 135  |{
                             9549 ; 136  |        unsigned int m_uLength;
                             9550 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             9551 ; 138  |};
                             9552 ; 139  |
                             9553 ; 140  |typedef struct {
                             9554 ; 141  |    WORD m_wLength;
                             9555 ; 142  |    WORD m_wMessage;
                             9556 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             9557 ; 144  |} Message;
                             9558 ; 145  |
                             9559 ; 146  |struct MessageQueueDescriptor
                             9560 ; 147  |{
                             9561 ; 148  |        int *m_pBase;
                             9562 ; 149  |        int m_iModulo;
                             9563 ; 150  |        int m_iSize;
                             9564 ; 151  |        int *m_pHead;
                             9565 ; 152  |        int *m_pTail;
                             9566 ; 153  |};
                             9567 ; 154  |
                             9568 ; 155  |struct ModuleEntry
                             9569 ; 156  |{
                             9570 ; 157  |    int m_iSignaledEventMask;
                             9571 ; 158  |    int m_iWaitEventMask;
                             9572 ; 159  |    int m_iResourceOfCode;
                             9573 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             9574 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             9575 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             9576 ; 163  |    int m_uTimeOutHigh;
                             9577 ; 164  |    int m_uTimeOutLow;
                             9578 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             9579 ; 166  |};
                             9580 ; 167  |
                             9581 ; 168  |union WaitMask{
                             9582 ; 169  |    struct B{
                             9583 ; 170  |        unsigned int m_bNone     :1;
                             9584 ; 171  |        unsigned int m_bMessage  :1;
                             9585 ; 172  |        unsigned int m_bTimer    :1;
                             9586 ; 173  |        unsigned int m_bButton   :1;
                             9587 ; 174  |    } B;
                             9588 ; 175  |    int I;
                             9589 ; 176  |} ;
                             9590 ; 177  |
                             9591 ; 178  |
                             9592 ; 179  |struct Button {
                             9593 ; 180  |        WORD wButtonEvent;
                             9594 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             9595 ; 182  |};
                             9596 ; 183  |
                             9597 ; 184  |struct Message {
                             9598 ; 185  |        WORD wMsgLength;
                             9599 ; 186  |        WORD wMsgCommand;
                             9600 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             9601 ; 188  |};
                             9602 ; 189  |
                             9603 ; 190  |union EventTypes {
                             9604 ; 191  |        struct CMessage msg;
                             9605 ; 192  |        struct Button Button ;
                             9606 ; 193  |        struct Message Message;
                             9607 ; 194  |};
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  39

M:ADDR CODE           CYCLES LINE SOURCELINE
                             9608 ; 195  |
                             9609 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             9610 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             9611 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             9612 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             9613 ; 200  |
                             9614 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             9615 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             9616 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             9617 ; 204  |
                             9618 ; 205  |#if DEBUG
                             9619 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             9620 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             9621 ; 208  |#else 
                             9622 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             9623 ; 210  |#define DebugBuildAssert(x)    
                             9624 ; 211  |#endif
                             9625 ; 212  |
                             9626 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             9627 ; 214  |//  #pragma asm
                             9628 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             9629 ; 216  |//  #pragma endasm
                             9630 ; 217  |
                             9631 ; 218  |
                             9632 ; 219  |#ifdef COLOR_262K
                             9633 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             9634 ; 221  |#elif defined(COLOR_65K)
                             9635 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             9636 ; 223  |#else
                             9637 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             9638 ; 225  |#endif
                             9639 ; 226  |    
                             9640 ; 227  |#endif // #ifndef _TYPES_H
                             9641 
                             9643 
                             9644 ; 31   |
                             9645 ; 32   |#define HW_SDRAM_BASEADDR 0xF900
                             9646 ; 33   |
                             9647 ; 34   |
                             9648 ; 35   |/////////////////////////////////////////////////////////////////////////////////
                             9649 ; 36   |//  SDRAM CSR (HW_SDRAM_CSR) Bit Definitions
                             9650 ; 37   |#define HW_SDRAM_CSR_SDRAMEN_BITPOS 0
                             9651 ; 38   |#define HW_SDRAM_CSR_IE_BITPOS 1
                             9652 ; 39   |#define HW_SDRAM_CSR_RNW_BITPOS 2
                             9653 ; 40   |#define HW_SDRAM_CSR_KICK_BITPOS 3
                             9654 ; 41   |#define HW_SDRAM_CSR_LM_BITPOS 4
                             9655 ; 42   |#define HW_SDRAM_CSR_ISTAT_BITPOS 5
                             9656 ; 43   |#define HW_SDRAM_CSR_PWDN_BITPOS 6
                             9657 ; 44   |#define HW_SDRAM_CSR_SBYTE_BITPOS 8
                             9658 ; 45   |#define HW_SDRAM_CSR_MEM_BITPOS 10
                             9659 ; 46   |#define HW_SDRAM_CSR_BIGE_BITPOS 12
                             9660 ; 47   |#define HW_SDRAM_CSR_ASIZE_BITPOS 13
                             9661 ; 48   |#define HW_SDRAM_CSR_UKICK_BITPOS 16
                             9662 ; 49   |#define HW_SDRAM_CSR_DIV_BITPOS 17
                             9663 ; 50   |#define HW_SDRAM_CSR_MULTI_BITPOS 21
                             9664 ; 51   |#define HW_SDRAM_CSR_SDRAM_BITPOS 22
                             9665 ; 52   |#define HW_SDRAM_CSR_SIGN_BITPOS 23
                             9666 ; 53   |
                             9667 ; 54   |#define HW_SDRAM_CSR_SDRAMEN_WIDTH 1
                             9668 ; 55   |#define HW_SDRAM_CSR_IE_WIDTH 1
                             9669 ; 56   |#define HW_SDRAM_CSR_RNW_WIDTH 1
                             9670 ; 57   |#define HW_SDRAM_CSR_KICK_WIDTH 1
                             9671 ; 58   |#define HW_SDRAM_CSR_LM_WIDTH 1
                             9672 ; 59   |#define HW_SDRAM_CSR_ISTAT_WIDTH 1
                             9673 ; 60   |#define HW_SDRAM_CSR_PWDN_WIDTH 1
                             9674 ; 61   |#define HW_SDRAM_CSR_SBYTE_WIDTH 2
                             9675 ; 62   |#define HW_SDRAM_CSR_MEM_WIDTH 2
                             9676 ; 63   |#define HW_SDRAM_CSR_BIGE_WIDTH 1
                             9677 ; 64   |#define HW_SDRAM_CSR_ASIZE_WIDTH 3
                             9678 ; 65   |#define HW_SDRAM_CSR_UKICK_WIDTH 1
                             9679 ; 66   |#define HW_SDRAM_CSR_DIV_WIDTH 4
                             9680 ; 67   |#define HW_SDRAM_CSR_MULTI_WIDTH 1
                             9681 ; 68   |#define HW_SDRAM_CSR_SDRAM_WIDTH 1
                             9682 ; 69   |#define HW_SDRAM_CSR_SIGN_WIDTH 1
                             9683 ; 70   |
                             9684 ; 71   |#define HW_SDRAM_CSR_SDRAMEN_SETMASK (((1<<HW_SDRAM_CSR_SDRAMEN_WIDTH)-1)<<HW_SDRAM_CSR_SDRAMEN_BITPOS)
                             9685 ; 72   |#define HW_SDRAM_CSR_IE_SETMASK (((1<<HW_SDRAM_CSR_IE_WIDTH)-1)<<HW_SDRAM_CSR_IE_BITPOS)
                             9686 ; 73   |#define HW_SDRAM_CSR_RNW_SETMASK (((1<<HW_SDRAM_CSR_RNW_WIDTH)-1)<<HW_SDRAM_CSR_RNW_BITPOS)
                             9687 ; 74   |#define HW_SDRAM_CSR_KICK_SETMASK (((1<<HW_SDRAM_CSR_KICK_WIDTH)-1)<<HW_SDRAM_CSR_KICK_BITPOS)
                             9688 ; 75   |#define HW_SDRAM_CSR_LM_SETMASK (((1<<HW_SDRAM_CSR_LM_WIDTH)-1)<<HW_SDRAM_CSR_LM_BITPOS)
                             9689 ; 76   |#define HW_SDRAM_CSR_ISTAT_SETMASK (((1<<HW_SDRAM_CSR_ISTAT_WIDTH)-1)<<HW_SDRAM_CSR_ISTAT_BITPOS)
                             9690 ; 77   |#define HW_SDRAM_CSR_PWDN_SETMASK (((1<<HW_SDRAM_CSR_PWDN_WIDTH)-1)<<HW_SDRAM_CSR_PWDN_BITPOS)
                             9691 ; 78   |#define HW_SDRAM_CSR_SBYTE_SETMASK (((1<<HW_SDRAM_CSR_SBYTE_WIDTH)-1)<<HW_SDRAM_CSR_SBYTE_BITPOS)
                             9692 ; 79   |#define HW_SDRAM_CSR_MEM_SETMASK (((1<<HW_SDRAM_CSR_MEM_WIDTH)-1)<<HW_SDRAM_CSR_MEM_BITPOS)
                             9693 ; 80   |#define HW_SDRAM_CSR_BIGE_SETMASK (((1<<HW_SDRAM_CSR_BIGE_WIDTH)-1)<<HW_SDRAM_CSR_BIGE_BITPOS)
                             9694 ; 81   |#define HW_SDRAM_CSR_ASIZE_SETMASK (((1<<HW_SDRAM_CSR_ASIZE_WIDTH)-1)<<HW_SDRAM_CSR_ASIZE_BITPOS)
                             9695 ; 82   |#define HW_SDRAM_CSR_UKICK_SETMASK (((1<<HW_SDRAM_CSR_UKICK_WIDTH)-1)<<HW_SDRAM_CSR_UKICK_BITPOS)
                             9696 ; 83   |#define HW_SDRAM_CSR_DIV_SETMASK (((1<<HW_SDRAM_CSR_DIV_WIDTH)-1)<<HW_SDRAM_CSR_DIV_BITPOS)
                             9697 ; 84   |#define HW_SDRAM_CSR_MULTI_SETMASK (((1<<HW_SDRAM_CSR_MULTI_WIDTH)-1)<<HW_SDRAM_CSR_MULTI_BITPOS)
                             9698 ; 85   |#define HW_SDRAM_CSR_SDRAM_SETMASK (((1<<HW_SDRAM_CSR_SDRAM_WIDTH)-1)<<HW_SDRAM_CSR_SDRAM_BITPOS)
                             9699 ; 86   |#define HW_SDRAM_CSR_SIGN_SETMASK (((1<<HW_SDRAM_CSR_SIGN_WIDTH)-1)<<HW_SDRAM_CSR_SIGN_BITPOS)
                             9700 ; 87   |
                             9701 ; 88   |#define HW_SDRAM_CSR_SDRAMEN_CLRMASK ~(WORD)HW_SDRAM_CSR_SDRAMEN_SETMASK
                             9702 ; 89   |#define HW_SDRAM_CSR_IE_CLRMASK ~(WORD)HW_SDRAM_CSR_IE_SETMASK
                             9703 ; 90   |#define HW_SDRAM_CSR_RNW_CLRMASK ~(WORD)HW_SDRAM_CSR_RNW_SETMASK
                             9704 ; 91   |#define HW_SDRAM_CSR_KICK_CLRMASK ~(WORD)HW_SDRAM_CSR_KICK_SETMASK
                             9705 ; 92   |#define HW_SDRAM_CSR_LM_CLRMASK ~(WORD)HW_SDRAM_CSR_LM_SETMASK
                             9706 ; 93   |#define HW_SDRAM_CSR_ISTAT_CLRMASK ~(WORD)HW_SDRAM_CSR_ISTAT_SETMASK
                             9707 ; 94   |#define HW_SDRAM_CSR_PWDN_CLRMASK ~(WORD)HW_SDRAM_CSR_PWDN_SETMASK
                             9708 ; 95   |#define HW_SDRAM_CSR_SBYTE_CLRMASK ~(WORD)HW_SDRAM_CSR_SBYTE_SETMASK
                             9709 ; 96   |#define HW_SDRAM_CSR_MEM_CLRMASK ~(WORD)HW_SDRAM_CSR_MEM_SETMASK
                             9710 ; 97   |#define HW_SDRAM_CSR_BIGE_CLRMASK ~(WORD)HW_SDRAM_CSR_BIGE_SETMASK
                             9711 ; 98   |#define HW_SDRAM_CSR_ASIZE_CLRMASK ~(WORD)HW_SDRAM_CSR_ASIZE_SETMASK
                             9712 ; 99   |#define HW_SDRAM_CSR_UKICK_CLRMASK ~(WORD)HW_SDRAM_CSR_UKICK_SETMASK
                             9713 ; 100  |#define HW_SDRAM_CSR_DIV_CLRMASK ~(WORD)HW_SDRAM_CSR_DIV_SETMASK
                             9714 ; 101  |#define HW_SDRAM_CSR_MULTI_CLRMASK ~(WORD)HW_SDRAM_CSR_MULTI_SETMASK
                             9715 ; 102  |#define HW_SDRAM_CSR_SDRAM_CLRMASK ~(WORD)HW_SDRAM_CSR_SDRAM_SETMASK
                             9716 ; 103  |#define HW_SDRAM_CSR_SIGN_CLRMASK ~(WORD)HW_SDRAM_CSR_SIGN_SETMASK
                             9717 ; 104  |
                             9718 ; 105  |typedef union               
                             9719 ; 106  |{
                             9720 ; 107  |    struct {
                             9721 ; 108  |        int SDRAMEN                     :1;
                             9722 ; 109  |        int IE                          :1;
                             9723 ; 110  |        int RNW                         :1;
                             9724 ; 111  |        int KICK                        :1;
                             9725 ; 112  |        int LM                          :1;
                             9726 ; 113  |        int ISTAT                       :1;
                             9727 ; 114  |        int PWDN                        :1;
                             9728 ; 115  |        int RSVD                        :1;
                             9729 ; 116  |        int SBYTE                       :2;
                             9730 ; 117  |        int MEM                         :2;
                             9731 ; 118  |        int BIGE                        :1;
                             9732 ; 119  |        int ASIZE                       :3;
                             9733 ; 120  |        int UKICK                       :1;
                             9734 ; 121  |        int DIV                         :4;
                             9735 ; 122  |        int MULTI                       :1;
                             9736 ; 123  |        int SDRAM                       :1;
                             9737 ; 124  |        int SIGN                        :1;
                             9738 ; 125  |    } B;
                             9739 ; 126  |    int I;
                             9740 ; 127  |} sdramcsr_type;
                             9741 ; 128  |#define HW_SDRAM_CSR (*(volatile sdramcsr_type _X*) (HW_SDRAM_BASEADDR))        
                             9742 ; 129  |#define HW_SDRAM_ADDR1 (*(volatile unsigned int _X*) (HW_SDRAM_BASEADDR+1))
                             9743 ; 130  |#define HW_SDRAM_ADDR2 (*(volatile unsigned int _X*) (HW_SDRAM_BASEADDR+2))
                             9744 ; 131  |#define HW_SDRAM_SYSADDR (*(volatile unsigned int _X*) (HW_SDRAM_BASEADDR+3))
                             9745 ; 132  |#define HW_SDRAM_SIZE (*(volatile unsigned int _X*) (HW_SDRAM_BASEADDR+4))
                             9746 ; 133  |#define HW_SDRAM_BAR (*(volatile unsigned int _X*) (HW_SDRAM_BASEADDR+7))
                             9747 ; 134  |#define HW_SDRAM_MR (*(volatile unsigned int _X*) (HW_SDRAM_BASEADDR+8))
                             9748 ; 135  |#define HW_SDRAM_DBAR1 (*(volatile unsigned int _X*) (HW_SDRAM_BASEADDR+9))
                             9749 ; 136  |#define HW_SDRAM_DBAR2 (*(volatile unsigned int _X*) (HW_SDRAM_BASEADDR+10))
                             9750 ; 137  |#define HW_SDRAM_DMR1 (*(volatile unsigned int _X*) (HW_SDRAM_BASEADDR+11))
                             9751 ; 138  |#define HW_SDRAM_DMR2 (*(volatile unsigned int _X*) (HW_SDRAM_BASEADDR+12))
                             9752 ; 139  |
                             9753 ; 140  |/////////////////////////////////////////////////////////////////////////////////
                             9754 ; 141  |//  SDRAM Start Address Low Register (HW_SDRAM_ADDR1) Bit Definitions
                             9755 ; 142  |#define HW_SDRAM_ADDR1_XA_BITPOS 0
                             9756 ; 143  |
                             9757 ; 144  |#define HW_SDRAM_ADDR1_XA_SETMASK 0xFFFFFF<<HW_SDRAM_ADDR1_XA_BITPOS
                             9758 ; 145  |
                             9759 ; 146  |#define HW_SDRAM_ADDR1_XA_CLRMASK ~(WORD)HW_SDRAM_ADDR1_XA_SETMASK
                             9760 ; 147  |
                             9761 ; 148  |/////////////////////////////////////////////////////////////////////////////////
                             9762 ; 149  |//  SDRAM Start Address High Register (HW_SDRAM_ADDR2) Bit Definitions
                             9763 ; 150  |#define HW_SDRAM_ADDR2_XA_BITPOS 0
                             9764 ; 151  |
                             9765 ; 152  |#define HW_SDRAM_ADDR2_XA_SETMASK 0x1F<<HW_SDRAM_ADDR2_XA_BITPOS
                             9766 ; 153  |
                             9767 ; 154  |#define HW_SDRAM_ADDR2_XA_CLRMASK ~(WORD)HW_SDRAM_ADDR2_XA_SETMASK
                             9768 ; 155  |
                             9769 ; 156  |/////////////////////////////////////////////////////////////////////////////////
                             9770 ; 157  |//  System Start Address Register (HW_SDRAM_SYSADDR) Bit Definitions
                             9771 ; 158  |#define HW_SDRAM_SYSADDR_XA_BITPOS 0
                             9772 ; 159  |
                             9773 ; 160  |#define HW_SDRAM_SYSADDR_XA_SETMASK 0xFFFF<<HW_SDRAM_SYSADDR_XA_BITPOS
                             9774 ; 161  |
                             9775 ; 162  |#define HW_SDRAM_SYSADDR_XA_CLRMASK ~(WORD)HW_SDRAM_SYSADDR_XA_SETMASK
                             9776 ; 163  |
                             9777 ; 164  |/////////////////////////////////////////////////////////////////////////////////
                             9778 ; 165  |//  Number of Bytes to be transfered Register (HW_SDRAM_SIZE) Bit Definitions
                             9779 ; 166  |#define HW_SDRAM_SIZE_XA_BITPOS 0
                             9780 ; 167  |
                             9781 ; 168  |#define HW_SDRAM_SIZE_XA_SETMASK 0x3FFFF<<HW_SDRAM_SIZE_XA_BITPOS
                             9782 ; 169  |
                             9783 ; 170  |#define HW_SDRAM_SIZE_XA_CLRMASK ~(WORD)HW_SDRAM_SIZE_XA_SETMASK
                             9784 ; 171  |
                             9785 ; 172  |/////////////////////////////////////////////////////////////////////////////////
                             9786 ; 173  |//  SDRAM Timer1 Register (HW_SDRAM_TIMER1) Bit Definitions
                             9787 ; 174  |#define HW_SDRAM_TIMER1_INIT_BITPOS 0
                             9788 ; 175  |#define HW_SDRAM_TIMER1_TRP_BITPOS 16
                             9789 ; 176  |#define HW_SDRAM_TIMER1_TRFC_BITPOS 20
                             9790 ; 177  |
                             9791 ; 178  |#define HW_SDRAM_TIMER1_INIT_WIDTH 16
                             9792 ; 179  |#define HW_SDRAM_TIMER1_TRP_WIDTH 4
                             9793 ; 180  |#define HW_SDRAM_TIMER1_TRFC_WIDTH 4
                             9794 ; 181  |
                             9795 ; 182  |#define HW_SDRAM_TIMER1_INIT_SETMASK (((1<<HW_SDRAM_TIMER1_INIT_WIDTH)-1)<<HW_SDRAM_TIMER1_INIT_BITPOS)
                             9796 ; 183  |#define HW_SDRAM_TIMER1_TRP_SETMASK (((1<<HW_SDRAM_TIMER1_TRP_WIDTH)-1)<<HW_SDRAM_TIMER1_TRP_BITPOS)
                             9797 ; 184  |#define HW_SDRAM_TIMER1_TRFC_SETMASK (((1<<HW_SDRAM_TIMER1_TRFC_WIDTH)-1)<<HW_SDRAM_TIMER1_TRFC_BITPOS)
                             9798 ; 185  |
                             9799 ; 186  |#define HW_SDRAM_TIMER1_INIT_CLRMASK ~(WORD)HW_SDRAM_TIMER1_INIT_SETMASK
                             9800 ; 187  |#define HW_SDRAM_TIMER1_TRP_CLRMASK ~(WORD)HW_SDRAM_TIMER1_TRP_SETMASK
                             9801 ; 188  |#define HW_SDRAM_TIMER1_TRFC_CLRMASK ~(WORD)HW_SDRAM_TIMER1_TRFC_SETMASK
                             9802 ; 189  |
                             9803 ; 190  |typedef union               
                             9804 ; 191  |{
                             9805 ; 192  |    struct {
                             9806 ; 193  |        int INIT                :16;
                             9807 ; 194  |        int TRP                 :4;
                             9808 ; 195  |        int TRFC                :4;
                             9809 ; 196  |    } B;
                             9810 ; 197  |    int I;
                             9811 ; 198  |} sdramtimer1_type;
                             9812 ; 199  |#define HW_SDRAM_TIMER1 (*(volatile sdramtimer1_type _X*) (HW_SDRAM_BASEADDR+5))
                             9813 ; 200  |
                             9814 ; 201  |/////////////////////////////////////////////////////////////////////////////////
                             9815 ; 202  |//  SDRAM Timer2 Register (HW_SDRAM_TIMER2) Bit Definitions
                             9816 ; 203  |#define HW_SDRAM_TIMER2_TXSR_BITPOS 0
                             9817 ; 204  |#define HW_SDRAM_TIMER2_TREF_BITPOS 4
                             9818 ; 205  |#define HW_SDRAM_TIMER2_TRCD_BITPOS 16
                             9819 ; 206  |
                             9820 ; 207  |#define HW_SDRAM_TIMER2_TXSR_WIDTH 4
                             9821 ; 208  |#define HW_SDRAM_TIMER2_TREF_WIDTH 12
                             9822 ; 209  |#define HW_SDRAM_TIMER2_TRCD_WIDTH 4
                             9823 ; 210  |
                             9824 ; 211  |#define HW_SDRAM_TIMER2_TXSR_SETMASK (((1<<HW_SDRAM_TIMER2_TXSR_WIDTH)-1)<<HW_SDRAM_TIMER2_TXSR_BITPOS)
                             9825 ; 212  |#define HW_SDRAM_TIMER2_TREF_SETMASK (((1<<HW_SDRAM_TIMER2_TREF_WIDTH)-1)<<HW_SDRAM_TIMER2_TREF_BITPOS)
                             9826 ; 213  |#define HW_SDRAM_TIMER2_TRCD_SETMASK (((1<<HW_SDRAM_TIMER2_TRCD_WIDTH)-1)<<HW_SDRAM_TIMER2_TRCD_BITPOS)
                             9827 ; 214  |
                             9828 ; 215  |#define HW_SDRAM_TIMER2_TXSR_CLRMASK ~(WORD)HW_SDRAM_TIMER2_TXSR_SETMASK
                             9829 ; 216  |#define HW_SDRAM_TIMER2_TREF_CLRMASK ~(WORD)HW_SDRAM_TIMER2_TREF_SETMASK
                             9830 ; 217  |#define HW_SDRAM_TIMER2_TRCD_CLRMASK ~(WORD)HW_SDRAM_TIMER2_TRCD_SETMASK
                             9831 ; 218  |
                             9832 ; 219  |typedef union               
                             9833 ; 220  |{
                             9834 ; 221  |    struct {
                             9835 ; 222  |        int TXSR                :4;
                             9836 ; 223  |        int TREF                :12;
                             9837 ; 224  |        int TRCD                :4;
                             9838 ; 225  |        int RSVD                :4; 
                             9839 ; 226  |    } B;
                             9840 ; 227  |    int I;
                             9841 ; 228  |} sdramtimer2_type;
                             9842 ; 229  |#define HW_SDRAM_TIMER2 (*(volatile sdramtimer2_type _X*) (HW_SDRAM_BASEADDR+6))
                             9843 ; 230  |
                             9844 ; 231  |/////////////////////////////////////////////////////////////////////////////////
                             9845 ; 232  |//  System Modulo Base Address Register (HW_SDRAM_BAR) Bit Definitions
                             9846 ; 233  |#define HW_SDRAM_BAR_XA_BITPOS 0
                             9847 ; 234  |
                             9848 ; 235  |#define HW_SDRAM_BAR_XA_SETMASK 0xFFFF<<HW_SDRAM_BAR_XA_BITPOS
                             9849 ; 236  |
                             9850 ; 237  |#define HW_SDRAM_BAR_XA_CLRMASK ~(WORD)HW_SDRAM_BAR_XA_SETMASK
                             9851 ; 238  |
                             9852 ; 239  |/////////////////////////////////////////////////////////////////////////////////
                             9853 ; 240  |//  System Modulo Register (HW_SDRAM_MR) Bit Definitions
                             9854 ; 241  |#define HW_SDRAM_MR_XA_BITPOS 0
                             9855 ; 242  |
                             9856 ; 243  |#define HW_SDRAM_MR_XA_SETMASK 0xFFFF<<HW_SDRAM_MR_XA_BITPOS
                             9857 ; 244  |
                             9858 ; 245  |#define HW_SDRAM_MR_XA_CLRMASK ~(WORD)HW_SDRAM_MR_XA_SETMASK
                             9859 ; 246  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  40

M:ADDR CODE           CYCLES LINE SOURCELINE
                             9860 ; 247  |/////////////////////////////////////////////////////////////////////////////////
                             9861 ; 248  |//  SDRAM Mode Register (HW_SDRAM_MODE) Bit Definitions
                             9862 ; 249  |#define HW_SDRAM_MODE_XA_BITPOS 0
                             9863 ; 250  |
                             9864 ; 251  |#define HW_SDRAM_MODE_XA_WIDTH 14
                             9865 ; 252  |
                             9866 ; 253  |#define HW_SDRAM_MODE_XA_SETMASK (((1<<HW_SDRAM_MODE_XA_WIDTH)-1)<<HW_SDRAM_MODE_XA_BITPOS)
                             9867 ; 254  |
                             9868 ; 255  |#define HW_SDRAM_MODE_XA_CLRMASK ~(WORD)HW_SDRAM_MODE_XA_SETMASK
                             9869 ; 256  |
                             9870 ; 257  |typedef union               
                             9871 ; 258  |{
                             9872 ; 259  |    struct {
                             9873 ; 260  |        int VALUE               :14;
                             9874 ; 261  |        int RSVD                :10; 
                             9875 ; 262  |    } B;
                             9876 ; 263  |    int I;
                             9877 ; 264  |} sdrammode_type;
                             9878 ; 265  |#define HW_SDRAM_MODE (*(volatile sdrammode_type _X*) (HW_SDRAM_BASEADDR+14))
                             9879 ; 266  |
                             9880 ; 267  |/////////////////////////////////////////////////////////////////////////////////
                             9881 ; 268  |//  SDRAM Type Register (HW_SDRAM_TYPE) Bit Definitions
                             9882 ; 269  |#define HW_SDRAM_TYPE_COLWIDTH_BITPOS 0
                             9883 ; 270  |#define HW_SDRAM_TYPE_ROWWIDTH_BITPOS 4
                             9884 ; 271  |
                             9885 ; 272  |#define HW_SDRAM_TYPE_COLWIDTH_WIDTH 4
                             9886 ; 273  |#define HW_SDRAM_TYPE_ROWWIDTH_WIDTH 4
                             9887 ; 274  |
                             9888 ; 275  |#define HW_SDRAM_TYPE_COLWIDTH_SETMASK (((1<<HW_SDRAM_TYPE_COLWIDTH_WIDTH)-1)<<HW_SDRAM_TYPE_COLWIDTH_BITPOS)
                             9889 ; 276  |#define HW_SDRAM_TYPE_ROWWIDTH_SETMASK (((1<<HW_SDRAM_TYPE_ROWWIDTH_WIDTH)-1)<<HW_SDRAM_TYPE_ROWWIDTH_BITPOS)
                             9890 ; 277  |
                             9891 ; 278  |#define HW_SDRAM_TYPE_COLWIDTH_CLRMASK (~(WORD)HW_SDRAM_TYPE_COLWIDTH_SETMASK)
                             9892 ; 279  |#define HW_SDRAM_TYPE_ROWWIDTH_CLRMASK (~(WORD)HW_SDRAM_TYPE_ROWWIDTH_SETMASK)
                             9893 ; 280  |
                             9894 ; 281  |typedef union               
                             9895 ; 282  |{
                             9896 ; 283  |    struct {
                             9897 ; 284  |        int COLWIDTH               :4;
                             9898 ; 285  |        int ROWWIDTH               :4; 
                             9899 ; 286  |    } B;
                             9900 ; 287  |    int I;
                             9901 ; 288  |} sdramtype_type;
                             9902 ; 289  |#define HW_SDRAM_TYPE (*(volatile sdramtype_type _X*) (HW_SDRAM_BASEADDR+14))
                             9903 ; 290  |
                             9904 ; 291  |#endif
                             9905 ; 292  |
                             9906 ; 293  |
                             9907 ; 294  |
                             9908 ; 295  |
                             9909 ; 296  |
                             9910 ; 297  |
                             9911 
                             9913 
                             9914 ; 34   |#include "regstb.h"
                             9915 
                             9917 
                             9918 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             9919 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2003
                             9920 ; 3    |// Filename: regstb.inc
                             9921 ; 4    |// Description: Register definitions for Trace Buffer
                             9922 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             9923 ; 6    |// The following naming conventions are followed in this file.
                             9924 ; 7    |// All registers are named using the format...
                             9925 ; 8    |//     HW_<module>_<regname>
                             9926 ; 9    |// where <module> is the module name which can be any of the following...
                             9927 ; 10   |//     USB20
                             9928 ; 11   |// (Note that when there is more than one copy of a particular module, the
                             9929 ; 12   |// module name includes a number starting from 0 for the first instance of
                             9930 ; 13   |// that module)
                             9931 ; 14   |// <regname> is the specific register within that module
                             9932 ; 15   |// We also define the following...
                             9933 ; 16   |//     HW_<module>_<regname>_BITPOS
                             9934 ; 17   |// which defines the starting bit (i.e. LSB) of a multi bit field
                             9935 ; 18   |//     HW_<module>_<regname>_SETMASK
                             9936 ; 19   |// which does something else, and
                             9937 ; 20   |//     HW_<module>_<regname>_CLRMASK
                             9938 ; 21   |// which does something else.
                             9939 ; 22   |// Other rules
                             9940 ; 23   |//     All caps
                             9941 ; 24   |//     Numeric identifiers start at 0
                             9942 ; 25   |#if !(defined(regstbinc))
                             9943 ; 26   |#define regstbinc 1
                             9944 ; 27   |
                             9945 ; 28   |#include "types.h"
                             9946 
                             9948 
                             9949 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             9950 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             9951 ; 3    |//
                             9952 ; 4    |// Filename: types.h
                             9953 ; 5    |// Description: Standard data types
                             9954 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             9955 ; 7    |
                             9956 ; 8    |#ifndef _TYPES_H
                             9957 ; 9    |#define _TYPES_H
                             9958 ; 10   |
                             9959 ; 11   |// TODO:  move this outta here!
                             9960 ; 12   |#if !defined(NOERROR)
                             9961 ; 13   |#define NOERROR 0
                             9962 ; 14   |#define SUCCESS 0
                             9963 ; 15   |#endif 
                             9964 ; 16   |#if !defined(SUCCESS)
                             9965 ; 17   |#define SUCCESS  0
                             9966 ; 18   |#endif
                             9967 ; 19   |#if !defined(ERROR)
                             9968 ; 20   |#define ERROR   -1
                             9969 ; 21   |#endif
                             9970 ; 22   |#if !defined(FALSE)
                             9971 ; 23   |#define FALSE 0
                             9972 ; 24   |#endif
                             9973 ; 25   |#if !defined(TRUE)
                             9974 ; 26   |#define TRUE  1
                             9975 ; 27   |#endif
                             9976 ; 28   |
                             9977 ; 29   |#if !defined(NULL)
                             9978 ; 30   |#define NULL 0
                             9979 ; 31   |#endif
                             9980 ; 32   |
                             9981 ; 33   |#define MAX_INT     0x7FFFFF
                             9982 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             9983 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             9984 ; 36   |#define MAX_ULONG   (-1) 
                             9985 ; 37   |
                             9986 ; 38   |#define WORD_SIZE   24              // word size in bits
                             9987 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             9988 ; 40   |
                             9989 ; 41   |
                             9990 ; 42   |#define BYTE    unsigned char       // btVarName
                             9991 ; 43   |#define CHAR    signed char         // cVarName
                             9992 ; 44   |#define USHORT  unsigned short      // usVarName
                             9993 ; 45   |#define SHORT   unsigned short      // sVarName
                             9994 ; 46   |#define WORD    unsigned int        // wVarName
                             9995 ; 47   |#define INT     signed int          // iVarName
                             9996 ; 48   |#define DWORD   unsigned long       // dwVarName
                             9997 ; 49   |#define LONG    signed long         // lVarName
                             9998 ; 50   |#define BOOL    unsigned int        // bVarName
                             9999 ; 51   |#define FRACT   _fract              // frVarName
                            10000 ; 52   |#define LFRACT  long _fract         // lfrVarName
                            10001 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                            10002 ; 54   |#define FLOAT   float               // fVarName
                            10003 ; 55   |#define DBL     double              // dVarName
                            10004 ; 56   |#define ENUM    enum                // eVarName
                            10005 ; 57   |#define CMX     _complex            // cmxVarName
                            10006 ; 58   |typedef WORD UCS3;                   // 
                            10007 ; 59   |
                            10008 ; 60   |#define UINT16  unsigned short
                            10009 ; 61   |#define UINT8   unsigned char   
                            10010 ; 62   |#define UINT32  unsigned long
                            10011 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            10012 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            10013 ; 65   |#define WCHAR   UINT16
                            10014 ; 66   |
                            10015 ; 67   |//UINT128 is 16 bytes or 6 words
                            10016 ; 68   |typedef struct UINT128_3500 {   
                            10017 ; 69   |    int val[6];     
                            10018 ; 70   |} UINT128_3500;
                            10019 ; 71   |
                            10020 ; 72   |#define UINT128   UINT128_3500
                            10021 ; 73   |
                            10022 ; 74   |// Little endian word packed byte strings:   
                            10023 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            10024 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            10025 ; 77   |// Little endian word packed byte strings:   
                            10026 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            10027 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            10028 ; 80   |
                            10029 ; 81   |// Declare Memory Spaces To Use When Coding
                            10030 ; 82   |// A. Sector Buffers
                            10031 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                            10032 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                            10033 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                            10034 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                            10035 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                            10036 ; 88   |// B. Media DDI Memory
                            10037 ; 89   |#define MEDIA_DDI_MEM _Y
                            10038 ; 90   |
                            10039 ; 91   |
                            10040 ; 92   |
                            10041 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                            10042 ; 94   |// Examples of circular pointers:
                            10043 ; 95   |//    INT CIRC cpiVarName
                            10044 ; 96   |//    DWORD CIRC cpdwVarName
                            10045 ; 97   |
                            10046 ; 98   |#define RETCODE INT                 // rcVarName
                            10047 ; 99   |
                            10048 ; 100  |// generic bitfield structure
                            10049 ; 101  |struct Bitfield {
                            10050 ; 102  |    unsigned int B0  :1;
                            10051 ; 103  |    unsigned int B1  :1;
                            10052 ; 104  |    unsigned int B2  :1;
                            10053 ; 105  |    unsigned int B3  :1;
                            10054 ; 106  |    unsigned int B4  :1;
                            10055 ; 107  |    unsigned int B5  :1;
                            10056 ; 108  |    unsigned int B6  :1;
                            10057 ; 109  |    unsigned int B7  :1;
                            10058 ; 110  |    unsigned int B8  :1;
                            10059 ; 111  |    unsigned int B9  :1;
                            10060 ; 112  |    unsigned int B10 :1;
                            10061 ; 113  |    unsigned int B11 :1;
                            10062 ; 114  |    unsigned int B12 :1;
                            10063 ; 115  |    unsigned int B13 :1;
                            10064 ; 116  |    unsigned int B14 :1;
                            10065 ; 117  |    unsigned int B15 :1;
                            10066 ; 118  |    unsigned int B16 :1;
                            10067 ; 119  |    unsigned int B17 :1;
                            10068 ; 120  |    unsigned int B18 :1;
                            10069 ; 121  |    unsigned int B19 :1;
                            10070 ; 122  |    unsigned int B20 :1;
                            10071 ; 123  |    unsigned int B21 :1;
                            10072 ; 124  |    unsigned int B22 :1;
                            10073 ; 125  |    unsigned int B23 :1;
                            10074 ; 126  |};
                            10075 ; 127  |
                            10076 ; 128  |union BitInt {
                            10077 ; 129  |        struct Bitfield B;
                            10078 ; 130  |        int        I;
                            10079 ; 131  |};
                            10080 ; 132  |
                            10081 ; 133  |#define MAX_MSG_LENGTH 10
                            10082 ; 134  |struct CMessage
                            10083 ; 135  |{
                            10084 ; 136  |        unsigned int m_uLength;
                            10085 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                            10086 ; 138  |};
                            10087 ; 139  |
                            10088 ; 140  |typedef struct {
                            10089 ; 141  |    WORD m_wLength;
                            10090 ; 142  |    WORD m_wMessage;
                            10091 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                            10092 ; 144  |} Message;
                            10093 ; 145  |
                            10094 ; 146  |struct MessageQueueDescriptor
                            10095 ; 147  |{
                            10096 ; 148  |        int *m_pBase;
                            10097 ; 149  |        int m_iModulo;
                            10098 ; 150  |        int m_iSize;
                            10099 ; 151  |        int *m_pHead;
                            10100 ; 152  |        int *m_pTail;
                            10101 ; 153  |};
                            10102 ; 154  |
                            10103 ; 155  |struct ModuleEntry
                            10104 ; 156  |{
                            10105 ; 157  |    int m_iSignaledEventMask;
                            10106 ; 158  |    int m_iWaitEventMask;
                            10107 ; 159  |    int m_iResourceOfCode;
                            10108 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                            10109 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                            10110 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                            10111 ; 163  |    int m_uTimeOutHigh;
                            10112 ; 164  |    int m_uTimeOutLow;
                            10113 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  41

M:ADDR CODE           CYCLES LINE SOURCELINE
                            10114 ; 166  |};
                            10115 ; 167  |
                            10116 ; 168  |union WaitMask{
                            10117 ; 169  |    struct B{
                            10118 ; 170  |        unsigned int m_bNone     :1;
                            10119 ; 171  |        unsigned int m_bMessage  :1;
                            10120 ; 172  |        unsigned int m_bTimer    :1;
                            10121 ; 173  |        unsigned int m_bButton   :1;
                            10122 ; 174  |    } B;
                            10123 ; 175  |    int I;
                            10124 ; 176  |} ;
                            10125 ; 177  |
                            10126 ; 178  |
                            10127 ; 179  |struct Button {
                            10128 ; 180  |        WORD wButtonEvent;
                            10129 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                            10130 ; 182  |};
                            10131 ; 183  |
                            10132 ; 184  |struct Message {
                            10133 ; 185  |        WORD wMsgLength;
                            10134 ; 186  |        WORD wMsgCommand;
                            10135 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                            10136 ; 188  |};
                            10137 ; 189  |
                            10138 ; 190  |union EventTypes {
                            10139 ; 191  |        struct CMessage msg;
                            10140 ; 192  |        struct Button Button ;
                            10141 ; 193  |        struct Message Message;
                            10142 ; 194  |};
                            10143 ; 195  |
                            10144 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                            10145 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                            10146 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                            10147 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                            10148 ; 200  |
                            10149 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                            10150 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                            10151 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                            10152 ; 204  |
                            10153 ; 205  |#if DEBUG
                            10154 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                            10155 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                            10156 ; 208  |#else 
                            10157 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                            10158 ; 210  |#define DebugBuildAssert(x)    
                            10159 ; 211  |#endif
                            10160 ; 212  |
                            10161 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                            10162 ; 214  |//  #pragma asm
                            10163 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                            10164 ; 216  |//  #pragma endasm
                            10165 ; 217  |
                            10166 ; 218  |
                            10167 ; 219  |#ifdef COLOR_262K
                            10168 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                            10169 ; 221  |#elif defined(COLOR_65K)
                            10170 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                            10171 ; 223  |#else
                            10172 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                            10173 ; 225  |#endif
                            10174 ; 226  |    
                            10175 ; 227  |#endif // #ifndef _TYPES_H
                            10176 
                            10178 
                            10179 ; 29   |
                            10180 ; 30   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            10181 ; 31   |
                            10182 ; 32   |//   Trace Buffer STMP Registers 
                            10183 ; 33   |//   Last Updated 6.30.2003 D. Baker
                            10184 ; 34   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            10185 ; 35   |
                            10186 ; 36   |#define HW_TB_BASEADDR (0xF080)
                            10187 ; 37   |
                            10188 ; 38   |
                            10189 ; 39   |
                            10190 ; 40   |
                            10191 ; 41   |/////////////////////////////////////////////////////////////////////////////////
                            10192 ; 42   |
                            10193 ; 43   |//  Trace Buffer Configuration Register (HW_TB_CFG) Bit Definitions
                            10194 ; 44   |
                            10195 ; 45   |#define HW_TB_CFG_CLK_ENABLE_BITPOS (0)
                            10196 ; 46   |#define HW_TB_CFG_ENABLE_BITPOS (1)
                            10197 ; 47   |#define HW_TB_CFG_DONE_BITPOS (3)
                            10198 ; 48   |#define HW_TB_CFG_DMA_ASEL_BITPOS (4)
                            10199 ; 49   |#define HW_TB_CFG_TRIG_EVENT_BITPOS (6)
                            10200 ; 50   |
                            10201 ; 51   |#define HW_TB_CFG_CLK_ENABLE_WIDTH (1)
                            10202 ; 52   |#define HW_TB_CFG_ENABLE_WIDTH (1)
                            10203 ; 53   |#define HW_TB_CFG_RSVD1_WIDTH (1)
                            10204 ; 54   |#define HW_TB_CFG_DONE_WIDTH (1)
                            10205 ; 55   |#define HW_TB_CFG_DMA_ASEL_WIDTH (2)
                            10206 ; 56   |#define HW_TB_CFG_TRIG_EVENT_WIDTH (1)
                            10207 ; 57   |#define HW_TB_CFG_RSVD2_WIDTH (17)
                            10208 ; 58   |
                            10209 ; 59   |#define HW_TB_CFG_CLK_ENABLE_SETMASK (((1<<HW_TB_CFG_CLK_ENABLE_WIDTH)-1)<<HW_TB_CFG_CLK_ENABLE_BITPOS) 
                            10210 ; 60   |#define HW_TB_CFG_ENABLE_SETMASK (((1<<HW_TB_CFG_ENABLE_WIDTH)-1)<<HW_TB_CFG_ENABLE_BITPOS) 
                            10211 ; 61   |#define HW_TB_CFG_DONE_SETMASK (((1<<HW_TB_CFG_DONE_WIDTH)-1)<<HW_TB_CFG_DONE_BITPOS) 
                            10212 ; 62   |#define HW_TB_CFG_DMA_ASEL_SETMASK (((1<<HW_TB_CFG_DMA_ASEL_WIDTH)-1)<<HW_TB_CFG_DMA_ASEL_BITPOS) 
                            10213 ; 63   |#define HW_TB_CFG_TRIG_EVENT_SETMASK (((1<<HW_TB_CFG_TRIG_EVENT_WIDTH)-1)<<HW_TB_CFG_TRIG_EVENT_BITPOS) 
                            10214 ; 64   |
                            10215 ; 65   |#define HW_TB_CFG_CLK_ENABLE_CLRMASK (~(WORD)HW_TB_CFG_CLK_ENABLE_SETMASK)
                            10216 ; 66   |#define HW_TB_CFG_ENABLE_CLRMASK (~(WORD)HW_TB_CFG_ENABLE_SETMASK)
                            10217 ; 67   |#define HW_TB_CFG_DONE_CLRMASK (~(WORD)HW_TB_CFG_DONE_SETMASK)
                            10218 ; 68   |#define HW_TB_CFG_DMA_ASEL_CLRMASK (~(WORD)HW_TB_CFG_DMA_ASEL_SETMASK)
                            10219 ; 69   |#define HW_TB_CFG_TRIG_EVENT_CLRMASK (~(WORD)HW_TB_CFG_TRIG_EVENT_SETMASK)
                            10220 ; 70   |
                            10221 ; 71   |typedef union               
                            10222 ; 72   |{
                            10223 ; 73   |    struct {
                            10224 ; 74   |         int CLK_ENABLE      : HW_TB_CFG_CLK_ENABLE_WIDTH;
                            10225 ; 75   |         int ENABLE          : HW_TB_CFG_ENABLE_WIDTH;
                            10226 ; 76   |        int rsvd1           : HW_TB_CFG_RSVD1_WIDTH;
                            10227 ; 77   |         int DONE            : HW_TB_CFG_DONE_WIDTH;
                            10228 ; 78   |         int DMA_ASEL        : HW_TB_CFG_DMA_ASEL_WIDTH;
                            10229 ; 79   |         int TRIG_EVENT      : HW_TB_CFG_TRIG_EVENT_WIDTH;
                            10230 ; 80   |        int rsvd2           : HW_TB_CFG_RSVD2_WIDTH;
                            10231 ; 81   |    } B;
                            10232 ; 82   |    int I;
                            10233 ; 83   |    unsigned int U;
                            10234 ; 84   |} tb_cfg_type;
                            10235 ; 85   |#define HW_TB_CFG      (*(volatile tb_cfg_type _X*) (HW_TB_BASEADDR+0))    /* Trace Buffer Configuration Register */
                            10236 ; 86   |
                            10237 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                            10238 ; 88   |
                            10239 ; 89   |//  Trace Buffer Base Address Register (HW_TB_BAR) Bit Definitions
                            10240 ; 90   |
                            10241 ; 91   |#define HW_TB_BAR_ADDRESS_BITPOS (0)
                            10242 ; 92   |
                            10243 ; 93   |#define HW_TB_BAR_ADDRESS_WIDTH (16)        
                            10244 ; 94   |#define HW_TB_BAR_RSVD_WIDTH (8)
                            10245 ; 95   |
                            10246 ; 96   |#define HW_TB_BAR_ADDRESS_SETMASK (((1<<HW_TB_BAR_ADDRESS_WIDTH)-1)<<HW_TB_BAR_ADDRESS_BITPOS) 
                            10247 ; 97   |
                            10248 ; 98   |#define HW_TB_BAR_ADDRESS_CLRMASK (~(WORD)HW_TB_BAR_ADDRESS_SETMASK)
                            10249 ; 99   |
                            10250 ; 100  |typedef union               
                            10251 ; 101  |{
                            10252 ; 102  |    struct {
                            10253 ; 103  |         int ADDRESS      : HW_TB_BAR_ADDRESS_WIDTH;
                            10254 ; 104  |        int reserved     : HW_TB_BAR_RSVD_WIDTH;
                            10255 ; 105  |    } B;
                            10256 ; 106  |    int I;
                            10257 ; 107  |    unsigned int U;
                            10258 ; 108  |} tb_bar_type;
                            10259 ; 109  |#define HW_TB_BAR      (*(volatile tb_bar_type _X*) (HW_TB_BASEADDR+1))    /* Trace Buffer Base Address Register */
                            10260 ; 110  |
                            10261 ; 111  |/////////////////////////////////////////////////////////////////////////////////
                            10262 ; 112  |
                            10263 ; 113  |//  Trace Buffer Modulo Register (HW_TB_MOD) Bit Definitions
                            10264 ; 114  |
                            10265 ; 115  |#define HW_TB_MOD_MODULUS_BITPOS (0)
                            10266 ; 116  |
                            10267 ; 117  |#define HW_TB_MOD_MODULUS_WIDTH (14)        
                            10268 ; 118  |#define HW_TB_MOD_RSVD_WIDTH (10)
                            10269 ; 119  |
                            10270 ; 120  |#define HW_TB_MOD_MODULUS_SETMASK (((1<<HW_TB_MOD_MODULUS_WIDTH)-1)<<HW_TB_MOD_MODULUS_BITPOS) 
                            10271 ; 121  |
                            10272 ; 122  |#define HW_TB_MOD_MODULUS_CLRMASK (~(WORD)HW_TB_MOD_MODULUS_SETMASK)
                            10273 ; 123  |
                            10274 ; 124  |typedef union               
                            10275 ; 125  |{
                            10276 ; 126  |    struct {
                            10277 ; 127  |         int MODULUS      : HW_TB_MOD_MODULUS_WIDTH;
                            10278 ; 128  |        int reserved        : HW_TB_MOD_RSVD_WIDTH;
                            10279 ; 129  |    } B;
                            10280 ; 130  |    int I;
                            10281 ; 131  |    unsigned int U;
                            10282 ; 132  |} tb_mod_type;
                            10283 ; 133  |#define HW_TB_MOD      (*(volatile tb_mod_type _X*) (HW_TB_BASEADDR+2))    /* Trace Buffer Modulus Register */
                            10284 ; 134  |
                            10285 ; 135  |/////////////////////////////////////////////////////////////////////////////////
                            10286 ; 136  |
                            10287 ; 137  |//  Trace Buffer Current Index Register (HW_TB_CIR) Bit Definitions
                            10288 ; 138  |
                            10289 ; 139  |#define HW_TB_CIR_INDEX_BITPOS (0)
                            10290 ; 140  |
                            10291 ; 141  |#define HW_TB_CIR_INDEX_WIDTH (14)        
                            10292 ; 142  |#define HW_TB_CIR_RSVD_WIDTH (10)
                            10293 ; 143  |
                            10294 ; 144  |#define HW_TB_CIR_INDEX_SETMASK (((1<<HW_TB_CIR_INDEX_WIDTH)-1)<<HW_TB_CIR_INDEX_BITPOS) 
                            10295 ; 145  |
                            10296 ; 146  |#define HW_TB_CIR_INDEX_CLRMASK (~(WORD)HW_TB_CIR_INDEX_SETMASK)
                            10297 ; 147  |
                            10298 ; 148  |typedef union               
                            10299 ; 149  |{
                            10300 ; 150  |    struct {
                            10301 ; 151  |         int INDEX        : HW_TB_CIR_INDEX_WIDTH;
                            10302 ; 152  |        int reserved     : HW_TB_CIR_RSVD_WIDTH;
                            10303 ; 153  |    } B;
                            10304 ; 154  |    int I;
                            10305 ; 155  |    unsigned int U;
                            10306 ; 156  |} tb_cir_type;
                            10307 ; 157  |#define HW_TB_CIR      (*(volatile tb_cir_type _X*) (HW_TB_BASEADDR+3))    /* Trace Buffer Current Index Register */
                            10308 ; 158  |
                            10309 ; 159  |/////////////////////////////////////////////////////////////////////////////////
                            10310 ; 160  |
                            10311 ; 161  |//  Trace Buffer One Byte Code Register (HW_TB_OBC) Bit Definitions
                            10312 ; 162  |
                            10313 ; 163  |#define HW_TB_OBC_CODE_BITPOS (0)
                            10314 ; 164  |
                            10315 ; 165  |#define HW_TB_OBC_CODE_WIDTH (8)        
                            10316 ; 166  |#define HW_TB_OBC_RSVD_WIDTH (16)
                            10317 ; 167  |
                            10318 ; 168  |#define HW_TB_OBC_CODE_SETMASK (((1<<HW_TB_OBC_CODE_WIDTH)-1)<<HW_TB_OBC_CODE_BITPOS) 
                            10319 ; 169  |
                            10320 ; 170  |#define HW_TB_OBC_CODE_CLRMASK (~(WORD)HW_TB_OBC_CODE_SETMASK)
                            10321 ; 171  |
                            10322 ; 172  |typedef union               
                            10323 ; 173  |{
                            10324 ; 174  |    struct {
                            10325 ; 175  |         int CODE        : HW_TB_OBC_CODE_WIDTH;
                            10326 ; 176  |        int reserved    : HW_TB_OBC_RSVD_WIDTH;
                            10327 ; 177  |    } B;
                            10328 ; 178  |    int I;
                            10329 ; 179  |    unsigned int U;
                            10330 ; 180  |} tb_obc_type;
                            10331 ; 181  |#define HW_TB_OBC      (*(volatile tb_obc_type _X*) (HW_TB_BASEADDR+4))    /* Trace Buffer one byte code Register */
                            10332 ; 182  |
                            10333 ; 183  |/////////////////////////////////////////////////////////////////////////////////
                            10334 ; 184  |
                            10335 ; 185  |//  Trace Buffer Trigger Command Register (HW_TB_TCS) Bit Definitions
                            10336 ; 186  |
                            10337 ; 187  |#define HW_TB_TCS_TRG_STYLE_BITPOS (0)
                            10338 ; 188  |#define HW_TB_TCS_CAP_CLASS_BITPOS (1)
                            10339 ; 189  |#define HW_TB_TCS_TRG_CLASS_BITPOS (3)
                            10340 ; 190  |#define HW_TB_TCS_FREEZE_BITPOS (5)
                            10341 ; 191  |
                            10342 ; 192  |#define HW_TB_TCS_TRG_STYLE_WIDTH (1)        
                            10343 ; 193  |#define HW_TB_TCS_CAP_CLASS_WIDTH (2)        
                            10344 ; 194  |#define HW_TB_TCS_TRG_CLASS_WIDTH (2)        
                            10345 ; 195  |#define HW_TB_TCS_FREEZE_WIDTH (1)        
                            10346 ; 196  |#define HW_TB_TCS_RSVD_WIDTH (18)
                            10347 ; 197  |
                            10348 ; 198  |#define HW_TB_TCS_TRG_STYLE_SETMASK (((1<<HW_TB_TCS_TRG_STYLE_WIDTH)-1)<<HW_TB_TCS_TRG_STYLE_BITPOS) 
                            10349 ; 199  |#define HW_TB_TCS_CAP_CLASS_SETMASK (((1<<HW_TB_TCS_CAP_CLASS_WIDTH)-1)<<HW_TB_TCS_CAP_CLASS_BITPOS) 
                            10350 ; 200  |#define HW_TB_TCS_TRG_CLASS_SETMASK (((1<<HW_TB_TCS_TRG_CLASS_WIDTH)-1)<<HW_TB_TCS_TRG_CLASS_BITPOS) 
                            10351 ; 201  |#define HW_TB_TCS_FREEZE_SETMASK (((1<<HW_TB_TCS_FREEZE_WIDTH)-1)<<HW_TB_TCS_FREEZE_BITPOS) 
                            10352 ; 202  |
                            10353 ; 203  |#define HW_TB_TCS_TRG_STYLE_CLRMASK (~(WORD)HW_TB_TCS_TRG_STYLE_SETMASK)
                            10354 ; 204  |#define HW_TB_TCS_CAP_CLASS_CLRMASK (~(WORD)HW_TB_TCS_CAP_CLASS_SETMASK)
                            10355 ; 205  |#define HW_TB_TCS_TRG_CLASS_CLRMASK (~(WORD)HW_TB_TCS_TRG_CLASS_SETMASK)
                            10356 ; 206  |#define HW_TB_TCS_FREEZE_CLRMASK (~(WORD)HW_TB_TCS_FREEZE_SETMASK)
                            10357 ; 207  |
                            10358 ; 208  |typedef union               
                            10359 ; 209  |{
                            10360 ; 210  |    struct {
                            10361 ; 211  |         int TRG_STYLE       : HW_TB_TCS_TRG_STYLE_WIDTH;
                            10362 ; 212  |         int CAP_CLASS       : HW_TB_TCS_CAP_CLASS_WIDTH;
                            10363 ; 213  |         int TRG_CLASS       : HW_TB_TCS_TRG_CLASS_WIDTH;
                            10364 ; 214  |         int FREEZE          : HW_TB_TCS_FREEZE_WIDTH;
                            10365 ; 215  |        int reserved        : HW_TB_TCS_RSVD_WIDTH;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  42

M:ADDR CODE           CYCLES LINE SOURCELINE
                            10366 ; 216  |    } B;
                            10367 ; 217  |    int I;
                            10368 ; 218  |    unsigned int U;
                            10369 ; 219  |} tb_tcs_type;
                            10370 ; 220  |#define HW_TB_TCS      (*(volatile tb_tcs_type _X*) (HW_TB_BASEADDR+16))    /* Trace Buffer Trigger Command Register */
                            10371 ; 221  |
                            10372 ; 222  |/////////////////////////////////////////////////////////////////////////////////
                            10373 ; 223  |
                            10374 ; 224  |//  Trace Buffer Trigger Value Register (HW_TB_TVR) Bit Definitions
                            10375 ; 225  |
                            10376 ; 226  |#define HW_TB_TVR_MATCH_ADDR_BITPOS (0)
                            10377 ; 227  |
                            10378 ; 228  |#define HW_TB_TVR_MATCH_ADDR_WIDTH (16)        
                            10379 ; 229  |#define HW_TB_TVR_RSVD_WIDTH (8)
                            10380 ; 230  |
                            10381 ; 231  |#define HW_TB_TVR_MATCH_ADDR_SETMASK (((1<<HW_TB_TVR_MATCH_ADDR_WIDTH)-1)<<HW_TB_TVR_MATCH_ADDR_BITPOS) 
                            10382 ; 232  |
                            10383 ; 233  |#define HW_TB_TVR_MATCH_ADDR_CLRMASK (~(WORD)HW_TB_TVR_MATCH_ADDR_SETMASK)
                            10384 ; 234  |
                            10385 ; 235  |typedef union               
                            10386 ; 236  |{
                            10387 ; 237  |    struct {
                            10388 ; 238  |         int MATCH_ADDR      : HW_TB_TVR_MATCH_ADDR_WIDTH;
                            10389 ; 239  |        int reserved        : HW_TB_TVR_RSVD_WIDTH;
                            10390 ; 240  |    } B;
                            10391 ; 241  |    int I;
                            10392 ; 242  |    unsigned int U;
                            10393 ; 243  |} tb_tvr_type;
                            10394 ; 244  |#define HW_TB_TVR      (*(volatile tb_tvr_type _X*) (HW_TB_BASEADDR+24))    /* Trace Buffer Trigger Value Register */
                            10395 ; 245  |
                            10396 ; 246  |
                            10397 ; 247  |
                            10398 ; 248  |#endif
                            10399 ; 249  |
                            10400 ; 250  |
                            10401 ; 251  |
                            10402 ; 252  |
                            10403 ; 253  |
                            10404 ; 254  |
                            10405 ; 255  |
                            10406 ; 256  |
                            10407 ; 257  |
                            10408 ; 258  |
                            10409 ; 259  |
                            10410 ; 260  |
                            10411 ; 261  |
                            10412 ; 262  |
                            10413 ; 263  |
                            10414 ; 264  |
                            10415 ; 265  |
                            10416 
                            10418 
                            10419 ; 35   |#include "regstimer.h"
                            10420 
                            10422 
                            10423 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                            10424 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                            10425 ; 3    |// Filename: regstimer.inc
                            10426 ; 4    |// Description: Register definitions for  Timers interface
                            10427 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                            10428 ; 6    |// The following naming conventions are followed in this file.
                            10429 ; 7    |// All registers are named using the format...
                            10430 ; 8    |//     HW_<module>_<regname>
                            10431 ; 9    |// where <module> is the module name which can be any of the following...
                            10432 ; 10   |//     USB20
                            10433 ; 11   |// (Note that when there is more than one copy of a particular module, the
                            10434 ; 12   |// module name includes a number starting from 0 for the first instance of
                            10435 ; 13   |// that module)
                            10436 ; 14   |// <regname> is the specific register within that module
                            10437 ; 15   |// We also define the following...
                            10438 ; 16   |//     HW_<module>_<regname>_BITPOS
                            10439 ; 17   |// which defines the starting bit (i.e. LSB) of a multi bit field
                            10440 ; 18   |//     HW_<module>_<regname>_SETMASK
                            10441 ; 19   |// which does something else, and
                            10442 ; 20   |//     HW_<module>_<regname>_CLRMASK
                            10443 ; 21   |// which does something else.
                            10444 ; 22   |// Other rules
                            10445 ; 23   |//     All caps
                            10446 ; 24   |//     Numeric identifiers start at 0
                            10447 ; 25   |#if !(defined(regstimerinc))
                            10448 ; 26   |#define regstimerinc 1
                            10449 ; 27   |
                            10450 ; 28   |#include "types.h"
                            10451 
                            10453 
                            10454 ; 1    |////////////////////////////////////////////////////////////////////////////////
                            10455 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                            10456 ; 3    |//
                            10457 ; 4    |// Filename: types.h
                            10458 ; 5    |// Description: Standard data types
                            10459 ; 6    |////////////////////////////////////////////////////////////////////////////////
                            10460 ; 7    |
                            10461 ; 8    |#ifndef _TYPES_H
                            10462 ; 9    |#define _TYPES_H
                            10463 ; 10   |
                            10464 ; 11   |// TODO:  move this outta here!
                            10465 ; 12   |#if !defined(NOERROR)
                            10466 ; 13   |#define NOERROR 0
                            10467 ; 14   |#define SUCCESS 0
                            10468 ; 15   |#endif 
                            10469 ; 16   |#if !defined(SUCCESS)
                            10470 ; 17   |#define SUCCESS  0
                            10471 ; 18   |#endif
                            10472 ; 19   |#if !defined(ERROR)
                            10473 ; 20   |#define ERROR   -1
                            10474 ; 21   |#endif
                            10475 ; 22   |#if !defined(FALSE)
                            10476 ; 23   |#define FALSE 0
                            10477 ; 24   |#endif
                            10478 ; 25   |#if !defined(TRUE)
                            10479 ; 26   |#define TRUE  1
                            10480 ; 27   |#endif
                            10481 ; 28   |
                            10482 ; 29   |#if !defined(NULL)
                            10483 ; 30   |#define NULL 0
                            10484 ; 31   |#endif
                            10485 ; 32   |
                            10486 ; 33   |#define MAX_INT     0x7FFFFF
                            10487 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                            10488 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                            10489 ; 36   |#define MAX_ULONG   (-1) 
                            10490 ; 37   |
                            10491 ; 38   |#define WORD_SIZE   24              // word size in bits
                            10492 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                            10493 ; 40   |
                            10494 ; 41   |
                            10495 ; 42   |#define BYTE    unsigned char       // btVarName
                            10496 ; 43   |#define CHAR    signed char         // cVarName
                            10497 ; 44   |#define USHORT  unsigned short      // usVarName
                            10498 ; 45   |#define SHORT   unsigned short      // sVarName
                            10499 ; 46   |#define WORD    unsigned int        // wVarName
                            10500 ; 47   |#define INT     signed int          // iVarName
                            10501 ; 48   |#define DWORD   unsigned long       // dwVarName
                            10502 ; 49   |#define LONG    signed long         // lVarName
                            10503 ; 50   |#define BOOL    unsigned int        // bVarName
                            10504 ; 51   |#define FRACT   _fract              // frVarName
                            10505 ; 52   |#define LFRACT  long _fract         // lfrVarName
                            10506 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                            10507 ; 54   |#define FLOAT   float               // fVarName
                            10508 ; 55   |#define DBL     double              // dVarName
                            10509 ; 56   |#define ENUM    enum                // eVarName
                            10510 ; 57   |#define CMX     _complex            // cmxVarName
                            10511 ; 58   |typedef WORD UCS3;                   // 
                            10512 ; 59   |
                            10513 ; 60   |#define UINT16  unsigned short
                            10514 ; 61   |#define UINT8   unsigned char   
                            10515 ; 62   |#define UINT32  unsigned long
                            10516 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            10517 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            10518 ; 65   |#define WCHAR   UINT16
                            10519 ; 66   |
                            10520 ; 67   |//UINT128 is 16 bytes or 6 words
                            10521 ; 68   |typedef struct UINT128_3500 {   
                            10522 ; 69   |    int val[6];     
                            10523 ; 70   |} UINT128_3500;
                            10524 ; 71   |
                            10525 ; 72   |#define UINT128   UINT128_3500
                            10526 ; 73   |
                            10527 ; 74   |// Little endian word packed byte strings:   
                            10528 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            10529 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            10530 ; 77   |// Little endian word packed byte strings:   
                            10531 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            10532 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            10533 ; 80   |
                            10534 ; 81   |// Declare Memory Spaces To Use When Coding
                            10535 ; 82   |// A. Sector Buffers
                            10536 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                            10537 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                            10538 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                            10539 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                            10540 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                            10541 ; 88   |// B. Media DDI Memory
                            10542 ; 89   |#define MEDIA_DDI_MEM _Y
                            10543 ; 90   |
                            10544 ; 91   |
                            10545 ; 92   |
                            10546 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                            10547 ; 94   |// Examples of circular pointers:
                            10548 ; 95   |//    INT CIRC cpiVarName
                            10549 ; 96   |//    DWORD CIRC cpdwVarName
                            10550 ; 97   |
                            10551 ; 98   |#define RETCODE INT                 // rcVarName
                            10552 ; 99   |
                            10553 ; 100  |// generic bitfield structure
                            10554 ; 101  |struct Bitfield {
                            10555 ; 102  |    unsigned int B0  :1;
                            10556 ; 103  |    unsigned int B1  :1;
                            10557 ; 104  |    unsigned int B2  :1;
                            10558 ; 105  |    unsigned int B3  :1;
                            10559 ; 106  |    unsigned int B4  :1;
                            10560 ; 107  |    unsigned int B5  :1;
                            10561 ; 108  |    unsigned int B6  :1;
                            10562 ; 109  |    unsigned int B7  :1;
                            10563 ; 110  |    unsigned int B8  :1;
                            10564 ; 111  |    unsigned int B9  :1;
                            10565 ; 112  |    unsigned int B10 :1;
                            10566 ; 113  |    unsigned int B11 :1;
                            10567 ; 114  |    unsigned int B12 :1;
                            10568 ; 115  |    unsigned int B13 :1;
                            10569 ; 116  |    unsigned int B14 :1;
                            10570 ; 117  |    unsigned int B15 :1;
                            10571 ; 118  |    unsigned int B16 :1;
                            10572 ; 119  |    unsigned int B17 :1;
                            10573 ; 120  |    unsigned int B18 :1;
                            10574 ; 121  |    unsigned int B19 :1;
                            10575 ; 122  |    unsigned int B20 :1;
                            10576 ; 123  |    unsigned int B21 :1;
                            10577 ; 124  |    unsigned int B22 :1;
                            10578 ; 125  |    unsigned int B23 :1;
                            10579 ; 126  |};
                            10580 ; 127  |
                            10581 ; 128  |union BitInt {
                            10582 ; 129  |        struct Bitfield B;
                            10583 ; 130  |        int        I;
                            10584 ; 131  |};
                            10585 ; 132  |
                            10586 ; 133  |#define MAX_MSG_LENGTH 10
                            10587 ; 134  |struct CMessage
                            10588 ; 135  |{
                            10589 ; 136  |        unsigned int m_uLength;
                            10590 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                            10591 ; 138  |};
                            10592 ; 139  |
                            10593 ; 140  |typedef struct {
                            10594 ; 141  |    WORD m_wLength;
                            10595 ; 142  |    WORD m_wMessage;
                            10596 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                            10597 ; 144  |} Message;
                            10598 ; 145  |
                            10599 ; 146  |struct MessageQueueDescriptor
                            10600 ; 147  |{
                            10601 ; 148  |        int *m_pBase;
                            10602 ; 149  |        int m_iModulo;
                            10603 ; 150  |        int m_iSize;
                            10604 ; 151  |        int *m_pHead;
                            10605 ; 152  |        int *m_pTail;
                            10606 ; 153  |};
                            10607 ; 154  |
                            10608 ; 155  |struct ModuleEntry
                            10609 ; 156  |{
                            10610 ; 157  |    int m_iSignaledEventMask;
                            10611 ; 158  |    int m_iWaitEventMask;
                            10612 ; 159  |    int m_iResourceOfCode;
                            10613 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                            10614 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                            10615 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                            10616 ; 163  |    int m_uTimeOutHigh;
                            10617 ; 164  |    int m_uTimeOutLow;
                            10618 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                            10619 ; 166  |};
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  43

M:ADDR CODE           CYCLES LINE SOURCELINE
                            10620 ; 167  |
                            10621 ; 168  |union WaitMask{
                            10622 ; 169  |    struct B{
                            10623 ; 170  |        unsigned int m_bNone     :1;
                            10624 ; 171  |        unsigned int m_bMessage  :1;
                            10625 ; 172  |        unsigned int m_bTimer    :1;
                            10626 ; 173  |        unsigned int m_bButton   :1;
                            10627 ; 174  |    } B;
                            10628 ; 175  |    int I;
                            10629 ; 176  |} ;
                            10630 ; 177  |
                            10631 ; 178  |
                            10632 ; 179  |struct Button {
                            10633 ; 180  |        WORD wButtonEvent;
                            10634 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                            10635 ; 182  |};
                            10636 ; 183  |
                            10637 ; 184  |struct Message {
                            10638 ; 185  |        WORD wMsgLength;
                            10639 ; 186  |        WORD wMsgCommand;
                            10640 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                            10641 ; 188  |};
                            10642 ; 189  |
                            10643 ; 190  |union EventTypes {
                            10644 ; 191  |        struct CMessage msg;
                            10645 ; 192  |        struct Button Button ;
                            10646 ; 193  |        struct Message Message;
                            10647 ; 194  |};
                            10648 ; 195  |
                            10649 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                            10650 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                            10651 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                            10652 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                            10653 ; 200  |
                            10654 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                            10655 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                            10656 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                            10657 ; 204  |
                            10658 ; 205  |#if DEBUG
                            10659 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                            10660 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                            10661 ; 208  |#else 
                            10662 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                            10663 ; 210  |#define DebugBuildAssert(x)    
                            10664 ; 211  |#endif
                            10665 ; 212  |
                            10666 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                            10667 ; 214  |//  #pragma asm
                            10668 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                            10669 ; 216  |//  #pragma endasm
                            10670 ; 217  |
                            10671 ; 218  |
                            10672 ; 219  |#ifdef COLOR_262K
                            10673 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                            10674 ; 221  |#elif defined(COLOR_65K)
                            10675 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                            10676 ; 223  |#else
                            10677 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                            10678 ; 225  |#endif
                            10679 ; 226  |    
                            10680 ; 227  |#endif // #ifndef _TYPES_H
                            10681 
                            10683 
                            10684 ; 29   |
                            10685 ; 30   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            10686 ; 31   |//   TIMER STMP Registers 
                            10687 ; 32   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            10688 ; 33   |#define HW_TMR_BASEADDR (0xF100)
                            10689 ; 34   |
                            10690 ; 35   |#define HW_TMR0_BASEADDR HW_TMR_BASEADDR
                            10691 ; 36   |#define HW_TMR1_BASEADDR HW_TMR_BASEADDR+0x40
                            10692 ; 37   |#define HW_TMR2_BASEADDR HW_TMR_BASEADDR+0x80
                            10693 ; 38   |#define HW_TMR3_BASEADDR HW_TMR_BASEADDR+0xC0
                            10694 ; 39   |
                            10695 ; 40   |#define HW_TIMER_NUMBER_0 0
                            10696 ; 41   |#define HW_TIMER_NUMBER_1 1
                            10697 ; 42   |#define HW_TIMER_NUMBER_2 2
                            10698 ; 43   |#define HW_TIMER_NUMBER_3 3
                            10699 ; 44   |
                            10700 ; 45   |#define HW_TMRCSR 0
                            10701 ; 46   |#define HW_TMRCNTR 1
                            10702 ; 47   |
                            10703 ; 48   |
                            10704 ; 49   |/////////////////////////////////////////////////////////////////////////////////
                            10705 ; 50   |//  TIMER CSR (HW_TMR0CSR) Bit Definitions
                            10706 ; 51   |#define HW_TMR0CSR_TIMER_ENABLE_BITPOS (0)
                            10707 ; 52   |#define HW_TMR0CSR_TIMER_INT_EN_BITPOS (1)
                            10708 ; 53   |#define HW_TMR0CSR_INVERT_BITPOS (2)
                            10709 ; 54   |#define HW_TMR0CSR_TIMER_CONTROL_BITPOS (3)
                            10710 ; 55   |#define HW_TMR0CSR_TIMER_STATUS_BITPOS (7)
                            10711 ; 56   |#define HW_TMR0CSR_TIMER_MODE_BITPOS (8)
                            10712 ; 57   |#define HW_TMR0CSR_CLKGT_BITPOS (23)
                            10713 ; 58   |
                            10714 ; 59   |#define HW_TMR0CSR_TIMER_ENABLE_WIDTH (1)
                            10715 ; 60   |#define HW_TMR0CSR_TIMER_INT_EN_WIDTH (1)
                            10716 ; 61   |#define HW_TMR0CSR_INVERT_WIDTH (1)
                            10717 ; 62   |#define HW_TMR0CSR_TIMER_CONTROL_WIDTH (3)
                            10718 ; 63   |#define HW_TMR0CSR_TIMER_STATUS_WIDTH (1)
                            10719 ; 64   |#define HW_TMR0CSR_TIMER_MODE_WIDTH (2)
                            10720 ; 65   |#define HW_TMR0CSR_CLKGT_WIDTH (1)
                            10721 ; 66   |
                            10722 ; 67   |#define HW_TMR0CSR_TIMER_ENABLE_SETMASK (((1<<HW_TMR0CSR_TIMER_ENABLE_WIDTH)-1)<<HW_TMR0CSR_TIMER_ENABLE_BITPOS)
                            10723 ; 68   |#define HW_TMR0CSR_TIMER_INT_EN_SETMASK (((1<<HW_TMR0CSR_TIMER_INT_EN_WIDTH)-1)<<HW_TMR0CSR_TIMER_INT_EN_BITPOS)
                            10724 ; 69   |#define HW_TMR0CSR_INVERT_SETMASK (((1<<HW_TMR0CSR_INVERT_WIDTH)-1)<<HW_TMR0CSR_INVERT_BITPOS)
                            10725 ; 70   |#define HW_TMR0CSR_TIMER_CONTROL_SETMASK (((1<<HW_TMR0CSR_TIMER_CONTROL_WIDTH)-1)<<HW_TMR0CSR_TIMER_CONTROL_BITPOS)
                            10726 ; 71   |#define HW_TMR0CSR_TIMER_STATUS_SETMASK (((1<<HW_TMR0CSR_TIMER_STATUS_WIDTH)-1)<<HW_TMR0CSR_TIMER_STATUS_BITPOS)
                            10727 ; 72   |#define HW_TMR0CSR_TIMER_MODE_SETMASK (((1<<HW_TMR0CSR_TIMER_MODE_WIDTH)-1)<<HW_TMR0CSR_TIMER_MODE_BITPOS)
                            10728 ; 73   |#define HW_TMR0CSR_CLKGT_SETMASK (((1<<HW_TMR0CSR_CLKGT_WIDTH)-1)<<HW_TMR0CSR_CLKGT_BITPOS)
                            10729 ; 74   |
                            10730 ; 75   |#define HW_TMR0CSR_TIMER_ENABLE_CLRMASK (~(WORD)HW_TMR0CSR_TIMER_ENABLE_SETMASK)
                            10731 ; 76   |#define HW_TMR0CSR_TIMER_INT_EN_CLRMASK (~(WORD)HW_TMR0CSR_TIMER_INT_EN_SETMASK)
                            10732 ; 77   |#define HW_TMR0CSR_INVERT_CLRMASK (~(WORD)HW_TMR0CSR_INVERT_SETMASK)
                            10733 ; 78   |#define HW_TMR0CSR_TIMER_CONTROL_CLRMASK (~(WORD)HW_TMR0CSR_TIMER_CONTROL_SETMASK)
                            10734 ; 79   |#define HW_TMR0CSR_TIMER_STATUS_CLRMASK (~(WORD)HW_TMR0CSR_TIMER_STATUS_SETMASK)
                            10735 ; 80   |#define HW_TMR0CSR_TIMER_MODE_CLRMASK (~(WORD)HW_TMR0CSR_TIMER_MODE_SETMASK)
                            10736 ; 81   |#define HW_TMR0CSR_CLKGT_CLRMASK (~(WORD)HW_TMR0CSR_CLKGT_SETMASK)
                            10737 ; 82   |
                            10738 ; 83   |/////////////////////////////////////////////////////////////////////////////////
                            10739 ; 84   |//  TIMER CSR (HW_TMR1CSR) Bit Definitions
                            10740 ; 85   |#define HW_TMR1CSR_TIMER_ENABLE_BITPOS (0)
                            10741 ; 86   |#define HW_TMR1CSR_TIMER_INT_EN_BITPOS (1)
                            10742 ; 87   |#define HW_TMR1CSR_INVERT_BITPOS (2)
                            10743 ; 88   |#define HW_TMR1CSR_TIMER_CONTROL_BITPOS (3)
                            10744 ; 89   |#define HW_TMR1CSR_TIMER_STATUS_BITPOS (7)
                            10745 ; 90   |#define HW_TMR1CSR_TIMER_MODE_BITPOS (8)
                            10746 ; 91   |#define HW_TMR1CSR_CLKGT_BITPOS (23)
                            10747 ; 92   |
                            10748 ; 93   |#define HW_TMR1CSR_TIMER_ENABLE_WIDTH (1)
                            10749 ; 94   |#define HW_TMR1CSR_TIMER_INT_EN_WIDTH (1)
                            10750 ; 95   |#define HW_TMR1CSR_INVERT_WIDTH (1)
                            10751 ; 96   |#define HW_TMR1CSR_TIMER_CONTROL_WIDTH (3)
                            10752 ; 97   |#define HW_TMR1CSR_TIMER_STATUS_WIDTH (1)
                            10753 ; 98   |#define HW_TMR1CSR_TIMER_MODE_WIDTH (2)
                            10754 ; 99   |#define HW_TMR1CSR_CLKGT_WIDTH (1)
                            10755 ; 100  |
                            10756 ; 101  |#define HW_TMR1CSR_TIMER_ENABLE_SETMASK (((1<<HW_TMR1CSR_TIMER_ENABLE_WIDTH)-1)<<HW_TMR1CSR_TIMER_ENABLE_BITPOS)
                            10757 ; 102  |#define HW_TMR1CSR_TIMER_INT_EN_SETMASK (((1<<HW_TMR1CSR_TIMER_INT_EN_WIDTH)-1)<<HW_TMR1CSR_TIMER_INT_EN_BITPOS)
                            10758 ; 103  |#define HW_TMR1CSR_INVERT_SETMASK (((1<<HW_TMR1CSR_INVERT_WIDTH)-1)<<HW_TMR1CSR_INVERT_BITPOS)
                            10759 ; 104  |#define HW_TMR1CSR_TIMER_CONTROL_SETMASK (((1<<HW_TMR1CSR_TIMER_CONTROL_WIDTH)-1)<<HW_TMR1CSR_TIMER_CONTROL_BITPOS)
                            10760 ; 105  |#define HW_TMR1CSR_TIMER_STATUS_SETMASK (((1<<HW_TMR1CSR_TIMER_STATUS_WIDTH)-1)<<HW_TMR1CSR_TIMER_STATUS_BITPOS)
                            10761 ; 106  |#define HW_TMR1CSR_TIMER_MODE_SETMASK (((1<<HW_TMR1CSR_TIMER_MODE_WIDTH)-1)<<HW_TMR1CSR_TIMER_MODE_BITPOS)
                            10762 ; 107  |#define HW_TMR1CSR_CLKGT_SETMASK (((1<<HW_TMR1CSR_CLKGT_WIDTH)-1)<<HW_TMR1CSR_CLKGT_BITPOS)
                            10763 ; 108  |
                            10764 ; 109  |#define HW_TMR1CSR_TIMER_ENABLE_CLRMASK (~(WORD)HW_TMR1CSR_TIMER_ENABLE_SETMASK)
                            10765 ; 110  |#define HW_TMR1CSR_TIMER_INT_EN_CLRMASK (~(WORD)HW_TMR1CSR_TIMER_INT_EN_SETMASK)
                            10766 ; 111  |#define HW_TMR1CSR_INVERT_CLRMASK (~(WORD)HW_TMR1CSR_INVERT_SETMASK)
                            10767 ; 112  |#define HW_TMR1CSR_TIMER_CONTROL_CLRMASK (~(WORD)HW_TMR1CSR_TIMER_CONTROL_SETMASK)
                            10768 ; 113  |#define HW_TMR1CSR_TIMER_STATUS_CLRMASK (~(WORD)HW_TMR1CSR_TIMER_STATUS_SETMASK)
                            10769 ; 114  |#define HW_TMR1CSR_TIMER_MODE_CLRMASK (~(WORD)HW_TMR1CSR_TIMER_MODE_SETMASK)
                            10770 ; 115  |#define HW_TMR1CSR_CLKGT_CLRMASK (~(WORD)HW_TMR1CSR_CLKGT_SETMASK)
                            10771 ; 116  |
                            10772 ; 117  |/////////////////////////////////////////////////////////////////////////////////
                            10773 ; 118  |//  TIMER CSR (HW_TMR2CSR) Bit Definitions
                            10774 ; 119  |#define HW_TMR2CSR_TIMER_ENABLE_BITPOS (0)
                            10775 ; 120  |#define HW_TMR2CSR_TIMER_INT_EN_BITPOS (1)
                            10776 ; 121  |#define HW_TMR2CSR_INVERT_BITPOS (2)
                            10777 ; 122  |#define HW_TMR2CSR_TIMER_CONTROL_BITPOS (3)
                            10778 ; 123  |#define HW_TMR2CSR_TIMER_STATUS_BITPOS (7)
                            10779 ; 124  |#define HW_TMR2CSR_TIMER_MODE_BITPOS (8)
                            10780 ; 125  |#define HW_TMR2CSR_CLKGT_BITPOS (23)
                            10781 ; 126  |
                            10782 ; 127  |#define HW_TMR2CSR_TIMER_ENABLE_WIDTH (1)
                            10783 ; 128  |#define HW_TMR2CSR_TIMER_INT_EN_WIDTH (1)
                            10784 ; 129  |#define HW_TMR2CSR_INVERT_WIDTH (1)
                            10785 ; 130  |#define HW_TMR2CSR_TIMER_CONTROL_WIDTH (3)
                            10786 ; 131  |#define HW_TMR2CSR_TIMER_STATUS_WIDTH (1)
                            10787 ; 132  |#define HW_TMR2CSR_TIMER_MODE_WIDTH (2)
                            10788 ; 133  |#define HW_TMR2CSR_CLKGT_WIDTH (1)
                            10789 ; 134  |
                            10790 ; 135  |#define HW_TMR2CSR_TIMER_ENABLE_SETMASK (((1<<HW_TMR2CSR_TIMER_ENABLE_WIDTH)-1)<<HW_TMR2CSR_TIMER_ENABLE_BITPOS)
                            10791 ; 136  |#define HW_TMR2CSR_TIMER_INT_EN_SETMASK (((1<<HW_TMR2CSR_TIMER_INT_EN_WIDTH)-1)<<HW_TMR2CSR_TIMER_INT_EN_BITPOS)
                            10792 ; 137  |#define HW_TMR2CSR_INVERT_SETMASK (((1<<HW_TMR2CSR_INVERT_WIDTH)-1)<<HW_TMR2CSR_INVERT_BITPOS)
                            10793 ; 138  |#define HW_TMR2CSR_TIMER_CONTROL_SETMASK (((1<<HW_TMR2CSR_TIMER_CONTROL_WIDTH)-1)<<HW_TMR2CSR_TIMER_CONTROL_BITPOS)
                            10794 ; 139  |#define HW_TMR2CSR_TIMER_STATUS_SETMASK (((1<<HW_TMR2CSR_TIMER_STATUS_WIDTH)-1)<<HW_TMR2CSR_TIMER_STATUS_BITPOS)
                            10795 ; 140  |#define HW_TMR2CSR_TIMER_MODE_SETMASK (((1<<HW_TMR2CSR_TIMER_MODE_WIDTH)-1)<<HW_TMR2CSR_TIMER_MODE_BITPOS)
                            10796 ; 141  |#define HW_TMR2CSR_CLKGT_SETMASK (((1<<HW_TMR2CSR_CLKGT_WIDTH)-1)<<HW_TMR2CSR_CLKGT_BITPOS)
                            10797 ; 142  |
                            10798 ; 143  |#define HW_TMR2CSR_TIMER_ENABLE_CLRMASK (~(WORD)HW_TMR2CSR_TIMER_ENABLE_SETMASK)
                            10799 ; 144  |#define HW_TMR2CSR_TIMER_INT_EN_CLRMASK (~(WORD)HW_TMR2CSR_TIMER_INT_EN_SETMASK)
                            10800 ; 145  |#define HW_TMR2CSR_INVERT_CLRMASK (~(WORD)HW_TMR2CSR_INVERT_SETMASK)
                            10801 ; 146  |#define HW_TMR2CSR_TIMER_CONTROL_CLRMASK (~(WORD)HW_TMR2CSR_TIMER_CONTROL_SETMASK)
                            10802 ; 147  |#define HW_TMR2CSR_TIMER_STATUS_CLRMASK (~(WORD)HW_TMR2CSR_TIMER_STATUS_SETMASK)
                            10803 ; 148  |#define HW_TMR2CSR_TIMER_MODE_CLRMASK (~(WORD)HW_TMR2CSR_TIMER_MODE_SETMASK)
                            10804 ; 149  |#define HW_TMR2CSR_CLKGT_CLRMASK (~(WORD)HW_TMR2CSR_CLKGT_SETMASK)
                            10805 ; 150  |
                            10806 ; 151  |/////////////////////////////////////////////////////////////////////////////////
                            10807 ; 152  |//  TIMER CSR (HW_TMR3CSR) Bit Definitions
                            10808 ; 153  |#define HW_TMR3CSR_TIMER_ENABLE_BITPOS (0)
                            10809 ; 154  |#define HW_TMR3CSR_TIMER_INT_EN_BITPOS (1)
                            10810 ; 155  |#define HW_TMR3CSR_INVERT_BITPOS (2)
                            10811 ; 156  |#define HW_TMR3CSR_TIMER_CONTROL_BITPOS (3)
                            10812 ; 157  |#define HW_TMR3CSR_TIMER_STATUS_BITPOS (7)
                            10813 ; 158  |#define HW_TMR3CSR_TIMER_MODE_BITPOS (8)
                            10814 ; 159  |#define HW_TMR3CSR_CLKGT_BITPOS (23)
                            10815 ; 160  |
                            10816 ; 161  |#define HW_TMR3CSR_TIMER_ENABLE_WIDTH (1)
                            10817 ; 162  |#define HW_TMR3CSR_TIMER_INT_EN_WIDTH (1)
                            10818 ; 163  |#define HW_TMR3CSR_INVERT_WIDTH (1)
                            10819 ; 164  |#define HW_TMR3CSR_TIMER_CONTROL_WIDTH (3)
                            10820 ; 165  |#define HW_TMR3CSR_TIMER_STATUS_WIDTH (1)
                            10821 ; 166  |#define HW_TMR3CSR_TIMER_MODE_WIDTH (2)
                            10822 ; 167  |#define HW_TMR3CSR_CLKGT_WIDTH (1)
                            10823 ; 168  |
                            10824 ; 169  |#define HW_TMR3CSR_TIMER_ENABLE_SETMASK (((1<<HW_TMR3CSR_TIMER_ENABLE_WIDTH)-1)<<HW_TMR3CSR_TIMER_ENABLE_BITPOS)
                            10825 ; 170  |#define HW_TMR3CSR_TIMER_INT_EN_SETMASK (((1<<HW_TMR3CSR_TIMER_INT_EN_WIDTH)-1)<<HW_TMR3CSR_TIMER_INT_EN_BITPOS)
                            10826 ; 171  |#define HW_TMR3CSR_INVERT_SETMASK (((1<<HW_TMR3CSR_INVERT_WIDTH)-1)<<HW_TMR3CSR_INVERT_BITPOS)
                            10827 ; 172  |#define HW_TMR3CSR_TIMER_CONTROL_SETMASK (((1<<HW_TMR3CSR_TIMER_CONTROL_WIDTH)-1)<<HW_TMR3CSR_TIMER_CONTROL_BITPOS)
                            10828 ; 173  |#define HW_TMR3CSR_TIMER_STATUS_SETMASK (((1<<HW_TMR3CSR_TIMER_STATUS_WIDTH)-1)<<HW_TMR3CSR_TIMER_STATUS_BITPOS)
                            10829 ; 174  |#define HW_TMR3CSR_TIMER_MODE_SETMASK (((1<<HW_TMR3CSR_TIMER_MODE_WIDTH)-1)<<HW_TMR3CSR_TIMER_MODE_BITPOS)
                            10830 ; 175  |#define HW_TMR3CSR_CLKGT_SETMASK (((1<<HW_TMR3CSR_CLKGT_WIDTH)-1)<<HW_TMR3CSR_CLKGT_BITPOS)
                            10831 ; 176  |
                            10832 ; 177  |#define HW_TMR3CSR_TIMER_ENABLE_CLRMASK (~(WORD)HW_TMR3CSR_TIMER_ENABLE_SETMASK)
                            10833 ; 178  |#define HW_TMR3CSR_TIMER_INT_EN_CLRMASK (~(WORD)HW_TMR3CSR_TIMER_INT_EN_SETMASK)
                            10834 ; 179  |#define HW_TMR3CSR_INVERT_CLRMASK (~(WORD)HW_TMR3CSR_INVERT_SETMASK)
                            10835 ; 180  |#define HW_TMR3CSR_TIMER_CONTROL_CLRMASK (~(WORD)HW_TMR3CSR_TIMER_CONTROL_SETMASK)
                            10836 ; 181  |#define HW_TMR3CSR_TIMER_STATUS_CLRMASK (~(WORD)HW_TMR3CSR_TIMER_STATUS_SETMASK)
                            10837 ; 182  |#define HW_TMR3CSR_TIMER_MODE_CLRMASK (~(WORD)HW_TMR3CSR_TIMER_MODE_SETMASK)
                            10838 ; 183  |#define HW_TMR3CSR_CLKGT_CLRMASK (~(WORD)HW_TMR3CSR_CLKGT_SETMASK)
                            10839 ; 184  |
                            10840 ; 185  |typedef union               
                            10841 ; 186  |{
                            10842 ; 187  |    struct {
                            10843 ; 188  |       int TIMER_ENABLE              :1;
                            10844 ; 189  |       int TIMER_INT_EN              :1;
                            10845 ; 190  |       int INVERT                    :1;
                            10846 ; 191  |       int TIMER_CONTROL             :3;
                            10847 ; 192  |       int RSVD0                     :1;
                            10848 ; 193  |       int TIMER_STATUS              :1;
                            10849 ; 194  |       int TIMER_MODE                :2;
                            10850 ; 195  |       int RSVD1                     :13;
                            10851 ; 196  |       int CLKGT                     :1;
                            10852 ; 197  |    } B;
                            10853 ; 198  |    int I;
                            10854 ; 199  |} timercsr_type;
                            10855 ; 200  |#define HW_TMR0CSR        (*(volatile timercsr_type _X*) (HW_TMR0_BASEADDR+HW_TMRCSR))  /* Timer0 Control Status Register */
                            10856 ; 201  |#define HW_TMR1CSR        (*(volatile timercsr_type _X*) (HW_TMR1_BASEADDR+HW_TMRCSR))  /* Timer1 Control Status Register */
                            10857 ; 202  |#define HW_TMR2CSR        (*(volatile timercsr_type _X*) (HW_TMR2_BASEADDR+HW_TMRCSR))  /* Timer2 Control Status Register */
                            10858 ; 203  |#define HW_TMR3CSR        (*(volatile timercsr_type _X*) (HW_TMR3_BASEADDR+HW_TMRCSR))  /* Timer3 Control Status Register */
                            10859 ; 204  |
                            10860 ; 205  |/////////////////////////////////////////////////////////////////////////////////
                            10861 ; 206  |//  TIMER CNTR register (HW_TMR0CNTR) Bit Definitions
                            10862 ; 207  |#define HW_TMR0CNTR_COUNT_BITPOS 0
                            10863 ; 208  |#define HW_TMR0CNTR_COUNT_WIDTH 24
                            10864 ; 209  |#define HW_TMR0CNTR_COUNT_SETMASK (((1<<HW_TMR0CNTR_COUNT_WIDTH)-1)<<HW_TMR0CNTR_COUNT_BITPOS)
                            10865 ; 210  |#define HW_TMR0CNTR_COUNT_CLRMASK (~(WORD)HW_TMR0CNTR_COUNT_SETMASK)
                            10866 ; 211  |
                            10867 ; 212  |/////////////////////////////////////////////////////////////////////////////////
                            10868 ; 213  |//  TIMER CNTR register (HW_TMR1CNTR) Bit Definitions
                            10869 ; 214  |#define HW_TMR1CNTR_COUNT_BITPOS 0
                            10870 ; 215  |#define HW_TMR1CNTR_COUNT_WIDTH 24
                            10871 ; 216  |#define HW_TMR1CNTR_COUNT_SETMASK (((1<<HW_TMR1CNTR_COUNT_WIDTH)-1)<<HW_TMR1CNTR_COUNT_BITPOS)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  44

M:ADDR CODE           CYCLES LINE SOURCELINE
                            10872 ; 217  |#define HW_TMR1CNTR_COUNT_CLRMASK (~(WORD)HW_TMR1CNTR_COUNT_SETMASK)
                            10873 ; 218  |
                            10874 ; 219  |/////////////////////////////////////////////////////////////////////////////////
                            10875 ; 220  |//  TIMER CNTR register (HW_TMR2CNTR) Bit Definitions
                            10876 ; 221  |#define HW_TMR2CNTR_COUNT_BITPOS 0
                            10877 ; 222  |#define HW_TMR2CNTR_COUNT_WIDTH 24
                            10878 ; 223  |#define HW_TMR2CNTR_COUNT_SETMASK (((1<<HW_TMR2CNTR_COUNT_WIDTH)-1)<<HW_TMR2CNTR_COUNT_BITPOS)
                            10879 ; 224  |#define HW_TMR2CNTR_COUNT_CLRMASK (~(WORD)HW_TMR2CNTR_COUNT_SETMASK)
                            10880 ; 225  |
                            10881 ; 226  |typedef union               
                            10882 ; 227  |{
                            10883 ; 228  |    struct {
                            10884 ; 229  |       int COUNT                    :24;
                            10885 ; 230  |    } B;
                            10886 ; 231  |    int I;
                            10887 ; 232  |} tmrcntr_type;
                            10888 ; 233  |#define HW_TMR0CNTR        (*(volatile tmrcntr_type _X*) (HW_TMR0_BASEADDR+HW_TMRCNTR))  /* Timer0 Count Register */
                            10889 ; 234  |#define HW_TMR1CNTR        (*(volatile tmrcntr_type _X*) (HW_TMR1_BASEADDR+HW_TMRCNTR))  /* Timer1 Count Register */
                            10890 ; 235  |#define HW_TMR2CNTR        (*(volatile tmrcntr_type _X*) (HW_TMR2_BASEADDR+HW_TMRCNTR))  /* Timer2 Count Register */
                            10891 ; 236  |#define HW_TMR3CNTR        (*(volatile tmrcntr_type _X*) (HW_TMR3_BASEADDR+HW_TMRCNTR))  /* Timer3 Count Register */
                            10892 ; 237  |
                            10893 ; 238  |
                            10894 ; 239  |//*********************  REGISTER ALIAS DEFINES TO MATCH LEGACY CODE *******************************
                            10895 ; 240  |// The following defines were added to match regs3410.inc definition to build SDK2XXX code without needing 
                            10896 ; 241  |// to update the actual files. Only the defines needed to build SDK2.400 were added.   
                            10897 ; 242  |#define HW_TIMER_BASEADDR 0xF100
                            10898 ; 243  |
                            10899 ; 244  |#define HW_TIMER0_BASEADDR HW_TIMER_BASEADDR
                            10900 ; 245  |#define HW_TIMER1_BASEADDR HW_TIMER0_BASEADDR+0x40
                            10901 ; 246  |#define HW_TIMER2_BASEADDR HW_TIMER1_BASEADDR+0x40
                            10902 ; 247  |#define HW_TIMER3_BASEADDR HW_TIMER2_BASEADDR+0x40
                            10903 ; 248  |
                            10904 ; 249  |#define HW_TMR0CR HW_TMR0_BASEADDR
                            10905 ; 250  |#define HW_TMR1CR HW_TMR1_BASEADDR
                            10906 ; 251  |#define HW_TMR2CR HW_TMR2_BASEADDR
                            10907 ; 252  |#define HW_TMR3CR HW_TIMER3_BASEADDR
                            10908 ; 253  |
                            10909 ; 254  |// Timer enable
                            10910 ; 255  |#define HW_TMRCR_TE_BITPOS 0   
                            10911 ; 256  |// Timer clock gating control
                            10912 ; 257  |#define HW_TMR3CR_CG_BITPOS 23  
                            10913 ; 258  |#define HW_TMR3CR_CG_SETMASK 1<<HW_TMR3CR_CG_BITPOS
                            10914 ; 259  |#define HW_TMR3CR_CG_CLRMASK ~(WORD)HW_TMR3CR_CG_SETMASK
                            10915 ; 260  |#endif
                            10916 ; 261  |
                            10917 ; 262  |
                            10918 ; 263  |
                            10919 ; 264  |
                            10920 
                            10922 
                            10923 ; 36   |#include "regsusb20.h"
                            10924 
                            10926 
                            10927 ; 1    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            10928 ; 2    |//;  Copyright(C) SigmaTel, Inc. 2002-2003
                            10929 ; 3    |//;  File        : regsusb20ip.inc
                            10930 ; 4    |//;  Description : USB20 IP Register definition
                            10931 ; 5    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            10932 ; 6    |
                            10933 ; 7    |// The following naming conventions are followed in this file.
                            10934 ; 8    |// All registers are named using the format...
                            10935 ; 9    |//     HW_<module>_<regname>
                            10936 ; 10   |// where <module> is the module name which can be any of the following...
                            10937 ; 11   |//     USB20
                            10938 ; 12   |// (Note that when there is more than one copy of a particular module, the
                            10939 ; 13   |// module name includes a number starting from 0 for the first instance of
                            10940 ; 14   |// that module)
                            10941 ; 15   |// <regname> is the specific register within that module
                            10942 ; 16   |// We also define the following...
                            10943 ; 17   |//     HW_<module>_<regname>_BITPOS
                            10944 ; 18   |// which defines the starting bit (i.e. LSB) of a multi bit field
                            10945 ; 19   |//     HW_<module>_<regname>_SETMASK
                            10946 ; 20   |// which does something else, and
                            10947 ; 21   |//     HW_<module>_<regname>_CLRMASK
                            10948 ; 22   |// which does something else.
                            10949 ; 23   |// Other rules
                            10950 ; 24   |//     All caps
                            10951 ; 25   |//     Numeric identifiers start at 0
                            10952 ; 26   |
                            10953 ; 27   |#if !(defined(regsusb20inc))
                            10954 ; 28   |#define regsusb20inc 1
                            10955 ; 29   |
                            10956 ; 30   |#include "types.h"
                            10957 
                            10959 
                            10960 ; 1    |////////////////////////////////////////////////////////////////////////////////
                            10961 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                            10962 ; 3    |//
                            10963 ; 4    |// Filename: types.h
                            10964 ; 5    |// Description: Standard data types
                            10965 ; 6    |////////////////////////////////////////////////////////////////////////////////
                            10966 ; 7    |
                            10967 ; 8    |#ifndef _TYPES_H
                            10968 ; 9    |#define _TYPES_H
                            10969 ; 10   |
                            10970 ; 11   |// TODO:  move this outta here!
                            10971 ; 12   |#if !defined(NOERROR)
                            10972 ; 13   |#define NOERROR 0
                            10973 ; 14   |#define SUCCESS 0
                            10974 ; 15   |#endif 
                            10975 ; 16   |#if !defined(SUCCESS)
                            10976 ; 17   |#define SUCCESS  0
                            10977 ; 18   |#endif
                            10978 ; 19   |#if !defined(ERROR)
                            10979 ; 20   |#define ERROR   -1
                            10980 ; 21   |#endif
                            10981 ; 22   |#if !defined(FALSE)
                            10982 ; 23   |#define FALSE 0
                            10983 ; 24   |#endif
                            10984 ; 25   |#if !defined(TRUE)
                            10985 ; 26   |#define TRUE  1
                            10986 ; 27   |#endif
                            10987 ; 28   |
                            10988 ; 29   |#if !defined(NULL)
                            10989 ; 30   |#define NULL 0
                            10990 ; 31   |#endif
                            10991 ; 32   |
                            10992 ; 33   |#define MAX_INT     0x7FFFFF
                            10993 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                            10994 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                            10995 ; 36   |#define MAX_ULONG   (-1) 
                            10996 ; 37   |
                            10997 ; 38   |#define WORD_SIZE   24              // word size in bits
                            10998 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                            10999 ; 40   |
                            11000 ; 41   |
                            11001 ; 42   |#define BYTE    unsigned char       // btVarName
                            11002 ; 43   |#define CHAR    signed char         // cVarName
                            11003 ; 44   |#define USHORT  unsigned short      // usVarName
                            11004 ; 45   |#define SHORT   unsigned short      // sVarName
                            11005 ; 46   |#define WORD    unsigned int        // wVarName
                            11006 ; 47   |#define INT     signed int          // iVarName
                            11007 ; 48   |#define DWORD   unsigned long       // dwVarName
                            11008 ; 49   |#define LONG    signed long         // lVarName
                            11009 ; 50   |#define BOOL    unsigned int        // bVarName
                            11010 ; 51   |#define FRACT   _fract              // frVarName
                            11011 ; 52   |#define LFRACT  long _fract         // lfrVarName
                            11012 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                            11013 ; 54   |#define FLOAT   float               // fVarName
                            11014 ; 55   |#define DBL     double              // dVarName
                            11015 ; 56   |#define ENUM    enum                // eVarName
                            11016 ; 57   |#define CMX     _complex            // cmxVarName
                            11017 ; 58   |typedef WORD UCS3;                   // 
                            11018 ; 59   |
                            11019 ; 60   |#define UINT16  unsigned short
                            11020 ; 61   |#define UINT8   unsigned char   
                            11021 ; 62   |#define UINT32  unsigned long
                            11022 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            11023 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            11024 ; 65   |#define WCHAR   UINT16
                            11025 ; 66   |
                            11026 ; 67   |//UINT128 is 16 bytes or 6 words
                            11027 ; 68   |typedef struct UINT128_3500 {   
                            11028 ; 69   |    int val[6];     
                            11029 ; 70   |} UINT128_3500;
                            11030 ; 71   |
                            11031 ; 72   |#define UINT128   UINT128_3500
                            11032 ; 73   |
                            11033 ; 74   |// Little endian word packed byte strings:   
                            11034 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            11035 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            11036 ; 77   |// Little endian word packed byte strings:   
                            11037 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            11038 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            11039 ; 80   |
                            11040 ; 81   |// Declare Memory Spaces To Use When Coding
                            11041 ; 82   |// A. Sector Buffers
                            11042 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                            11043 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                            11044 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                            11045 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                            11046 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                            11047 ; 88   |// B. Media DDI Memory
                            11048 ; 89   |#define MEDIA_DDI_MEM _Y
                            11049 ; 90   |
                            11050 ; 91   |
                            11051 ; 92   |
                            11052 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                            11053 ; 94   |// Examples of circular pointers:
                            11054 ; 95   |//    INT CIRC cpiVarName
                            11055 ; 96   |//    DWORD CIRC cpdwVarName
                            11056 ; 97   |
                            11057 ; 98   |#define RETCODE INT                 // rcVarName
                            11058 ; 99   |
                            11059 ; 100  |// generic bitfield structure
                            11060 ; 101  |struct Bitfield {
                            11061 ; 102  |    unsigned int B0  :1;
                            11062 ; 103  |    unsigned int B1  :1;
                            11063 ; 104  |    unsigned int B2  :1;
                            11064 ; 105  |    unsigned int B3  :1;
                            11065 ; 106  |    unsigned int B4  :1;
                            11066 ; 107  |    unsigned int B5  :1;
                            11067 ; 108  |    unsigned int B6  :1;
                            11068 ; 109  |    unsigned int B7  :1;
                            11069 ; 110  |    unsigned int B8  :1;
                            11070 ; 111  |    unsigned int B9  :1;
                            11071 ; 112  |    unsigned int B10 :1;
                            11072 ; 113  |    unsigned int B11 :1;
                            11073 ; 114  |    unsigned int B12 :1;
                            11074 ; 115  |    unsigned int B13 :1;
                            11075 ; 116  |    unsigned int B14 :1;
                            11076 ; 117  |    unsigned int B15 :1;
                            11077 ; 118  |    unsigned int B16 :1;
                            11078 ; 119  |    unsigned int B17 :1;
                            11079 ; 120  |    unsigned int B18 :1;
                            11080 ; 121  |    unsigned int B19 :1;
                            11081 ; 122  |    unsigned int B20 :1;
                            11082 ; 123  |    unsigned int B21 :1;
                            11083 ; 124  |    unsigned int B22 :1;
                            11084 ; 125  |    unsigned int B23 :1;
                            11085 ; 126  |};
                            11086 ; 127  |
                            11087 ; 128  |union BitInt {
                            11088 ; 129  |        struct Bitfield B;
                            11089 ; 130  |        int        I;
                            11090 ; 131  |};
                            11091 ; 132  |
                            11092 ; 133  |#define MAX_MSG_LENGTH 10
                            11093 ; 134  |struct CMessage
                            11094 ; 135  |{
                            11095 ; 136  |        unsigned int m_uLength;
                            11096 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                            11097 ; 138  |};
                            11098 ; 139  |
                            11099 ; 140  |typedef struct {
                            11100 ; 141  |    WORD m_wLength;
                            11101 ; 142  |    WORD m_wMessage;
                            11102 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                            11103 ; 144  |} Message;
                            11104 ; 145  |
                            11105 ; 146  |struct MessageQueueDescriptor
                            11106 ; 147  |{
                            11107 ; 148  |        int *m_pBase;
                            11108 ; 149  |        int m_iModulo;
                            11109 ; 150  |        int m_iSize;
                            11110 ; 151  |        int *m_pHead;
                            11111 ; 152  |        int *m_pTail;
                            11112 ; 153  |};
                            11113 ; 154  |
                            11114 ; 155  |struct ModuleEntry
                            11115 ; 156  |{
                            11116 ; 157  |    int m_iSignaledEventMask;
                            11117 ; 158  |    int m_iWaitEventMask;
                            11118 ; 159  |    int m_iResourceOfCode;
                            11119 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                            11120 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                            11121 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                            11122 ; 163  |    int m_uTimeOutHigh;
                            11123 ; 164  |    int m_uTimeOutLow;
                            11124 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                            11125 ; 166  |};
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  45

M:ADDR CODE           CYCLES LINE SOURCELINE
                            11126 ; 167  |
                            11127 ; 168  |union WaitMask{
                            11128 ; 169  |    struct B{
                            11129 ; 170  |        unsigned int m_bNone     :1;
                            11130 ; 171  |        unsigned int m_bMessage  :1;
                            11131 ; 172  |        unsigned int m_bTimer    :1;
                            11132 ; 173  |        unsigned int m_bButton   :1;
                            11133 ; 174  |    } B;
                            11134 ; 175  |    int I;
                            11135 ; 176  |} ;
                            11136 ; 177  |
                            11137 ; 178  |
                            11138 ; 179  |struct Button {
                            11139 ; 180  |        WORD wButtonEvent;
                            11140 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                            11141 ; 182  |};
                            11142 ; 183  |
                            11143 ; 184  |struct Message {
                            11144 ; 185  |        WORD wMsgLength;
                            11145 ; 186  |        WORD wMsgCommand;
                            11146 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                            11147 ; 188  |};
                            11148 ; 189  |
                            11149 ; 190  |union EventTypes {
                            11150 ; 191  |        struct CMessage msg;
                            11151 ; 192  |        struct Button Button ;
                            11152 ; 193  |        struct Message Message;
                            11153 ; 194  |};
                            11154 ; 195  |
                            11155 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                            11156 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                            11157 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                            11158 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                            11159 ; 200  |
                            11160 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                            11161 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                            11162 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                            11163 ; 204  |
                            11164 ; 205  |#if DEBUG
                            11165 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                            11166 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                            11167 ; 208  |#else 
                            11168 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                            11169 ; 210  |#define DebugBuildAssert(x)    
                            11170 ; 211  |#endif
                            11171 ; 212  |
                            11172 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                            11173 ; 214  |//  #pragma asm
                            11174 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                            11175 ; 216  |//  #pragma endasm
                            11176 ; 217  |
                            11177 ; 218  |
                            11178 ; 219  |#ifdef COLOR_262K
                            11179 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                            11180 ; 221  |#elif defined(COLOR_65K)
                            11181 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                            11182 ; 223  |#else
                            11183 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                            11184 ; 225  |#endif
                            11185 ; 226  |    
                            11186 ; 227  |#endif // #ifndef _TYPES_H
                            11187 
                            11189 
                            11190 ; 31   |
                            11191 ; 32   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            11192 ; 33   |//   USB2.0 STMP Registers 
                            11193 ; 34   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            11194 ; 35   |#define HW_USB_BASEADDR (0xF200)
                            11195 ; 36   |
                            11196 ; 37   |
                            11197 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                            11198 ; 39   |//  USB Control Status Register (HW_USBCSR) Bit Definitions
                            11199 ; 40   |#define HW_USBCSR_USBEN_BITPOS (0)
                            11200 ; 41   |#define HW_USBCSR_WAKEUPIRQ_BITPOS (1)
                            11201 ; 42   |#define HW_USBCSR_WAKEUPIE_BITPOS (2)
                            11202 ; 43   |#define HW_USBCSR_VBUSCXIRQ_BITPOS (3)
                            11203 ; 44   |#define HW_USBCSR_VBUSCXIE_BITPOS (4)
                            11204 ; 45   |#define HW_USBCSR_VBUSDISCXIRQ_BITPOS (5)
                            11205 ; 46   |#define HW_USBCSR_VBUSDISCXIE_BITPOS (6)
                            11206 ; 47   |#define HW_USBCSR_CLKOFF_BITPOS (7)
                            11207 ; 48   |#define HW_USBCSR_SUSP_BITPOS (8)
                            11208 ; 49   |#define HW_USBCSR_SUSPF_BITPOS (9)
                            11209 ; 50   |#define HW_USBCSR_UTMITST_BITPOS (10)
                            11210 ; 51   |#define HW_USBCSR_UTMI_EXT_BITPOS (11)
                            11211 ; 52   |#define HW_USBCSR_PLUGGEDIN_EN_BITPOS (12)
                            11212 ; 53   |#define HW_USBCSR_PLUGGEDIN_BITPOS (13)
                            11213 ; 54   |#define HW_USBCSR_HOSTDISCONNECT_BITPOS (22)
                            11214 ; 55   |#define HW_USBCSR_VBUSSENSE_BITPOS (23)
                            11215 ; 56   |
                            11216 ; 57   |#define HW_USBCSR_USBEN_SETMASK (1<<HW_USBCSR_USBEN_BITPOS)        
                            11217 ; 58   |#define HW_USBCSR_WAKEUPIRQ_SETMASK (1<<HW_USBCSR_WAKEUPIRQ_BITPOS) 
                            11218 ; 59   |#define HW_USBCSR_WAKEUPIE_SETMASK (1<<HW_USBCSR_WAKEUPIE_BITPOS)  
                            11219 ; 60   |#define HW_USBCSR_VBUSCXIRQ_SETMASK (1<<HW_USBCSR_VBUSCXIRQ_BITPOS)
                            11220 ; 61   |#define HW_USBCSR_VBUSCXIE_SETMASK (1<<HW_USBCSR_VBUSCXIE_BITPOS)
                            11221 ; 62   |#define HW_USBCSR_VBUSDISCXIRQ_SETMASK (1<<HW_USBCSR_VBUSDISCXIRQ_BITPOS)
                            11222 ; 63   |#define HW_USBCSR_VBUSDISCXIE_SETMASK (1<<HW_USBCSR_VBUSDISCXIE_BITPOS)
                            11223 ; 64   |#define HW_USBCSR_CLKOFF_SETMASK (1<<HW_USBCSR_CLKOFF_BITPOS)    
                            11224 ; 65   |#define HW_USBCSR_SUSP_SETMASK (1<<HW_USBCSR_SUSP_BITPOS)      
                            11225 ; 66   |#define HW_USBCSR_SUSPF_SETMASK (1<<HW_USBCSR_SUSPF_BITPOS)     
                            11226 ; 67   |#define HW_USBCSR_UTMITST_SETMASK (1<<HW_USBCSR_UTMITST_BITPOS)   
                            11227 ; 68   |#define HW_USBCSR_UTMI_EXT_SETMASK (1<<HW_USBCSR_UTMI_EXT_BITPOS)
                            11228 ; 69   |#define HW_USBCSR_VBUSSENSE_SETMASK (1<<HW_USBCSR_VBUSSENSE_BITPOS)
                            11229 ; 70   |
                            11230 ; 71   |
                            11231 ; 72   |#define HW_USBCSR_USBEN_CLRMASK (~(WORD)HW_USBCSR_USBEN_SETMASK)     
                            11232 ; 73   |#define HW_USBCSR_WAKEUPIRQ_CLRMASK (~(WORD)HW_USBCSR_WAKEUPIRQ_SETMASK) 
                            11233 ; 74   |#define HW_USBCSR_WAKEUPIE_CLRMASK (~(WORD)HW_USBCSR_WAKEUPIE_SETMASK)  
                            11234 ; 75   |#define HW_USBCSR_VBUSCXIRQ_CLRMASK (~(WORD)HW_USBCSR_VBUSCXIRQ_SETMASK)
                            11235 ; 76   |#define HW_USBCSR_VBUSCXIE_CLRMASK (~(WORD)HW_USBCSR_VBUSCXIE_SETMASK)
                            11236 ; 77   |#define HW_USBCSR_VBUSDISCXIRQ_CLRMASK (~(WORD)HW_USBCSR_VBUSDISCXIRQ_SETMASK)
                            11237 ; 78   |#define HW_USBCSR_VBUSDISCXIE_CLRMASK (~(WORD)HW_USBCSR_VBUSDISCXIE_SETMASK) 
                            11238 ; 79   |#define HW_USBCSR_CLKOFF_CLRMASK (~(WORD)HW_USBCSR_CLKOFF_SETMASK)    
                            11239 ; 80   |#define HW_USBCSR_SUSP_CLRMASK (~(WORD)HW_USBCSR_SUSP_SETMASK)      
                            11240 ; 81   |#define HW_USBCSR_SUSPF_CLRMASK (~(WORD)HW_USBCSR_SUSPF_SETMASK)     
                            11241 ; 82   |#define HW_USBCSR_UTMITST_CLRMASK (~(WORD)HW_USBCSR_UTMITST_SETMASK)   
                            11242 ; 83   |#define HW_USBCSR_UTMI_EXT_CLRMASK (~(WORD)HW_USBCSR_UTMI_EXT_SETMASK) 
                            11243 ; 84   |#define HW_USBCSR_VBUSSENSE_CLRMASK (~(WORD)HW_USBCSR_VBUSSENSE_SETMASK) 
                            11244 ; 85   |
                            11245 ; 86   |typedef union               
                            11246 ; 87   |{
                            11247 ; 88   |    struct {
                            11248 ; 89   |        int USBEN          :1;
                            11249 ; 90   |        int WAKEUPIRQ      :1;
                            11250 ; 91   |        int WAKEUPIE       :1;
                            11251 ; 92   |        int VBUSCXIRQ      :1;
                            11252 ; 93   |        int VBUSCXIE       :1;
                            11253 ; 94   |        int VBUSDISCXIRQ   :1;
                            11254 ; 95   |        int VBUSDISCXIE    :1;
                            11255 ; 96   |        int CLKOFF         :1;
                            11256 ; 97   |        int SUSP           :1;
                            11257 ; 98   |        int SUSPF          :1;
                            11258 ; 99   |        int UTMITST        :1;
                            11259 ; 100  |        int ARCCONNECT     :1;
                            11260 ; 101  |        int PLUGGEDIN_EN   :1;
                            11261 ; 102  |        int PLUGGEDIN      :1;
                            11262 ; 103  |        int                :8;
                            11263 ; 104  |        int HOSTDISCONNECT :1;
                            11264 ; 105  |        int VBUSSENSE      :1;
                            11265 ; 106  |    } B;
                            11266 ; 107  |    int I;
                            11267 ; 108  |} usbcsr_type;
                            11268 ; 109  |#define HW_USBCSR      (*(volatile usbcsr_type _X*) (HW_USB_BASEADDR))    /* USB Control / Status Register */
                            11269 ; 110  |
                            11270 ; 111  |/////////////////////////////////////////////////////////////////////////////////
                            11271 ; 112  |//  USB DMA OFFSET register (HW_USBDMAOFF) Bit Definitions
                            11272 ; 113  |#define HW_USBDMAOFF_MEM_BITPOS (16)
                            11273 ; 114  |
                            11274 ; 115  |#define HW_USBDMAOFF_ADD_SETMASK (0x00FFFF)
                            11275 ; 116  |#define HW_USBDMAOFF_MEM_SETMASK (3<<HW_USBDMAOFF_MEM_BITPOS)
                            11276 ; 117  |
                            11277 ; 118  |#define HW_USBDMAOFF_ADD_CLRMASK (~(WORD)HW_USBDMAOFF_ADD_SETMASK)
                            11278 ; 119  |#define HW_USBDMAOFF_MEM_CLRMASK (~(WORD)HW_USBDMAOFF_MEM_SETMASK)
                            11279 ; 120  |
                            11280 ; 121  |typedef union               
                            11281 ; 122  |{
                            11282 ; 123  |    struct {
                            11283 ; 124  |        int ADD            :16;
                            11284 ; 125  |        int MEM            :2;
                            11285 ; 126  |        int                :6;
                            11286 ; 127  |    } B;
                            11287 ; 128  |    int I;
                            11288 ; 129  |} usbdmaoff_type;
                            11289 ; 130  |#define HW_USBDMAOFF      (*(volatile usbdmaoff_type _X*) (HW_USB_BASEADDR+1))    
                            11290 ; 131  |
                            11291 ; 132  |/////////////////////////////////////////////////////////////////////////////////
                            11292 ; 133  |//  USB ARC ACCESS register (HW_USBARCACCESS) Bit Definitions
                            11293 ; 134  |#define HW_USBARCACCESS_RWB_BITPOS (16)
                            11294 ; 135  |#define HW_USBARCACCESS_KICK_BITPOS (23)
                            11295 ; 136  |
                            11296 ; 137  |#define HW_USBARCACCESS_ADD_SETMASK (0x0001FF)
                            11297 ; 138  |#define HW_USBARCACCESS_RWB_SETMASK (1<<HW_USBARCACCESS_RWB_BITPOS)
                            11298 ; 139  |#define HW_USBARCACCESS_KICK_SETMASK (23<<HW_USBDMAOFF_MEM_BITPOS)
                            11299 ; 140  |
                            11300 ; 141  |#define HW_USBARCACCESS_ADD_CLRMASK (~(WORD)HW_USBARCACCESS_ADD_SETMASK)
                            11301 ; 142  |#define HW_USBARCACCESS_RWB_CLRMASK (~(WORD)HW_USBARCACCESS_RWB_SETMASK) 
                            11302 ; 143  |#define HW_USBARCACCESS_KICK_CLRMASK (~(WORD)HW_USBARCACCESS_KICK_SETMASK)
                            11303 ; 144  |
                            11304 ; 145  |typedef union               
                            11305 ; 146  |{
                            11306 ; 147  |    struct {
                            11307 ; 148  |        int ADD            :9;
                            11308 ; 149  |        int                :7;
                            11309 ; 150  |        int RWB            :1;
                            11310 ; 151  |        int                :14;
                            11311 ; 152  |        int KICK           :1;
                            11312 ; 153  |    } B;
                            11313 ; 154  |    int I;
                            11314 ; 155  |} usbarcaccess_type;
                            11315 ; 156  |#define HW_USBARCACCESS      (*(volatile usbarcaccess_type _X*) (HW_USB_BASEADDR+2))    
                            11316 ; 157  |
                            11317 ; 158  |/////////////////////////////////////////////////////////////////////////////////
                            11318 ; 159  |//  USB ARC DATA LOW register (HW_USBARCDATALOW) Bit Definitions
                            11319 ; 160  |#define HW_USBARCDATALOW_DATA_SETMASK (0x00FFFF)
                            11320 ; 161  |
                            11321 ; 162  |#define HW_USBARCDATALOW_ADD_CLRMASK (~(WORD)HW_USBARCDATALOW_DATA_SETMASK)
                            11322 ; 163  |
                            11323 ; 164  |typedef union               
                            11324 ; 165  |{
                            11325 ; 166  |    struct {
                            11326 ; 167  |        int DATA           :16;
                            11327 ; 168  |        int                :8;
                            11328 ; 169  |    } B;
                            11329 ; 170  |    int I;
                            11330 ; 171  |} usbarcdatalow_type;
                            11331 ; 172  |#define HW_USBARCDATALOW      (*(volatile usbarcdatalow_type _X*) (HW_USB_BASEADDR+3))    
                            11332 ; 173  |
                            11333 ; 174  |/////////////////////////////////////////////////////////////////////////////////
                            11334 ; 175  |//  USB ARC DATA HIGH register (HW_USBARCDATAHIGH) Bit Definitions
                            11335 ; 176  |#define HW_USBARCDATAHIGH_DATA_SETMASK (0x00FFFF)
                            11336 ; 177  |
                            11337 ; 178  |#define HW_USBARCDATAHIGH_ADD_CLRMASK (~(WORD)HW_USBARCDATAHIGH_DATA_SETMASK)
                            11338 ; 179  |
                            11339 ; 180  |typedef union               
                            11340 ; 181  |{
                            11341 ; 182  |    struct {
                            11342 ; 183  |        int DATA           :16;
                            11343 ; 184  |        int                :8;
                            11344 ; 185  |    } B;
                            11345 ; 186  |    int I;
                            11346 ; 187  |} usbarcdatahigh_type;
                            11347 ; 188  |#define HW_USBARCDATAHIGH     (*(volatile usbarcdatahigh_type _X*) (HW_USB_BASEADDR+4))    
                            11348 ; 189  |
                            11349 ; 190  |
                            11350 ; 191  |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            11351 ; 192  |//   USB2.0 ARC Registers 
                            11352 ; 193  |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            11353 ; 194  |#define HW_ARC_BASE_ADDR (0x0000)
                            11354 ; 195  |
                            11355 ; 196  |#define HW_ARC_HCSPARAMS (HW_ARC_BASE_ADDR+0x104)
                            11356 ; 197  |#define HW_ARC_USBCMD (HW_ARC_BASE_ADDR+0x140)
                            11357 ; 198  |#define HW_ARC_USBSTS (HW_ARC_BASE_ADDR+0x144)
                            11358 ; 199  |#define HW_ARC_USBINTR (HW_ARC_BASE_ADDR+0x148)
                            11359 ; 200  |#define HW_ARC_DEVADDR (HW_ARC_BASE_ADDR+0x154)
                            11360 ; 201  |#define HW_ARC_ENDPTLISTADDR (HW_ARC_BASE_ADDR+0x158)
                            11361 ; 202  |#define HW_ARC_PORTSC1 (HW_ARC_BASE_ADDR+0x184)
                            11362 ; 203  |#define HW_ARC_USBMODE (HW_ARC_BASE_ADDR+0x1a8)
                            11363 ; 204  |#define HW_ARC_ENDPTSETUPSTAT (HW_ARC_BASE_ADDR+0x1ac)
                            11364 ; 205  |#define HW_ARC_ENDPTPRIME (HW_ARC_BASE_ADDR+0x1b0)
                            11365 ; 206  |#define HW_ARC_ENDPTFLUSH (HW_ARC_BASE_ADDR+0x1b4)
                            11366 ; 207  |#define HW_ARC_ENDPTSTATUS (HW_ARC_BASE_ADDR+0x1b8)
                            11367 ; 208  |#define HW_ARC_ENDPTCOMPLETE (HW_ARC_BASE_ADDR+0x1bc)
                            11368 ; 209  |#define HW_ARC_ENDPTCTRL0 (HW_ARC_BASE_ADDR+0x1c0)
                            11369 ; 210  |#define HW_ARC_ENDPTCTRL1 (HW_ARC_BASE_ADDR+0x1c4)
                            11370 ; 211  |#define HW_ARC_ENDPTCTRL2 (HW_ARC_BASE_ADDR+0x1c8)
                            11371 ; 212  |#define HW_ARC_ENDPTCTRL3 (HW_ARC_BASE_ADDR+0x1cc)
                            11372 ; 213  |#define HW_ARC_ENDPTCTRL4 (HW_ARC_BASE_ADDR+0x1d0)
                            11373 ; 214  |#define HW_ARC_ENDPTCTRL5 (HW_ARC_BASE_ADDR+0x1d4)
                            11374 ; 215  |#define HW_ARC_ENDPTCTRL6 (HW_ARC_BASE_ADDR+0x1d8)
                            11375 ; 216  |#define HW_ARC_ENDPTCTRL7 (HW_ARC_BASE_ADDR+0x1dc)
                            11376 ; 217  |#define HW_ARC_ENDPTCTRL8 (HW_ARC_BASE_ADDR+0x1e0)
                            11377 ; 218  |#define HW_ARC_ENDPTCTRL9 (HW_ARC_BASE_ADDR+0x1e4)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  46

M:ADDR CODE           CYCLES LINE SOURCELINE
                            11378 ; 219  |#define HW_ARC_ENDPTCTRL10 (HW_ARC_BASE_ADDR+0x1e8)
                            11379 ; 220  |#define HW_ARC_ENDPTCTRL11 (HW_ARC_BASE_ADDR+0x1ec)
                            11380 ; 221  |#define HW_ARC_ENDPTCTRL12 (HW_ARC_BASE_ADDR+0x1f0)
                            11381 ; 222  |#define HW_ARC_ENDPTCTRL13 (HW_ARC_BASE_ADDR+0x1f4)
                            11382 ; 223  |#define HW_ARC_ENDPTCTRL14 (HW_ARC_BASE_ADDR+0x1f8)
                            11383 ; 224  |#define HW_ARC_ENDPTCTRL15 (HW_ARC_BASE_ADDR+0x1fc)
                            11384 ; 225  |
                            11385 ; 226  |#define HW_ARC_ENDPTCTRL(n) (HW_ARC_ENDPTCTRL0+((n)*4))    
                            11386 ; 227  |/////////////////////////////////////////////////////////////////////////////////
                            11387 ; 228  |//  USB ARC Register Host Control Structural Parameters (HW_ARC_HCSPARAMS)
                            11388 ; 229  |
                            11389 ; 230  |#define HW_ARC_HCSPARAMS_NPORTS_BITPOS (0)
                            11390 ; 231  |#define HW_ARC_HCSPARAMS_PPC_BITPOS (4)
                            11391 ; 232  |#define HW_ARC_HCSPARAMS_NPCC_BITPOS (8)
                            11392 ; 233  |#define HW_ARC_HCSPARAMS_NCC_BITPOS (12)
                            11393 ; 234  |#define HW_ARC_HCSPARAMS_PI_BITPOS (16)
                            11394 ; 235  |#define HW_ARC_HCSPARAMS_NPTT_BITPOS (20)
                            11395 ; 236  |#define HW_ARC_HCSPARAMS_NTT_BITPOS (24)
                            11396 ; 237  |
                            11397 ; 238  |#define HW_ARC_HCSPARAMS_NPORTS_SETMASK (15<<HW_ARC_HCSPARAMS_NPORTS_BITPOS)
                            11398 ; 239  |#define HW_ARC_HCSPARAMS_PPC_SETMASK (1<<HW_ARC_HCSPARAMS_PPC_BITPOS)        
                            11399 ; 240  |#define HW_ARC_HCSPARAMS_NPCC_SETMASK (15<<HW_ARC_HCSPARAMS_NPCC_BITPOS)  
                            11400 ; 241  |#define HW_ARC_HCSPARAMS_NCC_SETMASK (15<<HW_ARC_HCSPARAMS_NCC_BITPOS)       
                            11401 ; 242  |#define HW_ARC_HCSPARAMS_PI_SETMASK (1<<HW_ARC_HCSPARAMS_PI_BITPOS)     
                            11402 ; 243  |#define HW_ARC_HCSPARAMS_NPTT_SETMASK (15<<HW_ARC_HCSPARAMS_NPTT_BITPOS)  
                            11403 ; 244  |#define HW_ARC_HCSPARAMS_NTT_SETMASK (15<<HW_ARC_HCSPARAMS_NTT_BITPOS)       
                            11404 ; 245  |
                            11405 ; 246  |#define HW_ARC_HCSPARAMS_NPORTS_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NPORTS_SETMASK)
                            11406 ; 247  |#define HW_ARC_HCSPARAMS_PPC_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_PPC_SETMASK)
                            11407 ; 248  |#define HW_ARC_HCSPARAMS_NPCC_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NPCC_SETMASK)
                            11408 ; 249  |#define HW_ARC_HCSPARAMS_NCC_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NCC_SETMASK)
                            11409 ; 250  |#define HW_ARC_HCSPARAMS_PI_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_PI_SETMASK)  
                            11410 ; 251  |#define HW_ARC_HCSPARAMS_NPTT_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NPTT_SETMASK)
                            11411 ; 252  |#define HW_ARC_HCSPARAMS_NTT_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NTT_SETMASK)
                            11412 ; 253  |
                            11413 ; 254  |typedef union               
                            11414 ; 255  |{
                            11415 ; 256  |    struct {
                            11416 ; 257  |        int N_PORTS         :4;
                            11417 ; 258  |        int PPC             :1;
                            11418 ; 259  |        int                 :3;
                            11419 ; 260  |        int N_PCC           :4;
                            11420 ; 261  |        int N_CC            :4;
                            11421 ; 262  |        int PI              :1;
                            11422 ; 263  |        int                 :3;
                            11423 ; 264  |        int N_PTT           :4;
                            11424 ; 265  |        int N_TT            :4;
                            11425 ; 266  |        int                 :20;
                            11426 ; 267  |    } B;
                            11427 ; 268  |    DWORD I;
                            11428 ; 269  |} hcsparams_type;
                            11429 ; 270  |// #define HW_ARC_HCSPARAMS (*(volatile hcsparams_type _X*) (HW_ARC_BASEADDR))    
                            11430 ; 271  |
                            11431 ; 272  |/////////////////////////////////////////////////////////////////////////////////
                            11432 ; 273  |//  USB ARC Register USB Command (HW_ARC_USBCMD)
                            11433 ; 274  |
                            11434 ; 275  |#define HW_ARC_USBCMD_RS_BITPOS (0)
                            11435 ; 276  |#define HW_ARC_USBCMD_RST_BITPOS (1)
                            11436 ; 277  |#define HW_ARC_USBCMD_FS0_BITPOS (2)
                            11437 ; 278  |#define HW_ARC_USBCMD_FS1_BITPOS (3)
                            11438 ; 279  |#define HW_ARC_USBCMD_PSE_BITPOS (4)
                            11439 ; 280  |#define HW_ARC_USBCMD_ASE_BITPOS (5)
                            11440 ; 281  |#define HW_ARC_USBCMD_IAA_BITPOS (6)
                            11441 ; 282  |#define HW_ARC_USBCMD_LR_BITPOS (7)
                            11442 ; 283  |#define HW_ARC_USBCMD_ASP0_BITPOS (8)
                            11443 ; 284  |#define HW_ARC_USBCMD_ASP1_BITPOS (9)
                            11444 ; 285  |#define HW_ARC_USBCMD_ASPE_BITPOS (11)
                            11445 ; 286  |#define HW_ARC_USBCMD_FS2_BITPOS (15)
                            11446 ; 287  |#define HW_ARC_USBCMD_ITC_BITPOS (16)
                            11447 ; 288  |
                            11448 ; 289  |#define HW_ARC_USBCMD_RS_SETMASK (1<<HW_ARC_USBCMD_RS_BITPOS)                
                            11449 ; 290  |#define HW_ARC_USBCMD_RST_SETMASK (1<<HW_ARC_USBCMD_RST_BITPOS)   
                            11450 ; 291  |#define HW_ARC_USBCMD_FS0_SETMASK (1<<HW_ARC_USBCMD_FS0_BITPOS)   
                            11451 ; 292  |#define HW_ARC_USBCMD_FS1_SETMASK (1<<HW_ARC_USBCMD_FS1_BITPOS)   
                            11452 ; 293  |#define HW_ARC_USBCMD_PSE_SETMASK (1<<HW_ARC_USBCMD_PSE_BITPOS)   
                            11453 ; 294  |#define HW_ARC_USBCMD_ASE_SETMASK (1<<HW_ARC_USBCMD_ASE_BITPOS)   
                            11454 ; 295  |#define HW_ARC_USBCMD_IAA_SETMASK (1<<HW_ARC_USBCMD_IAA_BITPOS)   
                            11455 ; 296  |#define HW_ARC_USBCMD_LR_SETMASK (1<<HW_ARC_USBCMD_LR_BITPOS)        
                            11456 ; 297  |#define HW_ARC_USBCMD_ASP0_SETMASK (1<<HW_ARC_USBCMD_ASP0_BITPOS)
                            11457 ; 298  |#define HW_ARC_USBCMD_ASP1_SETMASK (1<<HW_ARC_USBCMD_ASP1_BITPOS)
                            11458 ; 299  |#define HW_ARC_USBCMD_ASPE_SETMASK (1<<HW_ARC_USBCMD_ASPE_BITPOS)
                            11459 ; 300  |#define HW_ARC_USBCMD_FS2_SETMASK (1<<HW_ARC_USBCMD_FS2_BITPOS)    
                            11460 ; 301  |#define HW_ARC_USBCMD_ITC_SETMASK (255<<HW_ARC_USBCMD_ITC_BITPOS)
                            11461 ; 302  |
                            11462 ; 303  |#define HW_ARC_USBCMD_RS_CLRMASK (~(WORD)HW_ARC_USBCMD_RS_SETMASK)     
                            11463 ; 304  |#define HW_ARC_USBCMD_RST_CLRMASK (~(WORD)HW_ARC_USBCMD_RST_SETMASK)    
                            11464 ; 305  |#define HW_ARC_USBCMD_FS0_CLRMASK (~(WORD)HW_ARC_USBCMD_FS0_SETMASK)    
                            11465 ; 306  |#define HW_ARC_USBCMD_FS1_CLRMASK (~(WORD)HW_ARC_USBCMD_FS1_SETMASK)    
                            11466 ; 307  |#define HW_ARC_USBCMD_PSE_CLRMASK (~(WORD)HW_ARC_USBCMD_PSE_SETMASK)    
                            11467 ; 308  |#define HW_ARC_USBCMD_ASE_CLRMASK (~(WORD)HW_ARC_USBCMD_ASE_SETMASK)    
                            11468 ; 309  |#define HW_ARC_USBCMD_IAA_CLRMASK (~(WORD)HW_ARC_USBCMD_IAA_SETMASK)    
                            11469 ; 310  |#define HW_ARC_USBCMD_LR_CLRMASK (~(WORD)HW_ARC_USBCMD_LR_SETMASK) 
                            11470 ; 311  |#define HW_ARC_USBCMD_ASP0_CLRMASK (~(WORD)HW_ARC_USBCMD_ASP0_SETMASK)
                            11471 ; 312  |#define HW_ARC_USBCMD_ASP1_CLRMASK (~(WORD)HW_ARC_USBCMD_ASP1_SETMASK)
                            11472 ; 313  |#define HW_ARC_USBCMD_ASPE_CLRMASK (~(WORD)HW_ARC_USBCMD_ASPE_SETMASK)
                            11473 ; 314  |#define HW_ARC_USBCMD_FS2_CLRMASK (~(WORD)HW_ARC_USBCMD_FS2_SETMASK)    
                            11474 ; 315  |#define HW_ARC_USBCMD_ITC_CLRMASK (~(WORD)HW_ARC_USBCMD_ITC_SETMASK)    
                            11475 ; 316  |
                            11476 ; 317  |typedef union               
                            11477 ; 318  |{
                            11478 ; 319  |    struct {
                            11479 ; 320  |        int RS              :1;
                            11480 ; 321  |        int RST             :1;
                            11481 ; 322  |        int FS0             :1;
                            11482 ; 323  |        int FS1             :1;
                            11483 ; 324  |        int PSE             :1;
                            11484 ; 325  |        int ASE             :1;
                            11485 ; 326  |        int IAA             :1;
                            11486 ; 327  |        int LR              :1;
                            11487 ; 328  |        int ASP0            :1;
                            11488 ; 329  |        int ASP1            :1;
                            11489 ; 330  |        int                 :1;
                            11490 ; 331  |        int ASPE            :1;
                            11491 ; 332  |        int                 :3;
                            11492 ; 333  |        int FS2             :1;
                            11493 ; 334  |        int ITC             :8;
                            11494 ; 335  |        int                 :24;
                            11495 ; 336  |    } B;
                            11496 ; 337  |    DWORD I;
                            11497 ; 338  |} usbcmd_type;
                            11498 ; 339  |//#define HW_ARC_USBCMD ((volatile usbcmd_type _X*) (HW_ARC_BASEADDR+0x140))    
                            11499 ; 340  |
                            11500 ; 341  |/////////////////////////////////////////////////////////////////////////////////
                            11501 ; 342  |//  USB ARC Register USB Status (HW_ARC_USBSTS)
                            11502 ; 343  |
                            11503 ; 344  |#define HW_ARC_USBSTS_UI_BITPOS (0)
                            11504 ; 345  |#define HW_ARC_USBSTS_UEI_BITPOS (1)
                            11505 ; 346  |#define HW_ARC_USBSTS_PCI_BITPOS (2)
                            11506 ; 347  |#define HW_ARC_USBSTS_FRI_BITPOS (3)
                            11507 ; 348  |#define HW_ARC_USBSTS_SEI_BITPOS (4)
                            11508 ; 349  |#define HW_ARC_USBSTS_AAI_BITPOS (5)
                            11509 ; 350  |#define HW_ARC_USBSTS_URI_BITPOS (6)
                            11510 ; 351  |#define HW_ARC_USBSTS_SRI_BITPOS (7)
                            11511 ; 352  |#define HW_ARC_USBSTS_SLI_BITPOS (8)
                            11512 ; 353  |#define HW_ARC_USBSTS_HCH_BITPOS (12)
                            11513 ; 354  |#define HW_ARC_USBSTS_RCL_BITPOS (13)
                            11514 ; 355  |#define HW_ARC_USBSTS_PS_BITPOS (14)
                            11515 ; 356  |#define HW_ARC_USBSTS_AS_BITPOS (15)
                            11516 ; 357  |
                            11517 ; 358  |#define HW_ARC_USBSTS_UI_SETMASK (1<<HW_ARC_USBSTS_UI_BITPOS)    
                            11518 ; 359  |#define HW_ARC_USBSTS_UEI_SETMASK (1<<HW_ARC_USBSTS_UEI_BITPOS)
                            11519 ; 360  |#define HW_ARC_USBSTS_PCI_SETMASK (1<<HW_ARC_USBSTS_PCI_BITPOS)
                            11520 ; 361  |#define HW_ARC_USBSTS_FRI_SETMASK (1<<HW_ARC_USBSTS_FRI_BITPOS)
                            11521 ; 362  |#define HW_ARC_USBSTS_SEI_SETMASK (1<<HW_ARC_USBSTS_SEI_BITPOS)
                            11522 ; 363  |#define HW_ARC_USBSTS_AAI_SETMASK (1<<HW_ARC_USBSTS_AAI_BITPOS)
                            11523 ; 364  |#define HW_ARC_USBSTS_URI_SETMASK (1<<HW_ARC_USBSTS_URI_BITPOS)
                            11524 ; 365  |#define HW_ARC_USBSTS_SRI_SETMASK (1<<HW_ARC_USBSTS_SRI_BITPOS)
                            11525 ; 366  |#define HW_ARC_USBSTS_SLI_SETMASK (1<<HW_ARC_USBSTS_SLI_BITPOS)
                            11526 ; 367  |#define HW_ARC_USBSTS_HCH_SETMASK (1<<HW_ARC_USBSTS_HCH_BITPOS)
                            11527 ; 368  |#define HW_ARC_USBSTS_RCL_SETMASK (1<<HW_ARC_USBSTS_RCL_BITPOS)
                            11528 ; 369  |#define HW_ARC_USBSTS_PS_SETMASK (1<<HW_ARC_USBSTS_PS_BITPOS)    
                            11529 ; 370  |#define HW_ARC_USBSTS_AS_SETMASK (1<<HW_ARC_USBSTS_AS_BITPOS)    
                            11530 ; 371  |
                            11531 ; 372  |#define HW_ARC_USBSTS_UI_CLRMASK (~(WORD)HW_ARC_USBSTS_UI_SETMASK)
                            11532 ; 373  |#define HW_ARC_USBSTS_UEI_CLRMASK (~(WORD)HW_ARC_USBSTS_UEI_SETMASK)
                            11533 ; 374  |#define HW_ARC_USBSTS_PCI_CLRMASK (~(WORD)HW_ARC_USBSTS_PCI_SETMASK)
                            11534 ; 375  |#define HW_ARC_USBSTS_FRI_CLRMASK (~(WORD)HW_ARC_USBSTS_FRI_SETMASK)
                            11535 ; 376  |#define HW_ARC_USBSTS_SEI_CLRMASK (~(WORD)HW_ARC_USBSTS_SEI_SETMASK)
                            11536 ; 377  |#define HW_ARC_USBSTS_AAI_CLRMASK (~(WORD)HW_ARC_USBSTS_AAI_SETMASK)
                            11537 ; 378  |#define HW_ARC_USBSTS_URI_CLRMASK (~(WORD)HW_ARC_USBSTS_URI_SETMASK)
                            11538 ; 379  |#define HW_ARC_USBSTS_SRI_CLRMASK (~(WORD)HW_ARC_USBSTS_SRI_SETMASK)
                            11539 ; 380  |#define HW_ARC_USBSTS_SLI_CLRMASK (~(WORD)HW_ARC_USBSTS_SLI_SETMASK)
                            11540 ; 381  |#define HW_ARC_USBSTS_HCH_CLRMASK (~(WORD)HW_ARC_USBSTS_HCH_SETMASK)
                            11541 ; 382  |#define HW_ARC_USBSTS_RCL_CLRMASK (~(WORD)HW_ARC_USBSTS_RCL_SETMASK)
                            11542 ; 383  |#define HW_ARC_USBSTS_PS_CLRMASK (~(WORD)HW_ARC_USBSTS_PS_SETMASK)
                            11543 ; 384  |#define HW_ARC_USBSTS_AS_CLRMASK (~(WORD)HW_ARC_USBSTS_AS_SETMASK)
                            11544 ; 385  |
                            11545 ; 386  |
                            11546 ; 387  |typedef union               
                            11547 ; 388  |{
                            11548 ; 389  |    struct {
                            11549 ; 390  |        int UI              :1;
                            11550 ; 391  |        int UEI             :1;
                            11551 ; 392  |        int PCI             :1;
                            11552 ; 393  |        int FRI             :1;
                            11553 ; 394  |        int SEI             :1;
                            11554 ; 395  |        int AAI             :1;
                            11555 ; 396  |        int URI             :1;
                            11556 ; 397  |        int STI             :1;
                            11557 ; 398  |        int SLI             :1;
                            11558 ; 399  |        int                 :3;
                            11559 ; 400  |        int HCH             :1;
                            11560 ; 401  |        int RCL             :1;
                            11561 ; 402  |        int PS              :1;
                            11562 ; 403  |        int AS              :1;
                            11563 ; 404  |        int                 :24;
                            11564 ; 405  |    } B;
                            11565 ; 406  |    DWORD I;
                            11566 ; 407  |} usbsts_type;
                            11567 ; 408  |//#define HW_ARC_USBSTS (*(volatile usbsts_type _X*) (HW_ARC_BASEADDR+0x144))    
                            11568 ; 409  |
                            11569 ; 410  |/////////////////////////////////////////////////////////////////////////////////
                            11570 ; 411  |//  USB ARC Register USB Interrupt Enable (HW_ARC_USBINTR)
                            11571 ; 412  |
                            11572 ; 413  |#define HW_ARC_USBINTR_UE_BITPOS (0)
                            11573 ; 414  |#define HW_ARC_USBINTR_UEE_BITPOS (1)
                            11574 ; 415  |#define HW_ARC_USBINTR_PCE_BITPOS (2)
                            11575 ; 416  |#define HW_ARC_USBINTR_FRE_BITPOS (3)
                            11576 ; 417  |#define HW_ARC_USBINTR_SEE_BITPOS (4)
                            11577 ; 418  |#define HW_ARC_USBINTR_AAE_BITPOS (5)
                            11578 ; 419  |#define HW_ARC_USBINTR_URE_BITPOS (6)
                            11579 ; 420  |#define HW_ARC_USBINTR_SRE_BITPOS (7)
                            11580 ; 421  |#define HW_ARC_USBINTR_SLE_BITPOS (8)
                            11581 ; 422  |
                            11582 ; 423  |#define HW_ARC_USBINTR_UE_SETMASK (1<<HW_ARC_USBINTR_UE_BITPOS)   
                            11583 ; 424  |#define HW_ARC_USBINTR_UEE_SETMASK (1<<HW_ARC_USBINTR_UEE_BITPOS)
                            11584 ; 425  |#define HW_ARC_USBINTR_PCE_SETMASK (1<<HW_ARC_USBINTR_PCE_BITPOS)
                            11585 ; 426  |#define HW_ARC_USBINTR_FRE_SETMASK (1<<HW_ARC_USBINTR_FRE_BITPOS)
                            11586 ; 427  |#define HW_ARC_USBINTR_SEE_SETMASK (1<<HW_ARC_USBINTR_SEE_BITPOS)
                            11587 ; 428  |#define HW_ARC_USBINTR_AAE_SETMASK (1<<HW_ARC_USBINTR_AAE_BITPOS)
                            11588 ; 429  |#define HW_ARC_USBINTR_URE_SETMASK (1<<HW_ARC_USBINTR_URE_BITPOS)
                            11589 ; 430  |#define HW_ARC_USBINTR_SRE_SETMASK (1<<HW_ARC_USBINTR_SRE_BITPOS)
                            11590 ; 431  |#define HW_ARC_USBINTR_SLE_SETMASK (1<<HW_ARC_USBINTR_SLE_BITPOS)
                            11591 ; 432  |
                            11592 ; 433  |#define HW_ARC_USBINTR_UE_CLRMASK (~(WORD)HW_ARC_USBINTR_UE_SETMASK)
                            11593 ; 434  |#define HW_ARC_USBINTR_UEE_CLRMASK (~(WORD)HW_ARC_USBINTR_UEE_SETMASK)
                            11594 ; 435  |#define HW_ARC_USBINTR_PCE_CLRMASK (~(WORD)HW_ARC_USBINTR_PCE_SETMASK)
                            11595 ; 436  |#define HW_ARC_USBINTR_FRE_CLRMASK (~(WORD)HW_ARC_USBINTR_FRE_SETMASK)
                            11596 ; 437  |#define HW_ARC_USBINTR_SEE_CLRMASK (~(WORD)HW_ARC_USBINTR_SEE_SETMASK)
                            11597 ; 438  |#define HW_ARC_USBINTR_AAE_CLRMASK (~(WORD)HW_ARC_USBINTR_AAE_SETMASK)
                            11598 ; 439  |#define HW_ARC_USBINTR_URE_CLRMASK (~(WORD)HW_ARC_USBINTR_URE_SETMASK)
                            11599 ; 440  |#define HW_ARC_USBINTR_SRE_CLRMASK (~(WORD)HW_ARC_USBINTR_SRE_SETMASK)
                            11600 ; 441  |#define HW_ARC_USBINTR_SLE_CLRMASK (~(WORD)HW_ARC_USBINTR_SLE_SETMASK)
                            11601 ; 442  |
                            11602 ; 443  |
                            11603 ; 444  |typedef union               
                            11604 ; 445  |{
                            11605 ; 446  |    struct {
                            11606 ; 447  |        int UE              :1;
                            11607 ; 448  |        int UEE             :1;
                            11608 ; 449  |        int PCE             :1;
                            11609 ; 450  |        int FRE             :1;
                            11610 ; 451  |        int SEE             :1;
                            11611 ; 452  |        int AAE             :1;
                            11612 ; 453  |        int URE             :1;
                            11613 ; 454  |        int STE             :1;
                            11614 ; 455  |        int SLE             :1;
                            11615 ; 456  |        int                 :39;
                            11616 ; 457  |    } B;
                            11617 ; 458  |    DWORD I;
                            11618 ; 459  |} usbintr_type;
                            11619 ; 460  |//#define HW_ARC_USBINTR (*(volatile usbintr_type _X*) (HW_ARC_BASEADDR+0x148))    
                            11620 ; 461  |
                            11621 ; 462  |
                            11622 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                            11623 ; 464  |//  USB ARC Register USB Device Controller Device Address (HW_ARC_DEVADDR)
                            11624 ; 465  |
                            11625 ; 466  |#define HW_ARC_DEVADDR_ADD_BITPOS (25)
                            11626 ; 467  |
                            11627 ; 468  |#define HW_ARC_DEVADDR_ADD_SETMASK (127<<HW_ARC_DEVADDR_ADD_BITPOS)    
                            11628 ; 469  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  47

M:ADDR CODE           CYCLES LINE SOURCELINE
                            11629 ; 470  |#define HW_ARC_DEVEADDR_ADD_CLRMASK (~(WORD)HW_ARC_DEVADDR_ADD_SETMASK)   
                            11630 ; 471  |
                            11631 ; 472  |typedef union               
                            11632 ; 473  |{
                            11633 ; 474  |    struct {
                            11634 ; 475  |        int                 :25;
                            11635 ; 476  |        int ADD             :7;
                            11636 ; 477  |        int                 :16;
                            11637 ; 478  |    } B;
                            11638 ; 479  |    DWORD I;
                            11639 ; 480  |} devaddr_type;
                            11640 ; 481  |//#define HW_ARC_DEVADDR (*(volatile devaddr_type _X*) (HW_ARC_BASEADDR+0x154))    
                            11641 ; 482  |
                            11642 ; 483  |
                            11643 ; 484  |/////////////////////////////////////////////////////////////////////////////////
                            11644 ; 485  |//  USB ARC Register USB Device Controller Endpoint List Address (HW_ARC_ENDPTLISTADDR)
                            11645 ; 486  |
                            11646 ; 487  |#define HW_ARC_ENDPTLISTADDR_ADD_BITPOS (11)
                            11647 ; 488  |
                            11648 ; 489  |#define HW_ARC_ENDPTLISTADDR_ADD_SETMASK (0x400000<<HW_ARC_ENDPTLISTADDR_ADD_BITPOS) 
                            11649 ; 490  |
                            11650 ; 491  |#define HW_ARC_ENDPTLISTADDR_ADD_CLRMASK (~(WORD)HW_ARC_ENDPTLISTADDR_ADD_SETMASK) 
                            11651 ; 492  |
                            11652 ; 493  |typedef union               
                            11653 ; 494  |{
                            11654 ; 495  |    struct {
                            11655 ; 496  |        int                 :10;
                            11656 ; 497  |        int ADD             :22;
                            11657 ; 498  |        int                 :16;
                            11658 ; 499  |    } B;
                            11659 ; 500  |    DWORD I;
                            11660 ; 501  |} endptlistaddr_type;
                            11661 ; 502  |//#define HW_ARC_ENDPTLISTADDR (*(volatile endptlistaddr_type _X*) (HW_ARC_BASEADDR+0x158))    
                            11662 ; 503  |
                            11663 ; 504  |
                            11664 ; 505  |/////////////////////////////////////////////////////////////////////////////////
                            11665 ; 506  |//  USB ARC Register USB Port Status Control 1 (HW_ARC_PORTSC1)
                            11666 ; 507  |
                            11667 ; 508  |#define HW_ARC_PORTSC1_CCS_BITPOS (0)
                            11668 ; 509  |#define HW_ARC_PORTSC1_CSC_BITPOS (1)
                            11669 ; 510  |#define HW_ARC_PORTSC1_PE_BITPOS (2)
                            11670 ; 511  |#define HW_ARC_PORTSC1_PEC_BITPOS (3)
                            11671 ; 512  |#define HW_ARC_PORTSC1_OCA_BITPOS (4)
                            11672 ; 513  |#define HW_ARC_PORTSC1_OCC_BITPOS (5)
                            11673 ; 514  |#define HW_ARC_PORTSC1_FPR_BITPOS (6)
                            11674 ; 515  |#define HW_ARC_PORTSC1_SUSP_BITPOS (7)
                            11675 ; 516  |#define HW_ARC_PORTSC1_PR_BITPOS (8)
                            11676 ; 517  |#define HW_ARC_PORTSC1_HSP_BITPOS (9)
                            11677 ; 518  |#define HW_ARC_PORTSC1_LS_BITPOS (10)
                            11678 ; 519  |#define HW_ARC_PORTSC1_PP_BITPOS (12)
                            11679 ; 520  |#define HW_ARC_PORTSC1_PO_BITPOS (13)
                            11680 ; 521  |#define HW_ARC_PORTSC1_PIC_BITPOS (14)
                            11681 ; 522  |#define HW_ARC_PORTSC1_PTC_BITPOS (16)
                            11682 ; 523  |#define HW_ARC_PORTSC1_WKCN_BITPOS (20)
                            11683 ; 524  |#define HW_ARC_PORTSC1_WKDS_BITPOS (21)
                            11684 ; 525  |#define HW_ARC_PORTSC1_WKOC_BITPOS (22)
                            11685 ; 526  |#define HW_ARC_PORTSC1_PHCD_BITPOS (23)
                            11686 ; 527  |#define HW_ARC_PORTSC1_PFSC_BITPOS (24)
                            11687 ; 528  |#define HW_ARC_PORTSC1_PSPD_BITPOS (26)
                            11688 ; 529  |#define HW_ARC_PORTSC1_PTW_BITPOS (29)
                            11689 ; 530  |#define HW_ARC_PORTSC1_STS_BITPOS (30)
                            11690 ; 531  |#define HW_ARC_PORTSC1_PTS_BITPOS (31)
                            11691 ; 532  |
                            11692 ; 533  |#define HW_ARC_PORTSC1_CCS_SETMASK (1<<HW_ARC_PORTSC1_CCS_BITPOS)  
                            11693 ; 534  |#define HW_ARC_PORTSC1_CSC_SETMASK (1<<HW_ARC_PORTSC1_CSC_BITPOS)  
                            11694 ; 535  |#define HW_ARC_PORTSC1_PE_SETMASK (1<<HW_ARC_PORTSC1_PE_BITPOS)   
                            11695 ; 536  |#define HW_ARC_PORTSC1_PEC_SETMASK (1<<HW_ARC_PORTSC1_PEC_BITPOS)  
                            11696 ; 537  |#define HW_ARC_PORTSC1_OCA_SETMASK (1<<HW_ARC_PORTSC1_OCA_BITPOS)  
                            11697 ; 538  |#define HW_ARC_PORTSC1_OCC_SETMASK (1<<HW_ARC_PORTSC1_OCC_BITPOS)  
                            11698 ; 539  |#define HW_ARC_PORTSC1_FPR_SETMASK (1<<HW_ARC_PORTSC1_FPR_BITPOS)  
                            11699 ; 540  |#define HW_ARC_PORTSC1_SUSP_SETMASK (1<<HW_ARC_PORTSC1_SUSP_BITPOS)
                            11700 ; 541  |#define HW_ARC_PORTSC1_PR_SETMASK (1<<HW_ARC_PORTSC1_PR_BITPOS)   
                            11701 ; 542  |#define HW_ARC_PORTSC1_HSP_SETMASK (1<<HW_ARC_PORTSC1_HSP_BITPOS)  
                            11702 ; 543  |#define HW_ARC_PORTSC1_LS_SETMASK (3<<HW_ARC_PORTSC1_LS_BITPOS)   
                            11703 ; 544  |#define HW_ARC_PORTSC1_PP_SETMASK (1<<HW_ARC_PORTSC1_PP_BITPOS)   
                            11704 ; 545  |#define HW_ARC_PORTSC1_PO_SETMASK (1<<HW_ARC_PORTSC1_PO_BITPOS)   
                            11705 ; 546  |#define HW_ARC_PORTSC1_PIC_SETMASK (3<<HW_ARC_PORTSC1_PIC_BITPOS)  
                            11706 ; 547  |#define HW_ARC_PORTSC1_PTC_SETMASK (15<<HW_ARC_PORTSC1_PTC_BITPOS) 
                            11707 ; 548  |#define HW_ARC_PORTSC1_WKCN_SETMASK (1<<HW_ARC_PORTSC1_WKCN_BITPOS)
                            11708 ; 549  |#define HW_ARC_PORTSC1_WKDS_SETMASK (1<<HW_ARC_PORTSC1_WKDS_BITPOS)
                            11709 ; 550  |#define HW_ARC_PORTSC1_WKOC_SETMASK (1<<HW_ARC_PORTSC1_WKOC_BITPOS)
                            11710 ; 551  |#define HW_ARC_PORTSC1_PHCD_SETMASK (1<<HW_ARC_PORTSC1_PHCD_BITPOS)
                            11711 ; 552  |
                            11712 ; 553  |// We need to equate the following label like this due to a sign extension problem
                            11713 ; 554  |// if equated like so (1<<HW_ARC_PORTSC1_PFSC_SETMASK)
                            11714 ; 555  |#define HW_ARC_PORTSC1_PFSC_SETMASK (0x01000000)
                            11715 ; 556  |
                            11716 ; 557  |#define HW_ARC_PORTSC1_PSPD_SETMASK (3<<HW_ARC_PORTSC1_PSPD_BITPOS)
                            11717 ; 558  |#define HW_ARC_PORTSC1_PTW_SETMASK (1<<HW_ARC_PORTSC1_PTW_BITPOS)  
                            11718 ; 559  |#define HW_ARC_PORTSC1_STS_SETMASK (1<<HW_ARC_PORTSC1_STS_BITPOS)  
                            11719 ; 560  |#define HW_ARC_PORTSC1_PTS_SETMASK (1<<HW_ARC_PORTSC1_PTS_BITPOS)  
                            11720 ; 561  |
                            11721 ; 562  |#define HW_ARC_PORTSC1_CCS_CLRMASK (~(WORD)HW_ARC_PORTSC1_CCS_SETMASK)   
                            11722 ; 563  |#define HW_ARC_PORTSC1_CSC_CLRMASK (~(WORD)HW_ARC_PORTSC1_CSC_SETMASK)   
                            11723 ; 564  |#define HW_ARC_PORTSC1_PE_CLRMASK (~(WORD)HW_ARC_PORTSC1_PE_SETMASK)    
                            11724 ; 565  |#define HW_ARC_PORTSC1_PEC_CLRMASK (~(WORD)HW_ARC_PORTSC1_PEC_SETMASK)   
                            11725 ; 566  |#define HW_ARC_PORTSC1_OCA_CLRMASK (~(WORD)HW_ARC_PORTSC1_OCA_SETMASK)   
                            11726 ; 567  |#define HW_ARC_PORTSC1_OCC_CLRMASK (~(WORD)HW_ARC_PORTSC1_OCC_SETMASK)   
                            11727 ; 568  |#define HW_ARC_PORTSC1_FPR_CLRMASK (~(WORD)HW_ARC_PORTSC1_FPR_SETMASK)   
                            11728 ; 569  |#define HW_ARC_PORTSC1_SUSP_CLRMASK (~(WORD)HW_ARC_PORTSC1_SUSP_SETMASK)
                            11729 ; 570  |#define HW_ARC_PORTSC1_PR_CLRMASK (~(WORD)HW_ARC_PORTSC1_PR_SETMASK)    
                            11730 ; 571  |#define HW_ARC_PORTSC1_HSP_CLRMASK (~(WORD)HW_ARC_PORTSC1_HSP_SETMASK)   
                            11731 ; 572  |#define HW_ARC_PORTSC1_LS_CLRMASK (~(WORD)HW_ARC_PORTSC1_LS_SETMASK)    
                            11732 ; 573  |#define HW_ARC_PORTSC1_PP_CLRMASK (~(WORD)HW_ARC_PORTSC1_PP_SETMASK)    
                            11733 ; 574  |#define HW_ARC_PORTSC1_PO_CLRMASK (~(WORD)HW_ARC_PORTSC1_PO_SETMASK)    
                            11734 ; 575  |#define HW_ARC_PORTSC1_PIC_CLRMASK (~(WORD)HW_ARC_PORTSC1_PIC_SETMASK)   
                            11735 ; 576  |#define HW_ARC_PORTSC1_PTC_CLRMASK (~(WORD)HW_ARC_PORTSC1_PTC_SETMASK)   
                            11736 ; 577  |#define HW_ARC_PORTSC1_WKCN_CLRMASK (~(WORD)HW_ARC_PORTSC1_WKCN_SETMASK)
                            11737 ; 578  |#define HW_ARC_PORTSC1_WKDS_CLRMASK (~(WORD)HW_ARC_PORTSC1_WKDS_SETMASK)
                            11738 ; 579  |#define HW_ARC_PORTSC1_WKOC_CLRMASK (~(WORD)HW_ARC_PORTSC1_WKOC_SETMASK)
                            11739 ; 580  |#define HW_ARC_PORTSC1_PHCD_CLRMASK (~(WORD)HW_ARC_PORTSC1_PHCD_SETMASK)
                            11740 ; 581  |#define HW_ARC_PORTSC1_PFSC_CLRMASK (~(WORD)HW_ARC_PORTSC1_PFSC_SETMASK)
                            11741 ; 582  |#define HW_ARC_PORTSC1_PSPD_CLRMASK (~(WORD)HW_ARC_PORTSC1_PSPD_SETMASK)
                            11742 ; 583  |#define HW_ARC_PORTSC1_PTW_CLRMASK (~(WORD)HW_ARC_PORTSC1_PTW_SETMASK)   
                            11743 ; 584  |#define HW_ARC_PORTSC1_STS_CLRMASK (~(WORD)HW_ARC_PORTSC1_STS_SETMASK)   
                            11744 ; 585  |#define HW_ARC_PORTSC1_PTS_CLRMASK (~(WORD)HW_ARC_PORTSC1_PTS_SETMASK)   
                            11745 ; 586  |
                            11746 ; 587  |typedef union               
                            11747 ; 588  |{
                            11748 ; 589  |    struct {
                            11749 ; 590  |        int CCS             :1;
                            11750 ; 591  |        int CSC             :1;
                            11751 ; 592  |        int PE              :1;
                            11752 ; 593  |        int PEC             :1;
                            11753 ; 594  |        int OCA             :1;
                            11754 ; 595  |        int OCC             :1;
                            11755 ; 596  |        int FPR             :1;
                            11756 ; 597  |        int SUSP            :1;
                            11757 ; 598  |        int PR              :1;
                            11758 ; 599  |        int HSP             :1;
                            11759 ; 600  |        int LS              :2;
                            11760 ; 601  |        int PP              :1;
                            11761 ; 602  |        int PO              :1;
                            11762 ; 603  |        int PIC             :2;
                            11763 ; 604  |        int PTC             :4;
                            11764 ; 605  |        int WKCN            :1;
                            11765 ; 606  |        int WKDS            :1;
                            11766 ; 607  |        int WKOC            :1;
                            11767 ; 608  |        int PHCD            :1;
                            11768 ; 609  |        int PFSC            :1;
                            11769 ; 610  |        int                 :1;
                            11770 ; 611  |        int PSPD            :2;
                            11771 ; 612  |        int                 :1;
                            11772 ; 613  |        int PTW             :1;
                            11773 ; 614  |        int STS             :1;
                            11774 ; 615  |        int PTS             :1;
                            11775 ; 616  |        int                 :16;
                            11776 ; 617  |    } B;
                            11777 ; 618  |    DWORD I;
                            11778 ; 619  |} portsc1_type;
                            11779 ; 620  |//#define HW_ARC_PORTSC1 (*(volatile portsc1_type _X*) (HW_ARC_BASEADDR+0x184))    
                            11780 ; 621  |
                            11781 ; 622  |
                            11782 ; 623  |/////////////////////////////////////////////////////////////////////////////////
                            11783 ; 624  |//  USB ARC Register USB Device Mode (HW_ARC_USBMODE)
                            11784 ; 625  |
                            11785 ; 626  |#define HW_ARC_USBMODE_CM_BITPOS (0)
                            11786 ; 627  |#define HW_ARC_USBMODE_ES_BITPOS (2)
                            11787 ; 628  |
                            11788 ; 629  |#define HW_ARC_USBMODE_CM_SETMASK (3<<HW_ARC_USBMODE_CM_BITPOS)   
                            11789 ; 630  |#define HW_ARC_USBMODE_ES_SETMASK (1<<HW_ARC_USBMODE_ES_BITPOS)   
                            11790 ; 631  |
                            11791 ; 632  |#define HW_ARC_USBMODE_CM_CLRMASK (~(WORD)HW_ARC_USBMODE_CM_SETMASK) 
                            11792 ; 633  |#define HW_ARC_USBMODE_ES_CLRMASK (~(WORD)HW_ARC_USBMODE_ES_SETMASK)    
                            11793 ; 634  |
                            11794 ; 635  |typedef union               
                            11795 ; 636  |{
                            11796 ; 637  |    struct {
                            11797 ; 638  |        int CM              :2;
                            11798 ; 639  |        int ES              :1;
                            11799 ; 640  |        int                 :46;
                            11800 ; 641  |    } B;
                            11801 ; 642  |    DWORD I;
                            11802 ; 643  |} usbmode_type;
                            11803 ; 644  |//#define HW_ARC_USBMODE (*(volatile usbmode_type _X*) (HW_ARC_BASEADDR+0x1a8))    
                            11804 ; 645  |
                            11805 ; 646  |
                            11806 ; 647  |/////////////////////////////////////////////////////////////////////////////////
                            11807 ; 648  |//  The following endpoint equates are common for the following registers
                            11808 ; 649  |
                            11809 ; 650  |#define ENDPOINT0_BITPOS (0)
                            11810 ; 651  |#define ENDPOINT1_BITPOS (1)
                            11811 ; 652  |#define ENDPOINT2_BITPOS (2)
                            11812 ; 653  |#define ENDPOINT3_BITPOS (3)
                            11813 ; 654  |#define ENDPOINT4_BITPOS (4)
                            11814 ; 655  |#define ENDPOINT5_BITPOS (5)
                            11815 ; 656  |#define ENDPOINT6_BITPOS (6)
                            11816 ; 657  |#define ENDPOINT7_BITPOS (7)
                            11817 ; 658  |#define ENDPOINT8_BITPOS (8)
                            11818 ; 659  |#define ENDPOINT9_BITPOS (9)
                            11819 ; 660  |#define ENDPOINT10_BITPOS (10)
                            11820 ; 661  |#define ENDPOINT11_BITPOS (11)
                            11821 ; 662  |#define ENDPOINT12_BITPOS (12)
                            11822 ; 663  |#define ENDPOINT13_BITPOS (13)
                            11823 ; 664  |#define ENDPOINT14_BITPOS (14)
                            11824 ; 665  |#define ENDPOINT15_BITPOS (15)
                            11825 ; 666  |
                            11826 ; 667  |#define ENDPOINT0_SETMASK (1<<ENDPOINT0_BITPOS)
                            11827 ; 668  |#define ENDPOINT1_SETMASK (1<<ENDPOINT1_BITPOS)
                            11828 ; 669  |#define ENDPOINT2_SETMASK (1<<ENDPOINT2_BITPOS)
                            11829 ; 670  |#define ENDPOINT3_SETMASK (1<<ENDPOINT3_BITPOS)
                            11830 ; 671  |#define ENDPOINT4_SETMASK (1<<ENDPOINT4_BITPOS)
                            11831 ; 672  |#define ENDPOINT5_SETMASK (1<<ENDPOINT5_BITPOS)
                            11832 ; 673  |#define ENDPOINT6_SETMASK (1<<ENDPOINT6_BITPOS)
                            11833 ; 674  |#define ENDPOINT7_SETMASK (1<<ENDPOINT7_BITPOS)
                            11834 ; 675  |#define ENDPOINT8_SETMASK (1<<ENDPOINT8_BITPOS)
                            11835 ; 676  |#define ENDPOINT9_SETMASK (1<<ENDPOINT9_BITPOS)
                            11836 ; 677  |#define ENDPOINT10_SETMASK (1<<ENDPOINT10_BITPOS)
                            11837 ; 678  |#define ENDPOINT11_SETMASK (1<<ENDPOINT11_BITPOS)
                            11838 ; 679  |#define ENDPOINT12_SETMASK (1<<ENDPOINT12_BITPOS)
                            11839 ; 680  |#define ENDPOINT13_SETMASK (1<<ENDPOINT13_BITPOS)
                            11840 ; 681  |#define ENDPOINT14_SETMASK (1<<ENDPOINT14_BITPOS)
                            11841 ; 682  |#define ENDPOINT15_SETMASK (1<<ENDPOINT15_BITPOS)
                            11842 ; 683  |
                            11843 ; 684  |#define ENDPOINT0_CLRMASK (~(WORD)ENDPOINT0_SETMASK)    
                            11844 ; 685  |#define ENDPOINT1_CLRMASK (~(WORD)ENDPOINT1_SETMASK)    
                            11845 ; 686  |#define ENDPOINT2_CLRMASK (~(WORD)ENDPOINT2_SETMASK)    
                            11846 ; 687  |#define ENDPOINT3_CLRMASK (~(WORD)ENDPOINT3_SETMASK)    
                            11847 ; 688  |#define ENDPOINT4_CLRMASK (~(WORD)ENDPOINT4_SETMASK)    
                            11848 ; 689  |#define ENDPOINT5_CLRMASK (~(WORD)ENDPOINT5_SETMASK)    
                            11849 ; 690  |#define ENDPOINT6_CLRMASK (~(WORD)ENDPOINT6_SETMASK)    
                            11850 ; 691  |#define ENDPOINT7_CLRMASK (~(WORD)ENDPOINT7_SETMASK)    
                            11851 ; 692  |#define ENDPOINT8_CLRMASK (~(WORD)ENDPOINT8_SETMASK)    
                            11852 ; 693  |#define ENDPOINT9_CLRMASK (~(WORD)ENDPOINT9_SETMASK)    
                            11853 ; 694  |#define ENDPOINT10_CLRMASK (~(WORD)ENDPOINT10_SETMASK)
                            11854 ; 695  |#define ENDPOINT11_CLRMASK (~(WORD)ENDPOINT11_SETMASK)
                            11855 ; 696  |#define ENDPOINT12_CLRMASK (~(WORD)ENDPOINT12_SETMASK)
                            11856 ; 697  |#define ENDPOINT13_CLRMASK (~(WORD)ENDPOINT13_SETMASK)
                            11857 ; 698  |#define ENDPOINT14_CLRMASK (~(WORD)ENDPOINT14_SETMASK)
                            11858 ; 699  |#define ENDPOINT15_CLRMASK (~(WORD)ENDPOINT15_SETMASK)
                            11859 ; 700  |
                            11860 ; 701  |typedef union               
                            11861 ; 702  |{
                            11862 ; 703  |    struct {
                            11863 ; 704  |        int EP0              :1;
                            11864 ; 705  |        int EP1              :1;
                            11865 ; 706  |        int EP2              :1;
                            11866 ; 707  |        int EP3              :1;
                            11867 ; 708  |        int EP4              :1;
                            11868 ; 709  |        int EP5              :1;
                            11869 ; 710  |        int EP6              :1;
                            11870 ; 711  |        int EP7              :1;
                            11871 ; 712  |        int EP8              :1;
                            11872 ; 713  |        int EP9              :1;
                            11873 ; 714  |        int EP10             :1;
                            11874 ; 715  |        int EP11             :1;
                            11875 ; 716  |        int EP12             :1;
                            11876 ; 717  |        int EP13             :1;
                            11877 ; 718  |        int EP14             :1;
                            11878 ; 719  |        int EP15             :1;
                            11879 ; 720  |        int                  :32;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  48

M:ADDR CODE           CYCLES LINE SOURCELINE
                            11880 ; 721  |    } B;
                            11881 ; 722  |    DWORD I;
                            11882 ; 723  |} endpsetupstat_type;
                            11883 ; 724  |
                            11884 ; 725  |//#define HW_ARC_ENDPTSETUPSTAT (*(volatile endpsetupstat_type _X*) (HW_ARC_BASEADDR+0x1ac))    
                            11885 ; 726  |
                            11886 ; 727  |typedef union               
                            11887 ; 728  |{
                            11888 ; 729  |    struct {
                            11889 ; 730  |        int EP0              :1;
                            11890 ; 731  |        int EP1              :1;
                            11891 ; 732  |        int EP2              :1;
                            11892 ; 733  |        int EP3              :1;
                            11893 ; 734  |        int EP4              :1;
                            11894 ; 735  |        int EP5              :1;
                            11895 ; 736  |        int EP6              :1;
                            11896 ; 737  |        int EP7              :1;
                            11897 ; 738  |        int EP8              :1;
                            11898 ; 739  |        int EP9              :1;
                            11899 ; 740  |        int EP10             :1;
                            11900 ; 741  |        int EP11             :1;
                            11901 ; 742  |        int EP12             :1;
                            11902 ; 743  |        int EP13             :1;
                            11903 ; 744  |        int EP14             :1;
                            11904 ; 745  |        int EP15             :1;
                            11905 ; 746  |        int                  :8;
                            11906 ; 747  |    } B;
                            11907 ; 748  |    WORD I;
                            11908 ; 749  |} endpt_type;
                            11909 
                            11947 
                            11948 ; 750  |
                            11949 ; 751  |typedef union
                            11950 ; 752  |{
                            11951 ; 753  |   struct {
                            11952 ; 754  |       endpt_type  RX;
                            11953 ; 755  |       endpt_type  TX;
                            11954 ; 756  |   } W;
                            11955 ; 757  |   DWORD DW;
                            11956 ; 758  |} endptrxtx_type;
                            11957 ; 759  |
                            11958 ; 760  |//#define HW_ARC_ENDPTPRIME    (*(volatile endptrxtx_type _X*) (HW_ARC_BASEADDR+0x1b0))    
                            11959 ; 761  |//#define HW_ARC_ENDPTFLUSH    (*(volatile endptrxtx_type _X*) (HW_ARC_BASEADDR+0x1b4))    
                            11960 ; 762  |//#define HW_ARC_ENDPTSTAT     (*(volatile endptrxtx_type _X*) (HW_ARC_BASEADDR+0x1b8))    
                            11961 ; 763  |//#define HW_ARC_ENDPTCOMPLETE (*(volatile endptrxtx_type _X*) (HW_ARC_BASEADDR+0x1bc))    
                            11962 ; 764  |
                            11963 ; 765  |
                            11964 ; 766  |
                            11965 ; 767  |/////////////////////////////////////////////////////////////////////////////////
                            11966 ; 768  |//  USB ARC Register Endpoint control (HW_ARC_ENDPTCTRL)
                            11967 ; 769  |
                            11968 ; 770  |#define HW_ARC_ENDPTCTRL_RXS_BITPOS (0)
                            11969 ; 771  |#define HW_ARC_ENDPTCTRL_RXD_BITPOS (1)
                            11970 ; 772  |#define HW_ARC_ENDPTCTRL_RXT_BITPOS (2)
                            11971 ; 773  |#define HW_ARC_ENDPTCTRL_RXI_BITPOS (5)
                            11972 ; 774  |#define HW_ARC_ENDPTCTRL_RXR_BITPOS (6)
                            11973 ; 775  |#define HW_ARC_ENDPTCTRL_RXE_BITPOS (7)
                            11974 ; 776  |#define HW_ARC_ENDPTCTRL_TXS_BITPOS (16)
                            11975 ; 777  |#define HW_ARC_ENDPTCTRL_TXD_BITPOS (17)
                            11976 ; 778  |#define HW_ARC_ENDPTCTRL_TXT_BITPOS (18)
                            11977 ; 779  |#define HW_ARC_ENDPTCTRL_TXI_BITPOS (21)
                            11978 ; 780  |#define HW_ARC_ENDPTCTRL_TXR_BITPOS (22)
                            11979 ; 781  |#define HW_ARC_ENDPTCTRL_TXE_BITPOS (23)
                            11980 ; 782  |
                            11981 ; 783  |#define HW_ARC_ENDPTCTRL_RXS_SETMASK (1<<HW_ARC_ENDPTCTRL_RXS_BITPOS)
                            11982 ; 784  |#define HW_ARC_ENDPTCTRL_RXD_SETMASK (1<<HW_ARC_ENDPTCTRL_RXD_BITPOS)
                            11983 ; 785  |#define HW_ARC_ENDPTCTRL_RXT_SETMASK (3<<HW_ARC_ENDPTCTRL_RXT_BITPOS)
                            11984 ; 786  |#define HW_ARC_ENDPTCTRL_RXI_SETMASK (1<<HW_ARC_ENDPTCTRL_RXI_BITPOS)
                            11985 ; 787  |#define HW_ARC_ENDPTCTRL_RXR_SETMASK (1<<HW_ARC_ENDPTCTRL_RXR_BITPOS)
                            11986 ; 788  |#define HW_ARC_ENDPTCTRL_RXE_SETMASK (1<<HW_ARC_ENDPTCTRL_RXE_BITPOS)
                            11987 ; 789  |#define HW_ARC_ENDPTCTRL_TXS_SETMASK (1<<HW_ARC_ENDPTCTRL_TXS_BITPOS)
                            11988 ; 790  |#define HW_ARC_ENDPTCTRL_TXD_SETMASK (1<<HW_ARC_ENDPTCTRL_TXD_BITPOS)
                            11989 ; 791  |#define HW_ARC_ENDPTCTRL_TXT_SETMASK (3<<HW_ARC_ENDPTCTRL_TXT_BITPOS)
                            11990 ; 792  |#define HW_ARC_ENDPTCTRL_TXI_SETMASK (1<<HW_ARC_ENDPTCTRL_TXI_BITPOS)
                            11991 ; 793  |#define HW_ARC_ENDPTCTRL_TXR_SETMASK (1<<HW_ARC_ENDPTCTRL_TXR_BITPOS)
                            11992 ; 794  |
                            11993 ; 795  |// We need to equate the following label like this due to a sign extension problem
                            11994 ; 796  |// if equated like so (1<<HW_ARC_ENDPTCTRL_TXE_BITPOS)
                            11995 ; 797  |#define HW_ARC_ENDPTCTRL_TXE_SETMASK (0x00800000)
                            11996 ; 798  |//HW_ARC_ENDPTCTRL_TXE_SETMASK    equ     (1<<HW_ARC_ENDPTCTRL_TXE_BITPOS)
                            11997 ; 799  |
                            11998 ; 800  |#define HW_ARC_ENDPTCTRL_RXS_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXS_SETMASK)
                            11999 ; 801  |#define HW_ARC_ENDPTCTRL_RXD_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXD_SETMASK)
                            12000 ; 802  |#define HW_ARC_ENDPTCTRL_RXT_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXT_SETMASK)
                            12001 ; 803  |#define HW_ARC_ENDPTCTRL_RXI_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXI_SETMASK)
                            12002 ; 804  |#define HW_ARC_ENDPTCTRL_RXR_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXR_SETMASK)
                            12003 ; 805  |#define HW_ARC_ENDPTCTRL_RXE_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXE_SETMASK)
                            12004 ; 806  |#define HW_ARC_ENDPTCTRL_TXS_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXS_SETMASK)
                            12005 ; 807  |#define HW_ARC_ENDPTCTRL_TXD_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXD_SETMASK)
                            12006 ; 808  |#define HW_ARC_ENDPTCTRL_TXT_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXT_SETMASK)
                            12007 ; 809  |#define HW_ARC_ENDPTCTRL_TXI_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXI_SETMASK)
                            12008 ; 810  |#define HW_ARC_ENDPTCTRL_TXR_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXR_SETMASK)
                            12009 ; 811  |#define HW_ARC_ENDPTCTRL_TXE_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXE_SETMASK)
                            12010 ; 812  |
                            12011 ; 813  |
                            12012 ; 814  |typedef union               
                            12013 ; 815  |{
                            12014 ; 816  |    struct {
                            12015 ; 817  |        int RXS             :1;
                            12016 ; 818  |        int RXD             :1;
                            12017 ; 819  |        int RXT             :2;
                            12018 ; 820  |        int                 :1;
                            12019 ; 821  |        int RXI             :1;
                            12020 ; 822  |        int RXR             :1;
                            12021 ; 823  |        int RXE             :1;
                            12022 ; 824  |        int                 :8;
                            12023 ; 825  |        int TXS             :1;
                            12024 ; 826  |        int TXD             :1;
                            12025 ; 827  |        int TXT             :2;
                            12026 ; 828  |        int                 :1;
                            12027 ; 829  |        int TXI             :1;
                            12028 ; 830  |        int TXR             :1;
                            12029 ; 831  |        int TXE             :1;
                            12030 ; 832  |        int                 :24;
                            12031 ; 833  |    } B;
                            12032 ; 834  |    DWORD I;
                            12033 ; 835  |} endptctrl_type;
                            12034 ; 836  |//#define HW_ARC_ENDPTCTRL[n] (*(volatile usbintr_type _X*) (HW_ARC_BASEADDR+0x1c0+((n)*4)))    
                            12035 ; 837  |
                            12036 ; 838  |#endif
                            12037 ; 839  |
                            12038 ; 840  |
                            12039 
                            12041 
                            12042 ; 37   |#include "regsusb20phy.h"
                            12043 
                            12045 
                            12046 ; 1    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            12047 ; 2    |//;  Copyright(C) SigmaTel, Inc. 2002-2005
                            12048 ; 3    |//;  File        : regsusbphy.inc
                            12049 ; 4    |//;  Description : USB20 PHY Register definition
                            12050 ; 5    |//;  Updated 2.23.2003 By M. Henson
                            12051 ; 6    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            12052 ; 7    |
                            12053 ; 8    |// The following naming conventions are followed in this file.
                            12054 ; 9    |// All registers are named using the format...
                            12055 ; 10   |//     HW_<module>_<regname>
                            12056 ; 11   |// where <module> is the module name which can be any of the following...
                            12057 ; 12   |//     USB20
                            12058 ; 13   |// (Note that when there is more than one copy of a particular module, the
                            12059 ; 14   |// module name includes a number starting from 0 for the first instance of
                            12060 ; 15   |// that module)
                            12061 ; 16   |// <regname> is the specific register within that module
                            12062 ; 17   |// We also define the following...
                            12063 ; 18   |//     HW_<module>_<regname>_BITPOS
                            12064 ; 19   |// which defines the starting bit (i.e. LSB) of a multi bit field
                            12065 ; 20   |//     HW_<module>_<regname>_SETMASK
                            12066 ; 21   |// which does something else, and
                            12067 ; 22   |//     HW_<module>_<regname>_CLRMASK
                            12068 ; 23   |// which does something else.
                            12069 ; 24   |// Other rules
                            12070 ; 25   |//     All caps
                            12071 ; 26   |//     Numeric identifiers start at 0
                            12072 ; 27   |
                            12073 ; 28   |#if !(defined(regsusbphyinc))
                            12074 ; 29   |#define regsusbphyinc 1
                            12075 ; 30   |
                            12076 ; 31   |#include "types.h"
                            12077 
                            12079 
                            12080 ; 1    |////////////////////////////////////////////////////////////////////////////////
                            12081 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                            12082 ; 3    |//
                            12083 ; 4    |// Filename: types.h
                            12084 ; 5    |// Description: Standard data types
                            12085 ; 6    |////////////////////////////////////////////////////////////////////////////////
                            12086 ; 7    |
                            12087 ; 8    |#ifndef _TYPES_H
                            12088 ; 9    |#define _TYPES_H
                            12089 ; 10   |
                            12090 ; 11   |// TODO:  move this outta here!
                            12091 ; 12   |#if !defined(NOERROR)
                            12092 ; 13   |#define NOERROR 0
                            12093 ; 14   |#define SUCCESS 0
                            12094 ; 15   |#endif 
                            12095 ; 16   |#if !defined(SUCCESS)
                            12096 ; 17   |#define SUCCESS  0
                            12097 ; 18   |#endif
                            12098 ; 19   |#if !defined(ERROR)
                            12099 ; 20   |#define ERROR   -1
                            12100 ; 21   |#endif
                            12101 ; 22   |#if !defined(FALSE)
                            12102 ; 23   |#define FALSE 0
                            12103 ; 24   |#endif
                            12104 ; 25   |#if !defined(TRUE)
                            12105 ; 26   |#define TRUE  1
                            12106 ; 27   |#endif
                            12107 ; 28   |
                            12108 ; 29   |#if !defined(NULL)
                            12109 ; 30   |#define NULL 0
                            12110 ; 31   |#endif
                            12111 ; 32   |
                            12112 ; 33   |#define MAX_INT     0x7FFFFF
                            12113 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                            12114 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                            12115 ; 36   |#define MAX_ULONG   (-1) 
                            12116 ; 37   |
                            12117 ; 38   |#define WORD_SIZE   24              // word size in bits
                            12118 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                            12119 ; 40   |
                            12120 ; 41   |
                            12121 ; 42   |#define BYTE    unsigned char       // btVarName
                            12122 ; 43   |#define CHAR    signed char         // cVarName
                            12123 ; 44   |#define USHORT  unsigned short      // usVarName
                            12124 ; 45   |#define SHORT   unsigned short      // sVarName
                            12125 ; 46   |#define WORD    unsigned int        // wVarName
                            12126 ; 47   |#define INT     signed int          // iVarName
                            12127 ; 48   |#define DWORD   unsigned long       // dwVarName
                            12128 ; 49   |#define LONG    signed long         // lVarName
                            12129 ; 50   |#define BOOL    unsigned int        // bVarName
                            12130 ; 51   |#define FRACT   _fract              // frVarName
                            12131 ; 52   |#define LFRACT  long _fract         // lfrVarName
                            12132 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                            12133 ; 54   |#define FLOAT   float               // fVarName
                            12134 ; 55   |#define DBL     double              // dVarName
                            12135 ; 56   |#define ENUM    enum                // eVarName
                            12136 ; 57   |#define CMX     _complex            // cmxVarName
                            12137 ; 58   |typedef WORD UCS3;                   // 
                            12138 ; 59   |
                            12139 ; 60   |#define UINT16  unsigned short
                            12140 ; 61   |#define UINT8   unsigned char   
                            12141 ; 62   |#define UINT32  unsigned long
                            12142 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            12143 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            12144 ; 65   |#define WCHAR   UINT16
                            12145 ; 66   |
                            12146 ; 67   |//UINT128 is 16 bytes or 6 words
                            12147 ; 68   |typedef struct UINT128_3500 {   
                            12148 ; 69   |    int val[6];     
                            12149 ; 70   |} UINT128_3500;
                            12150 ; 71   |
                            12151 ; 72   |#define UINT128   UINT128_3500
                            12152 ; 73   |
                            12153 ; 74   |// Little endian word packed byte strings:   
                            12154 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            12155 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            12156 ; 77   |// Little endian word packed byte strings:   
                            12157 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            12158 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            12159 ; 80   |
                            12160 ; 81   |// Declare Memory Spaces To Use When Coding
                            12161 ; 82   |// A. Sector Buffers
                            12162 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                            12163 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                            12164 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                            12165 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                            12166 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                            12167 ; 88   |// B. Media DDI Memory
                            12168 ; 89   |#define MEDIA_DDI_MEM _Y
                            12169 ; 90   |
                            12170 ; 91   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  49

M:ADDR CODE           CYCLES LINE SOURCELINE
                            12171 ; 92   |
                            12172 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                            12173 ; 94   |// Examples of circular pointers:
                            12174 ; 95   |//    INT CIRC cpiVarName
                            12175 ; 96   |//    DWORD CIRC cpdwVarName
                            12176 ; 97   |
                            12177 ; 98   |#define RETCODE INT                 // rcVarName
                            12178 ; 99   |
                            12179 ; 100  |// generic bitfield structure
                            12180 ; 101  |struct Bitfield {
                            12181 ; 102  |    unsigned int B0  :1;
                            12182 ; 103  |    unsigned int B1  :1;
                            12183 ; 104  |    unsigned int B2  :1;
                            12184 ; 105  |    unsigned int B3  :1;
                            12185 ; 106  |    unsigned int B4  :1;
                            12186 ; 107  |    unsigned int B5  :1;
                            12187 ; 108  |    unsigned int B6  :1;
                            12188 ; 109  |    unsigned int B7  :1;
                            12189 ; 110  |    unsigned int B8  :1;
                            12190 ; 111  |    unsigned int B9  :1;
                            12191 ; 112  |    unsigned int B10 :1;
                            12192 ; 113  |    unsigned int B11 :1;
                            12193 ; 114  |    unsigned int B12 :1;
                            12194 ; 115  |    unsigned int B13 :1;
                            12195 ; 116  |    unsigned int B14 :1;
                            12196 ; 117  |    unsigned int B15 :1;
                            12197 ; 118  |    unsigned int B16 :1;
                            12198 ; 119  |    unsigned int B17 :1;
                            12199 ; 120  |    unsigned int B18 :1;
                            12200 ; 121  |    unsigned int B19 :1;
                            12201 ; 122  |    unsigned int B20 :1;
                            12202 ; 123  |    unsigned int B21 :1;
                            12203 ; 124  |    unsigned int B22 :1;
                            12204 ; 125  |    unsigned int B23 :1;
                            12205 ; 126  |};
                            12206 ; 127  |
                            12207 ; 128  |union BitInt {
                            12208 ; 129  |        struct Bitfield B;
                            12209 ; 130  |        int        I;
                            12210 ; 131  |};
                            12211 ; 132  |
                            12212 ; 133  |#define MAX_MSG_LENGTH 10
                            12213 ; 134  |struct CMessage
                            12214 ; 135  |{
                            12215 ; 136  |        unsigned int m_uLength;
                            12216 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                            12217 ; 138  |};
                            12218 ; 139  |
                            12219 ; 140  |typedef struct {
                            12220 ; 141  |    WORD m_wLength;
                            12221 ; 142  |    WORD m_wMessage;
                            12222 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                            12223 ; 144  |} Message;
                            12224 ; 145  |
                            12225 ; 146  |struct MessageQueueDescriptor
                            12226 ; 147  |{
                            12227 ; 148  |        int *m_pBase;
                            12228 ; 149  |        int m_iModulo;
                            12229 ; 150  |        int m_iSize;
                            12230 ; 151  |        int *m_pHead;
                            12231 ; 152  |        int *m_pTail;
                            12232 ; 153  |};
                            12233 ; 154  |
                            12234 ; 155  |struct ModuleEntry
                            12235 ; 156  |{
                            12236 ; 157  |    int m_iSignaledEventMask;
                            12237 ; 158  |    int m_iWaitEventMask;
                            12238 ; 159  |    int m_iResourceOfCode;
                            12239 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                            12240 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                            12241 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                            12242 ; 163  |    int m_uTimeOutHigh;
                            12243 ; 164  |    int m_uTimeOutLow;
                            12244 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                            12245 ; 166  |};
                            12246 ; 167  |
                            12247 ; 168  |union WaitMask{
                            12248 ; 169  |    struct B{
                            12249 ; 170  |        unsigned int m_bNone     :1;
                            12250 ; 171  |        unsigned int m_bMessage  :1;
                            12251 ; 172  |        unsigned int m_bTimer    :1;
                            12252 ; 173  |        unsigned int m_bButton   :1;
                            12253 ; 174  |    } B;
                            12254 ; 175  |    int I;
                            12255 ; 176  |} ;
                            12256 ; 177  |
                            12257 ; 178  |
                            12258 ; 179  |struct Button {
                            12259 ; 180  |        WORD wButtonEvent;
                            12260 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                            12261 ; 182  |};
                            12262 ; 183  |
                            12263 ; 184  |struct Message {
                            12264 ; 185  |        WORD wMsgLength;
                            12265 ; 186  |        WORD wMsgCommand;
                            12266 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                            12267 ; 188  |};
                            12268 ; 189  |
                            12269 ; 190  |union EventTypes {
                            12270 ; 191  |        struct CMessage msg;
                            12271 ; 192  |        struct Button Button ;
                            12272 ; 193  |        struct Message Message;
                            12273 ; 194  |};
                            12274 ; 195  |
                            12275 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                            12276 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                            12277 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                            12278 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                            12279 ; 200  |
                            12280 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                            12281 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                            12282 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                            12283 ; 204  |
                            12284 ; 205  |#if DEBUG
                            12285 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                            12286 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                            12287 ; 208  |#else 
                            12288 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                            12289 ; 210  |#define DebugBuildAssert(x)    
                            12290 ; 211  |#endif
                            12291 ; 212  |
                            12292 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                            12293 ; 214  |//  #pragma asm
                            12294 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                            12295 ; 216  |//  #pragma endasm
                            12296 ; 217  |
                            12297 ; 218  |
                            12298 ; 219  |#ifdef COLOR_262K
                            12299 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                            12300 ; 221  |#elif defined(COLOR_65K)
                            12301 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                            12302 ; 223  |#else
                            12303 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                            12304 ; 225  |#endif
                            12305 ; 226  |    
                            12306 ; 227  |#endif // #ifndef _TYPES_H
                            12307 
                            12309 
                            12310 ; 32   |
                            12311 ; 33   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            12312 ; 34   |//   USB2.0 PHY STMP Registers 
                            12313 ; 35   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            12314 ; 36   |#define HW_USBPHY_BASEADDR (0xF210)
                            12315 ; 37   |
                            12316 ; 38   |
                            12317 ; 39   |/////////////////////////////////////////////////////////////////////////////////
                            12318 ; 40   |//  USB PHY Powerdown Register (HW_USBPHYPWD) Bit Definitions
                            12319 ; 41   |
                            12320 ; 42   |#define HW_USBPHYPWD_TXDISCON1500_BITPOS (5)
                            12321 ; 43   |#define HW_USBPHYPWD_PLLVCOPWD_BITPOS (6)
                            12322 ; 44   |#define HW_USBPHYPWD_PLLVCPPWD_BITPOS (7)
                            12323 ; 45   |#define HW_USBPHYPWD_TXPWDFS_BITPOS (10)
                            12324 ; 46   |#define HW_USBPHYPWD_TXPWDIBIAS_BITPOS (11)
                            12325 ; 47   |#define HW_USBPHYPWD_TXPWDV2I_BITPOS (12)
                            12326 ; 48   |#define HW_USBPHYPWD_TXPWDVBG_BITPOS (13)
                            12327 ; 49   |#define HW_USBPHYPWD_TXPWDCOMP_BITPOS (14)
                            12328 ; 50   |#define HW_USBPHYPWD_RXPWDDISCONDET_BITPOS (16)
                            12329 ; 51   |#define HW_USBPHYPWD_RXPWDENV_BITPOS (17)
                            12330 ; 52   |#define HW_USBPHYPWD_RXPWD1PT1_BITPOS (18)
                            12331 ; 53   |#define HW_USBPHYPWD_RXPWDDIFF_BITPOS (19)
                            12332 ; 54   |#define HW_USBPHYPWD_RXPWDRX_BITPOS (20)
                            12333 ; 55   |#define HW_USBPHYPWD_PWDIBIAS_BITPOS (22)
                            12334 ; 56   |#define HW_USBPHYPWD_REGRESET_BITPOS (23)
                            12335 ; 57   |
                            12336 ; 58   |#define HW_USBPHYPWD_TXDISCON1500_SETMASK (1<<HW_USBPHYPWD_TXDISCON1500_BITPOS)
                            12337 ; 59   |#define HW_USBPHYPWD_PLLVCOPWD_SETMASK (1<<HW_USBPHYPWD_PLLVCOPWD_BITPOS)
                            12338 ; 60   |#define HW_USBPHYPWD_PLLVCPPWD_SETMASK (1<<HW_USBPHYPWD_PLLVCPPWD_BITPOS)
                            12339 ; 61   |#define HW_USBPHYPWD_TXPWDFS_SETMASK (1<<HW_USBPHYPWD_TXPWDFS_BITPOS)
                            12340 ; 62   |#define HW_USBPHYPWD_TXPWDIBIAS_SETMASK (1<<HW_USBPHYPWD_TXPWDIBIAS_BITPOS)
                            12341 ; 63   |#define HW_USBPHYPWD_TXPWDV2I_SETMASK (1<<HW_USBPHYPWD_TXPWDV2I_BITPOS)
                            12342 ; 64   |#define HW_USBPHYPWD_TXPWDVBG_SETMASK (1<<HW_USBPHYPWD_TXPWDVBG_BITPOS)
                            12343 ; 65   |#define HW_USBPHYPWD_TXPWDCOMP_SETMASK (1<<HW_USBPHYPWD_TXPWDCOMP_BITPOS)
                            12344 ; 66   |#define HW_USBPHYPWD_RXPWDDISCONDET_SETMASK (1<<HW_USBPHYPWD_RXPWDDISCONDET_BITPOS)
                            12345 ; 67   |#define HW_USBPHYPWD_RXPWDENV_SETMASK (1<<HW_USBPHYPWD_RXPWDENV_BITPOS)
                            12346 ; 68   |#define HW_USBPHYPWD_RXPWD1PT1_SETMASK (1<<HW_USBPHYPWD_RXPWD1PT1_BITPOS)
                            12347 ; 69   |#define HW_USBPHYPWD_RXPWDDIFF_SETMASK (1<<HW_USBPHYPWD_RXPWDDIFF_BITPOS)
                            12348 ; 70   |#define HW_USBPHYPWD_RXPWDRX_SETMASK (1<<HW_USBPHYPWD_RXPWDRX_BITPOS)
                            12349 ; 71   |#define HW_USBPHYPWD_PWDIBIAS_SETMASK (1<<HW_USBPHYPWD_PWDIBIAS_BITPOS)
                            12350 ; 72   |#define HW_USBPHYPWD_REGRESET_SETMASK (1<<HW_USBPHYPWD_REGRESET_BITPOS)
                            12351 ; 73   |
                            12352 ; 74   |#define HW_USBPHYPWD_TXDISCON1500_CLRMASK (~(WORD)HW_USBPHYPWD_TXDISCON1500_SETMASK)
                            12353 ; 75   |#define HW_USBPHYPWD_PLLVCOPWD_CLRMASK (~(WORD)HW_USBPHYPWD_PLLVCOPWD_SETMASK)
                            12354 ; 76   |#define HW_USBPHYPWD_PLLVCPPWD_CLRMASK (~(WORD)HW_USBPHYPWD_PLLVCPPWD_SETMASK)
                            12355 ; 77   |#define HW_USBPHYPWD_TXPWDFS_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDFS_SETMASK)
                            12356 ; 78   |#define HW_USBPHYPWD_TXPWDIBIAS_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDIBIAS_SETMASK)
                            12357 ; 79   |#define HW_USBPHYPWD_TXPWDV2I_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDV2I_SETMASK)
                            12358 ; 80   |#define HW_USBPHYPWD_TXPWDVBG_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDVBG_SETMASK)
                            12359 ; 81   |#define HW_USBPHYPWD_TXPWDCOMP_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDCOMP_SETMASK)
                            12360 ; 82   |#define HW_USBPHYPWD_RXPWDDISCONDET_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWDDISCONDET_SETMASK)
                            12361 ; 83   |#define HW_USBPHYPWD_RXPWDENV_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWDENV_SETMASK)
                            12362 ; 84   |#define HW_USBPHYPWD_RXPWD1PT1_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWD1PT1_SETMASK)
                            12363 ; 85   |#define HW_USBPHYPWD_RXPWDDIFF_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWDDIFF_SETMASK)
                            12364 ; 86   |#define HW_USBPHYPWD_RXPWDRX_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWDRX_SETMASK)
                            12365 ; 87   |#define HW_USBPHYPWD_PWDIBIAS_CLRMASK (~(WORD)HW_USBPHYPWD_PWDIBIAS_SETMASK)
                            12366 ; 88   |#define HW_USBPHYPWD_REGRESET_CLRMASK (~(WORD)HW_USBPHYPWD_REGRESET_SETMASK)
                            12367 ; 89   |
                            12368 ; 90   |typedef union               
                            12369 ; 91   |{
                            12370 ; 92   |    struct {
                            12371 ; 93   |        int RSVD0          :5;
                            12372 ; 94   |        int TXDISCON1500   :1;
                            12373 ; 95   |        int PLLVCOPWD      :1;
                            12374 ; 96   |        int PLLVCPPWD      :1;
                            12375 ; 97   |        int RSVD1          :2;
                            12376 ; 98   |        int TXPWDFS        :1;
                            12377 ; 99   |        int TXPWDIBIAS     :1;
                            12378 ; 100  |        int TXPWDV2I       :1;
                            12379 ; 101  |        int TXPWDVBG       :1;
                            12380 ; 102  |        int TXPWDCOMP      :1;
                            12381 ; 103  |        int RSVD2          :1;
                            12382 ; 104  |        int RXPWDDISCONDET :1;
                            12383 ; 105  |        int RXPWDENV       :1;
                            12384 ; 106  |        int RXPWD1PT1      :1;
                            12385 ; 107  |        int RXPWDDIFF      :1;
                            12386 ; 108  |        int RXPWDRX        :1;
                            12387 ; 109  |        int RSVD3          :1;
                            12388 ; 110  |        int PWDIBIAS       :1;
                            12389 ; 111  |        int REGRESET       :1;
                            12390 ; 112  |    } B;
                            12391 ; 113  |    int I;
                            12392 ; 114  |} usbphypwd_type;
                            12393 ; 115  |#define HW_USBPHYPWD      (*(volatile usbphypwd_type _X*) (HW_USBPHY_BASEADDR))    /* USB PHY Powerdown Register */
                            12394 ; 116  |
                            12395 ; 117  |/////////////////////////////////////////////////////////////////////////////////
                            12396 ; 118  |//  USB PHY Transmit register (HW_USBPHYTX) Bit Definitions
                            12397 ; 119  |#define HW_USBPHYTX_TXCAL1500_BITPOS (0)
                            12398 ; 120  |#define HW_USBPHYTX_TXENCAL1500_BITPOS (5)
                            12399 ; 121  |#define HW_USBPHYTX_TXHSXCVR_BITPOS (6)
                            12400 ; 122  |#define HW_USBPHYTX_TXCALIBRATE_BITPOS (7)
                            12401 ; 123  |#define HW_USBPHYTX_TXCAL45DN_BITPOS (8)
                            12402 ; 124  |#define HW_USBPHYTX_TXENCAL45DN_BITPOS (13)
                            12403 ; 125  |#define HW_USBPHYTX_TXHSTERM_BITPOS (14)
                            12404 ; 126  |#define HW_USBPHYTX_TXSKEW_BITPOS (15)
                            12405 ; 127  |#define HW_USBPHYTX_TXCAL45DP_BITPOS (16)
                            12406 ; 128  |#define HW_USBPHYTX_TXENCAL45DP_BITPOS (21)
                            12407 ; 129  |#define HW_USBPHYTX_TXFSHIZ_BITPOS (22)
                            12408 ; 130  |#define HW_USBPHYTX_TXCOMPOUT_BITPOS (23)
                            12409 ; 131  |
                            12410 ; 132  |#define HW_USBPHYTX_TXCAL1500_WIDTH (4)
                            12411 ; 133  |#define HW_USBPHYTX_TXENCAL1500_WIDTH (1)
                            12412 ; 134  |#define HW_USBPHYTX_TXHSXCVR_WIDTH (1)
                            12413 ; 135  |#define HW_USBPHYTX_TXCALIBRATE_WIDTH (1)
                            12414 ; 136  |#define HW_USBPHYTX_TXCAL45DN_WIDTH (4)
                            12415 ; 137  |#define HW_USBPHYTX_TXENCAL45DN_WIDTH (1)
                            12416 ; 138  |#define HW_USBPHYTX_TXHSTERM_WIDTH (1)
                            12417 ; 139  |#define HW_USBPHYTX_TXSKEW_WIDTH (1)
                            12418 ; 140  |#define HW_USBPHYTX_TXCAL45DP_WIDTH (4)
                            12419 ; 141  |#define HW_USBPHYTX_TXENCAL45DP_WIDTH (1)
                            12420 ; 142  |#define HW_USBPHYTX_TXFSHIZ_WIDTH (1)
                            12421 ; 143  |#define HW_USBPHYTX_TXCOMPOUT_WIDTH (1)
                            12422 ; 144  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  50

M:ADDR CODE           CYCLES LINE SOURCELINE
                            12423 ; 145  |#define HW_USBPHYTX_TXCAL1500_SETMASK (((1<<HW_USBPHYTX_TXCAL1500_WIDTH)-1)<<HW_USBPHYTX_TXCAL1500_BITPOS)
                            12424 ; 146  |#define HW_USBPHYTX_TXENCAL1500_SETMASK (((1<<HW_USBPHYTX_TXENCAL1500_WIDTH)-1)<<HW_USBPHYTX_TXENCAL1500_BITPOS)
                            12425 ; 147  |#define HW_USBPHYTX_TXHSXCVR_SETMASK (((1<<HW_USBPHYTX_TXHSXCVR_WIDTH)-1)<<HW_USBPHYTX_TXHSXCVR_BITPOS)
                            12426 ; 148  |#define HW_USBPHYTX_TXCALIBRATE_SETMASK (((1<<HW_USBPHYTX_TXCALIBRATE_WIDTH)-1)<<HW_USBPHYTX_TXCALIBRATE_BITPOS)
                            12427 ; 149  |#define HW_USBPHYTX_TXCAL45DN_SETMASK (((1<<HW_USBPHYTX_TXCAL45DN_WIDTH)-1)<<HW_USBPHYTX_TXCAL45DN_BITPOS)
                            12428 ; 150  |#define HW_USBPHYTX_TXENCAL45DN_SETMASK (((1<<HW_USBPHYTX_TXENCAL45DN_WIDTH)-1)<<HW_USBPHYTX_TXENCAL45DN_BITPOS)
                            12429 ; 151  |#define HW_USBPHYTX_TXHSTERM_SETMASK (((1<<HW_USBPHYTX_TXHSTERM_WIDTH)-1)<<HW_USBPHYTX_TXHSTERM_BITPOS)
                            12430 ; 152  |#define HW_USBPHYTX_TXSKEW_SETMASK (((1<<HW_USBPHYTX_TXSKEW_WIDTH)-1)<<HW_USBPHYTX_TXSKEW_BITPOS)
                            12431 ; 153  |#define HW_USBPHYTX_TXCAL45DP_SETMASK (((1<<HW_USBPHYTX_TXCAL45DP_WIDTH)-1)<<HW_USBPHYTX_TXCAL45DP_BITPOS)
                            12432 ; 154  |#define HW_USBPHYTX_TXENCAL45DP_SETMASK (((1<<HW_USBPHYTX_TXENCAL45DP_WIDTH)-1)<<HW_USBPHYTX_TXENCAL45DP_BITPOS)
                            12433 ; 155  |#define HW_USBPHYTX_TXFSHIZ_SETMASK (((1<<HW_USBPHYTX_TXFSHIZ_WIDTH)-1)<<HW_USBPHYTX_TXFSHIZ_BITPOS)
                            12434 ; 156  |#define HW_USBPHYTX_TXCOMPOUT_SETMASK (((1<<HW_USBPHYTX_TXCOMPOUT_WIDTH)-1)<<HW_USBPHYTX_TXCOMPOUT_BITPOS)
                            12435 ; 157  |
                            12436 ; 158  |#define HW_USBPHYTX_TXCAL1500_CLRMASK (~(WORD)HW_USBPHYTX_TXCAL1500_SETMASK)
                            12437 ; 159  |#define HW_USBPHYTX_TXENCAL1500_CLRMASK (~(WORD)HW_USBPHYTX_TXENCAL1500_SETMASK)
                            12438 ; 160  |#define HW_USBPHYTX_TXHSXCVR_CLRMASK (~(WORD)HW_USBPHYTX_TXHSXCVR_SETMASK)
                            12439 ; 161  |#define HW_USBPHYTX_TXCALIBRATE_CLRMASK (~(WORD)HW_USBPHYTX_TXCALIBRATE_SETMASK)
                            12440 ; 162  |#define HW_USBPHYTX_TXCAL45DN_CLRMASK (~(WORD)HW_USBPHYTX_TXCAL45DN_SETMASK)
                            12441 ; 163  |#define HW_USBPHYTX_TXENCAL45DN_CLRMASK (~(WORD)HW_USBPHYTX_TXENCAL45DN_SETMASK)
                            12442 ; 164  |#define HW_USBPHYTX_TXHSTERM_CLRMASK (~(WORD)HW_USBPHYTX_TXHSTERM_SETMASK)
                            12443 ; 165  |#define HW_USBPHYTX_TXSKEW_CLRMASK (~(WORD)HW_USBPHYTX_TXSKEW_SETMASK)
                            12444 ; 166  |#define HW_USBPHYTX_TXCAL45DP_CLRMASK (~(WORD)HW_USBPHYTX_TXCAL45DP_SETMASK)
                            12445 ; 167  |#define HW_USBPHYTX_TXENCAL45DP_CLRMASK (~(WORD)HW_USBPHYTX_TXENCAL45DP_SETMASK)
                            12446 ; 168  |#define HW_USBPHYTX_TXFSHIZ_CLRMASK (~(WORD)HW_USBPHYTX_TXFSHIZ_SETMASK)
                            12447 ; 169  |#define HW_USBPHYTX_TXCOMPOUT_CLRMASK (~(WORD)HW_USBPHYTX_TXCOMPOUT_SETMASK)
                            12448 ; 170  |
                            12449 ; 171  |typedef union               
                            12450 ; 172  |{
                            12451 ; 173  |    struct {
                            12452 ; 174  |        int TXCAL1500          :4;
                            12453 ; 175  |        int RSVD0              :1;
                            12454 ; 176  |        int TXENCAL1500        :1;
                            12455 ; 177  |        int TXHSXCVR           :1;
                            12456 ; 178  |        int TXCALIBRATE        :1;
                            12457 ; 179  |        int TXCAL45DN          :4;
                            12458 ; 180  |        int RSVD1              :1;
                            12459 ; 181  |        int TXENCAL45DN        :1;
                            12460 ; 182  |        int TXHSTERM           :1;
                            12461 ; 183  |        int TXSKEW             :1;
                            12462 ; 184  |        int TXCAL45DP          :4;
                            12463 ; 185  |        int RSVD2              :1;
                            12464 ; 186  |        int TXENCAL45DP        :1;
                            12465 ; 187  |        int TXFSHIZ            :1;
                            12466 ; 188  |        int TXCOMPOUT          :1;
                            12467 ; 189  |    } B;
                            12468 ; 190  |    int I;
                            12469 ; 191  |} usbphytx_type;
                            12470 ; 192  |#define HW_USBPHYTX      (*(volatile usbphytx_type _X*) (HW_USBPHY_BASEADDR+1))    
                            12471 ; 193  |
                            12472 ; 194  |/////////////////////////////////////////////////////////////////////////////////
                            12473 ; 195  |//  USB PHY PLL register (HW_USBPHYPLL) Bit Definitions
                            12474 ; 196  |#define HW_USBPHYPLL_PLLV2ISEL_BITPOS (0)
                            12475 ; 197  |#define HW_USBPHYPLL_PLLCPDBLIP_BITPOS (5)
                            12476 ; 198  |#define HW_USBPHYPLL_PLLVCOCLK2_BITPOS (6)
                            12477 ; 199  |#define HW_USBPHYPLL_PLLVCOCLK24_BITPOS (7)
                            12478 ; 200  |#define HW_USBPHYPLL_PLLCPNSEL_BITPOS (8)
                            12479 ; 201  |#define HW_USBPHYPLL_PLLCLKDIVSEL_BITPOS (12)
                            12480 ; 202  |#define HW_USBPHYPLL_PLLPFDRST_BITPOS (20)
                            12481 ; 203  |#define HW_USBPHYPLL_PLLCPSHORTLFR_BITPOS (21)
                            12482 ; 204  |#define HW_USBPHYPLL_PLLVCOKSTART_BITPOS (22)
                            12483 ; 205  |#define HW_USBPHYPLL_PLLCLKDIVRSTZ_BITPOS (23)
                            12484 ; 206  |
                            12485 ; 207  |#define HW_USBPHYPLL_PLLV2ISEL_WIDTH (4)
                            12486 ; 208  |#define HW_USBPHYPLL_PLLCPDBLIP_WIDTH (1)
                            12487 ; 209  |#define HW_USBPHYPLL_PLLVCOCLK2_WIDTH (1)
                            12488 ; 210  |#define HW_USBPHYPLL_PLLVCOCLK24_WIDTH (1)
                            12489 ; 211  |#define HW_USBPHYPLL_PLLCPNSEL_WIDTH (4)
                            12490 ; 212  |#define HW_USBPHYPLL_PLLCLKDIVSEL_WIDTH (4)
                            12491 ; 213  |#define HW_USBPHYPLL_PLLPFDRST_WIDTH (1)
                            12492 ; 214  |#define HW_USBPHYPLL_PLLCPSHORTLFR_WIDTH (1)
                            12493 ; 215  |#define HW_USBPHYPLL_PLLVCOKSTART_WIDTH (1)
                            12494 ; 216  |#define HW_USBPHYPLL_PLLCLKDIVRSTZ_WIDTH (1)
                            12495 ; 217  |
                            12496 ; 218  |#define HW_USBPHYPLL_PLLV2ISEL_SETMASK (((1<<HW_USBPHYPLL_PLLV2ISEL_WIDTH)-1)<<HW_USBPHYPLL_PLLV2ISEL_BITPOS)
                            12497 ; 219  |#define HW_USBPHYPLL_PLLCPDBLIP_SETMASK (((1<<HW_USBPHYPLL_PLLCPDBLIP_WIDTH)-1)<<HW_USBPHYPLL_PLLCPDBLIP_BITPOS)
                            12498 ; 220  |#define HW_USBPHYPLL_PLLVCOCLK2_SETMASK (((1<<HW_USBPHYPLL_PLLVCOCLK2_WIDTH)-1)<<HW_USBPHYPLL_PLLVCOCLK2_BITPOS)
                            12499 ; 221  |#define HW_USBPHYPLL_PLLVCOCLK24_SETMASK (((1<<HW_USBPHYPLL_PLLVCOCLK24_WIDTH)-1)<<HW_USBPHYPLL_PLLVCOCLK24_BITPOS)
                            12500 ; 222  |#define HW_USBPHYPLL_PLLCPNSEL_SETMASK (((1<<HW_USBPHYPLL_PLLCPNSEL_WIDTH)-1)<<HW_USBPHYPLL_PLLCPNSEL_BITPOS)
                            12501 ; 223  |#define HW_USBPHYPLL_PLLCLKDIVSEL_SETMASK (((1<<HW_USBPHYPLL_PLLCLKDIVSEL_WIDTH)-1)<<HW_USBPHYPLL_PLLCLKDIVSEL_BITPOS)
                            12502 ; 224  |#define HW_USBPHYPLL_PLLPFDRST_SETMASK (((1<<HW_USBPHYPLL_PLLPFDRST_WIDTH)-1)<<HW_USBPHYPLL_PLLPFDRST_BITPOS)
                            12503 ; 225  |#define HW_USBPHYPLL_PLLCPSHORTLFR_SETMASK (((1<<HW_USBPHYPLL_PLLCPSHORTLFR_WIDTH)-1)<<HW_USBPHYPLL_PLLCPSHORTLFR_BITPOS)
                            12504 ; 226  |#define HW_USBPHYPLL_PLLVCOKSTART_SETMASK (((1<<HW_USBPHYPLL_PLLVCOKSTART_WIDTH)-1)<<HW_USBPHYPLL_PLLVCOKSTART_BITPOS)
                            12505 ; 227  |#define HW_USBPHYPLL_PLLCLKDIVRSTZ_SETMASK (((1<<HW_USBPHYPLL_PLLCLKDIVRSTZ_WIDTH)-1)<<HW_USBPHYPLL_PLLCLKDIVRSTZ_BITPOS)
                            12506 ; 228  |
                            12507 ; 229  |#define HW_USBPHYPLL_PLLV2ISEL_CLRMASK (~(WORD)HW_USBPHYPLL_PLLV2ISEL_SETMASK)
                            12508 ; 230  |#define HW_USBPHYPLL_PLLCPDBLIP_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCPDBLIP_SETMASK)
                            12509 ; 231  |#define HW_USBPHYPLL_PLLVCOCLK2_CLRMASK (~(WORD)HW_USBPHYPLL_PLLVCOCLK2_SETMASK)
                            12510 ; 232  |#define HW_USBPHYPLL_PLLVCOCLK24_CLRMASK (~(WORD)HW_USBPHYPLL_PLLVCOCLK24_SETMASK)
                            12511 ; 233  |#define HW_USBPHYPLL_PLLCPNSEL_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCPNSEL_SETMASK)
                            12512 ; 234  |#define HW_USBPHYPLL_PLLCLKDIVSEL_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCLKDIVSEL_SETMASK)
                            12513 ; 235  |#define HW_USBPHYPLL_PLLPFDRST_CLRMASK (~(WORD)HW_USBPHYPLL_PLLPFDRST_SETMASK)
                            12514 ; 236  |#define HW_USBPHYPLL_PLLCPSHORTLFR_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCPSHORTLFR_SETMASK)
                            12515 ; 237  |#define HW_USBPHYPLL_PLLVCOKSTART_CLRMASK (~(WORD)HW_USBPHYPLL_PLLVCOKSTART_SETMASK)
                            12516 ; 238  |#define HW_USBPHYPLL_PLLCLKDIVRSTZ_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCLKDIVRSTZ_SETMASK)
                            12517 ; 239  |
                            12518 ; 240  |typedef union               
                            12519 ; 241  |{
                            12520 ; 242  |    struct {
                            12521 ; 243  |        int PLLV2ISEL        :4;
                            12522 ; 244  |        int RSVD0            :1;
                            12523 ; 245  |        int PLLCPDBLIP       :1;
                            12524 ; 246  |        int PLLVCOCLK2       :1;
                            12525 ; 247  |        int PLLVCOCLK24      :1;
                            12526 ; 248  |        int PLLCPNSEL        :4;
                            12527 ; 249  |        int PLLCLKDIVSEL     :4;
                            12528 ; 250  |        int RSVD1            :4;
                            12529 ; 251  |        int PLLPFDRST        :1;
                            12530 ; 252  |        int PLLCPSHORTLFR    :1;
                            12531 ; 253  |        int PLLVCOKSTART     :1;
                            12532 ; 254  |        int PLLCLKDIVRSTZ    :1;
                            12533 ; 255  |    } B;
                            12534 ; 256  |    int I;
                            12535 ; 257  |} usbphypll_type;
                            12536 ; 258  |#define HW_USBPHYPLL      (*(volatile usbphypll_type _X*) (HW_USBPHY_BASEADDR+2))    
                            12537 ; 259  |
                            12538 ; 260  |/////////////////////////////////////////////////////////////////////////////////
                            12539 ; 261  |//  USB PHY PLL register (HW_USBPHYRX) Bit Definitions
                            12540 ; 262  |#define HW_USBRX_ENVADJ_BITPOS (0)
                            12541 ; 263  |#define HW_USBRX_DISCONADJ_BITPOS (4)
                            12542 ; 264  |#define HW_USBRX_DEBUGMODE_BITPOS (8)
                            12543 ; 265  |#define HW_USBRX_PLLLKTIMECTL_BITPOS (12)
                            12544 ; 266  |#define HW_USBRX_PLLCKDIVCTL_BITPOS (16)
                            12545 ; 267  |#define HW_USBRX_HOSTMODETEST_BITPOS (20)
                            12546 ; 268  |#define HW_USBRX_FSCKSOURCESEL_BITPOS (21)
                            12547 ; 269  |#define HW_USBRX_REGRXDBYPASS_BITPOS (22)
                            12548 ; 270  |#define HW_USBRX_PLLLOCKED_BITPOS (23)
                            12549 ; 271  |
                            12550 ; 272  |#define HW_USBRX_ENVADJ_WIDTH (4)
                            12551 ; 273  |#define HW_USBRX_DISCONADJ_WIDTH (4)
                            12552 ; 274  |#define HW_USBRX_DEBUGMODE_WIDTH (4)
                            12553 ; 275  |#define HW_USBRX_PLLLKTIMECTL_WIDTH (4)
                            12554 ; 276  |#define HW_USBRX_PLLCKDIVCTL_WIDTH (4)
                            12555 ; 277  |#define HW_USBRX_HOSTMODETEST_WIDTH (1)
                            12556 ; 278  |#define HW_USBRX_FSCKSOURCESEL_WIDTH (1)
                            12557 ; 279  |#define HW_USBRX_REGRXDBYPASS_WIDTH (1)
                            12558 ; 280  |#define HW_USBRX_PLLLOCKED_WIDTH (1)
                            12559 ; 281  |
                            12560 ; 282  |#define HW_USBRX_ENVADJ_SETMASK (((1<<HW_USBRX_ENVADJ_WIDTH)-1)<<HW_USBRX_ENVADJ_BITPOS)
                            12561 ; 283  |#define HW_USBRX_DISCONADJ_SETMASK (((1<<HW_USBRX_DISCONADJ_WIDTH)-1)<<HW_USBRX_DISCONADJ_BITPOS)
                            12562 ; 284  |#define HW_USBRX_DEBUGMODE_SETMASK (((1<<HW_USBRX_DEBUGMODE_WIDTH)-1)<<HW_USBRX_DEBUGMODE_BITPOS)
                            12563 ; 285  |#define HW_USBRX_PLLLKTIMECTL_SETMASK (((1<<HW_USBRX_PLLLKTIMECTL_WIDTH)-1)<<HW_USBRX_PLLLKTIMECTL_BITPOS)
                            12564 ; 286  |#define HW_USBRX_PLLCKDIVCTL_SETMASK (((1<<HW_USBRX_PLLCKDIVCTL_WIDTH)-1)<<HW_USBRX_PLLCKDIVCTL_BITPOS)
                            12565 ; 287  |// 480 MHz PLL is divided by named number here. Setmask divider field nibble of 7 gives actual divider of 8 and so on. (8 gives 9, 9 gives 10)
                            12566 ; 288  |//              480Mhz/7 =68.57Mhz
                            12567 ; 289  |#define HW_USBPHYRX_PLLDIV_BY_7 0x060000
                            12568 ; 290  |
                            12569 ; 291  |//              480Mhz/8 ~60Mhz
                            12570 ; 292  |#define HW_USBPHYRX_PLLDIV_BY_8 0x070000
                            12571 ; 293  |
                            12572 ; 294  |//              480Mhz/9 =53.3Mhz
                            12573 ; 295  |#define HW_USBPHYRX_PLLDIV_BY_9 0x080000
                            12574 ; 296  |
                            12575 ; 297  |//              480Mhz/10 =48Mhz
                            12576 ; 298  |#define HW_USBPHYRX_PLLDIV_BY_10 0x090000
                            12577 ; 299  |
                            12578 ; 300  |
                            12579 ; 301  |#define HW_USBRX_HOSTMODETEST_SETMASK (((1<<HW_USBRX_HOSTMODETEST_WIDTH)-1)<<HW_USBRX_HOSTMODETEST_BITPOS)
                            12580 ; 302  |#define HW_USBRX_FSCKSOURCESEL_SETMASK (((1<<HW_USBRX_FSCKSOURCESEL_WIDTH)-1)<<HW_USBRX_FSCKSOURCESEL_BITPOS)
                            12581 ; 303  |#define HW_USBRX_REGRXDBYPASS_SETMASK (((1<<HW_USBRX_REGRXDBYPASS_WIDTH)-1)<<HW_USBRX_REGRXDBYPASS_BITPOS)
                            12582 ; 304  |#define HW_USBRX_PLLLOCKED_SETMASK (((1<<HW_USBRX_PLLLOCKED_WIDTH)-1)<<HW_USBRX_PLLLOCKED_BITPOS)
                            12583 ; 305  |
                            12584 ; 306  |#define HW_USBRX_ENVADJ_CLRMASK (~(WORD)HW_USBRX_ENVADJ_SETMASK)
                            12585 ; 307  |#define HW_USBRX_DISCONADJ_CLRMASK (~(WORD)HW_USBRX_DISCONADJ_SETMASK)
                            12586 ; 308  |#define HW_USBRX_DEBUGMODE_CLRMASK (~(WORD)HW_USBRX_DEBUGMODE_SETMASK)
                            12587 ; 309  |#define HW_USBRX_PLLLKTIMECTL_CLRMASK (~(WORD)HW_USBRX_PLLLKTIMECTL_SETMASK)
                            12588 ; 310  |#define HW_USBRX_PLLCKDIVCTL_CLRMASK (~(WORD)HW_USBRX_PLLCKDIVCTL_SETMASK)
                            12589 ; 311  |#define HW_USBRX_HOSTMODETEST_CLRMASK (~(WORD)HW_USBRX_HOSTMODETEST_SETMASK)
                            12590 ; 312  |#define HW_USBRX_FSCKSOURCESEL_CLRMASK (~(WORD)HW_USBRX_FSCKSOURCESEL_SETMASK)
                            12591 ; 313  |#define HW_USBRX_REGRXDBYPASS_CLRMASK (~(WORD)HW_USBRX_REGRXDBYPASS_SETMASK)
                            12592 ; 314  |#define HW_USBRX_PLLLOCKED_CLRMASK (~(WORD)HW_USBRX_PLLLOCKED_SETMASK)
                            12593 ; 315  |
                            12594 ; 316  |typedef union               
                            12595 ; 317  |{
                            12596 ; 318  |    struct {
                            12597 ; 319  |     int ENVADJ               :4;
                            12598 ; 320  |     int DISCONADJ            :4;
                            12599 ; 321  |     int DEBUGMODE            :4;
                            12600 ; 322  |     int PLLLKTIMECTL         :4;
                            12601 ; 323  |     int PLLCKDIVCTL          :4;
                            12602 ; 324  |     int HOSTMODETEST         :1;
                            12603 ; 325  |     int FSCKSOURCESEL        :1;
                            12604 ; 326  |     int REGRXDBYPASS         :1;
                            12605 ; 327  |     int PLLLOCKED            :1;
                            12606 ; 328  |    } B;
                            12607 ; 329  |    int I;
                            12608 ; 330  |} usbphyrx_type;
                            12609 ; 331  |#define HW_USBPHYRX      (*(volatile usbphyrx_type _X*) (HW_USBPHY_BASEADDR+3))    
                            12610 ; 332  |
                            12611 ; 333  |#endif
                            12612 ; 334  |
                            12613 
                            12615 
                            12616 ; 38   |
                            12617 ; 39   |
                            12618 ; 40   |#endif // if (!@def(hwequ))
                            12619 ; 41   |
                            12620 
                            12622 
                            12623 ; 10   |#include "project.h"
                            12624 
                            12626 
                            12627 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                            12628 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                            12629 ; 3    |//  Filename: project.inc
                            12630 ; 4    |//  Description: 
                            12631 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                            12632 ; 6    |
                            12633 ; 7    |#if (!defined(_PROJECT_INC))
                            12634 ; 8    |#define _PROJECT_INC 1
                            12635 ; 9    |
                            12636 ; 10   |#if defined(STMP_BUILD_PLAYER)
                            12637 ; 11   |#include "hwequ.h"
                            12638 
                            12640 
                            12641 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                            12642 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2001
                            12643 ; 3    |//  File        : hwequ.inc
                            12644 ; 4    |//  Description : STMP Hardware Constants
                            12645 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                            12646 ; 6    |
                            12647 ; 7    |// ////////////////////////////////////////////////////////////////////////////////
                            12648 ; 8    |// hwequ is being eliminated for SDK3XXX.  For SDK2.5XX it will now reside in the   
                            12649 ; 9    |// local folder instead of ..\inc.  All register includes are converted to .h by 
                            12650 ; 10   |// registers.mk placed in the ..\lcdexample\player\output_XXXX folder.
                            12651 ; 11   |// ////////////////////////////////////////////////////////////////////////////////
                            12652 ; 12   |
                            12653 ; 13   |#if (!defined(HWEQU_INC))
                            12654 ; 14   |#define HWEQU_INC 1
                            12655 ; 15   |
                            12656 ; 16   |#include "types.h"
                            12657 ; 17   |#include "regsclkctrl.h"
                            12658 ; 18   |#include "regscore.h"
                            12659 ; 19   |#include "regscodec.h"
                            12660 ; 20   |#include "regsdcdc.h"
                            12661 ; 21   |#include "regsemc.h"
                            12662 ; 22   |#include "regsgpio.h"
                            12663 ; 23   |#include "regsi2c.h"
                            12664 ; 24   |#include "regsi2s.h"
                            12665 ; 25   |#include "regsicoll.h"
                            12666 ; 26   |#include "regslradc.h"
                            12667 ; 27   |#include "regspwm.h"
                            12668 ; 28   |#include "regsrevision.h"
                            12669 ; 29   |#include "regsrtc.h"
                            12670 ; 30   |#include "regsspare.h"
                            12671 ; 31   |#include "regsspi.h"
                            12672 ; 32   |#include "regsswizzle.h"
                            12673 ; 33   |#include "regssdram.h"
                            12674 ; 34   |#include "regstb.h"
                            12675 ; 35   |#include "regstimer.h"
                            12676 ; 36   |#include "regsusb20.h"
                            12677 ; 37   |#include "regsusb20phy.h"
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  51

M:ADDR CODE           CYCLES LINE SOURCELINE
                            12678 ; 38   |
                            12679 ; 39   |
                            12680 ; 40   |#endif // if (!@def(hwequ))
                            12681 ; 41   |
                            12682 
                            12684 
                            12685 ; 12   |#else 
                            12686 ; 13   |//include "regscodec.inc"
                            12687 ; 14   |#endif
                            12688 ; 15   |
                            12689 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                            12690 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults ON) & 
                            12691 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm. STMP00012148
                            12692 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal). 
                            12693 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's specs can 
                            12694 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player mode.  
                            12695 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                            12696 ; 23   |
                            12697 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                            12698 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                            12699 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                            12700 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define below by defining
                            12701 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                            12702 ; 29   |#define ATTEMPT_FAST_BOOT 1
                            12703 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                            12704 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot config above- 
                            12705 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down threshholds by maybe 50mV.
                            12706 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed.
                            12707 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                            12708 ; 35   |
                            12709 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                            12710 ; 37   |// MEDIA DEFINITIONS
                            12711 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                            12712 ; 39   |
                            12713 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                            12714 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                            12715 ; 42   |#if defined(NAND1)
                            12716 ; 43   |#define SM_INTERNAL_CHIPS 1
                            12717 ; 44   |#else 
                            12718 ; 45   |#if defined(NAND2)
                            12719 ; 46   |#define SM_INTERNAL_CHIPS 2
                            12720 ; 47   |#else 
                            12721 ; 48   |#if defined(NAND3)
                            12722 ; 49   |#define SM_INTERNAL_CHIPS 3
                            12723 ; 50   |#else 
                            12724 ; 51   |#if defined(NAND4)
                            12725 ; 52   |#define SM_INTERNAL_CHIPS 4
                            12726 ; 53   |#else 
                            12727 ; 54   |#define SM_INTERNAL_CHIPS 1
                            12728 ; 55   |#endif
                            12729 ; 56   |#endif
                            12730 ; 57   |#endif
                            12731 ; 58   |#endif
                            12732 ; 59   |
                            12733 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                            12734 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                            12735 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it reads 0.  
                            12736 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                            12737 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it reads 1.
                            12738 ; 65   |//*** comment out if active high ****
                            12739 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                            12740 ; 67   |
                            12741 ; 68   |#if defined(SMEDIA)
                            12742 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                            12743 ; 70   |#define NUM_SM_EXTERNAL 1
                            12744 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                            12745 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                            12746 ; 73   |#else 
                            12747 ; 74   |#if defined(MMC)
                            12748 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                            12749 ; 76   |#define NUM_SM_EXTERNAL 0
                            12750 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                            12751 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                            12752 ; 79   |#else 
                            12753 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                            12754 ; 81   |#define NUM_SM_EXTERNAL 0
                            12755 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                            12756 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                            12757 ; 84   |#endif
                            12758 ; 85   |#endif
                            12759 ; 86   |
                            12760 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                            12761 ; 88   |// Mass Storage Class definitions
                            12762 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                            12763 ; 90   |// Set to 0 if Composite Device build is desired.    
                            12764 ; 91   |#define MULTI_LUN_BUILD 1   
                            12765 ; 92   |
                            12766 ; 93   |////////////////////////////////////////////////////////////////////////////////
                            12767 ; 94   |//  SCSI
                            12768 ; 95   |#if (MULTI_LUN_BUILD==0)
                            12769 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                            12770 ; 97   |    #define SCSI_NUM_TARGETS                        2
                            12771 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                            12772 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                            12773 ; 100  |  #else
                            12774 ; 101  |    #define SCSI_NUM_TARGETS                        1
                            12775 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                            12776 ; 103  |  #endif
                            12777 ; 104  |#else
                            12778 ; 105  |    #define SCSI_NUM_TARGETS                        1
                            12779 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                            12780 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                            12781 ; 108  |  #else
                            12782 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                            12783 ; 110  |  #endif
                            12784 ; 111  |#endif
                            12785 ; 112  |
                            12786 ; 113  |
                            12787 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                            12788 ; 115  |
                            12789 ; 116  |
                            12790 ; 117  |////////////////////////////////////////////////////////////////////////////////
                            12791 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                            12792 ; 119  |////////////////////////////////////////////////////////////////////////////////
                            12793 ; 120  |#ifdef MMC
                            12794 ; 121  |#ifdef MTP_BUILD
                            12795 ; 122  |// --------------------
                            12796 ; 123  |// MTP and MMC
                            12797 ; 124  |// --------------------
                            12798 ; 125  |#define NUM_LOGICAL_MEDIA       2
                            12799 ; 126  |#define NUM_LOGICAL_DRIVES      8
                            12800 ; 127  |#else  // ifndef MTP_BUILD
                            12801 ; 128  |#ifdef STMP_BUILD_PLAYER
                            12802 ; 129  |// --------------------
                            12803 ; 130  |// Player and MMC
                            12804 ; 131  |// --------------------
                            12805 ; 132  |#else
                            12806 ; 133  |// --------------------
                            12807 ; 134  |// USBMSC and MMC
                            12808 ; 135  |// --------------------
                            12809 ; 136  |#define NUM_LOGICAL_MEDIA       3
                            12810 ; 137  |#define NUM_LOGICAL_DRIVES      8
                            12811 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                            12812 ; 139  |#endif // ifdef MTP_BUILD
                            12813 ; 140  |#else  // ifndef MMC
                            12814 ; 141  |#ifdef MTP_BUILD
                            12815 ; 142  |// --------------------
                            12816 ; 143  |// MTP and NAND only
                            12817 ; 144  |// --------------------
                            12818 ; 145  |#define NUM_LOGICAL_MEDIA       1
                            12819 ; 146  |#define NUM_LOGICAL_DRIVES      7
                            12820 ; 147  |#else  // ifndef MTP_BUILD
                            12821 ; 148  |#ifdef STMP_BUILD_PLAYER
                            12822 ; 149  |// --------------------
                            12823 ; 150  |// Player and NAND only
                            12824 ; 151  |// --------------------
                            12825 ; 152  |#else
                            12826 ; 153  |// --------------------
                            12827 ; 154  |// USBMSC and NAND only
                            12828 ; 155  |// --------------------
                            12829 ; 156  |#define NUM_LOGICAL_MEDIA       2
                            12830 ; 157  |#define NUM_LOGICAL_DRIVES      7
                            12831 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                            12832 ; 159  |#endif // ifdef MTP_BUILD
                            12833 ; 160  |#endif // ifdef MMC 
                            12834 ; 161  |
                            12835 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                            12836 ; 163  |#if (defined(MTP_BUILD))
                            12837 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                            12838 ; 165  |
                            12839 ; 166  |////!
                            12840 ; 167  |////! This varible holds the watchdog count for the store flush.
                            12841 ; 168  |////!
                            12842 ; 169  |///
                            12843 ; 170  |#include <types.h>
                            12844 ; 171  |extern volatile INT g_StoreWatchDogCount;
                            12845 ; 172  |extern const INT g_StoreWatchDogTimeout;
                            12846 ; 173  |#endif
                            12847 ; 174  |
                            12848 ; 175  |////////////////////////////////////////////////////////////////////////////////
                            12849 ; 176  |// These are needed here for Mass Storage Class
                            12850 ; 177  |// Needs to be cleaned up
                            12851 ; 178  |////////////////////////////////////////////////////////////////////////////////
                            12852 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                            12853 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                            12854 ; 181  |#define SCRATCH_USER_X_SIZE 512
                            12855 ; 182  |
                            12856 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                            12857 ; 184  |
                            12858 ; 185  |#endif
                            12859 ; 186  |
                            12860 ; 187  |
                            12861 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                            12862 ; 189  |// SmartMedia/NAND defs
                            12863 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                            12864 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                            12865 ; 192  |
                            12866 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                            12867 ; 194  |// Sysloadresources defs
                            12868 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                            12869 ; 196  |
                            12870 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                            12871 ; 198  |// MMC defs
                            12872 ; 199  |#define MMC_MAX_PARTITIONS 1
                            12873 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                            12874 ; 201  |
                            12875 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                            12876 ; 203  |// SPI defs
                            12877 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                            12878 ; 205  |
                            12879 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                            12880 ; 207  |// Global media defs
                            12881 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                            12882 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                            12883 ; 210  |
                            12884 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                            12885 ; 212  |// DO NOT CHANGE THESE!!!
                            12886 ; 213  |#define SM_MAX_PARTITIONS 4
                            12887 ; 214  |#define MAX_HANDLES 2
                            12888 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                            12889 ; 216  |
                            12890 ; 217  |
                            12891 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                            12892 ; 219  |// Battery LRADC Values 
                            12893 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                            12894 ; 221  |// brownout trip point in mV (moved by RS)
                            12895 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                            12896 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                            12897 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                            12898 ; 225  |//     audio recording to media.
                            12899 ; 226  |#define BATT_SAFETY_MARGIN 10
                            12900 ; 227  |
                            12901 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                            12902 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline voltage to do a refresh.
                            12903 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                            12904 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                            12905 ; 232  |
                            12906 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc presence.
                            12907 ; 234  |
                            12908 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                            12909 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat check.
                            12910 ; 237  |#if (!defined(CLCD))
                            12911 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                            12912 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                            12913 ; 240  |#else 
                            12914 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                            12915 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                            12916 ; 243  |#endif
                            12917 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                            12918 ; 245  |
                            12919 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                            12920 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIon.
                            12921 ; 248  |// See mp3 encoder overlay.
                            12922 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                            12923 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                            12924 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                            12925 ; 252  |
                            12926 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                            12927 ; 254  |// Voice recording filenames
                            12928 ; 255  |// number of digits in filename Vxxx.wav
                            12929 ; 256  |/////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  52

M:ADDR CODE           CYCLES LINE SOURCELINE
                            12930 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                            12931 ; 258  |
                            12932 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                            12933 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                            12934 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                            12935 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                            12936 ; 263  |#if defined(DEVICE_3500)
                            12937 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                            12938 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                            12939 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                            12940 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, & demo player)
                            12941 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                            12942 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                            12943 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                            12944 ; 271  |
                            12945 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn when bias not yet ready.
                            12946 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                            12947 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevention if you use rec button from outside voice menu.
                            12948 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latency in the record-from-music-menu use-case.
                            12949 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                            12950 ; 277  |
                            12951 ; 278  |#else 
                            12952 ; 279  |// STMP3410
                            12953 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                            12954 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                            12955 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                            12956 ; 283  |#endif
                            12957 ; 284  |
                            12958 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                            12959 ; 286  |// Number of available soft timers
                            12960 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                            12961 ; 288  |#if defined(SYNC_LYRICS)
                            12962 ; 289  |#define SOFT_TIMERS 10
                            12963 ; 290  |#else 
                            12964 ; 291  |#if defined(JPEG_DECODER)
                            12965 ; 292  |#define SOFT_TIMERS 10
                            12966 ; 293  |#else 
                            12967 ; 294  |#define SOFT_TIMERS 9
                            12968 ; 295  |#endif
                            12969 ; 296  |#endif
                            12970 ; 297  |
                            12971 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                            12972 ; 299  |//  sizes
                            12973 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                            12974 ; 301  |#if defined(MMC)
                            12975 ; 302  |#if defined(USE_PLAYLIST5)
                            12976 ; 303  |#define MENU_STACK_SIZE 1500
                            12977 ; 304  |#else 
                            12978 ; 305  |#define MENU_STACK_SIZE 1250
                            12979 ; 306  |#endif //if @def('USE_PLAYLIST5')
                            12980 ; 307  |#else 
                            12981 ; 308  |#if defined(USE_PLAYLIST5)
                            12982 ; 309  |#define MENU_STACK_SIZE 1500
                            12983 ; 310  |#else 
                            12984 ; 311  |#define MENU_STACK_SIZE 1250
                            12985 ; 312  |#endif //if @def('USE_PLAYLIST5')
                            12986 ; 313  |#endif //if @def('MMC')
                            12987 ; 314  |
                            12988 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 750 else 550 for other builds? TOVERIFY. MYALLOC
                            12989 ; 316  |// 
                            12990 ; 317  |#define STACK_L1_SIZE 750
                            12991 ; 318  |#define STACK_L2_SIZE 100
                            12992 ; 319  |#define STACK_L3_SIZE 160
                            12993 ; 320  |
                            12994 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                            12995 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                            12996 ; 323  |// is ok with switching code.
                            12997 ; 324  |#if defined(MTP_BUILD)
                            12998 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                            12999 ; 326  |#endif
                            13000 ; 327  |
                            13001 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                            13002 ; 329  |// maximum number of nested funclets 
                            13003 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                            13004 ; 331  |#define MAX_NESTED_FUNCLET 6 
                            13005 ; 332  |
                            13006 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                            13007 ; 334  |//    LCD DEFINITIONS
                            13008 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                            13009 ; 336  |
                            13010 ; 337  |#define SPACE_CHAR 0x000020          
                            13011 ; 338  |#define ZERO_CHAR 0x000030
                            13012 ; 339  |#define COLON_CHAR 0x00003A
                            13013 ; 340  |#define PERIOD_CHAR 0x00002E
                            13014 ; 341  |
                            13015 ; 342  |#if (defined(S6B33B0A_LCD))
                            13016 ; 343  |#define LCD_X_SIZE 128
                            13017 ; 344  |#define LCD_Y_SIZE 159
                            13018 ; 345  |#endif
                            13019 ; 346  |
                            13020 ; 347  |#if (defined(SED15XX_LCD))
                            13021 ; 348  |#define LCD_X_SIZE 128
                            13022 ; 349  |#define LCD_Y_SIZE 64
                            13023 ; 350  |#endif
                            13024 ; 351  |
                            13025 ; 352  |
                            13026 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                            13027 ; 354  |//   Details on Customizing Contrast
                            13028 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                            13029 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                            13030 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                            13031 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                            13032 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                            13033 ; 360  |//   unless the ezact sequence is remembered.
                            13034 ; 361  |//   To find out what range your player supports: 
                            13035 ; 362  |//   change these equs to full range or comment out (full range is default)
                            13036 ; 363  |//;;;;;;
                            13037 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                            13038 ; 365  |// recommended calibration using player -- uncomment 
                            13039 ; 366  |//;;;;;;
                            13040 ; 367  |//CONTRAST_CALIBRATION    equ  1
                            13041 ; 368  |////////////////////////////
                            13042 ; 369  |#if (defined(DEMO_HW))
                            13043 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi LCD (June6'05)
                            13044 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                            13045 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                            13046 ; 373  |#else 
                            13047 ; 374  |
                            13048 ; 375  |#if (defined(S6B33B0A_LCD))
                            13049 ; 376  |#define LCD_MAX_CONTRAST 210
                            13050 ; 377  |#define LCD_MIN_CONTRAST 160    
                            13051 ; 378  |#endif
                            13052 ; 379  |
                            13053 ; 380  |#if (defined(SED15XX_LCD))
                            13054 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                            13055 ; 382  |// Engineering board regs support range [17-37].
                            13056 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                            13057 ; 384  |//   One default contrast range [24-42] works for both.
                            13058 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                            13059 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                            13060 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                            13061 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                            13062 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                            13063 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                            13064 ; 391  |
                            13065 ; 392  |#if (defined(NEWSHINGYIH))
                            13066 ; 393  |#define LCD_MAX_CONTRAST 250
                            13067 ; 394  |#define LCD_MIN_CONTRAST 0
                            13068 ; 395  |#else 
                            13069 ; 396  |//-----
                            13070 ; 397  |// Near optimal for OLD LCD with NEW file. 
                            13071 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for both LCDs.
                            13072 ; 399  |#define LCD_MAX_CONTRAST 250
                            13073 ; 400  |#define LCD_MIN_CONTRAST 0
                            13074 ; 401  |
                            13075 ; 402  |//=====
                            13076 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                            13077 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this historic ver.
                            13078 ; 405  |//LCD_MAX_CONTRAST equ 42
                            13079 ; 406  |//LCD_MIN_CONTRAST equ 24 
                            13080 ; 407  |
                            13081 ; 408  |#endif
                            13082 ; 409  |#endif
                            13083 ; 410  |
                            13084 ; 411  |#endif
                            13085 ; 412  |
                            13086 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                            13087 ; 414  |// The default value of the lcd contrast in % of range
                            13088 ; 415  |//   the default value is used when no settings.dat is available
                            13089 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                            13090 ; 417  |
                            13091 ; 418  |#if (defined(S6B33B0A_LCD))
                            13092 ; 419  |// 60% of range is default value
                            13093 ; 420  |#define DEFAULT_CONTRAST 50 
                            13094 ; 421  |#endif
                            13095 ; 422  |
                            13096 ; 423  |#if (defined(SED15XX_LCD))
                            13097 ; 424  |// % of range is default value (was 60%)
                            13098 ; 425  |#define DEFAULT_CONTRAST 50 
                            13099 ; 426  |#endif
                            13100 ; 427  |
                            13101 ; 428  |
                            13102 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                            13103 ; 430  |// make lower when doing calibration
                            13104 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                            13105 ; 432  |
                            13106 ; 433  |
                            13107 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                            13108 ; 435  |// For FFWD and RWND
                            13109 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                            13110 ; 437  |#define SECONDS_TO_SKIP 1
                            13111 ; 438  |#define SECONDS_TO_SKIP1 3
                            13112 ; 439  |#define SECONDS_TO_SKIP2 6
                            13113 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                            13114 ; 441  |#define PREV_SONG_THRESHOLD 5  
                            13115 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            13116 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                            13117 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            13118 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                            13119 ; 446  |
                            13120 ; 447  |// For audible FFW/RWD
                            13121 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                            13122 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                            13123 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                            13124 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                            13125 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            13126 ; 453  |#define LEVEL1_BOUNDARY 17 
                            13127 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            13128 ; 455  |#define LEVEL2_BOUNDARY 33 
                            13129 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            13130 ; 457  |#define LEVEL3_BOUNDARY 50 
                            13131 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                            13132 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                            13133 ; 460  |// Short Song Time, songs too short to play.
                            13134 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                            13135 ; 462  |
                            13136 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                            13137 ; 464  |// MP3 Sync Values
                            13138 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                            13139 ; 466  |// # bytes to look for sync before marking it bad
                            13140 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                            13141 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                            13142 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                            13143 ; 470  |// once we have sync'd, the isr should be called this frequently
                            13144 ; 471  |#define MP3_DECODERISR_FAST 7500  
                            13145 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                            13146 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                            13147 ; 474  |
                            13148 ; 475  |
                            13149 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                            13150 ; 477  |//// Multi-Stage Volume Control Definitions
                            13151 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                            13152 ; 479  |//// Use Multi-Stage Volume
                            13153 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                            13154 ; 481  |
                            13155 ; 482  |//// Master Volume definitions
                            13156 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                            13157 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                            13158 ; 485  |
                            13159 ; 486  |//// DAC-Mode definitions
                            13160 ; 487  |//// Adjusts 0dB point
                            13161 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                            13162 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                            13163 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines above.
                            13164 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                            13165 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provides 1.5 dB gain on Stmp34x0; 
                            13166 ; 493  |//                                               Max gain possible: 8 step diff would provide +12dB gain.   
                            13167 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                            13168 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                            13169 ; 496  |
                            13170 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                            13171 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                            13172 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                            13173 ; 500  |
                            13174 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not the default
                            13175 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoint.
                            13176 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                            13177 ; 504  |
                            13178 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the default
                            13179 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                            13180 ; 507  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  53

M:ADDR CODE           CYCLES LINE SOURCELINE
                            13181 ; 508  |
                            13182 ; 509  |//// Line In definitions (used for Line-In 1)
                            13183 ; 510  |//// 0dB point of the Line In
                            13184 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                            13185 ; 512  |//// Minimum volume of Line In
                            13186 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                            13187 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                            13188 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                            13189 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                            13190 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                            13191 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS+1)
                            13192 ; 519  |
                            13193 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                            13194 ; 521  |//// 0dB point of the Line In
                            13195 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                            13196 ; 523  |//// Minimum volume of Line In
                            13197 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                            13198 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                            13199 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                            13200 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                            13201 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                            13202 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                            13203 ; 530  |
                            13204 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                            13205 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid deadlock states & recovers. 
                            13206 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                            13207 ; 534  |#define FM_WATCHDOG_ENABLE 1
                            13208 ; 535  |
                            13209 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                            13210 ; 537  |////
                            13211 ; 538  |////! This varible holds the lcd display state for the mtp project.
                            13212 ; 539  |////
                            13213 ; 540  |///
                            13214 ; 541  |#include <types.h>
                            13215 ; 542  |extern volatile WORD g_wActivityState;
                            13216 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                            13217 ; 544  |
                            13218 ; 545  |void _reentrant Init5VSense(void);
                            13219 ; 546  |void _reentrant ServiceDCDC(void);
                            13220 ; 547  |
                            13221 ; 548  |////////////////////////////////////////////////////////////////////////////
                            13222 ; 549  |//// JPEG Thumbnail Mode Setting
                            13223 ; 550  |//// number of column in thumbnail mode
                            13224 ; 551  |#define THUMBNAIL_X 2           
                            13225 ; 552  |//// number of row in  thumbnail mode
                            13226 ; 553  |#define THUMBNAIL_Y 2           
                            13227 ; 554  |//// thumbnail boundary offset x
                            13228 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                            13229 ; 556  |//// thumbnail boundary offset y
                            13230 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                            13231 ; 558  |
                            13232 ; 559  |#endif // if (!@def(_PROJECT_INC))
                            13233 ; 560  |
                            13234 
                            13236 
                            13237 ; 11   |#include "FileSystem.h"
                            13238 
                            13240 
                            13241 ; 1    |////////////////////////////////////////////////////////////////////////////////
                            13242 ; 2    |//  Copyright(C) SigmaTel, Inc. 2001
                            13243 ; 3    |//
                            13244 ; 4    |//  File        : FileSystem.h
                            13245 ; 5    |//  Description : Header File for File System
                            13246 ; 6    |////////////////////////////////////////////////////////////////////////////////
                            13247 ; 7    |
                            13248 ; 8    |#ifndef _FILESYSTEM_H
                            13249 ; 9    |#define _FILESYSTEM_H
                            13250 ; 10   |
                            13251 ; 11   |#include "types.h"
                            13252 
                            13254 
                            13255 ; 1    |////////////////////////////////////////////////////////////////////////////////
                            13256 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                            13257 ; 3    |//
                            13258 ; 4    |// Filename: types.h
                            13259 ; 5    |// Description: Standard data types
                            13260 ; 6    |////////////////////////////////////////////////////////////////////////////////
                            13261 ; 7    |
                            13262 ; 8    |#ifndef _TYPES_H
                            13263 ; 9    |#define _TYPES_H
                            13264 ; 10   |
                            13265 ; 11   |// TODO:  move this outta here!
                            13266 ; 12   |#if !defined(NOERROR)
                            13267 ; 13   |#define NOERROR 0
                            13268 ; 14   |#define SUCCESS 0
                            13269 ; 15   |#endif 
                            13270 ; 16   |#if !defined(SUCCESS)
                            13271 ; 17   |#define SUCCESS  0
                            13272 ; 18   |#endif
                            13273 ; 19   |#if !defined(ERROR)
                            13274 ; 20   |#define ERROR   -1
                            13275 ; 21   |#endif
                            13276 ; 22   |#if !defined(FALSE)
                            13277 ; 23   |#define FALSE 0
                            13278 ; 24   |#endif
                            13279 ; 25   |#if !defined(TRUE)
                            13280 ; 26   |#define TRUE  1
                            13281 ; 27   |#endif
                            13282 ; 28   |
                            13283 ; 29   |#if !defined(NULL)
                            13284 ; 30   |#define NULL 0
                            13285 ; 31   |#endif
                            13286 ; 32   |
                            13287 ; 33   |#define MAX_INT     0x7FFFFF
                            13288 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                            13289 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                            13290 ; 36   |#define MAX_ULONG   (-1) 
                            13291 ; 37   |
                            13292 ; 38   |#define WORD_SIZE   24              // word size in bits
                            13293 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                            13294 ; 40   |
                            13295 ; 41   |
                            13296 ; 42   |#define BYTE    unsigned char       // btVarName
                            13297 ; 43   |#define CHAR    signed char         // cVarName
                            13298 ; 44   |#define USHORT  unsigned short      // usVarName
                            13299 ; 45   |#define SHORT   unsigned short      // sVarName
                            13300 ; 46   |#define WORD    unsigned int        // wVarName
                            13301 ; 47   |#define INT     signed int          // iVarName
                            13302 ; 48   |#define DWORD   unsigned long       // dwVarName
                            13303 ; 49   |#define LONG    signed long         // lVarName
                            13304 ; 50   |#define BOOL    unsigned int        // bVarName
                            13305 ; 51   |#define FRACT   _fract              // frVarName
                            13306 ; 52   |#define LFRACT  long _fract         // lfrVarName
                            13307 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                            13308 ; 54   |#define FLOAT   float               // fVarName
                            13309 ; 55   |#define DBL     double              // dVarName
                            13310 ; 56   |#define ENUM    enum                // eVarName
                            13311 ; 57   |#define CMX     _complex            // cmxVarName
                            13312 ; 58   |typedef WORD UCS3;                   // 
                            13313 ; 59   |
                            13314 ; 60   |#define UINT16  unsigned short
                            13315 ; 61   |#define UINT8   unsigned char   
                            13316 ; 62   |#define UINT32  unsigned long
                            13317 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            13318 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            13319 ; 65   |#define WCHAR   UINT16
                            13320 ; 66   |
                            13321 ; 67   |//UINT128 is 16 bytes or 6 words
                            13322 ; 68   |typedef struct UINT128_3500 {   
                            13323 ; 69   |    int val[6];     
                            13324 ; 70   |} UINT128_3500;
                            13325 ; 71   |
                            13326 ; 72   |#define UINT128   UINT128_3500
                            13327 ; 73   |
                            13328 ; 74   |// Little endian word packed byte strings:   
                            13329 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            13330 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            13331 ; 77   |// Little endian word packed byte strings:   
                            13332 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            13333 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            13334 ; 80   |
                            13335 ; 81   |// Declare Memory Spaces To Use When Coding
                            13336 ; 82   |// A. Sector Buffers
                            13337 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                            13338 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                            13339 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                            13340 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                            13341 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                            13342 ; 88   |// B. Media DDI Memory
                            13343 ; 89   |#define MEDIA_DDI_MEM _Y
                            13344 ; 90   |
                            13345 ; 91   |
                            13346 ; 92   |
                            13347 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                            13348 ; 94   |// Examples of circular pointers:
                            13349 ; 95   |//    INT CIRC cpiVarName
                            13350 ; 96   |//    DWORD CIRC cpdwVarName
                            13351 ; 97   |
                            13352 ; 98   |#define RETCODE INT                 // rcVarName
                            13353 ; 99   |
                            13354 ; 100  |// generic bitfield structure
                            13355 ; 101  |struct Bitfield {
                            13356 ; 102  |    unsigned int B0  :1;
                            13357 ; 103  |    unsigned int B1  :1;
                            13358 ; 104  |    unsigned int B2  :1;
                            13359 ; 105  |    unsigned int B3  :1;
                            13360 ; 106  |    unsigned int B4  :1;
                            13361 ; 107  |    unsigned int B5  :1;
                            13362 ; 108  |    unsigned int B6  :1;
                            13363 ; 109  |    unsigned int B7  :1;
                            13364 ; 110  |    unsigned int B8  :1;
                            13365 ; 111  |    unsigned int B9  :1;
                            13366 ; 112  |    unsigned int B10 :1;
                            13367 ; 113  |    unsigned int B11 :1;
                            13368 ; 114  |    unsigned int B12 :1;
                            13369 ; 115  |    unsigned int B13 :1;
                            13370 ; 116  |    unsigned int B14 :1;
                            13371 ; 117  |    unsigned int B15 :1;
                            13372 ; 118  |    unsigned int B16 :1;
                            13373 ; 119  |    unsigned int B17 :1;
                            13374 ; 120  |    unsigned int B18 :1;
                            13375 ; 121  |    unsigned int B19 :1;
                            13376 ; 122  |    unsigned int B20 :1;
                            13377 ; 123  |    unsigned int B21 :1;
                            13378 ; 124  |    unsigned int B22 :1;
                            13379 ; 125  |    unsigned int B23 :1;
                            13380 ; 126  |};
                            13381 ; 127  |
                            13382 ; 128  |union BitInt {
                            13383 ; 129  |        struct Bitfield B;
                            13384 ; 130  |        int        I;
                            13385 ; 131  |};
                            13386 ; 132  |
                            13387 ; 133  |#define MAX_MSG_LENGTH 10
                            13388 ; 134  |struct CMessage
                            13389 ; 135  |{
                            13390 ; 136  |        unsigned int m_uLength;
                            13391 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                            13392 ; 138  |};
                            13393 ; 139  |
                            13394 ; 140  |typedef struct {
                            13395 ; 141  |    WORD m_wLength;
                            13396 ; 142  |    WORD m_wMessage;
                            13397 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                            13398 ; 144  |} Message;
                            13399 ; 145  |
                            13400 ; 146  |struct MessageQueueDescriptor
                            13401 ; 147  |{
                            13402 ; 148  |        int *m_pBase;
                            13403 ; 149  |        int m_iModulo;
                            13404 ; 150  |        int m_iSize;
                            13405 ; 151  |        int *m_pHead;
                            13406 ; 152  |        int *m_pTail;
                            13407 ; 153  |};
                            13408 ; 154  |
                            13409 ; 155  |struct ModuleEntry
                            13410 ; 156  |{
                            13411 ; 157  |    int m_iSignaledEventMask;
                            13412 ; 158  |    int m_iWaitEventMask;
                            13413 ; 159  |    int m_iResourceOfCode;
                            13414 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                            13415 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                            13416 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                            13417 ; 163  |    int m_uTimeOutHigh;
                            13418 ; 164  |    int m_uTimeOutLow;
                            13419 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                            13420 ; 166  |};
                            13421 ; 167  |
                            13422 ; 168  |union WaitMask{
                            13423 ; 169  |    struct B{
                            13424 ; 170  |        unsigned int m_bNone     :1;
                            13425 ; 171  |        unsigned int m_bMessage  :1;
                            13426 ; 172  |        unsigned int m_bTimer    :1;
                            13427 ; 173  |        unsigned int m_bButton   :1;
                            13428 ; 174  |    } B;
                            13429 ; 175  |    int I;
                            13430 ; 176  |} ;
                            13431 ; 177  |
                            13432 ; 178  |
                            13433 ; 179  |struct Button {
                            13434 ; 180  |        WORD wButtonEvent;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  54

M:ADDR CODE           CYCLES LINE SOURCELINE
                            13435 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                            13436 ; 182  |};
                            13437 ; 183  |
                            13438 ; 184  |struct Message {
                            13439 ; 185  |        WORD wMsgLength;
                            13440 ; 186  |        WORD wMsgCommand;
                            13441 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                            13442 ; 188  |};
                            13443 ; 189  |
                            13444 ; 190  |union EventTypes {
                            13445 ; 191  |        struct CMessage msg;
                            13446 ; 192  |        struct Button Button ;
                            13447 ; 193  |        struct Message Message;
                            13448 ; 194  |};
                            13449 ; 195  |
                            13450 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                            13451 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                            13452 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                            13453 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                            13454 ; 200  |
                            13455 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                            13456 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                            13457 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                            13458 ; 204  |
                            13459 ; 205  |#if DEBUG
                            13460 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                            13461 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                            13462 ; 208  |#else 
                            13463 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                            13464 ; 210  |#define DebugBuildAssert(x)    
                            13465 ; 211  |#endif
                            13466 ; 212  |
                            13467 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                            13468 ; 214  |//  #pragma asm
                            13469 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                            13470 ; 216  |//  #pragma endasm
                            13471 ; 217  |
                            13472 ; 218  |
                            13473 ; 219  |#ifdef COLOR_262K
                            13474 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                            13475 ; 221  |#elif defined(COLOR_65K)
                            13476 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                            13477 ; 223  |#else
                            13478 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                            13479 ; 225  |#endif
                            13480 ; 226  |    
                            13481 ; 227  |#endif // #ifndef _TYPES_H
                            13482 
                            13484 
                            13485 ; 12   |
                            13486 ; 13   |
                            13487 ; 14   |// File attributes
                            13488 ; 15   |#ifndef _FS_ATTRIBUTES
                            13489 ; 16   |#define _FS_ATTRIBUTES
                            13490 ; 17   |#define READ        1
                            13491 ; 18   |#define WRITE       2
                            13492 ; 19   |#define WRITE_PLUS  3
                            13493 ; 20   |#define APPEND      4
                            13494 ; 21   |#define TRUNCATE    8
                            13495 ; 22   |#define CREATE      16
                            13496 ; 23   |#endif
                            13497 ; 24   |
                            13498 ; 25   |//#ifndef FAT12
                            13499 ; 26   |//#define FAT12   1
                            13500 ; 27   |//#endif
                            13501 ; 28   |//
                            13502 ; 29   |#ifndef FAT16
                            13503 ; 30   |#define FAT16   2
                            13504 ; 31   |#endif
                            13505 ; 32   |
                            13506 ; 33   |#define MEM_SPACE_P 0x100000
                            13507 ; 34   |#define MEM_SPACE_Y 0x400000
                            13508 ; 35   |#define MEM_SPACE_X 0x800000
                            13509 ; 36   |
                            13510 ; 37   |#define FILE_SYS_MODE_READ  0
                            13511 ; 38   |#define FILE_SYS_MODE_WRITE 1
                            13512 ; 39   | 
                            13513 ; 40   |#define ATTR_READ_ONLY      0x01
                            13514 ; 41   |#define ATTR_HIDDEN         0x02
                            13515 ; 42   |#define ATTR_SYSTEM         0x04
                            13516 ; 43   |#define ATTR_VOLUME_ID      0x08
                            13517 ; 44   |#define ATTR_DIRECTORY      0x10
                            13518 ; 45   |#define ATTR_ARCHIVE        0x20
                            13519 ; 46   |#define ATTR_LONG_NAME      ATTR_READ_ONLY|ATTR_HIDDEN|ATTR_SYSTEM|ATTR_VOLUME_ID
                            13520 ; 47   |
                            13521 ; 48   |#define SEEK_SET           -1
                            13522 ; 49   |#define SEEK_CUR            0
                            13523 ; 50   |#define SEEK_END            1
                            13524 ; 51   |
                            13525 ; 52   |#define DEVICE_INSTALLED              (WORD)(0)
                            13526 ; 53   |#define DEVICE_NOT_FOUND              (WORD)(2)
                            13527 ; 54   |#define INVALID_FILESYSTEM                        (WORD)(3)
                            13528 ; 55   |#define DEVICE_INVALID                (WORD)(-1)
                            13529 ; 56   |#define DEVICE_ERROR_WRITE_PROTECTED  (WORD)(-2)
                            13530 ; 57   |
                            13531 ; 58   |#define MEDIA_SIZE_TOTAL_SECTORS    0
                            13532 ; 59   |#define MEDIA_SIZE_TOTAL_BYTES      1
                            13533 ; 60   |#define MEDIA_SIZE_BYTES_PER_SECTOR 2
                            13534 ; 61   |#define MEDIA_SIZE_IN_MEGABYTES     3     
                            13535 ; 62   |
                            13536 ; 63   |#define READ_TYPE_NORMAL            0
                            13537 ; 64   |#define READ_TYPE_FAT               1
                            13538 ; 65   |#define READ_TYPE_RAW               2
                            13539 ; 66   |
                            13540 ; 67   |
                            13541 ; 68   |#ifdef MEDIA_DDI_PARTIAL_SEQ_ENABLE
                            13542 ; 69   |    #define WRITE_TYPE_RANDOM                   0
                            13543 ; 70   |    #define WRITE_TYPE_SEQ_FIRST                1
                            13544 ; 71   |    #define WRITE_TYPE_SEQ_NEXT                 2
                            13545 ; 72   |    #define WRITE_TYPE_RESET_CLEAN_UP           3
                            13546 ; 73   |    #define WRITE_TYPE_PARTIAL_SEQ_FIRST        4
                            13547 ; 74   |    #define WRITE_TYPE_PARTIAL_SEQ_NEXT         5
                            13548 ; 75   |    #define WRITE_TYPE_PARTIAL_SEQ_LAST         6
                            13549 ; 76   |    #ifdef MEDIA_DDI_RAW_SECTOR_SERVER_ENABLE
                            13550 ; 77   |        #define WRITE_TYPE_RANDOM_RAW               7
                            13551 ; 78   |        #define WRITE_TYPE_SEQ_FIRST_RAW            8
                            13552 ; 79   |        #define WRITE_TYPE_SEQ_NEXT_RAW             9
                            13553 ; 80   |        #define WRITE_TYPE_PARTIAL_SEQ_FIRST_RAW    10
                            13554 ; 81   |        #define WRITE_TYPE_PARTIAL_SEQ_NEXT_RAW     11
                            13555 ; 82   |        #define WRITE_TYPE_PARTIAL_SEQ_LAST_RAW     12
                            13556 ; 83   |    #endif
                            13557 ; 84   |#else
                            13558 ; 85   |    #define WRITE_TYPE_RANDOM                   0
                            13559 ; 86   |    #define WRITE_TYPE_SEQ_FIRST                1
                            13560 ; 87   |    #define WRITE_TYPE_SEQ_NEXT                 2
                            13561 ; 88   |    #ifdef MEDIA_DDI_RAW_SECTOR_SERVER_ENABLE
                            13562 ; 89   |        #define WRITE_TYPE_RANDOM_RAW               3
                            13563 ; 90   |        #define WRITE_TYPE_SEQ_FIRST_RAW            4
                            13564 ; 91   |        #define WRITE_TYPE_SEQ_NEXT_RAW             5
                            13565 ; 92   |    #endif
                            13566 ; 93   |#endif
                            13567 ; 94   |    #define WRITE_TYPE_UNDEFINED 0xFFFFFF
                            13568 ; 95   |
                            13569 ; 96   |
                            13570 ; 97   |#ifndef MAX_FILENAME_LENGTH
                            13571 ; 98   |#define MAX_FILENAME_LENGTH 256
                            13572 ; 99   |#endif
                            13573 ; 100  |
                            13574 ; 101  |typedef struct {
                            13575 ; 102  |    WORD wNumberOfZones;
                            13576 ; 103  |    WORD wSizeInMegaBytes;
                            13577 ; 104  |} SMARTMEDIA_CHIP_INFO;
                            13578 ; 105  |
                            13579 ; 106  |typedef struct {
                            13580 ; 107  |    WORD wBootIdentification;
                            13581 ; 108  |    WORD wStartHeadNumber;
                            13582 ; 109  |    WORD wStartSectorNumber;
                            13583 ; 110  |    WORD wStartCylinderNumber;
                            13584 ; 111  |    WORD wSystemIdentification;
                            13585 ; 112  |    WORD wEndHeadNumber;
                            13586 ; 113  |    WORD wEndSectorNumber;
                            13587 ; 114  |    WORD wEndCylinderNumber;
                            13588 ; 115  |    WORD wStartLogicalSectorNumberHigh;
                            13589 ; 116  |    WORD wStartLogicalSectorNumberLow;
                            13590 ; 117  |    WORD wPartitionSizeHigh;
                            13591 ; 118  |    WORD wPartitionSizeLow;
                            13592 ; 119  |} SMARTMEDIA_PARTITION_TABLE;
                            13593 ; 120  |
                            13594 ; 121  |typedef struct {
                            13595 ; 122  |    WORD wWord0;
                            13596 ; 123  |    WORD wWord1;
                            13597 ; 124  |    WORD wWord2;
                            13598 ; 125  |} SMARTMEDIA_CIS_IDI_MANUFACTURER_NAME;
                            13599 ; 126  |
                            13600 ; 127  |typedef struct {
                            13601 ; 128  |    WORD wWord0;
                            13602 ; 129  |    WORD wWord1;
                            13603 ; 130  |} SMARTMEDIA_CIS_IDI_PRODUCT_NAME;
                            13604 ; 131  |
                            13605 ; 132  |typedef struct {
                            13606 ; 133  |    WORD wWord0;
                            13607 ; 134  |    WORD wWord1;
                            13608 ; 135  |} SMARTMEDIA_CIS_IDI_PRODUCT_VERSION;
                            13609 ; 136  |
                            13610 ; 137  |typedef struct {
                            13611 ; 138  |    WORD wWord0;
                            13612 ; 139  |    WORD wWord1;
                            13613 ; 140  |    WORD wWord2;
                            13614 ; 141  |    WORD wWord3;
                            13615 ; 142  |} SMARTMEDIA_CIS_IDI_SERIAL_NUMBER;
                            13616 ; 143  |
                            13617 ; 144  |typedef struct {
                            13618 ; 145  |    WORD wWord0;
                            13619 ; 146  |} SMARTMEDIA_CIS_IDI_MODEL_NUMBER;
                            13620 
                            13643 
                            13644 ; 147  |
                            13645 ; 148  |typedef struct {
                            13646 ; 149  |    SMARTMEDIA_CIS_IDI_MANUFACTURER_NAME ManufacturerName;
                            13647 ; 150  |    SMARTMEDIA_CIS_IDI_PRODUCT_NAME ProductName;
                            13648 ; 151  |    SMARTMEDIA_CIS_IDI_PRODUCT_VERSION ProductVersion;
                            13649 ; 152  |    SMARTMEDIA_CIS_IDI_SERIAL_NUMBER SerialNumber;
                            13650 ; 153  |    SMARTMEDIA_CIS_IDI_MODEL_NUMBER ModelNumber;
                            13651 ; 154  |} SMARTMEDIA_CIS_IDI_TABLE;
                            13652 
                            13674 
                            13675 ; 155  |   
                            13676 ; 156  |typedef struct {
                            13677 ; 157  |    WORD wPageSizeInBytes;
                            13678 ; 158  |    WORD wRedundantAreaSizeInBytes;
                            13679 ; 159  |    WORD wNumberOfPagesPerBlock;
                            13680 ; 160  |    WORD wNumberOfBlocksPerZone;
                            13681 ; 161  |    WORD wNumberOfZonesInMedia;
                            13682 ; 162  |    WORD wMediaSizeInMBytes;
                            13683 ; 163  |    SMARTMEDIA_PARTITION_TABLE * pPartitionTable;
                            13684 ; 164  |    SMARTMEDIA_CIS_IDI_TABLE * pCisIdiTable;
                            13685 ; 165  |    WORD wMediaFlagStatus;
                            13686 ; 166  |    WORD wNumberOfBlocksToTheCisIdiBlock;
                            13687 ; 167  |    WORD wTotalNumberOfPhysicalBlocks;
                            13688 ; 168  |    WORD wNumberOfSystemBlocks;
                            13689 ; 169  |} SMARTMEDIA_ENTRY_TABLE;
                            13690 ; 170  |
                            13691 ; 171  |typedef struct {
                            13692 ; 172  |    WORD wDevice;        
                            13693 ; 173  |    WORD wDirtyBlockFlag;
                            13694 ; 174  |    WORD wCleanTailFlag; 
                            13695 ; 175  |    WORD wLogDOSPage;    
                            13696 ; 176  |    WORD wSrcLogBlock;   
                            13697 ; 177  |    WORD wSrcPhyBlock;   
                            13698 ; 178  |    WORD wDestPhyBlock;  
                            13699 ; 179  |    WORD wStartSrcPage;  
                            13700 ; 180  |    WORD wStartDestPage; 
                            13701 ; 181  |    WORD wPagesToCopy;   
                            13702 ; 182  |    WORD wReplaceBuff;   
                            13703 ; 183  |    WORD wReplaceRdnt;
                            13704 ; 184  |    #ifdef MEDIA_DDI_PARTIAL_SEQ_ENABLE
                            13705 ; 185  |        WORD wFirstCount;
                            13706 ; 186  |        WORD wNextCount;
                            13707 ; 187  |        WORD wLastCount;
                            13708 ; 188  |    #endif
                            13709 ; 189  |} SMARTMEDIA_FWPPS_TABLE;
                            13710 ; 190  |
                            13711 ; 191  |typedef struct {
                            13712 ; 192  |    WORD wWord0;
                            13713 ; 193  |    WORD wWord1;
                            13714 ; 194  |    WORD wWord2;
                            13715 ; 195  |    WORD wWord3;
                            13716 ; 196  |} DIRECTORY_NAME;
                            13717 ; 197  |
                            13718 ; 198  |typedef struct {
                            13719 ; 199  |    WORD wWord0;
                            13720 ; 200  |    WORD wWord1;
                            13721 ; 201  |} DIRECTORY_EXTENSION;
                            13722 ; 202  |
                            13723 ; 203  |typedef struct {
                            13724 ; 204  |    WORD wWord0;
                            13725 ; 205  |    WORD wWord1;
                            13726 ; 206  |} DIRECTORY_SIZE;
                            13727 
                            13742 
                            13743 ; 207  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  55

M:ADDR CODE           CYCLES LINE SOURCELINE
                            13744 ; 208  |typedef struct {
                            13745 ; 209  |    DIRECTORY_NAME Name;
                            13746 ; 210  |    DIRECTORY_EXTENSION Extension;
                            13747 ; 211  |    WORD wAttribute;
                            13748 ; 212  |    WORD wReserved[4];
                            13749 ; 213  |    WORD wCreationTime;
                            13750 ; 214  |    WORD wCreationData;
                            13751 ; 215  |    WORD wFirstCluster;
                            13752 ; 216  |    DIRECTORY_SIZE Size;
                            13753 ; 217  |    WORD wCurrentCluster;
                            13754 ; 218  |    WORD wPointer;
                            13755 ; 219  |    WORD wRecord;
                            13756 ; 220  |    WORD wRd;
                            13757 ; 221  |} DIRECTORY_FILE_CONTROL_BLOCK;
                            13758 ; 222  |
                            13759 ; 223  |// TODO:  clean this up.  There are two versions.
                            13760 ; 224  |struct FCB
                            13761 ; 225  |{
                            13762 ; 226  |    _packed BYTE m_szFileName[9];       //0-2
                            13763 ; 227  |    int     m_wReserved;                //3
                            13764 ; 228  |    _packed BYTE m_szExt[4];            //4-5
                            13765 ; 229  |    int     m_wAttributes;              //6
                            13766 ; 230  |    int     m_wReserved2[4];            //7,8,9,a
                            13767 ; 231  |    int     m_wTimeofCreation;          //b
                            13768 ; 232  |    int     m_wDateofCreation;          //c
                            13769 ; 233  |    int     m_wFirstCluster;            //d
                            13770 ; 234  |    int     m_wFileSizeHigh;            //e
                            13771 ; 235  |    int     m_wFileSizeLow;             //f
                            13772 ; 236  |};
                            13773 
                            13789 
                            13790 ; 237  |
                            13791 ; 238  |
                            13792 ; 239  |typedef struct {
                            13793 ; 240  |    WORD wFirstClusterCurrentDirectory;
                            13794 ; 241  |    WORD wFirstClusterParentDirectory;
                            13795 ; 242  |    WORD wAbsSectorCurrentlyCached;
                            13796 ; 243  |    WORD wCurrentRelativeSector;
                            13797 ; 244  |    WORD wNumberOfSectors;
                            13798 ; 245  |    WORD wCurrentRecordLoadedInDcb;
                            13799 ; 246  |    WORD wBufferedRecord;
                            13800 ; 247  |    WORD wMaxNumberRecordsCurrentDirectory;
                            13801 ; 248  |    WORD * pwPointerToBuffer;
                            13802 ; 249  |    WORD * pwPointerToPath;
                            13803 ; 250  |    DIRECTORY_FILE_CONTROL_BLOCK * pDirFcb;
                            13804 ; 251  |} DIRECTORY_CONTROL_BLOCK;
                            13805 ; 252  |
                            13806 ; 253  |typedef struct {
                            13807 ; 254  |    WORD wWord0;
                            13808 ; 255  |    WORD wWord1;
                            13809 ; 256  |    WORD wWord2;
                            13810 ; 257  |    WORD wWord3;
                            13811 ; 258  |} FILE_NAME;
                            13812 ; 259  |
                            13813 ; 260  |typedef struct {
                            13814 ; 261  |    WORD wWord0;
                            13815 ; 262  |    WORD wWord1;
                            13816 ; 263  |} FILE_EXTENSION;
                            13817 ; 264  |
                            13818 ; 265  |typedef struct {
                            13819 ; 266  |    WORD wWord0;
                            13820 ; 267  |    WORD wWord1;
                            13821 ; 268  |} FILE_SIZE;
                            13822 ; 269  |
                            13823 ; 270  |typedef union {
                            13824 ; 271  |    struct {
                            13825 ; 272  |        int Read        :1;
                            13826 ; 273  |        int Write       :1;
                            13827 ; 274  |        int Append      :1;
                            13828 ; 275  |        int Truncate    :1;
                            13829 ; 276  |        int Create      :1;
                            13830 ; 277  |        int Rsrv        :3;
                            13831 ; 278  |        int Mode        :8;
                            13832 ; 279  |        int Device      :8;
                            13833 ; 280  |    } B;
                            13834 ; 281  |    int I;
                            13835 ; 282  |} FILE_FLAGS;
                            13836 ; 283  |
                            13837 ; 284  |typedef struct {
                            13838 ; 285  |    WORD wWord0;
                            13839 ; 286  |    WORD wWord1;
                            13840 ; 287  |} FILE_BYTE_CURRENT;
                            13841 
                            13881 
                            13882 ; 288  |
                            13883 ; 289  |typedef struct {
                            13884 ; 290  |    FILE_NAME Name;
                            13885 ; 291  |    FILE_EXTENSION Extension;
                            13886 ; 292  |    WORD wAttributes;
                            13887 ; 293  |    WORD wReserved[4];
                            13888 ; 294  |    WORD wCreationTime;
                            13889 ; 295  |    WORD wCreationData;
                            13890 ; 296  |    WORD wFirstCluster;
                            13891 ; 297  |    FILE_SIZE Size;
                            13892 ; 298  |    WORD wCurrentCluster;
                            13893 ; 299  |    WORD wPointer;
                            13894 ; 300  |    WORD wRecord;
                            13895 ; 301  |    WORD wRd;
                            13896 ; 302  |    FILE_FLAGS Flags;
                            13897 ; 303  |    FILE_BYTE_CURRENT FcbByteCurrent;
                            13898 ; 304  |    WORD wFcbFlagEndOfCx;
                            13899 ; 305  |} FILE_CONTROL_BLOCK;    
                            13900 ; 306  |
                            13901 ; 307  |typedef struct {
                            13902 ; 308  |    WORD wWord0;
                            13903 ; 309  |    WORD wWord1;
                            13904 ; 310  |    WORD wWord2;
                            13905 ; 311  |    WORD wWord3;
                            13906 ; 312  |} VOLUME_LABEL;
                            13907 ; 313  |
                            13908 ; 314  |typedef struct {
                            13909 ; 315  |    WORD wFATPhysicalBlock1;
                            13910 ; 316  |    WORD wFATPhysicalBlock2;
                            13911 ; 317  |    WORD wFATPhysicalBlock3;
                            13912 ; 318  |    WORD wFATPhysicalBlock4;
                            13913 ; 319  |} FAT_PHYSICAL_BLOCK_LIST;
                            13914 
                            13921 
                            13922 ; 320  |
                            13923 ; 321  |typedef struct {
                            13924 ; 322  |    WORD wFATSectorInCache;
                            13925 ; 323  |    WORD wLastClusterFree;
                            13926 ; 324  |    WORD wNumberOfUsedClusters;
                            13927 ; 325  |    WORD wNumberOfFreeClusters;
                            13928 ; 326  |    WORD wNumberOfBadClusters;
                            13929 ; 327  |    WORD wNumberOfReservedClusters;
                            13930 ; 328  |    WORD wControl;
                            13931 ; 329  |    WORD * pwSectorCache;
                            13932 ; 330  |    FAT_PHYSICAL_BLOCK_LIST FATPhysicalLocationList;
                            13933 ; 331  |} FAT_TABLE;
                            13934 
                            13941 
                            13942 ; 332  |
                            13943 ; 333  |typedef struct {
                            13944 ; 334  |    WORD wStateMediaTable;
                            13945 ; 335  |    WORD wTypeFs;
                            13946 ; 336  |    WORD wBytesPerSector;
                            13947 ; 337  |    WORD wSectorsPerCluster;
                            13948 ; 338  |    WORD wNumberOfReservedSectors;
                            13949 ; 339  |    WORD wMaximumNumberOfFATs;
                            13950 ; 340  |    WORD wMaxRootDirectoryEntries;
                            13951 ; 341  |    WORD wTotalSectors;
                            13952 ; 342  |    WORD wNumberOfFATSectors;
                            13953 ; 343  |    WORD wNumberOfSectorsPerTrack;
                            13954 ; 344  |    WORD wNumberOfHeads;
                            13955 ; 345  |    WORD wNumberOfHiddenSectorsMSB;
                            13956 ; 346  |    WORD wNumberOfHiddenSectorsLSB;
                            13957 ; 347  |    WORD wTotalSectors32MSB;
                            13958 ; 348  |    WORD wTotalSectors32LSB;
                            13959 ; 349  |    WORD wDriverNumber;
                            13960 ; 350  |    WORD wExtendedBootSignature;
                            13961 ; 351  |    WORD wVolumeIDMSB;
                            13962 ; 352  |    WORD wVolumeIDLSB;
                            13963 ; 353  |    VOLUME_LABEL VolumeLabel;
                            13964 ; 354  |    WORD * pwWriteBuffer;
                            13965 ; 355  |    WORD wPrimaryFATRelativeSector;
                            13966 ; 356  |    WORD wSecondaryFATRelativeSector;
                            13967 ; 357  |    WORD wRootDirectoryRelativeSector;
                            13968 ; 358  |    WORD wFirstSectorNumberDataZone;
                            13969 ; 359  |    WORD wMaxNumberOfFATEntries;
                            13970 ; 360  |    WORD wRootDirectorySizeInSectors;
                            13971 ; 361  |    WORD wDataAreaSizeInSectors;
                            13972 ; 362  |} MEDIA_TABLE;
                            13973 
                            14032 
                            14033 ; 363  |
                            14034 ; 364  |typedef struct {
                            14035 ; 365  |    MEDIA_TABLE * pMediaTable;
                            14036 ; 366  |    DIRECTORY_CONTROL_BLOCK * pDirectoryControlBlock;
                            14037 ; 367  |    FAT_TABLE * pFATTable;
                            14038 ; 368  |} DEVICE_CONTROL_TABLE;
                            14039 ; 369  |    
                            14040 ; 370  |typedef struct {
                            14041 ; 371  |    WORD dwTotalSizeInMegaBytes;        // dwTotalSizeInMegaBytes is limited
                            14042 ; 372  |                                        //  to 2-bytes for compatibility with
                            14043 ; 373  |                                        //  older host drivers.
                            14044 ; 374  |    DWORD dwTotalNumberOfSectors;
                            14045 ; 375  |    DWORD dwTotalNumberOfBytes;
                            14046 ; 376  |    WORD wSectorSizeInBytes;
                            14047 ; 377  |} MEDIA_SIZE;
                            14048 ; 378  |
                            14049 ; 379  |typedef struct {
                            14050 ; 380  |    BOOL    bInstalled;
                            14051 ; 381  |    INT     iPbsSectorOffset;   // from the beginning of the data drive 
                            14052 ; 382  |    DWORD   dwSize;
                            14053 ; 383  |} DATA_DRIVE_PBS_LOC;
                            14054 ; 384  |extern  INT _reentrant FSFileOpen(_packed BYTE *fname,INT attribute, INT DeviceNumber);
                            14055 ; 385  |extern  INT _reentrant FSFastOpen(DWORD Key, INT attribute);
                            14056 ; 386  |extern  INT FSFileDelete(_packed BYTE *fname,INT DeviceNumber);
                            14057 ; 387  |extern  INT FSFileCreate(_packed BYTE *fname,INT DeviceNumber);
                            14058 ; 388  |extern  INT _reentrant FSChangeDir(_packed BYTE *dirname,INT DeviceNumber);
                            14059 ; 389  |extern  INT _reentrant FSCreateDir(_packed BYTE *dirname,INT DeviceNumber);
                            14060 ; 390  |extern  INT _reentrant FSDeleteDir(_packed BYTE *dirname,INT DeviceNumber);
                            14061 ; 391  |extern  INT _reentrant FSFileAppend(_packed BYTE *fname,INT DeviceNumber);
                            14062 ; 392  |extern  INT _reentrant FSFileRead(INT BytestoRead, INT Handle, INT memory_type, INT modulo, WORD *buffer);
                            14063 ; 393  |extern  INT _reentrant FSFileWrite(INT wNumberBytes, INT Handle, INT memory_type, INT iModulo, WORD *buffer);
                            14064 ; 394  |extern  INT _reentrant FSFileClose(INT Handle);
                            14065 ; 395  |extern  LONG _reentrant FSFileSize(INT HandleNumber);
                            14066 ; 396  |extern  LONG  FSSize(INT DeviceNum, INT TYPE);   
                            14067 ; 397  |extern  INT FSFreeClusters(INT Device);
                            14068 ; 398  |extern  INT BytesPerCluster(INT Device);
                            14069 ; 399  |
                            14070 ; 400  |
                            14071 ; 401  |
                            14072 ; 402  |//extern  INT FSFileCreate(_packed BYTE *pbFileName, BYTE bDevice);
                            14073 ; 403  |//extern  INT FSFileDelete(_packed BYTE *pbFileName, BYTE bDevice);
                            14074 ; 404  |extern  INT FSFileRename(_packed BYTE *pbCurFilename, _packed BYTE *pbNewFilename, BYTE bDevice);
                            14075 ; 405  |//extern  INT _reentrant FSFileAttribute(_packed BYTE *pbFilename, WORD wAttributes, BYTE bDevice);
                            14076 ; 406  |//extern  INT FSFileAppend(_packed BYTE *pbFileName, BYTE bDevice);
                            14077 ; 407  |//extern  INT FSFileOpen(_packed BYTE *pbFileName, WORD wAttributes, BYTE bDevice);
                            14078 ; 408  |//extern  INT FSFileClose(INT bHandle);
                            14079 ; 409  |//extern  INT FSFileRead(WORD wNumberBytes, BYTE bHandle, WORD wMemSpace, INT iModulo, WORD *pwBuffer);
                            14080 ; 410  |//extern  INT FSFileWrite(WORD wNumberBytes, BYTE bHandle, WORD wMemSpace, INT iModulo, WORD *pwBuffer);
                            14081 ; 411  |extern  INT _reentrant fseek( INT handle , LONG offset, INT iOrigin );
                            14082 ; 412  |extern  INT _reentrant FSFileEof(INT Handle);
                            14083 ; 413  |extern INT _reentrant FSFileAttribute(INT Attributes, _packed BYTE *fname, INT DeviceNumber);
                            14084 ; 414  |extern INT _reentrant FSFileAttributeClear(INT Attributes, _packed BYTE *fname, INT DeviceNumber);
                            14085 ; 415  |//extern  LONG FSFileSize(INT bHandle);
                            14086 ; 416  |extern _asmfunc INT FSPresent(BYTE bDevice);
                            14087 ; 417  |extern _asmfunc INT FSType(BYTE bDevice);
                            14088 ; 418  |//extern LONG FSSize(WORD wDevice, WORD wReturnType);
                            14089 ; 419  |//extern INT FSChangeDir(_packed BYTE *pbDirName, BYTE bDevice);
                            14090 ; 420  |//extern INT FSCreateDir(_packed BYTE *pbDirName, BYTE bDevice);
                            14091 ; 421  |//extern INT FSDeleteDir(_packed BYTE *pbDirName, BYTE bDevice);
                            14092 ; 422  |extern _asmfunc void SysLoadFATWrite(void);
                            14093 ; 423  |extern _asmfunc INT SysUnLoadFATWrite(void);
                            14094 ; 424  |extern LONG _reentrant ftell(INT iHandle);
                            14095 ; 425  |extern _asmfunc struct FCB * ReadDirectory(int iDevice, int iEntry);
                            14096 ; 426  |
                            14097 ; 427  |#endif
                            14098 
                            14100 
                            14101 ; 12   |#include "metadata.h"
                            14102 
                            14104 
                            14105 ; 1    |////////////////////////////////////////////////////////////////////////////////
                            14106 ; 2    |// Copyright(C) SigmaTel, Inc. 2002
                            14107 ; 3    |//
                            14108 ; 4    |// Filename: metadata.h
                            14109 ; 5    |// Description:
                            14110 ; 6    |////////////////////////////////////////////////////////////////////////////////
                            14111 ; 7    |
                            14112 ; 8    |#ifndef _METADATA_H
                            14113 ; 9    |#define _METADATA_H
                            14114 ; 10   |
                            14115 ; 11   |///////////////////////////////////////////////////////////////////////////////
                            14116 ; 12   |// MetaData definitions
                            14117 ; 13   |///////////////////////////////////////////////////////////////////////////////
                            14118 ; 14   |
                            14119 ; 15   |//#define MMC_CMD59       0x40|59
                            14120 ; 16   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  56

M:ADDR CODE           CYCLES LINE SOURCELINE
                            14121 ; 17   |///////////////////////////////////////////////////////////////////////////////
                            14122 ; 18   |// Meta Data structure definitions
                            14123 ; 19   |///////////////////////////////////////////////////////////////////////////////
                            14124 ; 20   |
                            14125 ; 21   |///////////////////////////////////////////////////////////////////////////////
                            14126 ; 22   |// MetaData definitions
                            14127 ; 23   |
                            14128 ; 24   |#define META_DATA_FOUND                     (WORD)(0)
                            14129 ; 25   |#define META_DATA_NOT_FOUND                 (WORD)(0x100)
                            14130 ; 26   |#define META_DATA_FILE_NOT_SUPPORTED        (WORD)(0x101)
                            14131 ; 27   |#define META_DATA_FILEOPEN_ERROR            (WORD)(0x200)
                            14132 ; 28   |#define META_DATA_FILEREAD_ERROR            (WORD)(0x201)
                            14133 ; 29   |#define META_DATA_FILECLOSE_ERROR           (WORD)(0x202)
                            14134 ; 30   |#define META_DATA_FILESEEK_ERROR            (WORD)(0x203)
                            14135 ; 31   |#define META_DATA_FILEWRITE_ERROR           (WORD)(0x204)
                            14136 ; 32   |#define META_DATA_SUCCESS                               (WORD)(0x205)
                            14137 ; 33   |
                            14138 ; 34   |#define META_DATA_NOT_VBR_FORMAT            (WORD)(0x102)
                            14139 ; 35   |
                            14140 ; 36   |// VBR
                            14141 ; 37   |#define VBR_NOT_DETERMINED 0
                            14142 ; 38   |#define VBR_TRUE 1
                            14143 ; 39   |
                            14144 ; 40   |#ifndef TITLE_SIZE
                            14145 ; 41   |//#define TITLE_SIZE 30
                            14146 ; 42   |#ifndef USE_PLAYLIST3
                            14147 ; 43   |#define TITLE_SIZE 256          //was 30 but LFNs require up to 256!
                            14148 ; 44   |#else
                            14149 ; 45   |#define TITLE_SIZE 80           //was 256 but music library only store up to 129!
                            14150 ; 46   |#endif
                            14151 ; 47   |#endif
                            14152 ; 48   |
                            14153 ; 49   |#ifndef ARTIST_SIZE
                            14154 ; 50   |#ifndef USE_PLAYLIST3
                            14155 ; 51   |//#define ARTIST_SIZE 30
                            14156 ; 52   |#define ARTIST_SIZE 100         // increase artist size for use with ID3V2 tags (Stmp00003110)
                            14157 ; 53   |#else
                            14158 ; 54   |#define ARTIST_SIZE 48          // increase artist size for use with ID3V2 tags (Stmp00003110)
                            14159 ; 55   |#endif
                            14160 ; 56   |#endif
                            14161 ; 57   |
                            14162 ; 58   |#ifndef ALBUM_SIZE
                            14163 ; 59   |#ifndef USE_PLAYLIST3
                            14164 ; 60   |//#define ALBUM_SIZE 30
                            14165 ; 61   |#define ALBUM_SIZE 50           // increase album size (not as much) for use with ID3V2 tags (Stmp00003110)
                            14166 ; 62   |#else
                            14167 ; 63   |#define ALBUM_SIZE 48           // increase album size (not as much) for use with ID3V2 tags (Stmp00003110)
                            14168 ; 64   |#endif
                            14169 ; 65   |#endif
                            14170 ; 66   |
                            14171 ; 67   |#ifdef USE_PLAYLIST3
                            14172 ; 68   |#ifndef GENRE_SIZE
                            14173 ; 69   |#define GENRE_SIZE 20
                            14174 ; 70   |#endif
                            14175 ; 71   |
                            14176 ; 72   |#ifndef YEAR_SIZE
                            14177 ; 73   |#define YEAR_SIZE 8
                            14178 ; 74   |#endif
                            14179 ; 75   |
                            14180 ; 76   |#ifndef TRACKNUM_SIZE
                            14181 ; 77   |#define TRACKNUM_SIZE 5 // assume track number is smaller than 0xfff (12bit or 4095)
                            14182 ; 78   |#endif
                            14183 ; 79   |
                            14184 ; 80   |#define MAX_TRACK_NUMBER 0x000fff
                            14185 ; 81   |#define UNKNOWN_TRACK_NUMBER MAX_TRACK_NUMBER
                            14186 ; 82   |#endif
                            14187 ; 83   |
                            14188 ; 84   |#define XING_TOC_SIZE   100
                            14189 ; 85   |#if MTP_BUILD
                            14190 ; 86   |// This size is used to build table for FF/RW for vbr songs,
                            14191 ; 87   |// and as there is no such function in mtp mode, it is reduced to release y-memory.
                            14192 ; 88   |#define VBR_TOC_SIZE    2
                            14193 ; 89   |#else
                            14194 ; 90   |#define VBR_TOC_SIZE    200
                            14195 ; 91   |#endif
                            14196 ; 92   |
                            14197 ; 93   |extern UCS3 g_wSongTitle[TITLE_SIZE];
                            14198 ; 94   |extern UCS3 g_wSongArtist[ARTIST_SIZE];
                            14199 ; 95   |extern UCS3 g_wSongAlbum[ALBUM_SIZE];
                            14200 ; 96   |#ifdef USE_PLAYLIST3
                            14201 ; 97   |extern UCS3 g_wSongGenre[GENRE_SIZE];
                            14202 ; 98   |extern UCS3 g_wSongYear[YEAR_SIZE];
                            14203 ; 99   |extern WORD g_wSongTrackNum;
                            14204 ; 100  |#endif
                            14205 ; 101  |
                            14206 ; 102  |extern WORD g_wVBRTOCTable[VBR_TOC_SIZE];
                            14207 ; 103  |
                            14208 ; 104  |typedef struct {
                            14209 ; 105  |    WORD        iTitleBufferLength;
                            14210 ; 106  |        UCS3       *wTitle;        // Title of Song
                            14211 ; 107  |    WORD        iArtistBufferLength;
                            14212 ; 108  |    UCS3       *wArtist;
                            14213 ; 109  |    WORD        iAlbumBufferLength;
                            14214 ; 110  |    UCS3       *wAlbum;
                            14215 ; 111  |#ifdef USE_PLAYLIST3
                            14216 ; 112  |    WORD        iGenreBufferLength;
                            14217 ; 113  |    UCS3       *wGenre;
                            14218 ; 114  |    WORD        iYearBufferLength;
                            14219 ; 115  |    UCS3       *wYear;
                            14220 ; 116  |    WORD        wTrackNum;
                            14221 ; 117  |#endif
                            14222 ; 118  |    BYTE       btGenre;       // Genre of audio file -- if MP3, use the ID3v1 tag byte
                            14223 ; 119  |        WORD       wSampRate;     // Sample Rate of song (Hz)
                            14224 ; 120  |        WORD       wNumChannels;
                            14225 ; 121  |        WORD       wBitRate;      // Bitrate of song (for MP3 VBR, this will be first bitrate found)
                            14226 ; 122  |        LONG       iTime;                 // Length of song in seconds
                            14227 ; 123  |        DWORD      dwStartPos;    // Position where audio starts. (if required by the decoder)
                            14228 ; 124  |        DWORD      dwNumBytes;    // Total Bytes in audio part of song
                            14229 ; 125  |    DWORD      dwDataBytes;   // for wma; (total bytes - header bytes)
                            14230 ; 126  |        DWORD      dwNumFrames;   // See note below on frames
                            14231 ; 127  |        BOOL       bVBR;                  // 0 = CBR or does not apply , 1 = VBR (**see question below**)
                            14232 ; 128  |        INT                iFileType;     // 0 = unknown, 1 = MP3, 2 = WMA, 4 = AAC, 8 = IMA ADPCM, etc (use defines below)
                            14233 ; 129  |        INT                iResourceNum;  // Resource number of the decoder that needed for this file
                            14234 ; 130  |} FILE_META_DATA;
                            14235 ; 131  |
                            14236 ; 132  |// File Type Defines (use for iFileType) -- matches bit defines in sysequ.inc
                            14237 ; 133  |#define UNKNOWN_TYPE   0
                            14238 ; 134  |#define MP3_TYPE       1
                            14239 ; 135  |#define WMA_TYPE       2
                            14240 ; 136  |#define AAC_TYPE       4
                            14241 ; 137  |#define IMA_ADPCM_TYPE 8
                            14242 ; 138  |#define MS_ADPCM_TYPE  16
                            14243 ; 139  |#define PCM_WAV_TYPE   32
                            14244 ; 140  |#define ASF_TYPE       64
                            14245 ; 141  |#define AUDIBLE_ACELP_TYPE 128
                            14246 ; 142  |#define AUDIBLE_MP3_TYPE   256          // 9/28/04 mmiu
                            14247 ; 143  |
                            14248 ; 144  |#define SMV_ADPCM_TYPE 512
                            14249 ; 145  |
                            14250 ; 146  |
                            14251 ; 147  |//////SRS WOW DEFS/////////////////////////////////////////////////////////////
                            14252 ; 148  |// Sample rates
                            14253 ; 149  |#ifdef WOW
                            14254 ; 150  |#define SR_48KHZ        48000
                            14255 ; 151  |#define SR_44KHZ        44100
                            14256 ; 152  |#define SR_32KHZ        32000
                            14257 ; 153  |#define SR_24KHZ        24000
                            14258 ; 154  |#define SR_22KHZ        22050
                            14259 ; 155  |#define SR_16KHZ        16000
                            14260 ; 156  |#define SR_12KHZ        12000
                            14261 ; 157  |#define SR_11KHZ        11025
                            14262 ; 158  |#define SR_8KHZ          8000
                            14263 ; 159  |#endif
                            14264 ; 160  |
                            14265 ; 161  |
                            14266 ; 162  |///////////////////////////////////////////////////////////////////////////////
                            14267 ; 163  |// MetaData prototypes
                            14268 ; 164  |///////////////////////////////////////////////////////////////////////////////
                            14269 ; 165  |
                            14270 ; 166  |RETCODE _reentrant GetFileMetaData(INT PackedPathNameAddress, INT btCurrentDevice, FILE_META_DATA *MetaData);
                            14271 
                            14299 
                            14300 ; 167  |#ifdef USE_PLAYLIST3
                            14301 ; 168  |INT _reentrant GetRelativePath(int highlight_index, int browse_type, INT* PackedPathNameAddress);
                            14302 ; 169  |INT _reentrant RetrieveSongInfo(INT a, INT b, INT *p_path);
                            14303 ; 170  |#endif
                            14304 ; 171  |
                            14305 ; 172  |#endif // #ifndef _METADATA_H
                            14306 
                            14308 
                            14309 ; 13   |#include "mp3metadata.h"
                            14310 
                            14312 
                            14313 ; 1    |#ifndef __MP3METADATA_H
                            14314 ; 2    |#define __MP3METADATA_H
                            14315 ; 3    |///////////////////////////////////////////////////////////////////////////////
                            14316 ; 4    |// Copyright(C) SigmaTel, Inc. 2002
                            14317 ; 5    |//
                            14318 ; 6    |// Filename: mp3metadata.h
                            14319 ; 7    |// Description: Includes header data for mp3 meta-data functions.
                            14320 ; 8    |///////////////////////////////////////////////////////////////////////////////
                            14321 ; 9    |
                            14322 ; 10   |#define READ_BUFFER_SIZE 156
                            14323 ; 11   |#define XING_BYTES_TO_READ 156
                            14324 ; 12   |#define VBR_BYTES_TO_READ 400   // must be less than READ_BUFFER_SIZE * 3
                            14325 ; 13   |#define MP3_BYTES_TO_READ 128
                            14326 ; 14   |#define ID3_BYTES_TO_READ 128
                            14327 ; 15   |#define MP3_FRAME_HEADER_BYTES_TO_READ 4
                            14328 ; 16   |#define FRAME_HEADER_SIZE 4
                            14329 ; 17   |#define FRAME_HEADER_PACKED 11
                            14330 ; 18   |
                            14331 ; 19   |// *************** XING Header Equates ************************
                            14332 ; 20   |// A Xing header may be present in the ancillary
                            14333 ; 21   |// data field of the first frame of an mp3 bitstream
                            14334 ; 22   |// The Xing header (optionally) contains
                            14335 ; 23   |//      frames      total number of audio frames in the bitstream
                            14336 ; 24   |//      bytes       total number of bytes in the bitstream
                            14337 ; 25   |//      toc         table of contents
                            14338 ; 26   |
                            14339 ; 27   |// toc (table of contents) gives seek points
                            14340 ; 28   |// for random access
                            14341 ; 29   |// the ith entry determines the seek point for
                            14342 ; 30   |// i-percent duration
                            14343 ; 31   |// seek point in bytes = (toc[i]/256.0) * total_bitstream_bytes
                            14344 ; 32   |// e.g. half duration seek point = (toc[50]/256.0) * total_bitstream_bytes
                            14345 ; 33   |
                            14346 ; 34   |#define FRAMES_FLAG     0x0001
                            14347 ; 35   |#define BYTES_FLAG      0x0002
                            14348 ; 36   |#define TOC_FLAG        0x0004
                            14349 ; 37   |#define VBR_SCALE_FLAG  0x0008
                            14350 ; 38   |#define FRAMES_AND_BYTES (FRAMES_FLAG | BYTES_FLAG)
                            14351 ; 39   |
                            14352 ; 40   |// Frame MPEG Versions (matches MP3 frame format)
                            14353 ; 41   |#define MPEGv2pt5    0x00
                            14354 ; 42   |#define MPEGvERROR   0x01
                            14355 ; 43   |#define MPEGv2       0x02
                            14356 ; 44   |#define MPEGv1       0x03
                            14357 ; 45   |// Frame Layer Info (matches MP3 frame format)
                            14358 ; 46   |#define LayerI   3  // seems backwards, but matches mp3 frame format
                            14359 ; 47   |#define LayerII  2
                            14360 ; 48   |#define LayerIII 1
                            14361 ; 49   |
                            14362 ; 50   |// Display selection on ID3V1 or ID3V2
                            14363 ; 51   |#define NO_TAG_SELECTED         0
                            14364 ; 52   |#define ID3V1_TAG_SELECTED      1
                            14365 ; 53   |#define ID3V2_TAG_SELECTED      2
                            14366 ; 54   |
                            14367 ; 55   |#define MP3L2_3FRAME_SIZE     1152    // Frame size for MPEG Layer 2 & 3 (# samples)
                            14368 ; 56   |#define MP3L1FRAME_SIZE       384     // Frame size for MPEG Layer 1
                            14369 ; 57   |#define MP3VBR_LOW_FRAME_SIZE 576     // Required constant for VBR - not sure where came from.
                            14370 ; 58   |
                            14371 ; 59   |
                            14372 ; 60   |// VBR
                            14373 ; 61   |#define MP3_FRAMES_TO_CHECK_VBR 100
                            14374 ; 62   |
                            14375 ; 63   |// structure to receive extracted header for Xing or VBR
                            14376 ; 64   |// VBRTable pointer may be NULL (but we're initializing it.)
                            14377 ; 65   |typedef struct {
                            14378 ; 66   |    WORD  VBRVersion;     // Version 0=MPEG2, 1=MPEG1
                            14379 ; 67   |    WORD  VBRSampleRate;  // Sample Rate from VBR frame
                            14380 ; 68   |    BYTE  VBRSignature;   // Xing or VBR
                            14381 ; 69   |    DWORD VBRStreamFrames;// total bit stream frames from Xing or VBR header
                            14382 ; 70   |    DWORD VBRStreamBytes; // total bit stream bytes from Xing or VBR header
                            14383 ; 71   |    WORD  VBRTableScale;  // Scale of Table (only for VBRi)
                            14384 ; 72   |    WORD  VBREntryBytes;  // Entry Bytes??
                            14385 ; 73   |    WORD  VBREntryFrames; // Entry Frames
                            14386 ; 74   |} VBR_HEADER_DATA;
                            14387 ; 75   |
                            14388 ; 76   |typedef struct {
                            14389 ; 77   |    WORD  VBRTableSize;   // Size of Table (100 for Xing, 200 for VBRi)
                            14390 ; 78   |    WORD  VBRTotalSeconds;// Total Seconds - max out at 4660 hrs.
                            14391 ; 79   |    WORD  VBRDurPerBin; // Duration per VBR Frame. x 128 for 2 digits of accuracy
                            14392 ; 80   |    WORD  * VBRTable;     // VBR Table
                            14393 ; 81   |} VBR_GLOBAL_HEADER_DATA;
                            14394 ; 82   |
                            14395 ; 83   |
                            14396 ; 84   |extern LONG         _Y Mp3DecoderStartFrameFilePosition;
                            14397 ; 85   |
                            14398 ; 86   |
                            14399 ; 87   |
                            14400 ; 88   |int SeekPoint(BYTE TOC[100], INT file_bytes, float percent);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  57

M:ADDR CODE           CYCLES LINE SOURCELINE
                            14401 ; 89   |// return seekpoint in bytes (may be at eof if percent=100.0)
                            14402 ; 90   |// TOC = table of contents from Xing header
                            14403 ; 91   |// file_bytes = number of bytes in mp3 file
                            14404 ; 92   |// percent = play time percentage of total playtime. May be
                            14405 ; 93   |//           fractional (e.g. 87.245)
                            14406 ; 94   |
                            14407 ; 95   |INT _reentrant GetID3v1Tag(FILE_META_DATA * MetaData,_packed BYTE *buf);
                            14408 ; 96   |RETCODE _reentrant GetMp3FrameInfo(FILE_META_DATA * MetaData,INT iHandle);
                            14409 ; 97   |INT _reentrant ExtractMp3Frame(INT iHandle, WORD * wFrameBufferPacked, BYTE * btFrameUnpack);
                            14410 ; 98   |WORD _reentrant GetFrameLength(BYTE btMPEGVer,WORD wBitRate, WORD wSampRate, BYTE btPaddingBit, INT iLayer);
                            14411 ; 99   |INT _reentrant GetMp3Rates(BYTE btMPEGVer,BYTE btSampRate,BYTE btBitRate,INT iLayer, WORD *wSampRate,WORD *wBitRate);
                            14412 ; 100  |DWORD _reentrant ExtractI4(unsigned char *buf, INT i);  // stmp 6724  Change type from INT to DWORD to allow 4-byte storage
                            14413 ; 101  |RETCODE _reentrant GetMp3MetaData (INT PackedPathNameAddress, INT btCurrentDevice, FILE_META_DATA *MetaData);
                            14414 ; 102  |RETCODE _reentrant Mp3MetaDataReadID3V1(INT iHandle,FILE_META_DATA*pMetaData);
                            14415 ; 103  |
                            14416 ; 104  |RETCODE _reentrant ScanForFF(INT iHandle, WORD wThresholdMax, FILE_META_DATA*pMetaData);
                            14417 ; 105  |
                            14418 ; 106  |#endif
                            14419 
                            14421 
                            14422 ; 14   |#include "menumanager.h"
                            14423 
                            14425 
                            14426 ; 1    |#ifndef _EXEC_H
                            14427 ; 2    |#define _EXEC_H
                            14428 ; 3    |
                            14429 ; 4    |#include "types.h"
                            14430 
                            14432 
                            14433 ; 1    |////////////////////////////////////////////////////////////////////////////////
                            14434 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                            14435 ; 3    |//
                            14436 ; 4    |// Filename: types.h
                            14437 ; 5    |// Description: Standard data types
                            14438 ; 6    |////////////////////////////////////////////////////////////////////////////////
                            14439 ; 7    |
                            14440 ; 8    |#ifndef _TYPES_H
                            14441 ; 9    |#define _TYPES_H
                            14442 ; 10   |
                            14443 ; 11   |// TODO:  move this outta here!
                            14444 ; 12   |#if !defined(NOERROR)
                            14445 ; 13   |#define NOERROR 0
                            14446 ; 14   |#define SUCCESS 0
                            14447 ; 15   |#endif 
                            14448 ; 16   |#if !defined(SUCCESS)
                            14449 ; 17   |#define SUCCESS  0
                            14450 ; 18   |#endif
                            14451 ; 19   |#if !defined(ERROR)
                            14452 ; 20   |#define ERROR   -1
                            14453 ; 21   |#endif
                            14454 ; 22   |#if !defined(FALSE)
                            14455 ; 23   |#define FALSE 0
                            14456 ; 24   |#endif
                            14457 ; 25   |#if !defined(TRUE)
                            14458 ; 26   |#define TRUE  1
                            14459 ; 27   |#endif
                            14460 ; 28   |
                            14461 ; 29   |#if !defined(NULL)
                            14462 ; 30   |#define NULL 0
                            14463 ; 31   |#endif
                            14464 ; 32   |
                            14465 ; 33   |#define MAX_INT     0x7FFFFF
                            14466 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                            14467 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                            14468 ; 36   |#define MAX_ULONG   (-1) 
                            14469 ; 37   |
                            14470 ; 38   |#define WORD_SIZE   24              // word size in bits
                            14471 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                            14472 ; 40   |
                            14473 ; 41   |
                            14474 ; 42   |#define BYTE    unsigned char       // btVarName
                            14475 ; 43   |#define CHAR    signed char         // cVarName
                            14476 ; 44   |#define USHORT  unsigned short      // usVarName
                            14477 ; 45   |#define SHORT   unsigned short      // sVarName
                            14478 ; 46   |#define WORD    unsigned int        // wVarName
                            14479 ; 47   |#define INT     signed int          // iVarName
                            14480 ; 48   |#define DWORD   unsigned long       // dwVarName
                            14481 ; 49   |#define LONG    signed long         // lVarName
                            14482 ; 50   |#define BOOL    unsigned int        // bVarName
                            14483 ; 51   |#define FRACT   _fract              // frVarName
                            14484 ; 52   |#define LFRACT  long _fract         // lfrVarName
                            14485 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                            14486 ; 54   |#define FLOAT   float               // fVarName
                            14487 ; 55   |#define DBL     double              // dVarName
                            14488 ; 56   |#define ENUM    enum                // eVarName
                            14489 ; 57   |#define CMX     _complex            // cmxVarName
                            14490 ; 58   |typedef WORD UCS3;                   // 
                            14491 ; 59   |
                            14492 ; 60   |#define UINT16  unsigned short
                            14493 ; 61   |#define UINT8   unsigned char   
                            14494 ; 62   |#define UINT32  unsigned long
                            14495 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            14496 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            14497 ; 65   |#define WCHAR   UINT16
                            14498 ; 66   |
                            14499 ; 67   |//UINT128 is 16 bytes or 6 words
                            14500 ; 68   |typedef struct UINT128_3500 {   
                            14501 ; 69   |    int val[6];     
                            14502 ; 70   |} UINT128_3500;
                            14503 ; 71   |
                            14504 ; 72   |#define UINT128   UINT128_3500
                            14505 ; 73   |
                            14506 ; 74   |// Little endian word packed byte strings:   
                            14507 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            14508 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            14509 ; 77   |// Little endian word packed byte strings:   
                            14510 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            14511 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            14512 ; 80   |
                            14513 ; 81   |// Declare Memory Spaces To Use When Coding
                            14514 ; 82   |// A. Sector Buffers
                            14515 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                            14516 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                            14517 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                            14518 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                            14519 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                            14520 ; 88   |// B. Media DDI Memory
                            14521 ; 89   |#define MEDIA_DDI_MEM _Y
                            14522 ; 90   |
                            14523 ; 91   |
                            14524 ; 92   |
                            14525 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                            14526 ; 94   |// Examples of circular pointers:
                            14527 ; 95   |//    INT CIRC cpiVarName
                            14528 ; 96   |//    DWORD CIRC cpdwVarName
                            14529 ; 97   |
                            14530 ; 98   |#define RETCODE INT                 // rcVarName
                            14531 ; 99   |
                            14532 ; 100  |// generic bitfield structure
                            14533 ; 101  |struct Bitfield {
                            14534 ; 102  |    unsigned int B0  :1;
                            14535 ; 103  |    unsigned int B1  :1;
                            14536 ; 104  |    unsigned int B2  :1;
                            14537 ; 105  |    unsigned int B3  :1;
                            14538 ; 106  |    unsigned int B4  :1;
                            14539 ; 107  |    unsigned int B5  :1;
                            14540 ; 108  |    unsigned int B6  :1;
                            14541 ; 109  |    unsigned int B7  :1;
                            14542 ; 110  |    unsigned int B8  :1;
                            14543 ; 111  |    unsigned int B9  :1;
                            14544 ; 112  |    unsigned int B10 :1;
                            14545 ; 113  |    unsigned int B11 :1;
                            14546 ; 114  |    unsigned int B12 :1;
                            14547 ; 115  |    unsigned int B13 :1;
                            14548 ; 116  |    unsigned int B14 :1;
                            14549 ; 117  |    unsigned int B15 :1;
                            14550 ; 118  |    unsigned int B16 :1;
                            14551 ; 119  |    unsigned int B17 :1;
                            14552 ; 120  |    unsigned int B18 :1;
                            14553 ; 121  |    unsigned int B19 :1;
                            14554 ; 122  |    unsigned int B20 :1;
                            14555 ; 123  |    unsigned int B21 :1;
                            14556 ; 124  |    unsigned int B22 :1;
                            14557 ; 125  |    unsigned int B23 :1;
                            14558 ; 126  |};
                            14559 ; 127  |
                            14560 ; 128  |union BitInt {
                            14561 ; 129  |        struct Bitfield B;
                            14562 ; 130  |        int        I;
                            14563 ; 131  |};
                            14564 ; 132  |
                            14565 ; 133  |#define MAX_MSG_LENGTH 10
                            14566 ; 134  |struct CMessage
                            14567 ; 135  |{
                            14568 ; 136  |        unsigned int m_uLength;
                            14569 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                            14570 ; 138  |};
                            14571 ; 139  |
                            14572 ; 140  |typedef struct {
                            14573 ; 141  |    WORD m_wLength;
                            14574 ; 142  |    WORD m_wMessage;
                            14575 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                            14576 ; 144  |} Message;
                            14577 ; 145  |
                            14578 ; 146  |struct MessageQueueDescriptor
                            14579 ; 147  |{
                            14580 ; 148  |        int *m_pBase;
                            14581 ; 149  |        int m_iModulo;
                            14582 ; 150  |        int m_iSize;
                            14583 ; 151  |        int *m_pHead;
                            14584 ; 152  |        int *m_pTail;
                            14585 ; 153  |};
                            14586 ; 154  |
                            14587 ; 155  |struct ModuleEntry
                            14588 ; 156  |{
                            14589 ; 157  |    int m_iSignaledEventMask;
                            14590 ; 158  |    int m_iWaitEventMask;
                            14591 ; 159  |    int m_iResourceOfCode;
                            14592 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                            14593 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                            14594 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                            14595 ; 163  |    int m_uTimeOutHigh;
                            14596 ; 164  |    int m_uTimeOutLow;
                            14597 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                            14598 ; 166  |};
                            14599 ; 167  |
                            14600 ; 168  |union WaitMask{
                            14601 ; 169  |    struct B{
                            14602 ; 170  |        unsigned int m_bNone     :1;
                            14603 ; 171  |        unsigned int m_bMessage  :1;
                            14604 ; 172  |        unsigned int m_bTimer    :1;
                            14605 ; 173  |        unsigned int m_bButton   :1;
                            14606 ; 174  |    } B;
                            14607 ; 175  |    int I;
                            14608 ; 176  |} ;
                            14609 ; 177  |
                            14610 ; 178  |
                            14611 ; 179  |struct Button {
                            14612 ; 180  |        WORD wButtonEvent;
                            14613 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                            14614 ; 182  |};
                            14615 ; 183  |
                            14616 ; 184  |struct Message {
                            14617 ; 185  |        WORD wMsgLength;
                            14618 ; 186  |        WORD wMsgCommand;
                            14619 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                            14620 ; 188  |};
                            14621 ; 189  |
                            14622 ; 190  |union EventTypes {
                            14623 ; 191  |        struct CMessage msg;
                            14624 ; 192  |        struct Button Button ;
                            14625 ; 193  |        struct Message Message;
                            14626 ; 194  |};
                            14627 ; 195  |
                            14628 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                            14629 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                            14630 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                            14631 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                            14632 ; 200  |
                            14633 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                            14634 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                            14635 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                            14636 ; 204  |
                            14637 ; 205  |#if DEBUG
                            14638 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                            14639 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                            14640 ; 208  |#else 
                            14641 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                            14642 ; 210  |#define DebugBuildAssert(x)    
                            14643 ; 211  |#endif
                            14644 ; 212  |
                            14645 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                            14646 ; 214  |//  #pragma asm
                            14647 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                            14648 ; 216  |//  #pragma endasm
                            14649 ; 217  |
                            14650 ; 218  |
                            14651 ; 219  |#ifdef COLOR_262K
                            14652 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                            14653 ; 221  |#elif defined(COLOR_65K)
                            14654 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  58

M:ADDR CODE           CYCLES LINE SOURCELINE
                            14655 ; 223  |#else
                            14656 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                            14657 ; 225  |#endif
                            14658 ; 226  |    
                            14659 ; 227  |#endif // #ifndef _TYPES_H
                            14660 
                            14662 
                            14663 ; 5    |
                            14664 ; 6    |int _asmfunc SysWaitOnEvent(unsigned int uEvent,struct CMessage *,int uLength);
                            14665 ; 7    |int _asmfunc SysCallFunction(unsigned int RESOURCE,int _reentrant (int,int,int*),  int, int, int *);
                            14666 ; 8    |
                            14667 ; 9    |#if !defined(NULL)
                            14668 ; 10   |#define NULL 0
                            14669 ; 11   |#endif 
                            14670 ; 12   |
                            14671 ; 13   |#if !defined(FALSE)
                            14672 ; 14   |#define FALSE 0
                            14673 ; 15   |#endif
                            14674 ; 16   |#if !defined(TRUE)
                            14675 ; 17   |#define TRUE  !FALSE
                            14676 ; 18   |#endif
                            14677 ; 19   |
                            14678 ; 20   |// The same memory location contains either a menu message or button event. 
                            14679 ; 21   |// The button info is stored in the first word or the entire message is stored.
                            14680 ; 22   |
                            14681 ; 23   |// CMessage is kept for backards compatibility.
                            14682 ; 24   |// The union and 2 new structures are added to aid in readability.
                            14683 ; 25   |
                            14684 ; 26   |
                            14685 ; 27   |#include "messages.h"
                            14686 
                            14688 
                            14689 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                            14690 ; 2    |// Copyright(C) SigmaTel, Inc. 2000
                            14691 ; 3    |// Message defs
                            14692 ; 4    |/////////////////////////////////////////////////////////////////////////////////
                            14693 ; 5    |
                            14694 ; 6    |#if (!defined(MSGEQU_INC))
                            14695 ; 7    |#define MSGEQU_INC 1
                            14696 ; 8    |
                            14697 ; 9    |
                            14698 ; 10   |#define MAX_MODULE_SIZE   (lc_u_eP_Module_overlay-lc_u_bP_Module_overlay)*3
                            14699 ; 11   |
                            14700 ; 12   |
                            14701 ; 13   |#define MSG_TYPE_DECODER 0x000000
                            14702 ; 14   |#define MSG_TYPE_ENCODER 0x010000
                            14703 ; 15   |#define MSG_TYPE_PARSER 0x020000
                            14704 ; 16   |#define MSG_TYPE_LCD 0x030000
                            14705 ; 17   |#define MSG_TYPE_MIXER 0x040000
                            14706 ; 18   |#define MSG_TYPE_SYSTEM 0x050000
                            14707 ; 19   |#define MSG_TYPE_MENU 0x060000
                            14708 ; 20   |#define MSG_TYPE_LED 0x070000
                            14709 ; 21   |#define MSG_TYPE_TUNER 0x080000
                            14710 ; 22   |#define MSG_TYPE_CHARLCD 0x030000
                            14711 ; 23   |#define MSG_TYPE_SOFT_TIMER 0x090000
                            14712 ; 24   |// Equalizer and other effects
                            14713 ; 25   |#define MSG_TYPE_GEQ 0x0a0000             
                            14714 ; 26   |#if (defined(USE_PLAYLIST3))
                            14715 ; 27   |#define MSG_TYPE_MUSICLIB_PLAY 0x0b0000
                            14716 ; 28   |#define MSG_TYPE_MUSICLIB_BROWSE 0x0c0000
                            14717 ; 29   |#define MSG_TYPE_MUSICLIB_PLAYALLNEXT 0x0d0000
                            14718 ; 30   |#define MSG_TYPE_MUSICLIB_PLAYALLPREV 0x0e0000
                            14719 ; 31   |#define MSG_TYPE_MUSICLIB_SHUFFLE 0x0f0000
                            14720 ; 32   |#define MSG_TYPE_MUSICLIB_VOICE 0x100000
                            14721 ; 33   |#define MSG_TYPE_MUSICLIB_VOICEPLAY 0x110000
                            14722 ; 34   |#define MSG_TYPE_MUSICLIB_MERGE 0x120000
                            14723 ; 35   |#endif // IF (@def(USE_PLAYLIST3))
                            14724 ; 36   |#if defined(USE_PLAYLIST5)
                            14725 ; 37   |#define MSG_TYPE_PL5_PLAYBACK 0x0b0000
                            14726 ; 38   |#define MSG_TYPE_PL5_BROWSE 0x0c0000
                            14727 ; 39   |#endif // if @def('USE_PLAYLIST5')
                            14728 ; 40   |
                            14729 ; 41   |// Message Structure Offsets
                            14730 ; 42   |#define MSG_Length 0
                            14731 ; 43   |#define MSG_ID 1
                            14732 ; 44   |#define MSG_Argument1 2
                            14733 ; 45   |#define MSG_Argument2 3
                            14734 ; 46   |#define MSG_Argument3 4
                            14735 ; 47   |#define MSG_Argument4 5
                            14736 ; 48   |#define MSG_Argument5 6
                            14737 ; 49   |#define MSG_Argument6 7
                            14738 ; 50   |
                            14739 ; 51   |
                            14740 ; 52   |
                            14741 ; 53   |// LCD Message IDs
                            14742 ; 54   |#define LCD_FIRST_MSG_ID MSG_TYPE_LCD+0
                            14743 ; 55   |#define LCD_CLEAR_RANGE MSG_TYPE_LCD+0
                            14744 ; 56   |#define LCD_PRINT_RANGE_RSRC MSG_TYPE_LCD+1
                            14745 ; 57   |#define LCD_PRINT_RANGE_ADDR MSG_TYPE_LCD+2
                            14746 ; 58   |#define LCD_PRINT_RANGE_INV_RSRC MSG_TYPE_LCD+3
                            14747 ; 59   |#define LCD_PRINT_RANGE_INV_ADDR MSG_TYPE_LCD+4
                            14748 ; 60   |#define LCD_PRINT_RANGE_FILE MSG_TYPE_LCD+5
                            14749 ; 61   |#define LCD_PRINT_RANGE_INV_FILE MSG_TYPE_LCD+6
                            14750 ; 62   |#define LCD_PRINT_STRING_RSRC MSG_TYPE_LCD+7
                            14751 ; 63   |#define LCD_PRINT_STRING_ADDR MSG_TYPE_LCD+8
                            14752 ; 64   |#define LCD_PRINT_STRING_INV_RSRC MSG_TYPE_LCD+9
                            14753 ; 65   |#define LCD_PRINT_STRING_INV_ADDR MSG_TYPE_LCD+10
                            14754 ; 66   |#define LCD_SCROLL_DISPLAY MSG_TYPE_LCD+11
                            14755 ; 67   |#define LCD_READ_LCD_ADDR MSG_TYPE_LCD+12
                            14756 ; 68   |#define LCD_SET_CONTRAST MSG_TYPE_LCD+13
                            14757 ; 69   |#define LCD_INC_CONTRAST MSG_TYPE_LCD+14
                            14758 ; 70   |#define LCD_DEC_CONTRAST MSG_TYPE_LCD+15
                            14759 ; 71   |#define LCD_BACKLIGHT_ON MSG_TYPE_LCD+16
                            14760 ; 72   |#define LCD_BACKLIGHT_OFF MSG_TYPE_LCD+17
                            14761 ; 73   |#define LCD_SET_FONT MSG_TYPE_LCD+18
                            14762 ; 74   |#define LCD_PRINT_NUMBER MSG_TYPE_LCD+19
                            14763 ; 75   |#define LCD_PRINT_TIME MSG_TYPE_LCD+20
                            14764 ; 76   |#define LCD_PRINT_TIME_LONG MSG_TYPE_LCD+21
                            14765 ; 77   |#define LCD_PRINT_STRING_UNICODE_INV_ADDR MSG_TYPE_LCD+22
                            14766 ; 78   |#define LCD_PRINT_STRING_UNICODE_ADDR MSG_TYPE_LCD+23
                            14767 ; 79   |#define LCD_PRINT_STRING_UNICODE_INV_RSRC MSG_TYPE_LCD+24
                            14768 ; 80   |#define LCD_PRINT_STRING_UNICODE_RSRC MSG_TYPE_LCD+25
                            14769 ; 81   |#define LCD_BEGIN_FRAME MSG_TYPE_LCD+26
                            14770 ; 82   |#define LCD_END_FRAME MSG_TYPE_LCD+27
                            14771 ; 83   |#define LCD_PRINT_NUMBER_INV MSG_TYPE_LCD+28
                            14772 ; 84   |#define LCD_PRINT_TIME_INV MSG_TYPE_LCD+29
                            14773 ; 85   |#define LCD_PRINT_TIME_LONG_INV MSG_TYPE_LCD+30
                            14774 ; 86   |#define LCD_SET_FRAMEBUFFER MSG_TYPE_LCD+31
                            14775 ; 87   |//send a NULL as Param1 to return to root frame buffer
                            14776 ; 88   |#define LCD_PUSH_MASK MSG_TYPE_LCD+32
                            14777 ; 89   |//Param1 = left
                            14778 ; 90   |//Param2 = top
                            14779 ; 91   |//Param3 = right
                            14780 ; 92   |//Param4 = bottom
                            14781 ; 93   |#define LCD_POP_MASK MSG_TYPE_LCD+33
                            14782 ; 94   |#define LCD_PRINT_UNICODE_CHAR MSG_TYPE_LCD+34
                            14783 ; 95   |#define LCD_PRINT_UNICODE_CHAR_INV MSG_TYPE_LCD+35
                            14784 ; 96   |#define LCD_DISPLAY_HISTOGRAM MSG_TYPE_LCD+36
                            14785 ; 97   |#define LCD_PRINT_TIME_L_1DIG_HR MSG_TYPE_LCD+37
                            14786 ; 98   |#define LCD_SET_ICON MSG_TYPE_LCD+38
                            14787 ; 99   |
                            14788 ; 100  |#define LCD_CLEAR_RANGE_BUFFER MSG_TYPE_LCD+39
                            14789 ; 101  |#define LCD_PRINT_RANGE_RSRC_BUFFER MSG_TYPE_LCD+40
                            14790 ; 102  |#define LCD_PRINT_RANGE_INV_RSRC_BUFFER MSG_TYPE_LCD+41
                            14791 ; 103  |#define LCD_PRINT_RANGE_ADDR_BUFFER MSG_TYPE_LCD+42
                            14792 ; 104  |#define LCD_PRINT_RANGE_INV_ADDR_BUFFER MSG_TYPE_LCD+43
                            14793 ; 105  |#define LCD_PRINT_STRING_RSRC_BUFFER MSG_TYPE_LCD+44
                            14794 ; 106  |#define LCD_PRINT_STRING_INV_RSRC_BUFFER MSG_TYPE_LCD+45
                            14795 ; 107  |#define LCD_PRINT_STRING_ADDR_BUFFER MSG_TYPE_LCD+46
                            14796 ; 108  |#define LCD_PRINT_STRING_INV_ADDR_BUFFER MSG_TYPE_LCD+47
                            14797 ; 109  |#define LCD_PRINT_NUMBER_BUFFER MSG_TYPE_LCD+48
                            14798 ; 110  |#define LCD_PRINT_NUMBER_INV_BUFFER MSG_TYPE_LCD+49
                            14799 ; 111  |#define LCD_PRINT_TIME_BUFFER MSG_TYPE_LCD+50
                            14800 ; 112  |#define LCD_PRINT_TIME_INV_BUFFER MSG_TYPE_LCD+51
                            14801 ; 113  |#define LCD_PRINT_TIME_LONG_BUFFER MSG_TYPE_LCD+52
                            14802 ; 114  |#define LCD_PRINT_TIME_LONG_INV_BUFFER MSG_TYPE_LCD+53
                            14803 ; 115  |#define LCD_PRINT_STRING_UNICODE_ADDR_BUFFER MSG_TYPE_LCD+54
                            14804 ; 116  |#define LCD_PRINT_STRING_UNICODE_INV_ADDR_BUFFER MSG_TYPE_LCD+55
                            14805 ; 117  |#define LCD_PRINT_STRING_UNICODE_RSRC_BUFFER MSG_TYPE_LCD+56
                            14806 ; 118  |#define LCD_PRINT_STRING_UNICODE_INV_RSRC_BUFFER MSG_TYPE_LCD+57
                            14807 ; 119  |#define LCD_PRINT_UNICODE_CHAR_BUFFER MSG_TYPE_LCD+58
                            14808 ; 120  |#define LCD_PRINT_UNICODE_CHAR_INV_BUFFER MSG_TYPE_LCD+59
                            14809 ; 121  |#define LCD_PRINT_TIME_L_1DIG_HR_BUFFER MSG_TYPE_LCD+60
                            14810 ; 122  |#define LCD_SET_BUFFER_COLOR MSG_TYPE_LCD+61
                            14811 ; 123  |#define LCD_FORCE_BUFFER_UPDATE MSG_TYPE_LCD+62
                            14812 ; 124  |#define LCD_SET_BUFFER_WINDOW MSG_TYPE_LCD+63
                            14813 ; 125  |#define LCD_SET_COLOR MSG_TYPE_LCD+64
                            14814 ; 126  |#define LCD_SET_BUFFER_POSITION MSG_TYPE_LCD+65
                            14815 ; 127  |
                            14816 ; 128  |#define LCD_TEMP_CONTRAST MSG_TYPE_LCD+66
                            14817 ; 129  |
                            14818 ; 130  |#if defined(CLCD_16BIT)
                            14819 ; 131  |#define LCD_16BIT_ON MSG_TYPE_LCD+67
                            14820 ; 132  |#define LCD_16BIT_OFF MSG_TYPE_LCD+68
                            14821 ; 133  |
                            14822 ; 134  |#define LCD_LAST_MSG_ID MSG_TYPE_LCD+68
                            14823 ; 135  |#else 
                            14824 ; 136  |#define LCD_LAST_MSG_ID MSG_TYPE_LCD+66
                            14825 ; 137  |#endif
                            14826 ; 138  |
                            14827 ; 139  |// If you change the LCD message ID's then you must
                            14828 ; 140  |// also change the jump table in lcdapi.asm
                            14829 ; 141  |
                            14830 ; 142  |// Character LCD Message IDs
                            14831 ; 143  |#define CHARLCD_FIRST_MSG_ID MSG_TYPE_CHARLCD+0
                            14832 ; 144  |#define CHARLCD_CLEAR_RANGE MSG_TYPE_CHARLCD+0
                            14833 ; 145  |#define CHARLCD_PRINT_RSRC MSG_TYPE_CHARLCD+1
                            14834 ; 146  |#define CHARLCD_PRINT_INV_RSRC MSG_TYPE_CHARLCD+2
                            14835 ; 147  |#define CHARLCD_PRINT_ASCII_CHAR MSG_TYPE_CHARLCD+3
                            14836 ; 148  |#define CHARLCD_PRINT_ASCII_INV_CHAR MSG_TYPE_CHARLCD+4
                            14837 ; 149  |#define CHARLCD_PRINT_STRING_RSRC MSG_TYPE_CHARLCD+5
                            14838 ; 150  |#define CHARLCD_PRINT_STRING_INV_RSRC MSG_TYPE_CHARLCD+6
                            14839 ; 151  |#define CHARLCD_PRINT_STRING_ADDR MSG_TYPE_CHARLCD+7
                            14840 ; 152  |#define CHARLCD_PRINT_STRING_INV_ADDR MSG_TYPE_CHARLCD+8
                            14841 ; 153  |#define CHARLCD_SCROLL_DISPLAY MSG_TYPE_CHARLCD+9
                            14842 ; 154  |#define CHARLCD_READ_LCD_ADDR MSG_TYPE_CHARLCD+10
                            14843 ; 155  |#define CHARLCD_SET_CURSOR MSG_TYPE_CHARLCD+11
                            14844 ; 156  |#define CHARLCD_SET_FONT MSG_TYPE_CHARLCD+12
                            14845 ; 157  |#define CHARLCD_PRINT_NUMBER MSG_TYPE_CHARLCD+13
                            14846 ; 158  |#define CHARLCD_PRINT_TIME MSG_TYPE_CHARLCD+14
                            14847 ; 159  |#define CHARLCD_SET_BATTERY MSG_TYPE_CHARLCD+15
                            14848 ; 160  |#define CHARLCD_SET_EQ MSG_TYPE_CHARLCD+16
                            14849 ; 161  |#define CHARLCD_SET_ICON MSG_TYPE_CHARLCD+17
                            14850 ; 162  |#define CHARLCD_SET_PLAYMODE MSG_TYPE_CHARLCD+18
                            14851 ; 163  |#define CHARLCD_SET_PLAYSTATE MSG_TYPE_CHARLCD+19
                            14852 ; 164  |#define CHARLCD_SET_VOLUME MSG_TYPE_CHARLCD+20
                            14853 ; 165  |#define CHARLCD_CLEAR_DISPLAY MSG_TYPE_CHARLCD+21
                            14854 ; 166  |#define CHARLCD_LAST_MSG_ID MSG_TYPE_CHARLCD+21
                            14855 ; 167  |// If you change the cHARACTER LCD message ID's then you must
                            14856 ; 168  |// also change the jump table in lcdapi.asm
                            14857 ; 169  |
                            14858 ; 170  |// Decoder Message IDs
                            14859 ; 171  |#define DECODER_FIRST_MSG_ID MSG_TYPE_DECODER+0
                            14860 ; 172  |#define DECODER_RESET MSG_TYPE_DECODER+0
                            14861 ; 173  |#define DECODER_SET_DIR MSG_TYPE_DECODER+1
                            14862 ; 174  |#define DECODER_PLAY MSG_TYPE_DECODER+2
                            14863 ; 175  |#define DECODER_STOP MSG_TYPE_DECODER+3
                            14864 ; 176  |#define DECODER_FFWD MSG_TYPE_DECODER+4
                            14865 ; 177  |#define DECODER_RWND MSG_TYPE_DECODER+5
                            14866 ; 178  |#define DECODER_NEXT_SONG MSG_TYPE_DECODER+6
                            14867 ; 179  |#define DECODER_PREV_SONG MSG_TYPE_DECODER+7
                            14868 ; 180  |#define DECODER_TIME_MODE MSG_TYPE_DECODER+8
                            14869 ; 181  |#define DECODER_AB_MODE MSG_TYPE_DECODER+9
                            14870 ; 182  |#define DECODER_SET_EQ MSG_TYPE_DECODER+10
                            14871 ; 183  |#define DECODER_GET_SONG_INFO MSG_TYPE_DECODER+11
                            14872 ; 184  |#define DECODER_NEXT_CHAPTER MSG_TYPE_DECODER+12
                            14873 ; 185  |#define DECODER_PREV_CHAPTER MSG_TYPE_DECODER+13
                            14874 ; 186  |#define DECODER_LAST_MSG_ID MSG_TYPE_DECODER+13
                            14875 ; 187  |// If you change the Decoder message ID's, then you must
                            14876 ; 188  |// also change the jump table in decoder_overlay.asm
                            14877 ; 189  |// and in dec_adpcm_overlay.asm.
                            14878 ; 190  |
                            14879 ; 191  |// Encoder Message IDs
                            14880 ; 192  |#define ENCODER_FIRST_MSG_ID MSG_TYPE_ENCODER+0
                            14881 ; 193  |#define ENCODER_RECORD MSG_TYPE_ENCODER+0
                            14882 ; 194  |#define ENCODER_STOP MSG_TYPE_ENCODER+1
                            14883 ; 195  |#define ENCODER_TIME_MODE MSG_TYPE_ENCODER+2
                            14884 ; 196  |#define ENCODER_LAST_MSG_ID MSG_TYPE_ENCODER+3
                            14885 ; 197  |// If you change the Encoder message ID's, then you must
                            14886 ; 198  |// also change the jump table in all encoder overlay modules.
                            14887 ; 199  |
                            14888 ; 200  |// Parser Message IDs
                            14889 ; 201  |#define PARSER_FIRST_MSG_ID MSG_TYPE_PARSER+0
                            14890 ; 202  |#define PARSER_NEXT_SONG MSG_TYPE_PARSER+0
                            14891 ; 203  |#define PARSER_PREV_SONG MSG_TYPE_PARSER+1
                            14892 ; 204  |#define PARSER_REPEAT MSG_TYPE_PARSER+2
                            14893 ; 205  |#define PARSER_RANDOM MSG_TYPE_PARSER+3
                            14894 ; 206  |#define PARSER_STOP MSG_TYPE_PARSER+4
                            14895 ; 207  |#define PARSER_DEVICE_ENUMERATE MSG_TYPE_PARSER+5
                            14896 ; 208  |#define PARSER_SET_CURRENT_SONG MSG_TYPE_PARSER+6
                            14897 ; 209  |#define PARSER_LAST_MSG_ID MSG_TYPE_PARSER+6
                            14898 ; 210  |// If you change the Parser message ID's, then you must
                            14899 ; 211  |// also change the jump table in parser.asm
                            14900 ; 212  |
                            14901 ; 213  |// Button Message IDs
                            14902 ; 214  |//BUTTON_FIRST_MSG_ID      equ     MSG_TYPE_BUTTON+0
                            14903 ; 215  |//BUTTON_BUTTONS_ON        equ     MSG_TYPE_BUTTON+0
                            14904 ; 216  |//BUTTON_BUTTONS_OFF       equ     MSG_TYPE_BUTTON+1
                            14905 ; 217  |//BUTTON_HOLD              equ     MSG_TYPE_BUTTON+2
                            14906 ; 218  |//BUTTON_HOLD_RELEASE      equ     MSG_TYPE_BUTTON+3
                            14907 ; 219  |//BUTTON_LAST_MSG_ID       equ     MSG_TYPE_BUTTON+3
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  59

M:ADDR CODE           CYCLES LINE SOURCELINE
                            14908 ; 220  |
                            14909 ; 221  |// Mixer Message IDs
                            14910 ; 222  |#define MIXER_FIRST_MSG_ID MSG_TYPE_MIXER+0
                            14911 ; 223  |#define MIXER_MASTER_INCR MSG_TYPE_MIXER+0
                            14912 ; 224  |#define MIXER_MASTER_DECR MSG_TYPE_MIXER+1
                            14913 ; 225  |#define MIXER_MASTER_SETLVL MSG_TYPE_MIXER+2
                            14914 ; 226  |#define MIXER_MASTER_MUTE MSG_TYPE_MIXER+3
                            14915 ; 227  |#define MIXER_MASTER_UNMUTE MSG_TYPE_MIXER+4
                            14916 ; 228  |#define MIXER_MASTER_FADE_OUT MSG_TYPE_MIXER+5
                            14917 ; 229  |#define MIXER_MASTER_FADE_IN MSG_TYPE_MIXER+6
                            14918 ; 230  |#define MIXER_MASTER_BAL_RIGHT MSG_TYPE_MIXER+7
                            14919 ; 231  |#define MIXER_MASTER_BAL_LEFT MSG_TYPE_MIXER+8
                            14920 ; 232  |#define MIXER_MIC_INCR MSG_TYPE_MIXER+9
                            14921 ; 233  |#define MIXER_MIC_DECR MSG_TYPE_MIXER+10
                            14922 ; 234  |#define MIXER_MIC_SETLVL MSG_TYPE_MIXER+11
                            14923 ; 235  |#define MIXER_MIC_MUTE MSG_TYPE_MIXER+12
                            14924 ; 236  |#define MIXER_MIC_UNMUTE MSG_TYPE_MIXER+13
                            14925 ; 237  |#define MIXER_MIC_BOOST MSG_TYPE_MIXER+14
                            14926 ; 238  |#define MIXER_MIC_UNBOOST MSG_TYPE_MIXER+15
                            14927 ; 239  |#define MIXER_LINE_INCR MSG_TYPE_MIXER+16
                            14928 ; 240  |#define MIXER_LINE_DECR MSG_TYPE_MIXER+17
                            14929 ; 241  |#define MIXER_LINE_SETLVL MSG_TYPE_MIXER+18
                            14930 ; 242  |#define MIXER_LINE_MUTE MSG_TYPE_MIXER+19
                            14931 ; 243  |#define MIXER_LINE_UNMUTE MSG_TYPE_MIXER+20
                            14932 ; 244  |#define MIXER_FM_INCR MSG_TYPE_MIXER+21
                            14933 ; 245  |#define MIXER_FM_DECR MSG_TYPE_MIXER+22
                            14934 ; 246  |#define MIXER_FM_SETLVL MSG_TYPE_MIXER+23
                            14935 ; 247  |#define MIXER_FM_MUTE MSG_TYPE_MIXER+24
                            14936 ; 248  |#define MIXER_FM_UNMUTE MSG_TYPE_MIXER+25
                            14937 ; 249  |#define MIXER_DAC_INCR MSG_TYPE_MIXER+26
                            14938 ; 250  |#define MIXER_DAC_DECR MSG_TYPE_MIXER+27
                            14939 ; 251  |#define MIXER_DAC_SETLVL MSG_TYPE_MIXER+28
                            14940 ; 252  |#define MIXER_DAC_MUTE MSG_TYPE_MIXER+29
                            14941 ; 253  |#define MIXER_DAC_UNMUTE MSG_TYPE_MIXER+30
                            14942 ; 254  |#define MIXER_ADC_SELECT MSG_TYPE_MIXER+31
                            14943 ; 255  |#define MIXER_ADC_INCR MSG_TYPE_MIXER+32
                            14944 ; 256  |#define MIXER_ADC_DECR MSG_TYPE_MIXER+33
                            14945 ; 257  |#define MIXER_ADC_SETLVL MSG_TYPE_MIXER+34
                            14946 ; 258  |#define MIXER_ADC_MUTE MSG_TYPE_MIXER+35
                            14947 ; 259  |#define MIXER_ADC_UNMUTE MSG_TYPE_MIXER+36
                            14948 ; 260  |#define MIXER_REC_SELECT MSG_TYPE_MIXER+37
                            14949 ; 261  |#define MIXER_POWER_DOWN MSG_TYPE_MIXER+38
                            14950 ; 262  |#define ENABLE_RIGHT_CH MSG_TYPE_MIXER+39
                            14951 ; 263  |#define DISABLE_RIGHT_CH MSG_TYPE_MIXER+40
                            14952 ; 264  |#define MIXER_LAST_MSG_ID MSG_TYPE_MIXER+40
                            14953 ; 265  |// If you change the mixer message ID's then you must
                            14954 ; 266  |// also change the jump table in mixer.asm
                            14955 ; 267  |#define MIXER_ON 0
                            14956 ; 268  |#define MIXER_OFF 1
                            14957 ; 269  |
                            14958 ; 270  |
                            14959 ; 271  |// System Message IDs
                            14960 ; 272  |#define SYSTEM_FIRST_MSG_ID MSG_TYPE_SYSTEM+0
                            14961 ; 273  |#define SYSTEM_SHUTDOWN MSG_TYPE_SYSTEM+0
                            14962 ; 274  |#define SYSTEM_SHUTDOWN_FALSE MSG_TYPE_SYSTEM+1
                            14963 ; 275  |#define SYSTEM_SHUTDOWN_FINAL MSG_TYPE_SYSTEM+2
                            14964 ; 276  |#define SYSTEM_LAST_MSG_ID MSG_TYPE_SYSTEM+2
                            14965 ; 277  |// If you change the system message ID's then you must
                            14966 ; 278  |// also change the jump table in systemapi.asm
                            14967 ; 279  |
                            14968 ; 280  |// Menu IDs
                            14969 ; 281  |#define MENU_FIRST_MSG_ID MSG_TYPE_MENU+0
                            14970 ; 282  |#define MENU_BUTTON_EVENT MSG_TYPE_MENU+0
                            14971 ; 283  |#define MENU_DECODER_STATE_CHNG MSG_TYPE_MENU+1
                            14972 ; 284  |#define MENU_RECORDER_STATE_CHNG MSG_TYPE_MENU+2
                            14973 ; 285  |//sub parameters for this message:
                            14974 ; 286  |#define RECORDER_START 0
                            14975 ; 287  |#define RECORDER_PAUSE 0x2000
                            14976 ; 288  |#define RECORDER_RESUME 0x4000
                            14977 ; 289  |#define RECORDER_STOP_NORMAL 0x8000
                            14978 ; 290  |#define RECORDER_STOP_FILE_ERROR 0x8001
                            14979 ; 291  |#define RECORDER_STOP_OUT_OF_SPACE 0x8002
                            14980 ; 292  |#define RECORDER_STOP_LOW_BATTERY 0x8003
                            14981 ; 293  |#define MENU_SONG_TIME_CHNG MSG_TYPE_MENU+3
                            14982 ; 294  |#define MENU_AB_MODE_OFF MSG_TYPE_MENU+4
                            14983 ; 295  |#define MENU_BATTERY_CHNG MSG_TYPE_MENU+5
                            14984 ; 296  |#define MENU_SCROLL_TITLE MSG_TYPE_MENU+6
                            14985 ; 297  |#define MENU_AUTO_SHUTDOWN MSG_TYPE_MENU+7
                            14986 ; 298  |#define MENU_MSG_MEDIA_CHANGED MSG_TYPE_MENU+8
                            14987 ; 299  |#define MENU_MSG_MEDIA_OVER_CUR MSG_TYPE_MENU+9
                            14988 ; 300  |#define MENU_TUNER_TUNED MSG_TYPE_MENU+10
                            14989 ; 301  |#define MENU_MSG_ENC_LOW_SPACE MSG_TYPE_MENU+11
                            14990 ; 302  |#define MENU_MSG_EQ_SETTINGS MSG_TYPE_MENU+12
                            14991 ; 303  |#define MENU_RECORDER_WRITE_DATA MSG_TYPE_MENU+13
                            14992 ; 304  |#define MENU_SONG_TRACK_CHNG MSG_TYPE_MENU+14
                            14993 ; 305  |#define MENU_SET_SONG_POSITION MSG_TYPE_MENU+15
                            14994 ; 306  |#define MENU_UPDATE_CHAPTER_INFO MSG_TYPE_MENU+16
                            14995 ; 307  |#define MENU_USB_CONNECTED MSG_TYPE_MENU+17
                            14996 ; 308  |#define MENU_MSG_LYRICS_SYNC_AB MSG_TYPE_MENU+18
                            14997 ; 309  |#define MENU_MSG_LYRICS_UPDATE MSG_TYPE_MENU+19
                            14998 ; 310  |#define MENU_TUNER_REFRESH_DISPLAY MSG_TYPE_MENU+20
                            14999 ; 311  |#define MENU_TUNER_DIRTY_FLASH MSG_TYPE_MENU+21
                            15000 ; 312  |#define MENU_LAST_MSG_ID MSG_TYPE_MENU+21
                            15001 ; 313  |
                            15002 ; 314  |// Note that other versions of this file have different msg equates.
                            15003 ; 315  |// If you change the system message ID's then you must
                            15004 ; 316  |// also change the jump table in all menu *.asm
                            15005 ; 317  |
                            15006 ; 318  |// LED Message IDs
                            15007 ; 319  |#define LED_FIRST_MSG_ID MSG_TYPE_LED+0
                            15008 ; 320  |#define LED_CONTROL MSG_TYPE_LED+0
                            15009 ; 321  |#define LED_RESET MSG_TYPE_LED+1
                            15010 ; 322  |#define LED_DLY_ON_CONTROL MSG_TYPE_LED+2
                            15011 ; 323  |#define LED_LAST_MSG_ID MSG_TYPE_LED+2
                            15012 ; 324  |// If you change the LeD message ID's then you must
                            15013 ; 325  |// also change the jump table in ledapi.asm
                            15014 ; 326  |
                            15015 ; 327  |#if (!defined(REMOVE_FM))
                            15016 ; 328  |// FM Tuner Message IDs
                            15017 ; 329  |#define TUNER_FIRST_MSG_ID MSG_TYPE_TUNER+0
                            15018 ; 330  |#define TUNER_TUNE_FREQUENCY MSG_TYPE_TUNER+0
                            15019 ; 331  |#define TUNER_TUNE_MANUAL_UP MSG_TYPE_TUNER+1
                            15020 ; 332  |#define TUNER_TUNE_MANUAL_DOWN MSG_TYPE_TUNER+2
                            15021 ; 333  |#define TUNER_TUNE_SEARCH_UP MSG_TYPE_TUNER+3
                            15022 ; 334  |#define TUNER_TUNE_SEARCH_DOWN MSG_TYPE_TUNER+4
                            15023 ; 335  |#define TUNER_FORCED_MONO MSG_TYPE_TUNER+5
                            15024 ; 336  |#define TUNER_RESET MSG_TYPE_TUNER+6
                            15025 ; 337  |#define TUNER_POWER_ON MSG_TYPE_TUNER+7
                            15026 ; 338  |#define TUNER_POWER_OFF MSG_TYPE_TUNER+8
                            15027 ; 339  |#define TUNER_SET_SENSITIVITY MSG_TYPE_TUNER+9
                            15028 ; 340  |//one parameter--the sensitivity in uV
                            15029 ; 341  |#define TUNER_GET_STATES MSG_TYPE_TUNER+10
                            15030 ; 342  |#define TUNER_MUTE_OUTPUTS MSG_TYPE_TUNER+11
                            15031 ; 343  |#define TUNER_PRESET_STATION MSG_TYPE_TUNER+12
                            15032 ; 344  |#define TUNER_TUNE_TO_PRESET MSG_TYPE_TUNER+13
                            15033 ; 345  |#define TUNER_SET_PRESET MSG_TYPE_TUNER+14
                            15034 ; 346  |#define TUNER_ERASE_PRESET MSG_TYPE_TUNER+15
                            15035 ; 347  |#define TUNER_LAST_MSG_ID MSG_TYPE_TUNER+15
                            15036 ; 348  |#endif
                            15037 ; 349  |
                            15038 ; 350  |#define SOFT_TIMER_FIRST_MSG_ID MSG_TYPE_SOFT_TIMER+0
                            15039 ; 351  |#define SOFT_TIMER_SET_TIMER MSG_TYPE_SOFT_TIMER+1
                            15040 ; 352  |#define SOFT_TIMER_KILL_TIMER MSG_TYPE_SOFT_TIMER+2
                            15041 ; 353  |#define SOFT_TIMER_LAST_MSG_ID MSG_TYPE_SOFT_TIMER+2
                            15042 ; 354  |
                            15043 ; 355  |
                            15044 ; 356  |#define GEQ_FIRST_MSG_ID MSG_TYPE_GEQ+0
                            15045 ; 357  |#define GEQ_SET_EQ MSG_TYPE_GEQ+0
                            15046 ; 358  |#define GEQ_SET_EQ_LEGACY MSG_TYPE_GEQ+1
                            15047 ; 359  |#define GEQ_SET_ALL_BAND_GAINS MSG_TYPE_GEQ+2
                            15048 ; 360  |#define GEQ_SET_GAIN MSG_TYPE_GEQ+3
                            15049 ; 361  |#define GEQ_SET_COEFFICIENTS MSG_TYPE_GEQ+4
                            15050 ; 362  |#define GEQ_SET_PARAM MSG_TYPE_GEQ+5
                            15051 ; 363  |#define GEQ_GET_SETTINGS MSG_TYPE_GEQ+6
                            15052 ; 364  |#define GEQ_LAST_MSG_ID MSG_TYPE_GEQ+6
                            15053 ; 365  |
                            15054 ; 366  |#if (defined(USE_PLAYLIST3))
                            15055 ; 367  |// Music Library
                            15056 ; 368  |#define MUSICLIB_PLAY_FIRST_MSG_ID MSG_TYPE_MUSICLIB_PLAY+0
                            15057 ; 369  |#define MUSICLIB_START_PLAY_SONG MSG_TYPE_MUSICLIB_PLAY+0
                            15058 ; 370  |#define MUSICLIB_START_PLAY_ALL_SONG MSG_TYPE_MUSICLIB_PLAY+1
                            15059 ; 371  |#define MUSICLIB_PLAY_SETSHUFFLE MSG_TYPE_MUSICLIB_PLAY+2
                            15060 ; 372  |#define MUSICLIB_PLAY_RESUME MSG_TYPE_MUSICLIB_PLAY+3
                            15061 ; 373  |#define MUSICLIB_PLAY_CURRENT_SIZE MSG_TYPE_MUSICLIB_PLAY+4
                            15062 ; 374  |#define MUSICLIB_PLAY_LAST_MSG_ID MSG_TYPE_MUSICLIB_PLAY+4
                            15063 ; 375  |
                            15064 ; 376  |#define MUSICLIB_BROWSE_FIRST_MSG_ID MSG_TYPE_MUSICLIB_BROWSE+0
                            15065 ; 377  |#define MUSICLIB_BROWSE_SETROOT MSG_TYPE_MUSICLIB_BROWSE+0
                            15066 ; 378  |#define MUSICLIB_BROWSE_BROWSEMENU MSG_TYPE_MUSICLIB_BROWSE+1
                            15067 ; 379  |#define MUSICLIB_BROWSE_DOWNLIST MSG_TYPE_MUSICLIB_BROWSE+2
                            15068 ; 380  |#define MUSICLIB_BROWSE_UPLIST MSG_TYPE_MUSICLIB_BROWSE+3
                            15069 ; 381  |#define MUSICLIB_BROWSE_UPMENU MSG_TYPE_MUSICLIB_BROWSE+4
                            15070 ; 382  |#define MUSICLIB_BROWSE_SONGNUMBER MSG_TYPE_MUSICLIB_BROWSE+5
                            15071 ; 383  |#define MUSICLIB_BROWSE_ON_THE_FLY_GET_STATUS MSG_TYPE_MUSICLIB_BROWSE+6
                            15072 ; 384  |#define MUSICLIB_BROWSE_ON_THE_FLY_ADD_ITEM MSG_TYPE_MUSICLIB_BROWSE+7
                            15073 ; 385  |#define MUSICLIB_BROWSE_ON_THE_FLY_DELETE_ITEM MSG_TYPE_MUSICLIB_BROWSE+8
                            15074 ; 386  |#define MUSICLIB_BROWSE_ON_THE_FLY_DELETE_ALL MSG_TYPE_MUSICLIB_BROWSE+9
                            15075 ; 387  |#define MUSICLIB_BROWSE_LAST_MSG_ID MSG_TYPE_MUSICLIB_BROWSE+9
                            15076 ; 388  |
                            15077 ; 389  |#define MUSICLIB_PLAYALLNEXT_FIRST_MSG_ID MSG_TYPE_MUSICLIB_PLAYALLNEXT+0
                            15078 ; 390  |#define MUSICLIB_PLAYNEXTSONG MSG_TYPE_MUSICLIB_PLAYALLNEXT+0
                            15079 ; 391  |#define MUSICLIB_PLAYALLNEXT_LAST_MSG_ID MSG_TYPE_MUSICLIB_PLAYALLNEXT+0
                            15080 ; 392  |
                            15081 ; 393  |#define MUSICLIB_PLAYALLPREV_FIRST_MSG_ID MSG_TYPE_MUSICLIB_PLAYALLPREV+0
                            15082 ; 394  |#define MUSICLIB_PLAYPREVIOUSSONG MSG_TYPE_MUSICLIB_PLAYALLPREV+0
                            15083 ; 395  |#define MUSICLIB_PLAYALLPREV_LAST_MSG_ID MSG_TYPE_MUSICLIB_PLAYALLPREV+0
                            15084 ; 396  |
                            15085 ; 397  |#define MUSICLIB_SHUFFLE_FIRST_MSG_ID MSG_TYPE_MUSICLIB_SHUFFLE+0
                            15086 ; 398  |#define MUSICLIB_SHUFFLE_NEXT MSG_TYPE_MUSICLIB_SHUFFLE+0
                            15087 ; 399  |#define MUSICLIB_SHUFFLE_LAST_MSG_ID MSG_TYPE_MUSICLIB_SHUFFLE+0
                            15088 ; 400  |
                            15089 ; 401  |#define MUSICLIB_VOICE_FIRST_MSG_ID MSG_TYPE_MUSICLIB_VOICE+0
                            15090 ; 402  |#define MUSICLIB_VOICE_BROWSEMENU MSG_TYPE_MUSICLIB_VOICE+0
                            15091 ; 403  |#define MUSICLIB_VOICE_DOWNLIST MSG_TYPE_MUSICLIB_VOICE+1
                            15092 ; 404  |#define MUSICLIB_VOICE_UPLIST MSG_TYPE_MUSICLIB_VOICE+2
                            15093 ; 405  |#define MUSICLIB_VOICE_UPMENU MSG_TYPE_MUSICLIB_VOICE+3
                            15094 ; 406  |#define MUSICLIB_VOICE_VOICENUMBER MSG_TYPE_MUSICLIB_VOICE+4
                            15095 ; 407  |#define MUSICLIB_VOICE_LAST_MSG_ID MSG_TYPE_MUSICLIB_VOICE+4
                            15096 ; 408  |
                            15097 ; 409  |#define MUSICLIB_VOICEPLAY_FIRST_MSG_ID MSG_TYPE_MUSICLIB_VOICEPLAY+0
                            15098 ; 410  |#define MUSICLIB_START_PLAY_VOICE MSG_TYPE_MUSICLIB_VOICEPLAY+0
                            15099 ; 411  |#define MUSICLIB_VOICEPLAY_LAST_MSG_ID MSG_TYPE_MUSICLIB_VOICEPLAY+0
                            15100 ; 412  |
                            15101 ; 413  |#define MUSICLIB_MERGE_FIRST_MSG_ID MSG_TYPE_MUSICLIB_MERGE+0
                            15102 ; 414  |#define MUSICLIB_MERGE_SONG MSG_TYPE_MUSICLIB_MERGE+0
                            15103 ; 415  |#define MUSICLIB_MERGE_ALL_SONG MSG_TYPE_MUSICLIB_MERGE+1
                            15104 ; 416  |#define MUSICLIB_MERGE_RESUME MSG_TYPE_MUSICLIB_MERGE+2
                            15105 ; 417  |#define MUSICLIB_MERGE_LAST_MSG_ID MSG_TYPE_MUSICLIB_MERGE+2
                            15106 ; 418  |#endif // IF (@def(USE_PLAYLIST3))
                            15107 ; 419  |
                            15108 ; 420  |#if defined(USE_PLAYLIST5)
                            15109 ; 421  |#define PL5_PL_FIRST_MSG_ID MSG_TYPE_PL5_PLAYBACK+0
                            15110 ; 422  |#define PL5_PL_MSG_RESET MSG_TYPE_PL5_PLAYBACK+0
                            15111 ; 423  |#define PL5_PL_MSG_CDSEARCHING MSG_TYPE_PL5_PLAYBACK+1
                            15112 ; 424  |#define PL5_PL_MSG_START MSG_TYPE_PL5_PLAYBACK+2
                            15113 ; 425  |#define PL5_PL_MSG_STOP MSG_TYPE_PL5_PLAYBACK+3
                            15114 ; 426  |#define PL5_PL_MSG_PAUSE MSG_TYPE_PL5_PLAYBACK+4
                            15115 ; 427  |#define PL5_PL_MSG_RESUME MSG_TYPE_PL5_PLAYBACK+5
                            15116 ; 428  |#define PL5_PL_MSG_DELETE MSG_TYPE_PL5_PLAYBACK+6
                            15117 ; 429  |#define PL5_PL_MSG_PLAY MSG_TYPE_PL5_PLAYBACK+7
                            15118 ; 430  |#define PL5_PL_MSG_DISCNT MSG_TYPE_PL5_PLAYBACK+8
                            15119 ; 431  |#define PL5_PL_MSG_ENACNT MSG_TYPE_PL5_PLAYBACK+9
                            15120 ; 432  |#define PL5_PL_LAST_MSG_ID MSG_TYPE_PL5_PLAYBACK+9
                            15121 ; 433  |
                            15122 ; 434  |#define PL5_BR_FIRST_MSG_ID MSG_TYPE_PL5_BROWSE+0
                            15123 ; 435  |#define PL5_BR_MSG_RESET MSG_TYPE_PL5_BROWSE+0
                            15124 ; 436  |#define PL5_BR_MSG_CDBROWSING MSG_TYPE_PL5_BROWSE+1
                            15125 ; 437  |#define PL5_BR_MSG_START MSG_TYPE_PL5_BROWSE+2
                            15126 ; 438  |#define PL5_BR_MSG_STOP MSG_TYPE_PL5_BROWSE+3
                            15127 ; 439  |#define PL5_BR_MSG_PAUSE MSG_TYPE_PL5_BROWSE+4
                            15128 ; 440  |#define PL5_BR_MSG_RESUME MSG_TYPE_PL5_BROWSE+5
                            15129 ; 441  |#define PL5_BR_MSG_DELETE MSG_TYPE_PL5_BROWSE+6
                            15130 ; 442  |#define PL5_BR_LAST_MSG_ID MSG_TYPE_PL5_BROWSE+6
                            15131 ; 443  |#endif // if @def('USE_PLAYLIST5')
                            15132 ; 444  |// Events
                            15133 ; 445  |// No event
                            15134 ; 446  |#define EVENT_NONE 0x000001   
                            15135 ; 447  |// A message has been posted
                            15136 ; 448  |#define EVENT_MESSAGE 0x000002   
                            15137 ; 449  |// Run if wait time elapsed
                            15138 ; 450  |#define EVENT_TIMER 0x000004   
                            15139 ; 451  |// Run if a button event occured
                            15140 ; 452  |#define EVENT_BUTTON 0x000008   
                            15141 ; 453  |// Run if a background event occured
                            15142 ; 454  |#define EVENT_BACKGROUND 0x000010   
                            15143 ; 455  |// The executive should immediately repeat this module
                            15144 ; 456  |#define EVENT_REPEAT 0x000020   
                            15145 ; 457  |// Run the module's init routine
                            15146 ; 458  |#define EVENT_INIT 0x800000   
                            15147 ; 459  |
                            15148 ; 460  |#define EVENT_NONE_BITPOS 0
                            15149 ; 461  |#define EVENT_MESSAGE_BITPOS 1
                            15150 ; 462  |#define EVENT_TIMER_BITPOS 2
                            15151 ; 463  |#define EVENT_BUTTON_BITPOS 3
                            15152 ; 464  |#define EVENT_BACKGROUND_BITPOS 4
                            15153 ; 465  |#define EVENT_REPEAT_BITPOS 5
                            15154 ; 466  |#define EVENT_INIT_BITPOS 23
                            15155 ; 467  |
                            15156 ; 468  |// Parser Message Buffers
                            15157 ; 469  |#define ParserPlayBit 0
                            15158 ; 470  |#define ButtonPressBit 1
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  60

M:ADDR CODE           CYCLES LINE SOURCELINE
                            15159 ; 471  |#define ParserRwndBit 1
                            15160 ; 472  |#define ParserFfwdBit 2
                            15161 ; 473  |
                            15162 ; 474  |//NextSong Message Parameters
                            15163 ; 475  |// ButtonPressBit1 set to denote button was pressed.
                            15164 ; 476  |#define NEXT_SONG 2             
                            15165 ; 477  |// ButtonPressBit1 cleared
                            15166 ; 478  |#define NEXT_SONG_PLAY_EOF 1          
                            15167 ; 479  |// ButtonPressBit1 set
                            15168 ; 480  |#define NEXT_SONG_PLAY_BUTTON 3          
                            15169 ; 481  |// NextSong + Ffwd
                            15170 ; 482  |#define NEXT_SONG_FFWD 4          
                            15171 ; 483  |
                            15172 ; 484  |//PrevSong Message Parameters
                            15173 ; 485  |// PrevSong + Stopped
                            15174 ; 486  |#define PREV_SONG 0          
                            15175 ; 487  |// PrevSong + Play
                            15176 ; 488  |#define PREV_SONG_PLAY 1          
                            15177 ; 489  |// PrevSong + Rwnd
                            15178 ; 490  |#define PREV_SONG_RWND 2          
                            15179 ; 491  |
                            15180 ; 492  |
                            15181 ; 493  |
                            15182 ; 494  |
                            15183 ; 495  |#endif // IF (!@def(MSGEQU_INC))
                            15184 ; 496  |
                            15185 ; 497  |
                            15186 
                            15188 
                            15189 ; 28   |
                            15190 ; 29   |#endif 
                            15191 
                            15193 
                            15194 ; 15   |#ifdef USE_PLAYLIST3
                            15195 ; 16   |#include "fsapi.h"
                            15196 
                            15198 
                            15199 ; 1    |#ifndef _FSAPI_H_
                            15200 ; 2    |#define _FSAPI_H_
                            15201 ; 3    |#include "filespec.h"
                            15202 
                            15204 
                            15205 ; 1    |#ifndef _FILESPEC_H_
                            15206 ; 2    |#define _FILESPEC_H_
                            15207 ; 3    |#include  "fstypes.h"
                            15208 
                            15210 
                            15211 ; 1    |#ifndef _FS_TYPE_H_
                            15212 ; 2    |#define _FS_TYPE_H_
                            15213 ; 3    |
                            15214 ; 4    |#include   "types.h"
                            15215 
                            15217 
                            15218 ; 1    |////////////////////////////////////////////////////////////////////////////////
                            15219 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                            15220 ; 3    |//
                            15221 ; 4    |// Filename: types.h
                            15222 ; 5    |// Description: Standard data types
                            15223 ; 6    |////////////////////////////////////////////////////////////////////////////////
                            15224 ; 7    |
                            15225 ; 8    |#ifndef _TYPES_H
                            15226 ; 9    |#define _TYPES_H
                            15227 ; 10   |
                            15228 ; 11   |// TODO:  move this outta here!
                            15229 ; 12   |#if !defined(NOERROR)
                            15230 ; 13   |#define NOERROR 0
                            15231 ; 14   |#define SUCCESS 0
                            15232 ; 15   |#endif 
                            15233 ; 16   |#if !defined(SUCCESS)
                            15234 ; 17   |#define SUCCESS  0
                            15235 ; 18   |#endif
                            15236 ; 19   |#if !defined(ERROR)
                            15237 ; 20   |#define ERROR   -1
                            15238 ; 21   |#endif
                            15239 ; 22   |#if !defined(FALSE)
                            15240 ; 23   |#define FALSE 0
                            15241 ; 24   |#endif
                            15242 ; 25   |#if !defined(TRUE)
                            15243 ; 26   |#define TRUE  1
                            15244 ; 27   |#endif
                            15245 ; 28   |
                            15246 ; 29   |#if !defined(NULL)
                            15247 ; 30   |#define NULL 0
                            15248 ; 31   |#endif
                            15249 ; 32   |
                            15250 ; 33   |#define MAX_INT     0x7FFFFF
                            15251 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                            15252 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                            15253 ; 36   |#define MAX_ULONG   (-1) 
                            15254 ; 37   |
                            15255 ; 38   |#define WORD_SIZE   24              // word size in bits
                            15256 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                            15257 ; 40   |
                            15258 ; 41   |
                            15259 ; 42   |#define BYTE    unsigned char       // btVarName
                            15260 ; 43   |#define CHAR    signed char         // cVarName
                            15261 ; 44   |#define USHORT  unsigned short      // usVarName
                            15262 ; 45   |#define SHORT   unsigned short      // sVarName
                            15263 ; 46   |#define WORD    unsigned int        // wVarName
                            15264 ; 47   |#define INT     signed int          // iVarName
                            15265 ; 48   |#define DWORD   unsigned long       // dwVarName
                            15266 ; 49   |#define LONG    signed long         // lVarName
                            15267 ; 50   |#define BOOL    unsigned int        // bVarName
                            15268 ; 51   |#define FRACT   _fract              // frVarName
                            15269 ; 52   |#define LFRACT  long _fract         // lfrVarName
                            15270 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                            15271 ; 54   |#define FLOAT   float               // fVarName
                            15272 ; 55   |#define DBL     double              // dVarName
                            15273 ; 56   |#define ENUM    enum                // eVarName
                            15274 ; 57   |#define CMX     _complex            // cmxVarName
                            15275 ; 58   |typedef WORD UCS3;                   // 
                            15276 ; 59   |
                            15277 ; 60   |#define UINT16  unsigned short
                            15278 ; 61   |#define UINT8   unsigned char   
                            15279 ; 62   |#define UINT32  unsigned long
                            15280 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            15281 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            15282 ; 65   |#define WCHAR   UINT16
                            15283 ; 66   |
                            15284 ; 67   |//UINT128 is 16 bytes or 6 words
                            15285 ; 68   |typedef struct UINT128_3500 {   
                            15286 ; 69   |    int val[6];     
                            15287 ; 70   |} UINT128_3500;
                            15288 ; 71   |
                            15289 ; 72   |#define UINT128   UINT128_3500
                            15290 ; 73   |
                            15291 ; 74   |// Little endian word packed byte strings:   
                            15292 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            15293 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            15294 ; 77   |// Little endian word packed byte strings:   
                            15295 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            15296 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            15297 ; 80   |
                            15298 ; 81   |// Declare Memory Spaces To Use When Coding
                            15299 ; 82   |// A. Sector Buffers
                            15300 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                            15301 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                            15302 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                            15303 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                            15304 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                            15305 ; 88   |// B. Media DDI Memory
                            15306 ; 89   |#define MEDIA_DDI_MEM _Y
                            15307 ; 90   |
                            15308 ; 91   |
                            15309 ; 92   |
                            15310 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                            15311 ; 94   |// Examples of circular pointers:
                            15312 ; 95   |//    INT CIRC cpiVarName
                            15313 ; 96   |//    DWORD CIRC cpdwVarName
                            15314 ; 97   |
                            15315 ; 98   |#define RETCODE INT                 // rcVarName
                            15316 ; 99   |
                            15317 ; 100  |// generic bitfield structure
                            15318 ; 101  |struct Bitfield {
                            15319 ; 102  |    unsigned int B0  :1;
                            15320 ; 103  |    unsigned int B1  :1;
                            15321 ; 104  |    unsigned int B2  :1;
                            15322 ; 105  |    unsigned int B3  :1;
                            15323 ; 106  |    unsigned int B4  :1;
                            15324 ; 107  |    unsigned int B5  :1;
                            15325 ; 108  |    unsigned int B6  :1;
                            15326 ; 109  |    unsigned int B7  :1;
                            15327 ; 110  |    unsigned int B8  :1;
                            15328 ; 111  |    unsigned int B9  :1;
                            15329 ; 112  |    unsigned int B10 :1;
                            15330 ; 113  |    unsigned int B11 :1;
                            15331 ; 114  |    unsigned int B12 :1;
                            15332 ; 115  |    unsigned int B13 :1;
                            15333 ; 116  |    unsigned int B14 :1;
                            15334 ; 117  |    unsigned int B15 :1;
                            15335 ; 118  |    unsigned int B16 :1;
                            15336 ; 119  |    unsigned int B17 :1;
                            15337 ; 120  |    unsigned int B18 :1;
                            15338 ; 121  |    unsigned int B19 :1;
                            15339 ; 122  |    unsigned int B20 :1;
                            15340 ; 123  |    unsigned int B21 :1;
                            15341 ; 124  |    unsigned int B22 :1;
                            15342 ; 125  |    unsigned int B23 :1;
                            15343 ; 126  |};
                            15344 ; 127  |
                            15345 ; 128  |union BitInt {
                            15346 ; 129  |        struct Bitfield B;
                            15347 ; 130  |        int        I;
                            15348 ; 131  |};
                            15349 ; 132  |
                            15350 ; 133  |#define MAX_MSG_LENGTH 10
                            15351 ; 134  |struct CMessage
                            15352 ; 135  |{
                            15353 ; 136  |        unsigned int m_uLength;
                            15354 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                            15355 ; 138  |};
                            15356 ; 139  |
                            15357 ; 140  |typedef struct {
                            15358 ; 141  |    WORD m_wLength;
                            15359 ; 142  |    WORD m_wMessage;
                            15360 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                            15361 ; 144  |} Message;
                            15362 ; 145  |
                            15363 ; 146  |struct MessageQueueDescriptor
                            15364 ; 147  |{
                            15365 ; 148  |        int *m_pBase;
                            15366 ; 149  |        int m_iModulo;
                            15367 ; 150  |        int m_iSize;
                            15368 ; 151  |        int *m_pHead;
                            15369 ; 152  |        int *m_pTail;
                            15370 ; 153  |};
                            15371 ; 154  |
                            15372 ; 155  |struct ModuleEntry
                            15373 ; 156  |{
                            15374 ; 157  |    int m_iSignaledEventMask;
                            15375 ; 158  |    int m_iWaitEventMask;
                            15376 ; 159  |    int m_iResourceOfCode;
                            15377 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                            15378 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                            15379 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                            15380 ; 163  |    int m_uTimeOutHigh;
                            15381 ; 164  |    int m_uTimeOutLow;
                            15382 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                            15383 ; 166  |};
                            15384 ; 167  |
                            15385 ; 168  |union WaitMask{
                            15386 ; 169  |    struct B{
                            15387 ; 170  |        unsigned int m_bNone     :1;
                            15388 ; 171  |        unsigned int m_bMessage  :1;
                            15389 ; 172  |        unsigned int m_bTimer    :1;
                            15390 ; 173  |        unsigned int m_bButton   :1;
                            15391 ; 174  |    } B;
                            15392 ; 175  |    int I;
                            15393 ; 176  |} ;
                            15394 ; 177  |
                            15395 ; 178  |
                            15396 ; 179  |struct Button {
                            15397 ; 180  |        WORD wButtonEvent;
                            15398 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                            15399 ; 182  |};
                            15400 ; 183  |
                            15401 ; 184  |struct Message {
                            15402 ; 185  |        WORD wMsgLength;
                            15403 ; 186  |        WORD wMsgCommand;
                            15404 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                            15405 ; 188  |};
                            15406 ; 189  |
                            15407 ; 190  |union EventTypes {
                            15408 ; 191  |        struct CMessage msg;
                            15409 ; 192  |        struct Button Button ;
                            15410 ; 193  |        struct Message Message;
                            15411 ; 194  |};
                            15412 ; 195  |
                            15413 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                            15414 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                            15415 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  61

M:ADDR CODE           CYCLES LINE SOURCELINE
                            15416 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                            15417 ; 200  |
                            15418 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                            15419 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                            15420 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                            15421 ; 204  |
                            15422 ; 205  |#if DEBUG
                            15423 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                            15424 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                            15425 ; 208  |#else 
                            15426 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                            15427 ; 210  |#define DebugBuildAssert(x)    
                            15428 ; 211  |#endif
                            15429 ; 212  |
                            15430 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                            15431 ; 214  |//  #pragma asm
                            15432 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                            15433 ; 216  |//  #pragma endasm
                            15434 ; 217  |
                            15435 ; 218  |
                            15436 ; 219  |#ifdef COLOR_262K
                            15437 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                            15438 ; 221  |#elif defined(COLOR_65K)
                            15439 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                            15440 ; 223  |#else
                            15441 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                            15442 ; 225  |#endif
                            15443 ; 226  |    
                            15444 ; 227  |#endif // #ifndef _TYPES_H
                            15445 
                            15447 
                            15448 ; 5    |
                            15449 ; 6    |// move FSMEDIA_TABLE from devicetable.h  15Apr2005   First moved in SDK2.6.
                            15450 ; 7    |typedef struct
                            15451 ; 8    |{
                            15452 ; 9    |
                            15453 ; 10   |INT     _Y BytesPerSector;
                            15454 ; 11   |INT     _Y SectorsPerCluster;
                            15455 ; 12   |INT     _Y RsvdSectors;
                            15456 ; 13   |INT     _Y NoOfFATs;
                            15457 ; 14   |INT     _Y MaxRootDirEntries;
                            15458 ; 15   |LONG    _Y TotalSectors;
                            15459 ; 16   |LONG    _Y FATSize;
                            15460 ; 17   |LONG    _Y RootdirCluster;
                            15461 ; 18   |//INT   _Y FSInfoSector;
                            15462 ; 19   |//INT   _Y BkBootSector;
                            15463 ; 20   |LONG    _Y NextFreeCluster;
                            15464 ; 21   |LONG    _Y TotalFreeClusters;
                            15465 ; 22   |INT     _Y RootDirSectors;
                            15466 ; 23   |INT     _Y FIRSTDataSector;
                            15467 ; 24   |INT    _Y FATType;
                            15468 ; 25   |LONG   _Y TotalNoofclusters;
                            15469 ; 26   |INT    _Y ClusterMask;
                            15470 ; 27   |INT    _Y ClusterShift;
                            15471 ; 28   |INT    _Y SectorShift;
                            15472 ; 29   |INT    _Y SectorMask;
                            15473 ; 30   |INT    _Y DevicePresent;
                            15474 ; 31   |LONG   _Y FirRootdirsec;
                            15475 ; 32   |INT             _Y FSInfoSector;
                            15476 ; 33   |}FSMEDIA_TABLE;
                            15477 ; 34   |
                            15478 ; 35   |
                            15479 ; 36   |#define         MAXDEVICES              2
                            15480 ; 37   |//#define       NUMCACHES               8  // this is already in fsproj.h (2 for player 2 for mtp as of 28jun2005) TOVERIFY 2 ok for player and mtp. 
                            15481 ; 38   |
                            15482 ; 39   |// NOTE:  This offset is the same no matter what the sector actual size!  
                            15483 ; 40   |//        TOVERIFY 3.0 doesn't have this defined but uses it in filesystempresent.c. lbmlc def'd it here so I insert it here.
                            15484 ; 41   |#define         FATFS_SIGNATURE_OFFSET  510
                            15485 ; 42   |#define         BOOTSECTOR              0
                            15486 ; 43   |#define     FSINFOSECTOR        1
                            15487 ; 44   |
                            15488 ; 45   |#define     READ_MODE           1
                            15489 ; 46   |#define     WRITE_MODE          2
                            15490 ; 47   |#define     APPEND_MODE         4
                            15491 ; 48   |#define     SEQ_WRITE_MODE      8
                            15492 ; 49   |#define     DIRECTORY_MODE         16
                            15493 ; 50   |#define     CREATE_MODE        32
                            15494 ; 51   |
                            15495 ; 52   |#define     RPLUS               5
                            15496 ; 53   |#define     WPLUS                   6
                            15497 ; 54   |#define     APLUS               7
                            15498 ; 55   |
                            15499 ; 56   |
                            15500 ; 57   |
                            15501 ; 58   |#define     X_MEMORY            0
                            15502 ; 59   |#define     Y_MEMORY            2
                            15503 ; 60   |#define     P_MEMORY            4
                            15504 ; 61   |
                            15505 ; 62   |#define     FAT12               0 
                            15506 ; 63   |#define     FAT16               1   
                            15507 ; 64   |#define     FAT32               2 
                            15508 ; 65   |
                            15509 ; 66   |
                            15510 ; 67   |#define FAT12EOF            0x0FFF
                            15511 ; 68   |#define FAT16EOF            0xFFFF
                            15512 ; 69   |#define FAT32EOF            0x0FFFFFFF
                            15513 ; 70   |
                            15514 ; 71   |
                            15515 ; 72   |
                            15516 ; 73   |#define FAT12FREECX         0x000
                            15517 ; 74   |#define FAT16FREECX         0x0000
                            15518 ; 75   |#define FAT32FREECX         0x00000000
                            15519 ; 76   |
                            15520 ; 77   |
                            15521 ; 78   |#define  DBCS               1
                            15522 ; 79   |#define  UNICODE            2
                            15523 ; 80   |
                            15524 ; 81   |
                            15525 ; 82   |#define     CREATION_DATE       1
                            15526 ; 83   |#define     CREATION_TIME       2
                            15527 ; 84   |#define     MODIFICATION_DATE   3
                            15528 ; 85   |#define     MODIFICATION_TIME   4
                            15529 ; 86   |
                            15530 ; 87   |
                            15531 ; 88   |#define     READ_ONLY      0X01
                            15532 ; 89   |#define     HIDDEN         0X02
                            15533 ; 90   |#define     SYSTEM         0X04
                            15534 ; 91   |#define     VOLUME_ID      0X08
                            15535 ; 92   |#define     DIRECTORY      0X10
                            15536 ; 93   |#define     ARCHIVE        0X20
                            15537 ; 94   |
                            15538 ; 95   |#define READCOUNTER         105
                            15539 ; 96   |#define WRITECOUNTER        100
                            15540 ; 97   |#define FLUSHCOUNTER        200
                            15541 ; 98   |
                            15542 ; 99   |
                            15543 ; 100  |#define DEFAULT_MEMORY      Y_MEMORY
                            15544 ; 101  |
                            15545 ; 102  |#define  CWD_HANDLE           0
                            15546 ; 103  |#define  DIRECTORY_HANDLE     1
                            15547 ; 104  |#define  FIRST_VALID_HANDLE   2
                            15548 ; 105  |#define  END_OF_DIR_PATH      3
                            15549 ; 106  |
                            15550 ; 107  |//Constants for Sector read and write (Normal and FAT 
                            15551 ; 108  |#define         NORMALTYPE              0
                            15552 ; 109  |#define         FATTYPE                 1
                            15553 ; 110  |#define     RAWTYPE         2
                            15554 ; 111  |
                            15555 ; 112  |#define  SHORTNAMERES_CH      6
                            15556 ; 113  |#define  LONGNAMERES_CH       9
                            15557 ; 114  |#define  MAXFILENAME_CH       260
                            15558 ; 115  |
                            15559 ; 116  |#define VOLUME_TYPE          0
                            15560 ; 117  |#define DIR_TYPE             1
                            15561 ; 118  |#define FILE_TYPE            2
                            15562 ; 119  |                                           
                            15563 ; 120  |#define WRITE_TYPE_RANDOM               0
                            15564 ; 121  |#define WRITE_TYPE_SEQ_FIRST    1
                            15565 ; 122  |#define WRITE_TYPE_SEQ_NEXT             2
                            15566 ; 123  |#define WRITE_TYPE_NOREADBACK   3
                            15567 ; 124  |                  
                            15568 ; 125  |
                            15569 ; 126  |#define     HANDLEENTRYSIZE         19
                            15570 ; 127  |
                            15571 ; 128  |// DEVICERECORDSIZE is now only defined in cachedef.h so deleted from here in first 3.1 prelim 
                            15572 ; 129  |
                            15573 ; 130  |#define     CACHEDESCRSIZE          8
                            15574 ; 131  |#define     CACHEBUFSIZE            705
                            15575 ; 132  |
                            15576 ; 133  |#define     UCS2s                     0
                            15577 ; 134  |#define     UCS3s                     1
                            15578 ; 135  |
                            15579 ; 136  |#define     FAT32FSIFREECOUNTSIZE       4
                            15580 ; 137  |
                            15581 ; 138  |#endif // _FS_TYPE_H_
                            15582 ; 139  |
                            15583 
                            15585 
                            15586 ; 4    |#define MAX_FILESNAME   13
                            15587 ; 5    |
                            15588 ; 6    |typedef struct {
                            15589 ; 7    |    INT     gCurrentRecord;
                            15590 ; 8    |    INT     DirAttribute;
                            15591 ; 9    |    _packed char    FileName[9];
                            15592 ; 10   |    _packed char    FileExtension[4];
                            15593 ; 11   |}FILESPEC;
                            15594 ; 12   |
                            15595 ; 13   |typedef struct {
                            15596 ; 14   |    INT attrib;
                            15597 ; 15   |        LONG FileSize;
                            15598 ; 16   |    int  device;
                            15599 ; 17   |    INT startrecord;
                            15600 ; 18   |    _packed char name[MAX_FILESNAME];
                            15601 ; 19   |        LONG Key;
                            15602 ; 20   |}Finddata;
                            15603 ; 21   |#endif
                            15604 ; 22   |
                            15605 
                            15607 
                            15608 ; 4    |extern _reentrant LONG Ftell(INT HandleNumber);
                            15609 ; 5    |extern _reentrant LONG Feof(INT HandleNumber);
                            15610 ; 6    |extern _reentrant INT *Fputs(INT HandleNumber,INT *Buffer);
                            15611 ; 7    |extern _reentrant LONG Fread(INT HandleNumber,INT *Buffer,LONG NumBytesToRead,INT Source_Memory,INT MOdulo);
                            15612 ; 8    |extern _reentrant INT Fgetc(INT HandleNumber);
                            15613 ; 9    |extern _reentrant INT Fputc(INT HandleNumber,INT ByteToWrite);
                            15614 ; 10   |extern _reentrant LONG ReadDirectoryRecord(INT HandleNumber,INT RecordNumber,INT *Buffer);
                            15615 ; 11   |extern _reentrant INT Fseek(INT HandleNumber,LONG NumBytesToSeek,INT SeekPosition);
                            15616 ; 12   |extern _reentrant INT Fopen(_packed char *filepath,_packed char *mode);
                            15617 ; 13   |extern _reentrant LONG Fwrite(INT HandleNumber,INT  *Buffer,LONG NumBytesToWrite,INT Source_Memory,INT MOdulo);
                            15618 ; 14   |extern _reentrant LONG Totalfreecluster(INT DeviceNum);
                            15619 ; 15   |extern _reentrant INT Rmdir(_packed char *filepath);
                            15620 ; 16   |extern _reentrant INT Rmdirw(_packed char *filepath);
                            15621 ; 17   |extern _reentrant INT Mkdir(_packed char *filepath);
                            15622 ; 18   |
                            15623 ; 19   |        //      SGTL-HK 27-05-2005
                            15624 ; 20   |extern _reentrant INT Mkdirw(UCS3 *filepath);
                            15625 ; 21   |
                            15626 ; 22   |extern _reentrant INT Chdir(_packed char *filepath);
                            15627 ; 23   |extern _reentrant INT FastOpen(LONG Key,_packed char *mode);
                            15628 ; 24   |
                            15629 ; 25   |extern _reentrant INT Setcwd(_packed char *filepath, _packed char *gCworkingDir,INT index,INT length);
                            15630 ; 26   |extern _reentrant _packed char *Getcwd(void);
                            15631 ; 27   |extern  _reentrant _packed char *Fgets(INT HandleNumber,INT NumBytesToRead, _packed char *Buffer);
                            15632 ; 28   |extern INT  FSInit(INT _X *bufx, INT _Y *bufy, INT maxdevices, INT maxhandles, INT maxcaches);
                            15633 ; 29   |extern INT  FlushCache(void);
                            15634 ; 30   |extern _reentrant INT FsShutDown(void);
                            15635 ; 31   |extern _reentrant LONG GetFileSize(INT HandleNumber);
                            15636 ; 32   |
                            15637 ; 33   |extern _reentrant INT filegetattrib(_packed char *FilePath);
                            15638 ; 34   |extern _reentrant INT Fopenw(INT *filepath,_packed char *mode);
                            15639 ; 35   |extern _reentrant INT Fremove(_packed char *filepath);
                            15640 ; 36   |extern _reentrant INT Fremovew(_packed char *filepath);
                            15641 ; 37   |extern _reentrant void DBCSToUnicode(_packed unsigned char *pDBCS, WORD *pUnicode,INT iLength);
                            15642 ; 38   |extern INT FlushCache(void);
                            15643 ; 39   |extern _reentrant INT DeleteTree(_packed char *Path);
                            15644 ; 40   |extern _reentrant INT Fclose(INT HandleNumber);
                            15645 ; 41   |extern INT FSMediaPresent(INT DeviceNum);
                            15646 ; 42   |extern INT FSFATType (INT DeviceNum);
                            15647 ; 43   |extern  INT _reentrant  GetVolumeLabel(_packed char *Buffer,INT DeviceNum);
                            15648 ; 44   |extern _reentrant INT SetVolumeLabel(_packed char *Buffer,INT DeviceNum);
                            15649 ; 45   |extern _reentrant LONG FgetFastHandle(INT HandleNumber);
                            15650 ; 46   |
                            15651 ; 47   |extern _reentrant INT ConstructLongFileName(INT HandleNumber, INT RecordNumber, INT *LFNBuffer);
                            15652 ; 48   |extern _reentrant void Uppercase(_packed char *file); 
                            15653 ; 49   |extern _reentrant INT FindNext(INT HandleNumber,Finddata *_finddata);
                            15654 
                            15664 
                            15665 ; 50   |extern _reentrant INT FindFirst(Finddata *_finddata,_packed char *FileName);
                            15666 ; 51   |extern _reentrant void ClearData(Finddata *_finddata);
                            15667 ; 52   |extern _reentrant INT GetShortfilename(LONG Key,INT *Buffer);
                            15668 ; 53   |
                            15669 ; 54   |
                            15670 ; 55   |
                            15671 ; 56   |
                            15672 ; 57   |typedef struct
                            15673 ; 58   |{
                            15674 ; 59   |
                            15675 ; 60   |INT             Day;
                            15676 ; 61   |INT             Month;
                            15677 ; 62   |INT             Year;
                            15678 ; 63   |}DIR_DATE;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  62

M:ADDR CODE           CYCLES LINE SOURCELINE
                            15679 ; 64   |
                            15680 ; 65   |
                            15681 ; 66   |typedef struct
                            15682 ; 67   |{
                            15683 ; 68   |
                            15684 ; 69   |INT             Second;
                            15685 ; 70   |INT             Minute;
                            15686 ; 71   |INT             Hour;
                            15687 ; 72   |}DIR_TIME;
                            15688 ; 73   |
                            15689 ; 74   |
                            15690 ; 75   |typedef struct
                            15691 ; 76   |{
                            15692 ; 77   |LONG CurrentOffset;     
                            15693 ; 78   |LONG CurrentCluster;
                            15694 ; 79   |}HANDLECONTEXT;
                            15695 ; 80   |
                            15696 ; 81   |extern _reentrant INT filesetattrib(INT HandleNumber,INT dirattribute);
                            15697 ; 82   |extern _reentrant INT filesetdate(_packed char *FilePath,INT crt_mod_date_time_para,DIR_DATE *dirdate,DIR_TIME *dirtime);
                            15698 
                            15709 
                            15710 ; 83   |extern _reentrant INT filegetdate(INT HandleNumber,INT crt_mod_date_time_para,DIR_DATE *dirdate,DIR_TIME *dirtime);
                            15711 ; 84   |#endif
                            15712 
                            15714 
                            15715 ; 17   |#include "fstypes.h"
                            15716 
                            15718 
                            15719 ; 1    |#ifndef _FS_TYPE_H_
                            15720 ; 2    |#define _FS_TYPE_H_
                            15721 ; 3    |
                            15722 ; 4    |#include   "types.h"
                            15723 ; 5    |
                            15724 ; 6    |// move FSMEDIA_TABLE from devicetable.h  15Apr2005   First moved in SDK2.6.
                            15725 ; 7    |typedef struct
                            15726 ; 8    |{
                            15727 ; 9    |
                            15728 ; 10   |INT     _Y BytesPerSector;
                            15729 ; 11   |INT     _Y SectorsPerCluster;
                            15730 ; 12   |INT     _Y RsvdSectors;
                            15731 ; 13   |INT     _Y NoOfFATs;
                            15732 ; 14   |INT     _Y MaxRootDirEntries;
                            15733 ; 15   |LONG    _Y TotalSectors;
                            15734 ; 16   |LONG    _Y FATSize;
                            15735 ; 17   |LONG    _Y RootdirCluster;
                            15736 ; 18   |//INT   _Y FSInfoSector;
                            15737 ; 19   |//INT   _Y BkBootSector;
                            15738 ; 20   |LONG    _Y NextFreeCluster;
                            15739 ; 21   |LONG    _Y TotalFreeClusters;
                            15740 ; 22   |INT     _Y RootDirSectors;
                            15741 ; 23   |INT     _Y FIRSTDataSector;
                            15742 ; 24   |INT    _Y FATType;
                            15743 ; 25   |LONG   _Y TotalNoofclusters;
                            15744 ; 26   |INT    _Y ClusterMask;
                            15745 ; 27   |INT    _Y ClusterShift;
                            15746 ; 28   |INT    _Y SectorShift;
                            15747 ; 29   |INT    _Y SectorMask;
                            15748 ; 30   |INT    _Y DevicePresent;
                            15749 ; 31   |LONG   _Y FirRootdirsec;
                            15750 ; 32   |INT             _Y FSInfoSector;
                            15751 ; 33   |}FSMEDIA_TABLE;
                            15752 ; 34   |
                            15753 ; 35   |
                            15754 ; 36   |#define         MAXDEVICES              2
                            15755 ; 37   |//#define       NUMCACHES               8  // this is already in fsproj.h (2 for player 2 for mtp as of 28jun2005) TOVERIFY 2 ok for player and mtp. 
                            15756 ; 38   |
                            15757 ; 39   |// NOTE:  This offset is the same no matter what the sector actual size!  
                            15758 ; 40   |//        TOVERIFY 3.0 doesn't have this defined but uses it in filesystempresent.c. lbmlc def'd it here so I insert it here.
                            15759 ; 41   |#define         FATFS_SIGNATURE_OFFSET  510
                            15760 ; 42   |#define         BOOTSECTOR              0
                            15761 ; 43   |#define     FSINFOSECTOR        1
                            15762 ; 44   |
                            15763 ; 45   |#define     READ_MODE           1
                            15764 ; 46   |#define     WRITE_MODE          2
                            15765 ; 47   |#define     APPEND_MODE         4
                            15766 ; 48   |#define     SEQ_WRITE_MODE      8
                            15767 ; 49   |#define     DIRECTORY_MODE         16
                            15768 ; 50   |#define     CREATE_MODE        32
                            15769 ; 51   |
                            15770 ; 52   |#define     RPLUS               5
                            15771 ; 53   |#define     WPLUS                   6
                            15772 ; 54   |#define     APLUS               7
                            15773 ; 55   |
                            15774 ; 56   |
                            15775 ; 57   |
                            15776 ; 58   |#define     X_MEMORY            0
                            15777 ; 59   |#define     Y_MEMORY            2
                            15778 ; 60   |#define     P_MEMORY            4
                            15779 ; 61   |
                            15780 ; 62   |#define     FAT12               0 
                            15781 ; 63   |#define     FAT16               1   
                            15782 ; 64   |#define     FAT32               2 
                            15783 ; 65   |
                            15784 ; 66   |
                            15785 ; 67   |#define FAT12EOF            0x0FFF
                            15786 ; 68   |#define FAT16EOF            0xFFFF
                            15787 ; 69   |#define FAT32EOF            0x0FFFFFFF
                            15788 ; 70   |
                            15789 ; 71   |
                            15790 ; 72   |
                            15791 ; 73   |#define FAT12FREECX         0x000
                            15792 ; 74   |#define FAT16FREECX         0x0000
                            15793 ; 75   |#define FAT32FREECX         0x00000000
                            15794 ; 76   |
                            15795 ; 77   |
                            15796 ; 78   |#define  DBCS               1
                            15797 ; 79   |#define  UNICODE            2
                            15798 ; 80   |
                            15799 ; 81   |
                            15800 ; 82   |#define     CREATION_DATE       1
                            15801 ; 83   |#define     CREATION_TIME       2
                            15802 ; 84   |#define     MODIFICATION_DATE   3
                            15803 ; 85   |#define     MODIFICATION_TIME   4
                            15804 ; 86   |
                            15805 ; 87   |
                            15806 ; 88   |#define     READ_ONLY      0X01
                            15807 ; 89   |#define     HIDDEN         0X02
                            15808 ; 90   |#define     SYSTEM         0X04
                            15809 ; 91   |#define     VOLUME_ID      0X08
                            15810 ; 92   |#define     DIRECTORY      0X10
                            15811 ; 93   |#define     ARCHIVE        0X20
                            15812 ; 94   |
                            15813 ; 95   |#define READCOUNTER         105
                            15814 ; 96   |#define WRITECOUNTER        100
                            15815 ; 97   |#define FLUSHCOUNTER        200
                            15816 ; 98   |
                            15817 ; 99   |
                            15818 ; 100  |#define DEFAULT_MEMORY      Y_MEMORY
                            15819 ; 101  |
                            15820 ; 102  |#define  CWD_HANDLE           0
                            15821 ; 103  |#define  DIRECTORY_HANDLE     1
                            15822 ; 104  |#define  FIRST_VALID_HANDLE   2
                            15823 ; 105  |#define  END_OF_DIR_PATH      3
                            15824 ; 106  |
                            15825 ; 107  |//Constants for Sector read and write (Normal and FAT 
                            15826 ; 108  |#define         NORMALTYPE              0
                            15827 ; 109  |#define         FATTYPE                 1
                            15828 ; 110  |#define     RAWTYPE         2
                            15829 ; 111  |
                            15830 ; 112  |#define  SHORTNAMERES_CH      6
                            15831 ; 113  |#define  LONGNAMERES_CH       9
                            15832 ; 114  |#define  MAXFILENAME_CH       260
                            15833 ; 115  |
                            15834 ; 116  |#define VOLUME_TYPE          0
                            15835 ; 117  |#define DIR_TYPE             1
                            15836 ; 118  |#define FILE_TYPE            2
                            15837 ; 119  |                                           
                            15838 ; 120  |#define WRITE_TYPE_RANDOM               0
                            15839 ; 121  |#define WRITE_TYPE_SEQ_FIRST    1
                            15840 ; 122  |#define WRITE_TYPE_SEQ_NEXT             2
                            15841 ; 123  |#define WRITE_TYPE_NOREADBACK   3
                            15842 ; 124  |                  
                            15843 ; 125  |
                            15844 ; 126  |#define     HANDLEENTRYSIZE         19
                            15845 ; 127  |
                            15846 ; 128  |// DEVICERECORDSIZE is now only defined in cachedef.h so deleted from here in first 3.1 prelim 
                            15847 ; 129  |
                            15848 ; 130  |#define     CACHEDESCRSIZE          8
                            15849 ; 131  |#define     CACHEBUFSIZE            705
                            15850 ; 132  |
                            15851 ; 133  |#define     UCS2s                     0
                            15852 ; 134  |#define     UCS3s                     1
                            15853 ; 135  |
                            15854 ; 136  |#define     FAT32FSIFREECOUNTSIZE       4
                            15855 ; 137  |
                            15856 ; 138  |#endif // _FS_TYPE_H_
                            15857 ; 139  |
                            15858 
                            15860 
                            15861 ; 18   |#include "playlist3.h"
                            15862 
                            15864 
                            15865 ; 1    |#ifndef _PLAYLIST3_H
                            15866 ; 2    |#define _PLAYLIST3_H
                            15867 ; 3    |#include "playlist.h"
                            15868 
                            15870 
                            15871 ; 1    |#ifndef PLAYLIST_H
                            15872 ; 2    |#define PLAYLIST_H
                            15873 ; 3    |
                            15874 ; 4    |#include "types.h"
                            15875 
                            15877 
                            15878 ; 1    |////////////////////////////////////////////////////////////////////////////////
                            15879 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                            15880 ; 3    |//
                            15881 ; 4    |// Filename: types.h
                            15882 ; 5    |// Description: Standard data types
                            15883 ; 6    |////////////////////////////////////////////////////////////////////////////////
                            15884 ; 7    |
                            15885 ; 8    |#ifndef _TYPES_H
                            15886 ; 9    |#define _TYPES_H
                            15887 ; 10   |
                            15888 ; 11   |// TODO:  move this outta here!
                            15889 ; 12   |#if !defined(NOERROR)
                            15890 ; 13   |#define NOERROR 0
                            15891 ; 14   |#define SUCCESS 0
                            15892 ; 15   |#endif 
                            15893 ; 16   |#if !defined(SUCCESS)
                            15894 ; 17   |#define SUCCESS  0
                            15895 ; 18   |#endif
                            15896 ; 19   |#if !defined(ERROR)
                            15897 ; 20   |#define ERROR   -1
                            15898 ; 21   |#endif
                            15899 ; 22   |#if !defined(FALSE)
                            15900 ; 23   |#define FALSE 0
                            15901 ; 24   |#endif
                            15902 ; 25   |#if !defined(TRUE)
                            15903 ; 26   |#define TRUE  1
                            15904 ; 27   |#endif
                            15905 ; 28   |
                            15906 ; 29   |#if !defined(NULL)
                            15907 ; 30   |#define NULL 0
                            15908 ; 31   |#endif
                            15909 ; 32   |
                            15910 ; 33   |#define MAX_INT     0x7FFFFF
                            15911 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                            15912 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                            15913 ; 36   |#define MAX_ULONG   (-1) 
                            15914 ; 37   |
                            15915 ; 38   |#define WORD_SIZE   24              // word size in bits
                            15916 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                            15917 ; 40   |
                            15918 ; 41   |
                            15919 ; 42   |#define BYTE    unsigned char       // btVarName
                            15920 ; 43   |#define CHAR    signed char         // cVarName
                            15921 ; 44   |#define USHORT  unsigned short      // usVarName
                            15922 ; 45   |#define SHORT   unsigned short      // sVarName
                            15923 ; 46   |#define WORD    unsigned int        // wVarName
                            15924 ; 47   |#define INT     signed int          // iVarName
                            15925 ; 48   |#define DWORD   unsigned long       // dwVarName
                            15926 ; 49   |#define LONG    signed long         // lVarName
                            15927 ; 50   |#define BOOL    unsigned int        // bVarName
                            15928 ; 51   |#define FRACT   _fract              // frVarName
                            15929 ; 52   |#define LFRACT  long _fract         // lfrVarName
                            15930 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                            15931 ; 54   |#define FLOAT   float               // fVarName
                            15932 ; 55   |#define DBL     double              // dVarName
                            15933 ; 56   |#define ENUM    enum                // eVarName
                            15934 ; 57   |#define CMX     _complex            // cmxVarName
                            15935 ; 58   |typedef WORD UCS3;                   // 
                            15936 ; 59   |
                            15937 ; 60   |#define UINT16  unsigned short
                            15938 ; 61   |#define UINT8   unsigned char   
                            15939 ; 62   |#define UINT32  unsigned long
                            15940 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            15941 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            15942 ; 65   |#define WCHAR   UINT16
                            15943 ; 66   |
                            15944 ; 67   |//UINT128 is 16 bytes or 6 words
                            15945 ; 68   |typedef struct UINT128_3500 {   
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  63

M:ADDR CODE           CYCLES LINE SOURCELINE
                            15946 ; 69   |    int val[6];     
                            15947 ; 70   |} UINT128_3500;
                            15948 ; 71   |
                            15949 ; 72   |#define UINT128   UINT128_3500
                            15950 ; 73   |
                            15951 ; 74   |// Little endian word packed byte strings:   
                            15952 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            15953 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            15954 ; 77   |// Little endian word packed byte strings:   
                            15955 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            15956 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            15957 ; 80   |
                            15958 ; 81   |// Declare Memory Spaces To Use When Coding
                            15959 ; 82   |// A. Sector Buffers
                            15960 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                            15961 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                            15962 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                            15963 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                            15964 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                            15965 ; 88   |// B. Media DDI Memory
                            15966 ; 89   |#define MEDIA_DDI_MEM _Y
                            15967 ; 90   |
                            15968 ; 91   |
                            15969 ; 92   |
                            15970 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                            15971 ; 94   |// Examples of circular pointers:
                            15972 ; 95   |//    INT CIRC cpiVarName
                            15973 ; 96   |//    DWORD CIRC cpdwVarName
                            15974 ; 97   |
                            15975 ; 98   |#define RETCODE INT                 // rcVarName
                            15976 ; 99   |
                            15977 ; 100  |// generic bitfield structure
                            15978 ; 101  |struct Bitfield {
                            15979 ; 102  |    unsigned int B0  :1;
                            15980 ; 103  |    unsigned int B1  :1;
                            15981 ; 104  |    unsigned int B2  :1;
                            15982 ; 105  |    unsigned int B3  :1;
                            15983 ; 106  |    unsigned int B4  :1;
                            15984 ; 107  |    unsigned int B5  :1;
                            15985 ; 108  |    unsigned int B6  :1;
                            15986 ; 109  |    unsigned int B7  :1;
                            15987 ; 110  |    unsigned int B8  :1;
                            15988 ; 111  |    unsigned int B9  :1;
                            15989 ; 112  |    unsigned int B10 :1;
                            15990 ; 113  |    unsigned int B11 :1;
                            15991 ; 114  |    unsigned int B12 :1;
                            15992 ; 115  |    unsigned int B13 :1;
                            15993 ; 116  |    unsigned int B14 :1;
                            15994 ; 117  |    unsigned int B15 :1;
                            15995 ; 118  |    unsigned int B16 :1;
                            15996 ; 119  |    unsigned int B17 :1;
                            15997 ; 120  |    unsigned int B18 :1;
                            15998 ; 121  |    unsigned int B19 :1;
                            15999 ; 122  |    unsigned int B20 :1;
                            16000 ; 123  |    unsigned int B21 :1;
                            16001 ; 124  |    unsigned int B22 :1;
                            16002 ; 125  |    unsigned int B23 :1;
                            16003 ; 126  |};
                            16004 ; 127  |
                            16005 ; 128  |union BitInt {
                            16006 ; 129  |        struct Bitfield B;
                            16007 ; 130  |        int        I;
                            16008 ; 131  |};
                            16009 ; 132  |
                            16010 ; 133  |#define MAX_MSG_LENGTH 10
                            16011 ; 134  |struct CMessage
                            16012 ; 135  |{
                            16013 ; 136  |        unsigned int m_uLength;
                            16014 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                            16015 ; 138  |};
                            16016 ; 139  |
                            16017 ; 140  |typedef struct {
                            16018 ; 141  |    WORD m_wLength;
                            16019 ; 142  |    WORD m_wMessage;
                            16020 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                            16021 ; 144  |} Message;
                            16022 ; 145  |
                            16023 ; 146  |struct MessageQueueDescriptor
                            16024 ; 147  |{
                            16025 ; 148  |        int *m_pBase;
                            16026 ; 149  |        int m_iModulo;
                            16027 ; 150  |        int m_iSize;
                            16028 ; 151  |        int *m_pHead;
                            16029 ; 152  |        int *m_pTail;
                            16030 ; 153  |};
                            16031 ; 154  |
                            16032 ; 155  |struct ModuleEntry
                            16033 ; 156  |{
                            16034 ; 157  |    int m_iSignaledEventMask;
                            16035 ; 158  |    int m_iWaitEventMask;
                            16036 ; 159  |    int m_iResourceOfCode;
                            16037 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                            16038 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                            16039 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                            16040 ; 163  |    int m_uTimeOutHigh;
                            16041 ; 164  |    int m_uTimeOutLow;
                            16042 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                            16043 ; 166  |};
                            16044 ; 167  |
                            16045 ; 168  |union WaitMask{
                            16046 ; 169  |    struct B{
                            16047 ; 170  |        unsigned int m_bNone     :1;
                            16048 ; 171  |        unsigned int m_bMessage  :1;
                            16049 ; 172  |        unsigned int m_bTimer    :1;
                            16050 ; 173  |        unsigned int m_bButton   :1;
                            16051 ; 174  |    } B;
                            16052 ; 175  |    int I;
                            16053 ; 176  |} ;
                            16054 ; 177  |
                            16055 ; 178  |
                            16056 ; 179  |struct Button {
                            16057 ; 180  |        WORD wButtonEvent;
                            16058 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                            16059 ; 182  |};
                            16060 ; 183  |
                            16061 ; 184  |struct Message {
                            16062 ; 185  |        WORD wMsgLength;
                            16063 ; 186  |        WORD wMsgCommand;
                            16064 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                            16065 ; 188  |};
                            16066 ; 189  |
                            16067 ; 190  |union EventTypes {
                            16068 ; 191  |        struct CMessage msg;
                            16069 ; 192  |        struct Button Button ;
                            16070 ; 193  |        struct Message Message;
                            16071 ; 194  |};
                            16072 ; 195  |
                            16073 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                            16074 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                            16075 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                            16076 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                            16077 ; 200  |
                            16078 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                            16079 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                            16080 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                            16081 ; 204  |
                            16082 ; 205  |#if DEBUG
                            16083 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                            16084 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                            16085 ; 208  |#else 
                            16086 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                            16087 ; 210  |#define DebugBuildAssert(x)    
                            16088 ; 211  |#endif
                            16089 ; 212  |
                            16090 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                            16091 ; 214  |//  #pragma asm
                            16092 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                            16093 ; 216  |//  #pragma endasm
                            16094 ; 217  |
                            16095 ; 218  |
                            16096 ; 219  |#ifdef COLOR_262K
                            16097 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                            16098 ; 221  |#elif defined(COLOR_65K)
                            16099 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                            16100 ; 223  |#else
                            16101 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                            16102 ; 225  |#endif
                            16103 ; 226  |    
                            16104 ; 227  |#endif // #ifndef _TYPES_H
                            16105 
                            16107 
                            16108 ; 5    |
                            16109 ; 6    |typedef struct {
                            16110 ; 7    |    WORD    m_wTrack;                       
                            16111 ; 8    |    WORD    m_wDeviceID;
                            16112 ; 9    |    WORD    m_wBufferLength;            //this is in BYTES, not WORDS!
                            16113 ; 10   |    _packed BYTE *m_pFilename;
                            16114 ; 11   |} SONGFILEINFO;
                            16115 ; 12   |
                            16116 ; 13   |#define PLAYLIST_SUCCESS                                0
                            16117 ; 14   |#define PLAYLIST_FILE_ERROR                             1
                            16118 ; 15   |#define PLAYLIST_END_OF_LIST                    2
                            16119 ; 16   |#define PLAYLIST_TRACK_NOT_FOUND                3
                            16120 ; 17   |#define PLAYLIST_DIR_NOT_EMPTY          4 
                            16121 ; 18   |#define PLAYLIST_REBUILD                5
                            16122 ; 19   |#define PLAYLIST_LAST_RETCODE                   5               //The value should always be the same as the last RETCODE
                            16123 ; 20   |
                            16124 ; 21   |
                            16125 ; 22   |#ifdef  USE_PLAYLIST1
                            16126 ; 23   |RETCODE ChangeDIRtoFileEntryDir(struct FileEntry *pCurrentEntry, _packed BYTE * buffer);
                            16127 ; 24   |#endif
                            16128 ; 25   |RETCODE _reentrant Playlist_LFNGetFileName(int,int,UCS3*);                      //UCS3 is actually typdef WORD
                            16129 ; 26   |RETCODE _reentrant Playlist_MarkCurrentSongPlayed(int,int,int*);
                            16130 ; 27   |RETCODE _reentrant Playlist_GetCurrentSongFileInfo(int, int, int*);
                            16131 ; 28   |RETCODE _reentrant Playlist_GetNextSongFileInfo(int, int , int*);
                            16132 ; 29   |RETCODE _reentrant Playlist_GetPreviousSongFileInfo(int,int,int*);
                            16133 ; 30   |#ifdef USE_PLAYLIST1
                            16134 ; 31   |_reentrant INT Playlist_LocateEntryFromName(INT,INT,INT*);
                            16135 ; 32   |#endif
                            16136 ; 33   |
                            16137 ; 34   |#endif 
                            16138 
                            16140 
                            16141 ; 4    |#include "playlist3internal.h"
                            16142 
                            16144 
                            16145 ; 1    |#ifndef __PLAYLIST3INTERNAL_H
                            16146 ; 2    |#define __PLAYLIST3INTERNAL_H
                            16147 ; 3    |
                            16148 ; 4    |#include "project.h"
                            16149 
                            16151 
                            16152 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                            16153 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                            16154 ; 3    |//  Filename: project.inc
                            16155 ; 4    |//  Description: 
                            16156 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                            16157 ; 6    |
                            16158 ; 7    |#if (!defined(_PROJECT_INC))
                            16159 ; 8    |#define _PROJECT_INC 1
                            16160 ; 9    |
                            16161 ; 10   |#if defined(STMP_BUILD_PLAYER)
                            16162 ; 11   |#include "hwequ.h"
                            16163 ; 12   |#else 
                            16164 ; 13   |//include "regscodec.inc"
                            16165 ; 14   |#endif
                            16166 ; 15   |
                            16167 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                            16168 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults ON) & 
                            16169 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm. STMP00012148
                            16170 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal). 
                            16171 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's specs can 
                            16172 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player mode.  
                            16173 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                            16174 ; 23   |
                            16175 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                            16176 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                            16177 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                            16178 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define below by defining
                            16179 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                            16180 ; 29   |#define ATTEMPT_FAST_BOOT 1
                            16181 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                            16182 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot config above- 
                            16183 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down threshholds by maybe 50mV.
                            16184 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed.
                            16185 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                            16186 ; 35   |
                            16187 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                            16188 ; 37   |// MEDIA DEFINITIONS
                            16189 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                            16190 ; 39   |
                            16191 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                            16192 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                            16193 ; 42   |#if defined(NAND1)
                            16194 ; 43   |#define SM_INTERNAL_CHIPS 1
                            16195 ; 44   |#else 
                            16196 ; 45   |#if defined(NAND2)
                            16197 ; 46   |#define SM_INTERNAL_CHIPS 2
                            16198 ; 47   |#else 
                            16199 ; 48   |#if defined(NAND3)
                            16200 ; 49   |#define SM_INTERNAL_CHIPS 3
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  64

M:ADDR CODE           CYCLES LINE SOURCELINE
                            16201 ; 50   |#else 
                            16202 ; 51   |#if defined(NAND4)
                            16203 ; 52   |#define SM_INTERNAL_CHIPS 4
                            16204 ; 53   |#else 
                            16205 ; 54   |#define SM_INTERNAL_CHIPS 1
                            16206 ; 55   |#endif
                            16207 ; 56   |#endif
                            16208 ; 57   |#endif
                            16209 ; 58   |#endif
                            16210 ; 59   |
                            16211 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                            16212 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                            16213 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it reads 0.  
                            16214 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                            16215 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it reads 1.
                            16216 ; 65   |//*** comment out if active high ****
                            16217 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                            16218 ; 67   |
                            16219 ; 68   |#if defined(SMEDIA)
                            16220 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                            16221 ; 70   |#define NUM_SM_EXTERNAL 1
                            16222 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                            16223 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                            16224 ; 73   |#else 
                            16225 ; 74   |#if defined(MMC)
                            16226 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                            16227 ; 76   |#define NUM_SM_EXTERNAL 0
                            16228 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                            16229 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                            16230 ; 79   |#else 
                            16231 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                            16232 ; 81   |#define NUM_SM_EXTERNAL 0
                            16233 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                            16234 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                            16235 ; 84   |#endif
                            16236 ; 85   |#endif
                            16237 ; 86   |
                            16238 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                            16239 ; 88   |// Mass Storage Class definitions
                            16240 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                            16241 ; 90   |// Set to 0 if Composite Device build is desired.    
                            16242 ; 91   |#define MULTI_LUN_BUILD 1   
                            16243 ; 92   |
                            16244 ; 93   |////////////////////////////////////////////////////////////////////////////////
                            16245 ; 94   |//  SCSI
                            16246 ; 95   |#if (MULTI_LUN_BUILD==0)
                            16247 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                            16248 ; 97   |    #define SCSI_NUM_TARGETS                        2
                            16249 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                            16250 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                            16251 ; 100  |  #else
                            16252 ; 101  |    #define SCSI_NUM_TARGETS                        1
                            16253 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                            16254 ; 103  |  #endif
                            16255 ; 104  |#else
                            16256 ; 105  |    #define SCSI_NUM_TARGETS                        1
                            16257 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                            16258 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                            16259 ; 108  |  #else
                            16260 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                            16261 ; 110  |  #endif
                            16262 ; 111  |#endif
                            16263 ; 112  |
                            16264 ; 113  |
                            16265 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                            16266 ; 115  |
                            16267 ; 116  |
                            16268 ; 117  |////////////////////////////////////////////////////////////////////////////////
                            16269 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                            16270 ; 119  |////////////////////////////////////////////////////////////////////////////////
                            16271 ; 120  |#ifdef MMC
                            16272 ; 121  |#ifdef MTP_BUILD
                            16273 ; 122  |// --------------------
                            16274 ; 123  |// MTP and MMC
                            16275 ; 124  |// --------------------
                            16276 ; 125  |#define NUM_LOGICAL_MEDIA       2
                            16277 ; 126  |#define NUM_LOGICAL_DRIVES      8
                            16278 ; 127  |#else  // ifndef MTP_BUILD
                            16279 ; 128  |#ifdef STMP_BUILD_PLAYER
                            16280 ; 129  |// --------------------
                            16281 ; 130  |// Player and MMC
                            16282 ; 131  |// --------------------
                            16283 ; 132  |#else
                            16284 ; 133  |// --------------------
                            16285 ; 134  |// USBMSC and MMC
                            16286 ; 135  |// --------------------
                            16287 ; 136  |#define NUM_LOGICAL_MEDIA       3
                            16288 ; 137  |#define NUM_LOGICAL_DRIVES      8
                            16289 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                            16290 ; 139  |#endif // ifdef MTP_BUILD
                            16291 ; 140  |#else  // ifndef MMC
                            16292 ; 141  |#ifdef MTP_BUILD
                            16293 ; 142  |// --------------------
                            16294 ; 143  |// MTP and NAND only
                            16295 ; 144  |// --------------------
                            16296 ; 145  |#define NUM_LOGICAL_MEDIA       1
                            16297 ; 146  |#define NUM_LOGICAL_DRIVES      7
                            16298 ; 147  |#else  // ifndef MTP_BUILD
                            16299 ; 148  |#ifdef STMP_BUILD_PLAYER
                            16300 ; 149  |// --------------------
                            16301 ; 150  |// Player and NAND only
                            16302 ; 151  |// --------------------
                            16303 ; 152  |#else
                            16304 ; 153  |// --------------------
                            16305 ; 154  |// USBMSC and NAND only
                            16306 ; 155  |// --------------------
                            16307 ; 156  |#define NUM_LOGICAL_MEDIA       2
                            16308 ; 157  |#define NUM_LOGICAL_DRIVES      7
                            16309 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                            16310 ; 159  |#endif // ifdef MTP_BUILD
                            16311 ; 160  |#endif // ifdef MMC 
                            16312 ; 161  |
                            16313 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                            16314 ; 163  |#if (defined(MTP_BUILD))
                            16315 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                            16316 ; 165  |
                            16317 ; 166  |////!
                            16318 ; 167  |////! This varible holds the watchdog count for the store flush.
                            16319 ; 168  |////!
                            16320 ; 169  |///
                            16321 ; 170  |#include <types.h>
                            16322 ; 171  |extern volatile INT g_StoreWatchDogCount;
                            16323 ; 172  |extern const INT g_StoreWatchDogTimeout;
                            16324 ; 173  |#endif
                            16325 ; 174  |
                            16326 ; 175  |////////////////////////////////////////////////////////////////////////////////
                            16327 ; 176  |// These are needed here for Mass Storage Class
                            16328 ; 177  |// Needs to be cleaned up
                            16329 ; 178  |////////////////////////////////////////////////////////////////////////////////
                            16330 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                            16331 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                            16332 ; 181  |#define SCRATCH_USER_X_SIZE 512
                            16333 ; 182  |
                            16334 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                            16335 ; 184  |
                            16336 ; 185  |#endif
                            16337 ; 186  |
                            16338 ; 187  |
                            16339 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                            16340 ; 189  |// SmartMedia/NAND defs
                            16341 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                            16342 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                            16343 ; 192  |
                            16344 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                            16345 ; 194  |// Sysloadresources defs
                            16346 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                            16347 ; 196  |
                            16348 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                            16349 ; 198  |// MMC defs
                            16350 ; 199  |#define MMC_MAX_PARTITIONS 1
                            16351 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                            16352 ; 201  |
                            16353 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                            16354 ; 203  |// SPI defs
                            16355 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                            16356 ; 205  |
                            16357 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                            16358 ; 207  |// Global media defs
                            16359 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                            16360 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                            16361 ; 210  |
                            16362 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                            16363 ; 212  |// DO NOT CHANGE THESE!!!
                            16364 ; 213  |#define SM_MAX_PARTITIONS 4
                            16365 ; 214  |#define MAX_HANDLES 2
                            16366 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                            16367 ; 216  |
                            16368 ; 217  |
                            16369 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                            16370 ; 219  |// Battery LRADC Values 
                            16371 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                            16372 ; 221  |// brownout trip point in mV (moved by RS)
                            16373 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                            16374 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                            16375 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                            16376 ; 225  |//     audio recording to media.
                            16377 ; 226  |#define BATT_SAFETY_MARGIN 10
                            16378 ; 227  |
                            16379 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                            16380 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline voltage to do a refresh.
                            16381 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                            16382 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                            16383 ; 232  |
                            16384 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc presence.
                            16385 ; 234  |
                            16386 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                            16387 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat check.
                            16388 ; 237  |#if (!defined(CLCD))
                            16389 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                            16390 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                            16391 ; 240  |#else 
                            16392 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                            16393 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                            16394 ; 243  |#endif
                            16395 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                            16396 ; 245  |
                            16397 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                            16398 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIon.
                            16399 ; 248  |// See mp3 encoder overlay.
                            16400 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                            16401 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                            16402 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                            16403 ; 252  |
                            16404 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                            16405 ; 254  |// Voice recording filenames
                            16406 ; 255  |// number of digits in filename Vxxx.wav
                            16407 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                            16408 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                            16409 ; 258  |
                            16410 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                            16411 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                            16412 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                            16413 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                            16414 ; 263  |#if defined(DEVICE_3500)
                            16415 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                            16416 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                            16417 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                            16418 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, & demo player)
                            16419 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                            16420 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                            16421 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                            16422 ; 271  |
                            16423 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn when bias not yet ready.
                            16424 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                            16425 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevention if you use rec button from outside voice menu.
                            16426 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latency in the record-from-music-menu use-case.
                            16427 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                            16428 ; 277  |
                            16429 ; 278  |#else 
                            16430 ; 279  |// STMP3410
                            16431 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                            16432 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                            16433 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                            16434 ; 283  |#endif
                            16435 ; 284  |
                            16436 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                            16437 ; 286  |// Number of available soft timers
                            16438 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                            16439 ; 288  |#if defined(SYNC_LYRICS)
                            16440 ; 289  |#define SOFT_TIMERS 10
                            16441 ; 290  |#else 
                            16442 ; 291  |#if defined(JPEG_DECODER)
                            16443 ; 292  |#define SOFT_TIMERS 10
                            16444 ; 293  |#else 
                            16445 ; 294  |#define SOFT_TIMERS 9
                            16446 ; 295  |#endif
                            16447 ; 296  |#endif
                            16448 ; 297  |
                            16449 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                            16450 ; 299  |//  sizes
                            16451 ; 300  |/////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  65

M:ADDR CODE           CYCLES LINE SOURCELINE
                            16452 ; 301  |#if defined(MMC)
                            16453 ; 302  |#if defined(USE_PLAYLIST5)
                            16454 ; 303  |#define MENU_STACK_SIZE 1500
                            16455 ; 304  |#else 
                            16456 ; 305  |#define MENU_STACK_SIZE 1250
                            16457 ; 306  |#endif //if @def('USE_PLAYLIST5')
                            16458 ; 307  |#else 
                            16459 ; 308  |#if defined(USE_PLAYLIST5)
                            16460 ; 309  |#define MENU_STACK_SIZE 1500
                            16461 ; 310  |#else 
                            16462 ; 311  |#define MENU_STACK_SIZE 1250
                            16463 ; 312  |#endif //if @def('USE_PLAYLIST5')
                            16464 ; 313  |#endif //if @def('MMC')
                            16465 ; 314  |
                            16466 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 750 else 550 for other builds? TOVERIFY. MYALLOC
                            16467 ; 316  |// 
                            16468 ; 317  |#define STACK_L1_SIZE 750
                            16469 ; 318  |#define STACK_L2_SIZE 100
                            16470 ; 319  |#define STACK_L3_SIZE 160
                            16471 ; 320  |
                            16472 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                            16473 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                            16474 ; 323  |// is ok with switching code.
                            16475 ; 324  |#if defined(MTP_BUILD)
                            16476 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                            16477 ; 326  |#endif
                            16478 ; 327  |
                            16479 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                            16480 ; 329  |// maximum number of nested funclets 
                            16481 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                            16482 ; 331  |#define MAX_NESTED_FUNCLET 6 
                            16483 ; 332  |
                            16484 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                            16485 ; 334  |//    LCD DEFINITIONS
                            16486 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                            16487 ; 336  |
                            16488 ; 337  |#define SPACE_CHAR 0x000020          
                            16489 ; 338  |#define ZERO_CHAR 0x000030
                            16490 ; 339  |#define COLON_CHAR 0x00003A
                            16491 ; 340  |#define PERIOD_CHAR 0x00002E
                            16492 ; 341  |
                            16493 ; 342  |#if (defined(S6B33B0A_LCD))
                            16494 ; 343  |#define LCD_X_SIZE 128
                            16495 ; 344  |#define LCD_Y_SIZE 159
                            16496 ; 345  |#endif
                            16497 ; 346  |
                            16498 ; 347  |#if (defined(SED15XX_LCD))
                            16499 ; 348  |#define LCD_X_SIZE 128
                            16500 ; 349  |#define LCD_Y_SIZE 64
                            16501 ; 350  |#endif
                            16502 ; 351  |
                            16503 ; 352  |
                            16504 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                            16505 ; 354  |//   Details on Customizing Contrast
                            16506 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                            16507 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                            16508 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                            16509 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                            16510 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                            16511 ; 360  |//   unless the ezact sequence is remembered.
                            16512 ; 361  |//   To find out what range your player supports: 
                            16513 ; 362  |//   change these equs to full range or comment out (full range is default)
                            16514 ; 363  |//;;;;;;
                            16515 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                            16516 ; 365  |// recommended calibration using player -- uncomment 
                            16517 ; 366  |//;;;;;;
                            16518 ; 367  |//CONTRAST_CALIBRATION    equ  1
                            16519 ; 368  |////////////////////////////
                            16520 ; 369  |#if (defined(DEMO_HW))
                            16521 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi LCD (June6'05)
                            16522 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                            16523 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                            16524 ; 373  |#else 
                            16525 ; 374  |
                            16526 ; 375  |#if (defined(S6B33B0A_LCD))
                            16527 ; 376  |#define LCD_MAX_CONTRAST 210
                            16528 ; 377  |#define LCD_MIN_CONTRAST 160    
                            16529 ; 378  |#endif
                            16530 ; 379  |
                            16531 ; 380  |#if (defined(SED15XX_LCD))
                            16532 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                            16533 ; 382  |// Engineering board regs support range [17-37].
                            16534 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                            16535 ; 384  |//   One default contrast range [24-42] works for both.
                            16536 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                            16537 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                            16538 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                            16539 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                            16540 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                            16541 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                            16542 ; 391  |
                            16543 ; 392  |#if (defined(NEWSHINGYIH))
                            16544 ; 393  |#define LCD_MAX_CONTRAST 250
                            16545 ; 394  |#define LCD_MIN_CONTRAST 0
                            16546 ; 395  |#else 
                            16547 ; 396  |//-----
                            16548 ; 397  |// Near optimal for OLD LCD with NEW file. 
                            16549 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for both LCDs.
                            16550 ; 399  |#define LCD_MAX_CONTRAST 250
                            16551 ; 400  |#define LCD_MIN_CONTRAST 0
                            16552 ; 401  |
                            16553 ; 402  |//=====
                            16554 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                            16555 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this historic ver.
                            16556 ; 405  |//LCD_MAX_CONTRAST equ 42
                            16557 ; 406  |//LCD_MIN_CONTRAST equ 24 
                            16558 ; 407  |
                            16559 ; 408  |#endif
                            16560 ; 409  |#endif
                            16561 ; 410  |
                            16562 ; 411  |#endif
                            16563 ; 412  |
                            16564 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                            16565 ; 414  |// The default value of the lcd contrast in % of range
                            16566 ; 415  |//   the default value is used when no settings.dat is available
                            16567 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                            16568 ; 417  |
                            16569 ; 418  |#if (defined(S6B33B0A_LCD))
                            16570 ; 419  |// 60% of range is default value
                            16571 ; 420  |#define DEFAULT_CONTRAST 50 
                            16572 ; 421  |#endif
                            16573 ; 422  |
                            16574 ; 423  |#if (defined(SED15XX_LCD))
                            16575 ; 424  |// % of range is default value (was 60%)
                            16576 ; 425  |#define DEFAULT_CONTRAST 50 
                            16577 ; 426  |#endif
                            16578 ; 427  |
                            16579 ; 428  |
                            16580 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                            16581 ; 430  |// make lower when doing calibration
                            16582 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                            16583 ; 432  |
                            16584 ; 433  |
                            16585 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                            16586 ; 435  |// For FFWD and RWND
                            16587 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                            16588 ; 437  |#define SECONDS_TO_SKIP 1
                            16589 ; 438  |#define SECONDS_TO_SKIP1 3
                            16590 ; 439  |#define SECONDS_TO_SKIP2 6
                            16591 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                            16592 ; 441  |#define PREV_SONG_THRESHOLD 5  
                            16593 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            16594 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                            16595 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            16596 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                            16597 ; 446  |
                            16598 ; 447  |// For audible FFW/RWD
                            16599 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                            16600 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                            16601 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                            16602 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                            16603 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            16604 ; 453  |#define LEVEL1_BOUNDARY 17 
                            16605 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            16606 ; 455  |#define LEVEL2_BOUNDARY 33 
                            16607 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            16608 ; 457  |#define LEVEL3_BOUNDARY 50 
                            16609 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                            16610 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                            16611 ; 460  |// Short Song Time, songs too short to play.
                            16612 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                            16613 ; 462  |
                            16614 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                            16615 ; 464  |// MP3 Sync Values
                            16616 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                            16617 ; 466  |// # bytes to look for sync before marking it bad
                            16618 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                            16619 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                            16620 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                            16621 ; 470  |// once we have sync'd, the isr should be called this frequently
                            16622 ; 471  |#define MP3_DECODERISR_FAST 7500  
                            16623 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                            16624 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                            16625 ; 474  |
                            16626 ; 475  |
                            16627 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                            16628 ; 477  |//// Multi-Stage Volume Control Definitions
                            16629 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                            16630 ; 479  |//// Use Multi-Stage Volume
                            16631 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                            16632 ; 481  |
                            16633 ; 482  |//// Master Volume definitions
                            16634 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                            16635 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                            16636 ; 485  |
                            16637 ; 486  |//// DAC-Mode definitions
                            16638 ; 487  |//// Adjusts 0dB point
                            16639 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                            16640 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                            16641 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines above.
                            16642 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                            16643 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provides 1.5 dB gain on Stmp34x0; 
                            16644 ; 493  |//                                               Max gain possible: 8 step diff would provide +12dB gain.   
                            16645 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                            16646 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                            16647 ; 496  |
                            16648 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                            16649 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                            16650 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                            16651 ; 500  |
                            16652 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not the default
                            16653 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoint.
                            16654 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                            16655 ; 504  |
                            16656 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the default
                            16657 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                            16658 ; 507  |
                            16659 ; 508  |
                            16660 ; 509  |//// Line In definitions (used for Line-In 1)
                            16661 ; 510  |//// 0dB point of the Line In
                            16662 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                            16663 ; 512  |//// Minimum volume of Line In
                            16664 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                            16665 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                            16666 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                            16667 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                            16668 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                            16669 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS+1)
                            16670 ; 519  |
                            16671 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                            16672 ; 521  |//// 0dB point of the Line In
                            16673 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                            16674 ; 523  |//// Minimum volume of Line In
                            16675 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                            16676 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                            16677 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                            16678 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                            16679 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                            16680 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                            16681 ; 530  |
                            16682 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                            16683 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid deadlock states & recovers. 
                            16684 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                            16685 ; 534  |#define FM_WATCHDOG_ENABLE 1
                            16686 ; 535  |
                            16687 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                            16688 ; 537  |////
                            16689 ; 538  |////! This varible holds the lcd display state for the mtp project.
                            16690 ; 539  |////
                            16691 ; 540  |///
                            16692 ; 541  |#include <types.h>
                            16693 ; 542  |extern volatile WORD g_wActivityState;
                            16694 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                            16695 ; 544  |
                            16696 ; 545  |void _reentrant Init5VSense(void);
                            16697 ; 546  |void _reentrant ServiceDCDC(void);
                            16698 ; 547  |
                            16699 ; 548  |////////////////////////////////////////////////////////////////////////////
                            16700 ; 549  |//// JPEG Thumbnail Mode Setting
                            16701 ; 550  |//// number of column in thumbnail mode
                            16702 ; 551  |#define THUMBNAIL_X 2           
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  66

M:ADDR CODE           CYCLES LINE SOURCELINE
                            16703 ; 552  |//// number of row in  thumbnail mode
                            16704 ; 553  |#define THUMBNAIL_Y 2           
                            16705 ; 554  |//// thumbnail boundary offset x
                            16706 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                            16707 ; 556  |//// thumbnail boundary offset y
                            16708 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                            16709 ; 558  |
                            16710 ; 559  |#endif // if (!@def(_PROJECT_INC))
                            16711 ; 560  |
                            16712 
                            16714 
                            16715 ; 5    |
                            16716 ; 6    |#include "filesystem.h"
                            16717 
                            16719 
                            16720 ; 1    |////////////////////////////////////////////////////////////////////////////////
                            16721 ; 2    |//  Copyright(C) SigmaTel, Inc. 2001
                            16722 ; 3    |//
                            16723 ; 4    |//  File        : FileSystem.h
                            16724 ; 5    |//  Description : Header File for File System
                            16725 ; 6    |////////////////////////////////////////////////////////////////////////////////
                            16726 ; 7    |
                            16727 ; 8    |#ifndef _FILESYSTEM_H
                            16728 ; 9    |#define _FILESYSTEM_H
                            16729 ; 10   |
                            16730 ; 11   |#include "types.h"
                            16731 ; 12   |
                            16732 ; 13   |
                            16733 ; 14   |// File attributes
                            16734 ; 15   |#ifndef _FS_ATTRIBUTES
                            16735 ; 16   |#define _FS_ATTRIBUTES
                            16736 ; 17   |#define READ        1
                            16737 ; 18   |#define WRITE       2
                            16738 ; 19   |#define WRITE_PLUS  3
                            16739 ; 20   |#define APPEND      4
                            16740 ; 21   |#define TRUNCATE    8
                            16741 ; 22   |#define CREATE      16
                            16742 ; 23   |#endif
                            16743 ; 24   |
                            16744 ; 25   |//#ifndef FAT12
                            16745 ; 26   |//#define FAT12   1
                            16746 ; 27   |//#endif
                            16747 ; 28   |//
                            16748 ; 29   |#ifndef FAT16
                            16749 ; 30   |#define FAT16   2
                            16750 ; 31   |#endif
                            16751 ; 32   |
                            16752 ; 33   |#define MEM_SPACE_P 0x100000
                            16753 ; 34   |#define MEM_SPACE_Y 0x400000
                            16754 ; 35   |#define MEM_SPACE_X 0x800000
                            16755 ; 36   |
                            16756 ; 37   |#define FILE_SYS_MODE_READ  0
                            16757 ; 38   |#define FILE_SYS_MODE_WRITE 1
                            16758 ; 39   | 
                            16759 ; 40   |#define ATTR_READ_ONLY      0x01
                            16760 ; 41   |#define ATTR_HIDDEN         0x02
                            16761 ; 42   |#define ATTR_SYSTEM         0x04
                            16762 ; 43   |#define ATTR_VOLUME_ID      0x08
                            16763 ; 44   |#define ATTR_DIRECTORY      0x10
                            16764 ; 45   |#define ATTR_ARCHIVE        0x20
                            16765 ; 46   |#define ATTR_LONG_NAME      ATTR_READ_ONLY|ATTR_HIDDEN|ATTR_SYSTEM|ATTR_VOLUME_ID
                            16766 ; 47   |
                            16767 ; 48   |#define SEEK_SET           -1
                            16768 ; 49   |#define SEEK_CUR            0
                            16769 ; 50   |#define SEEK_END            1
                            16770 ; 51   |
                            16771 ; 52   |#define DEVICE_INSTALLED              (WORD)(0)
                            16772 ; 53   |#define DEVICE_NOT_FOUND              (WORD)(2)
                            16773 ; 54   |#define INVALID_FILESYSTEM                        (WORD)(3)
                            16774 ; 55   |#define DEVICE_INVALID                (WORD)(-1)
                            16775 ; 56   |#define DEVICE_ERROR_WRITE_PROTECTED  (WORD)(-2)
                            16776 ; 57   |
                            16777 ; 58   |#define MEDIA_SIZE_TOTAL_SECTORS    0
                            16778 ; 59   |#define MEDIA_SIZE_TOTAL_BYTES      1
                            16779 ; 60   |#define MEDIA_SIZE_BYTES_PER_SECTOR 2
                            16780 ; 61   |#define MEDIA_SIZE_IN_MEGABYTES     3     
                            16781 ; 62   |
                            16782 ; 63   |#define READ_TYPE_NORMAL            0
                            16783 ; 64   |#define READ_TYPE_FAT               1
                            16784 ; 65   |#define READ_TYPE_RAW               2
                            16785 ; 66   |
                            16786 ; 67   |
                            16787 ; 68   |#ifdef MEDIA_DDI_PARTIAL_SEQ_ENABLE
                            16788 ; 69   |    #define WRITE_TYPE_RANDOM                   0
                            16789 ; 70   |    #define WRITE_TYPE_SEQ_FIRST                1
                            16790 ; 71   |    #define WRITE_TYPE_SEQ_NEXT                 2
                            16791 ; 72   |    #define WRITE_TYPE_RESET_CLEAN_UP           3
                            16792 ; 73   |    #define WRITE_TYPE_PARTIAL_SEQ_FIRST        4
                            16793 ; 74   |    #define WRITE_TYPE_PARTIAL_SEQ_NEXT         5
                            16794 ; 75   |    #define WRITE_TYPE_PARTIAL_SEQ_LAST         6
                            16795 ; 76   |    #ifdef MEDIA_DDI_RAW_SECTOR_SERVER_ENABLE
                            16796 ; 77   |        #define WRITE_TYPE_RANDOM_RAW               7
                            16797 ; 78   |        #define WRITE_TYPE_SEQ_FIRST_RAW            8
                            16798 ; 79   |        #define WRITE_TYPE_SEQ_NEXT_RAW             9
                            16799 ; 80   |        #define WRITE_TYPE_PARTIAL_SEQ_FIRST_RAW    10
                            16800 ; 81   |        #define WRITE_TYPE_PARTIAL_SEQ_NEXT_RAW     11
                            16801 ; 82   |        #define WRITE_TYPE_PARTIAL_SEQ_LAST_RAW     12
                            16802 ; 83   |    #endif
                            16803 ; 84   |#else
                            16804 ; 85   |    #define WRITE_TYPE_RANDOM                   0
                            16805 ; 86   |    #define WRITE_TYPE_SEQ_FIRST                1
                            16806 ; 87   |    #define WRITE_TYPE_SEQ_NEXT                 2
                            16807 ; 88   |    #ifdef MEDIA_DDI_RAW_SECTOR_SERVER_ENABLE
                            16808 ; 89   |        #define WRITE_TYPE_RANDOM_RAW               3
                            16809 ; 90   |        #define WRITE_TYPE_SEQ_FIRST_RAW            4
                            16810 ; 91   |        #define WRITE_TYPE_SEQ_NEXT_RAW             5
                            16811 ; 92   |    #endif
                            16812 ; 93   |#endif
                            16813 ; 94   |    #define WRITE_TYPE_UNDEFINED 0xFFFFFF
                            16814 ; 95   |
                            16815 ; 96   |
                            16816 ; 97   |#ifndef MAX_FILENAME_LENGTH
                            16817 ; 98   |#define MAX_FILENAME_LENGTH 256
                            16818 ; 99   |#endif
                            16819 ; 100  |
                            16820 ; 101  |typedef struct {
                            16821 ; 102  |    WORD wNumberOfZones;
                            16822 ; 103  |    WORD wSizeInMegaBytes;
                            16823 ; 104  |} SMARTMEDIA_CHIP_INFO;
                            16824 ; 105  |
                            16825 ; 106  |typedef struct {
                            16826 ; 107  |    WORD wBootIdentification;
                            16827 ; 108  |    WORD wStartHeadNumber;
                            16828 ; 109  |    WORD wStartSectorNumber;
                            16829 ; 110  |    WORD wStartCylinderNumber;
                            16830 ; 111  |    WORD wSystemIdentification;
                            16831 ; 112  |    WORD wEndHeadNumber;
                            16832 ; 113  |    WORD wEndSectorNumber;
                            16833 ; 114  |    WORD wEndCylinderNumber;
                            16834 ; 115  |    WORD wStartLogicalSectorNumberHigh;
                            16835 ; 116  |    WORD wStartLogicalSectorNumberLow;
                            16836 ; 117  |    WORD wPartitionSizeHigh;
                            16837 ; 118  |    WORD wPartitionSizeLow;
                            16838 ; 119  |} SMARTMEDIA_PARTITION_TABLE;
                            16839 ; 120  |
                            16840 ; 121  |typedef struct {
                            16841 ; 122  |    WORD wWord0;
                            16842 ; 123  |    WORD wWord1;
                            16843 ; 124  |    WORD wWord2;
                            16844 ; 125  |} SMARTMEDIA_CIS_IDI_MANUFACTURER_NAME;
                            16845 ; 126  |
                            16846 ; 127  |typedef struct {
                            16847 ; 128  |    WORD wWord0;
                            16848 ; 129  |    WORD wWord1;
                            16849 ; 130  |} SMARTMEDIA_CIS_IDI_PRODUCT_NAME;
                            16850 ; 131  |
                            16851 ; 132  |typedef struct {
                            16852 ; 133  |    WORD wWord0;
                            16853 ; 134  |    WORD wWord1;
                            16854 ; 135  |} SMARTMEDIA_CIS_IDI_PRODUCT_VERSION;
                            16855 ; 136  |
                            16856 ; 137  |typedef struct {
                            16857 ; 138  |    WORD wWord0;
                            16858 ; 139  |    WORD wWord1;
                            16859 ; 140  |    WORD wWord2;
                            16860 ; 141  |    WORD wWord3;
                            16861 ; 142  |} SMARTMEDIA_CIS_IDI_SERIAL_NUMBER;
                            16862 ; 143  |
                            16863 ; 144  |typedef struct {
                            16864 ; 145  |    WORD wWord0;
                            16865 ; 146  |} SMARTMEDIA_CIS_IDI_MODEL_NUMBER;
                            16866 ; 147  |
                            16867 ; 148  |typedef struct {
                            16868 ; 149  |    SMARTMEDIA_CIS_IDI_MANUFACTURER_NAME ManufacturerName;
                            16869 ; 150  |    SMARTMEDIA_CIS_IDI_PRODUCT_NAME ProductName;
                            16870 ; 151  |    SMARTMEDIA_CIS_IDI_PRODUCT_VERSION ProductVersion;
                            16871 ; 152  |    SMARTMEDIA_CIS_IDI_SERIAL_NUMBER SerialNumber;
                            16872 ; 153  |    SMARTMEDIA_CIS_IDI_MODEL_NUMBER ModelNumber;
                            16873 ; 154  |} SMARTMEDIA_CIS_IDI_TABLE;
                            16874 ; 155  |   
                            16875 ; 156  |typedef struct {
                            16876 ; 157  |    WORD wPageSizeInBytes;
                            16877 ; 158  |    WORD wRedundantAreaSizeInBytes;
                            16878 ; 159  |    WORD wNumberOfPagesPerBlock;
                            16879 ; 160  |    WORD wNumberOfBlocksPerZone;
                            16880 ; 161  |    WORD wNumberOfZonesInMedia;
                            16881 ; 162  |    WORD wMediaSizeInMBytes;
                            16882 ; 163  |    SMARTMEDIA_PARTITION_TABLE * pPartitionTable;
                            16883 ; 164  |    SMARTMEDIA_CIS_IDI_TABLE * pCisIdiTable;
                            16884 ; 165  |    WORD wMediaFlagStatus;
                            16885 ; 166  |    WORD wNumberOfBlocksToTheCisIdiBlock;
                            16886 ; 167  |    WORD wTotalNumberOfPhysicalBlocks;
                            16887 ; 168  |    WORD wNumberOfSystemBlocks;
                            16888 ; 169  |} SMARTMEDIA_ENTRY_TABLE;
                            16889 ; 170  |
                            16890 ; 171  |typedef struct {
                            16891 ; 172  |    WORD wDevice;        
                            16892 ; 173  |    WORD wDirtyBlockFlag;
                            16893 ; 174  |    WORD wCleanTailFlag; 
                            16894 ; 175  |    WORD wLogDOSPage;    
                            16895 ; 176  |    WORD wSrcLogBlock;   
                            16896 ; 177  |    WORD wSrcPhyBlock;   
                            16897 ; 178  |    WORD wDestPhyBlock;  
                            16898 ; 179  |    WORD wStartSrcPage;  
                            16899 ; 180  |    WORD wStartDestPage; 
                            16900 ; 181  |    WORD wPagesToCopy;   
                            16901 ; 182  |    WORD wReplaceBuff;   
                            16902 ; 183  |    WORD wReplaceRdnt;
                            16903 ; 184  |    #ifdef MEDIA_DDI_PARTIAL_SEQ_ENABLE
                            16904 ; 185  |        WORD wFirstCount;
                            16905 ; 186  |        WORD wNextCount;
                            16906 ; 187  |        WORD wLastCount;
                            16907 ; 188  |    #endif
                            16908 ; 189  |} SMARTMEDIA_FWPPS_TABLE;
                            16909 ; 190  |
                            16910 ; 191  |typedef struct {
                            16911 ; 192  |    WORD wWord0;
                            16912 ; 193  |    WORD wWord1;
                            16913 ; 194  |    WORD wWord2;
                            16914 ; 195  |    WORD wWord3;
                            16915 ; 196  |} DIRECTORY_NAME;
                            16916 ; 197  |
                            16917 ; 198  |typedef struct {
                            16918 ; 199  |    WORD wWord0;
                            16919 ; 200  |    WORD wWord1;
                            16920 ; 201  |} DIRECTORY_EXTENSION;
                            16921 ; 202  |
                            16922 ; 203  |typedef struct {
                            16923 ; 204  |    WORD wWord0;
                            16924 ; 205  |    WORD wWord1;
                            16925 ; 206  |} DIRECTORY_SIZE;
                            16926 ; 207  |
                            16927 ; 208  |typedef struct {
                            16928 ; 209  |    DIRECTORY_NAME Name;
                            16929 ; 210  |    DIRECTORY_EXTENSION Extension;
                            16930 ; 211  |    WORD wAttribute;
                            16931 ; 212  |    WORD wReserved[4];
                            16932 ; 213  |    WORD wCreationTime;
                            16933 ; 214  |    WORD wCreationData;
                            16934 ; 215  |    WORD wFirstCluster;
                            16935 ; 216  |    DIRECTORY_SIZE Size;
                            16936 ; 217  |    WORD wCurrentCluster;
                            16937 ; 218  |    WORD wPointer;
                            16938 ; 219  |    WORD wRecord;
                            16939 ; 220  |    WORD wRd;
                            16940 ; 221  |} DIRECTORY_FILE_CONTROL_BLOCK;
                            16941 ; 222  |
                            16942 ; 223  |// TODO:  clean this up.  There are two versions.
                            16943 ; 224  |struct FCB
                            16944 ; 225  |{
                            16945 ; 226  |    _packed BYTE m_szFileName[9];       //0-2
                            16946 ; 227  |    int     m_wReserved;                //3
                            16947 ; 228  |    _packed BYTE m_szExt[4];            //4-5
                            16948 ; 229  |    int     m_wAttributes;              //6
                            16949 ; 230  |    int     m_wReserved2[4];            //7,8,9,a
                            16950 ; 231  |    int     m_wTimeofCreation;          //b
                            16951 ; 232  |    int     m_wDateofCreation;          //c
                            16952 ; 233  |    int     m_wFirstCluster;            //d
                            16953 ; 234  |    int     m_wFileSizeHigh;            //e
                            16954 ; 235  |    int     m_wFileSizeLow;             //f
                            16955 ; 236  |};
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  67

M:ADDR CODE           CYCLES LINE SOURCELINE
                            16956 ; 237  |
                            16957 ; 238  |
                            16958 ; 239  |typedef struct {
                            16959 ; 240  |    WORD wFirstClusterCurrentDirectory;
                            16960 ; 241  |    WORD wFirstClusterParentDirectory;
                            16961 ; 242  |    WORD wAbsSectorCurrentlyCached;
                            16962 ; 243  |    WORD wCurrentRelativeSector;
                            16963 ; 244  |    WORD wNumberOfSectors;
                            16964 ; 245  |    WORD wCurrentRecordLoadedInDcb;
                            16965 ; 246  |    WORD wBufferedRecord;
                            16966 ; 247  |    WORD wMaxNumberRecordsCurrentDirectory;
                            16967 ; 248  |    WORD * pwPointerToBuffer;
                            16968 ; 249  |    WORD * pwPointerToPath;
                            16969 ; 250  |    DIRECTORY_FILE_CONTROL_BLOCK * pDirFcb;
                            16970 ; 251  |} DIRECTORY_CONTROL_BLOCK;
                            16971 ; 252  |
                            16972 ; 253  |typedef struct {
                            16973 ; 254  |    WORD wWord0;
                            16974 ; 255  |    WORD wWord1;
                            16975 ; 256  |    WORD wWord2;
                            16976 ; 257  |    WORD wWord3;
                            16977 ; 258  |} FILE_NAME;
                            16978 ; 259  |
                            16979 ; 260  |typedef struct {
                            16980 ; 261  |    WORD wWord0;
                            16981 ; 262  |    WORD wWord1;
                            16982 ; 263  |} FILE_EXTENSION;
                            16983 ; 264  |
                            16984 ; 265  |typedef struct {
                            16985 ; 266  |    WORD wWord0;
                            16986 ; 267  |    WORD wWord1;
                            16987 ; 268  |} FILE_SIZE;
                            16988 ; 269  |
                            16989 ; 270  |typedef union {
                            16990 ; 271  |    struct {
                            16991 ; 272  |        int Read        :1;
                            16992 ; 273  |        int Write       :1;
                            16993 ; 274  |        int Append      :1;
                            16994 ; 275  |        int Truncate    :1;
                            16995 ; 276  |        int Create      :1;
                            16996 ; 277  |        int Rsrv        :3;
                            16997 ; 278  |        int Mode        :8;
                            16998 ; 279  |        int Device      :8;
                            16999 ; 280  |    } B;
                            17000 ; 281  |    int I;
                            17001 ; 282  |} FILE_FLAGS;
                            17002 ; 283  |
                            17003 ; 284  |typedef struct {
                            17004 ; 285  |    WORD wWord0;
                            17005 ; 286  |    WORD wWord1;
                            17006 ; 287  |} FILE_BYTE_CURRENT;
                            17007 ; 288  |
                            17008 ; 289  |typedef struct {
                            17009 ; 290  |    FILE_NAME Name;
                            17010 ; 291  |    FILE_EXTENSION Extension;
                            17011 ; 292  |    WORD wAttributes;
                            17012 ; 293  |    WORD wReserved[4];
                            17013 ; 294  |    WORD wCreationTime;
                            17014 ; 295  |    WORD wCreationData;
                            17015 ; 296  |    WORD wFirstCluster;
                            17016 ; 297  |    FILE_SIZE Size;
                            17017 ; 298  |    WORD wCurrentCluster;
                            17018 ; 299  |    WORD wPointer;
                            17019 ; 300  |    WORD wRecord;
                            17020 ; 301  |    WORD wRd;
                            17021 ; 302  |    FILE_FLAGS Flags;
                            17022 ; 303  |    FILE_BYTE_CURRENT FcbByteCurrent;
                            17023 ; 304  |    WORD wFcbFlagEndOfCx;
                            17024 ; 305  |} FILE_CONTROL_BLOCK;    
                            17025 ; 306  |
                            17026 ; 307  |typedef struct {
                            17027 ; 308  |    WORD wWord0;
                            17028 ; 309  |    WORD wWord1;
                            17029 ; 310  |    WORD wWord2;
                            17030 ; 311  |    WORD wWord3;
                            17031 ; 312  |} VOLUME_LABEL;
                            17032 ; 313  |
                            17033 ; 314  |typedef struct {
                            17034 ; 315  |    WORD wFATPhysicalBlock1;
                            17035 ; 316  |    WORD wFATPhysicalBlock2;
                            17036 ; 317  |    WORD wFATPhysicalBlock3;
                            17037 ; 318  |    WORD wFATPhysicalBlock4;
                            17038 ; 319  |} FAT_PHYSICAL_BLOCK_LIST;
                            17039 ; 320  |
                            17040 ; 321  |typedef struct {
                            17041 ; 322  |    WORD wFATSectorInCache;
                            17042 ; 323  |    WORD wLastClusterFree;
                            17043 ; 324  |    WORD wNumberOfUsedClusters;
                            17044 ; 325  |    WORD wNumberOfFreeClusters;
                            17045 ; 326  |    WORD wNumberOfBadClusters;
                            17046 ; 327  |    WORD wNumberOfReservedClusters;
                            17047 ; 328  |    WORD wControl;
                            17048 ; 329  |    WORD * pwSectorCache;
                            17049 ; 330  |    FAT_PHYSICAL_BLOCK_LIST FATPhysicalLocationList;
                            17050 ; 331  |} FAT_TABLE;
                            17051 ; 332  |
                            17052 ; 333  |typedef struct {
                            17053 ; 334  |    WORD wStateMediaTable;
                            17054 ; 335  |    WORD wTypeFs;
                            17055 ; 336  |    WORD wBytesPerSector;
                            17056 ; 337  |    WORD wSectorsPerCluster;
                            17057 ; 338  |    WORD wNumberOfReservedSectors;
                            17058 ; 339  |    WORD wMaximumNumberOfFATs;
                            17059 ; 340  |    WORD wMaxRootDirectoryEntries;
                            17060 ; 341  |    WORD wTotalSectors;
                            17061 ; 342  |    WORD wNumberOfFATSectors;
                            17062 ; 343  |    WORD wNumberOfSectorsPerTrack;
                            17063 ; 344  |    WORD wNumberOfHeads;
                            17064 ; 345  |    WORD wNumberOfHiddenSectorsMSB;
                            17065 ; 346  |    WORD wNumberOfHiddenSectorsLSB;
                            17066 ; 347  |    WORD wTotalSectors32MSB;
                            17067 ; 348  |    WORD wTotalSectors32LSB;
                            17068 ; 349  |    WORD wDriverNumber;
                            17069 ; 350  |    WORD wExtendedBootSignature;
                            17070 ; 351  |    WORD wVolumeIDMSB;
                            17071 ; 352  |    WORD wVolumeIDLSB;
                            17072 ; 353  |    VOLUME_LABEL VolumeLabel;
                            17073 ; 354  |    WORD * pwWriteBuffer;
                            17074 ; 355  |    WORD wPrimaryFATRelativeSector;
                            17075 ; 356  |    WORD wSecondaryFATRelativeSector;
                            17076 ; 357  |    WORD wRootDirectoryRelativeSector;
                            17077 ; 358  |    WORD wFirstSectorNumberDataZone;
                            17078 ; 359  |    WORD wMaxNumberOfFATEntries;
                            17079 ; 360  |    WORD wRootDirectorySizeInSectors;
                            17080 ; 361  |    WORD wDataAreaSizeInSectors;
                            17081 ; 362  |} MEDIA_TABLE;
                            17082 ; 363  |
                            17083 ; 364  |typedef struct {
                            17084 ; 365  |    MEDIA_TABLE * pMediaTable;
                            17085 ; 366  |    DIRECTORY_CONTROL_BLOCK * pDirectoryControlBlock;
                            17086 ; 367  |    FAT_TABLE * pFATTable;
                            17087 ; 368  |} DEVICE_CONTROL_TABLE;
                            17088 ; 369  |    
                            17089 ; 370  |typedef struct {
                            17090 ; 371  |    WORD dwTotalSizeInMegaBytes;        // dwTotalSizeInMegaBytes is limited
                            17091 ; 372  |                                        //  to 2-bytes for compatibility with
                            17092 ; 373  |                                        //  older host drivers.
                            17093 ; 374  |    DWORD dwTotalNumberOfSectors;
                            17094 ; 375  |    DWORD dwTotalNumberOfBytes;
                            17095 ; 376  |    WORD wSectorSizeInBytes;
                            17096 ; 377  |} MEDIA_SIZE;
                            17097 ; 378  |
                            17098 ; 379  |typedef struct {
                            17099 ; 380  |    BOOL    bInstalled;
                            17100 ; 381  |    INT     iPbsSectorOffset;   // from the beginning of the data drive 
                            17101 ; 382  |    DWORD   dwSize;
                            17102 ; 383  |} DATA_DRIVE_PBS_LOC;
                            17103 ; 384  |extern  INT _reentrant FSFileOpen(_packed BYTE *fname,INT attribute, INT DeviceNumber);
                            17104 ; 385  |extern  INT _reentrant FSFastOpen(DWORD Key, INT attribute);
                            17105 ; 386  |extern  INT FSFileDelete(_packed BYTE *fname,INT DeviceNumber);
                            17106 ; 387  |extern  INT FSFileCreate(_packed BYTE *fname,INT DeviceNumber);
                            17107 ; 388  |extern  INT _reentrant FSChangeDir(_packed BYTE *dirname,INT DeviceNumber);
                            17108 ; 389  |extern  INT _reentrant FSCreateDir(_packed BYTE *dirname,INT DeviceNumber);
                            17109 ; 390  |extern  INT _reentrant FSDeleteDir(_packed BYTE *dirname,INT DeviceNumber);
                            17110 ; 391  |extern  INT _reentrant FSFileAppend(_packed BYTE *fname,INT DeviceNumber);
                            17111 ; 392  |extern  INT _reentrant FSFileRead(INT BytestoRead, INT Handle, INT memory_type, INT modulo, WORD *buffer);
                            17112 ; 393  |extern  INT _reentrant FSFileWrite(INT wNumberBytes, INT Handle, INT memory_type, INT iModulo, WORD *buffer);
                            17113 ; 394  |extern  INT _reentrant FSFileClose(INT Handle);
                            17114 ; 395  |extern  LONG _reentrant FSFileSize(INT HandleNumber);
                            17115 ; 396  |extern  LONG  FSSize(INT DeviceNum, INT TYPE);   
                            17116 ; 397  |extern  INT FSFreeClusters(INT Device);
                            17117 ; 398  |extern  INT BytesPerCluster(INT Device);
                            17118 ; 399  |
                            17119 ; 400  |
                            17120 ; 401  |
                            17121 ; 402  |//extern  INT FSFileCreate(_packed BYTE *pbFileName, BYTE bDevice);
                            17122 ; 403  |//extern  INT FSFileDelete(_packed BYTE *pbFileName, BYTE bDevice);
                            17123 ; 404  |extern  INT FSFileRename(_packed BYTE *pbCurFilename, _packed BYTE *pbNewFilename, BYTE bDevice);
                            17124 ; 405  |//extern  INT _reentrant FSFileAttribute(_packed BYTE *pbFilename, WORD wAttributes, BYTE bDevice);
                            17125 ; 406  |//extern  INT FSFileAppend(_packed BYTE *pbFileName, BYTE bDevice);
                            17126 ; 407  |//extern  INT FSFileOpen(_packed BYTE *pbFileName, WORD wAttributes, BYTE bDevice);
                            17127 ; 408  |//extern  INT FSFileClose(INT bHandle);
                            17128 ; 409  |//extern  INT FSFileRead(WORD wNumberBytes, BYTE bHandle, WORD wMemSpace, INT iModulo, WORD *pwBuffer);
                            17129 ; 410  |//extern  INT FSFileWrite(WORD wNumberBytes, BYTE bHandle, WORD wMemSpace, INT iModulo, WORD *pwBuffer);
                            17130 ; 411  |extern  INT _reentrant fseek( INT handle , LONG offset, INT iOrigin );
                            17131 ; 412  |extern  INT _reentrant FSFileEof(INT Handle);
                            17132 ; 413  |extern INT _reentrant FSFileAttribute(INT Attributes, _packed BYTE *fname, INT DeviceNumber);
                            17133 ; 414  |extern INT _reentrant FSFileAttributeClear(INT Attributes, _packed BYTE *fname, INT DeviceNumber);
                            17134 ; 415  |//extern  LONG FSFileSize(INT bHandle);
                            17135 ; 416  |extern _asmfunc INT FSPresent(BYTE bDevice);
                            17136 ; 417  |extern _asmfunc INT FSType(BYTE bDevice);
                            17137 ; 418  |//extern LONG FSSize(WORD wDevice, WORD wReturnType);
                            17138 ; 419  |//extern INT FSChangeDir(_packed BYTE *pbDirName, BYTE bDevice);
                            17139 ; 420  |//extern INT FSCreateDir(_packed BYTE *pbDirName, BYTE bDevice);
                            17140 ; 421  |//extern INT FSDeleteDir(_packed BYTE *pbDirName, BYTE bDevice);
                            17141 ; 422  |extern _asmfunc void SysLoadFATWrite(void);
                            17142 ; 423  |extern _asmfunc INT SysUnLoadFATWrite(void);
                            17143 ; 424  |extern LONG _reentrant ftell(INT iHandle);
                            17144 ; 425  |extern _asmfunc struct FCB * ReadDirectory(int iDevice, int iEntry);
                            17145 ; 426  |
                            17146 ; 427  |#endif
                            17147 
                            17149 
                            17150 ; 7    |#include "metadata.h"
                            17151 
                            17153 
                            17154 ; 1    |////////////////////////////////////////////////////////////////////////////////
                            17155 ; 2    |// Copyright(C) SigmaTel, Inc. 2002
                            17156 ; 3    |//
                            17157 ; 4    |// Filename: metadata.h
                            17158 ; 5    |// Description:
                            17159 ; 6    |////////////////////////////////////////////////////////////////////////////////
                            17160 ; 7    |
                            17161 ; 8    |#ifndef _METADATA_H
                            17162 ; 9    |#define _METADATA_H
                            17163 ; 10   |
                            17164 ; 11   |///////////////////////////////////////////////////////////////////////////////
                            17165 ; 12   |// MetaData definitions
                            17166 ; 13   |///////////////////////////////////////////////////////////////////////////////
                            17167 ; 14   |
                            17168 ; 15   |//#define MMC_CMD59       0x40|59
                            17169 ; 16   |
                            17170 ; 17   |///////////////////////////////////////////////////////////////////////////////
                            17171 ; 18   |// Meta Data structure definitions
                            17172 ; 19   |///////////////////////////////////////////////////////////////////////////////
                            17173 ; 20   |
                            17174 ; 21   |///////////////////////////////////////////////////////////////////////////////
                            17175 ; 22   |// MetaData definitions
                            17176 ; 23   |
                            17177 ; 24   |#define META_DATA_FOUND                     (WORD)(0)
                            17178 ; 25   |#define META_DATA_NOT_FOUND                 (WORD)(0x100)
                            17179 ; 26   |#define META_DATA_FILE_NOT_SUPPORTED        (WORD)(0x101)
                            17180 ; 27   |#define META_DATA_FILEOPEN_ERROR            (WORD)(0x200)
                            17181 ; 28   |#define META_DATA_FILEREAD_ERROR            (WORD)(0x201)
                            17182 ; 29   |#define META_DATA_FILECLOSE_ERROR           (WORD)(0x202)
                            17183 ; 30   |#define META_DATA_FILESEEK_ERROR            (WORD)(0x203)
                            17184 ; 31   |#define META_DATA_FILEWRITE_ERROR           (WORD)(0x204)
                            17185 ; 32   |#define META_DATA_SUCCESS                               (WORD)(0x205)
                            17186 ; 33   |
                            17187 ; 34   |#define META_DATA_NOT_VBR_FORMAT            (WORD)(0x102)
                            17188 ; 35   |
                            17189 ; 36   |// VBR
                            17190 ; 37   |#define VBR_NOT_DETERMINED 0
                            17191 ; 38   |#define VBR_TRUE 1
                            17192 ; 39   |
                            17193 ; 40   |#ifndef TITLE_SIZE
                            17194 ; 41   |//#define TITLE_SIZE 30
                            17195 ; 42   |#ifndef USE_PLAYLIST3
                            17196 ; 43   |#define TITLE_SIZE 256          //was 30 but LFNs require up to 256!
                            17197 ; 44   |#else
                            17198 ; 45   |#define TITLE_SIZE 80           //was 256 but music library only store up to 129!
                            17199 ; 46   |#endif
                            17200 ; 47   |#endif
                            17201 ; 48   |
                            17202 ; 49   |#ifndef ARTIST_SIZE
                            17203 ; 50   |#ifndef USE_PLAYLIST3
                            17204 ; 51   |//#define ARTIST_SIZE 30
                            17205 ; 52   |#define ARTIST_SIZE 100         // increase artist size for use with ID3V2 tags (Stmp00003110)
                            17206 ; 53   |#else
                            17207 ; 54   |#define ARTIST_SIZE 48          // increase artist size for use with ID3V2 tags (Stmp00003110)
                            17208 ; 55   |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  68

M:ADDR CODE           CYCLES LINE SOURCELINE
                            17209 ; 56   |#endif
                            17210 ; 57   |
                            17211 ; 58   |#ifndef ALBUM_SIZE
                            17212 ; 59   |#ifndef USE_PLAYLIST3
                            17213 ; 60   |//#define ALBUM_SIZE 30
                            17214 ; 61   |#define ALBUM_SIZE 50           // increase album size (not as much) for use with ID3V2 tags (Stmp00003110)
                            17215 ; 62   |#else
                            17216 ; 63   |#define ALBUM_SIZE 48           // increase album size (not as much) for use with ID3V2 tags (Stmp00003110)
                            17217 ; 64   |#endif
                            17218 ; 65   |#endif
                            17219 ; 66   |
                            17220 ; 67   |#ifdef USE_PLAYLIST3
                            17221 ; 68   |#ifndef GENRE_SIZE
                            17222 ; 69   |#define GENRE_SIZE 20
                            17223 ; 70   |#endif
                            17224 ; 71   |
                            17225 ; 72   |#ifndef YEAR_SIZE
                            17226 ; 73   |#define YEAR_SIZE 8
                            17227 ; 74   |#endif
                            17228 ; 75   |
                            17229 ; 76   |#ifndef TRACKNUM_SIZE
                            17230 ; 77   |#define TRACKNUM_SIZE 5 // assume track number is smaller than 0xfff (12bit or 4095)
                            17231 ; 78   |#endif
                            17232 ; 79   |
                            17233 ; 80   |#define MAX_TRACK_NUMBER 0x000fff
                            17234 ; 81   |#define UNKNOWN_TRACK_NUMBER MAX_TRACK_NUMBER
                            17235 ; 82   |#endif
                            17236 ; 83   |
                            17237 ; 84   |#define XING_TOC_SIZE   100
                            17238 ; 85   |#if MTP_BUILD
                            17239 ; 86   |// This size is used to build table for FF/RW for vbr songs,
                            17240 ; 87   |// and as there is no such function in mtp mode, it is reduced to release y-memory.
                            17241 ; 88   |#define VBR_TOC_SIZE    2
                            17242 ; 89   |#else
                            17243 ; 90   |#define VBR_TOC_SIZE    200
                            17244 ; 91   |#endif
                            17245 ; 92   |
                            17246 ; 93   |extern UCS3 g_wSongTitle[TITLE_SIZE];
                            17247 ; 94   |extern UCS3 g_wSongArtist[ARTIST_SIZE];
                            17248 ; 95   |extern UCS3 g_wSongAlbum[ALBUM_SIZE];
                            17249 ; 96   |#ifdef USE_PLAYLIST3
                            17250 ; 97   |extern UCS3 g_wSongGenre[GENRE_SIZE];
                            17251 ; 98   |extern UCS3 g_wSongYear[YEAR_SIZE];
                            17252 ; 99   |extern WORD g_wSongTrackNum;
                            17253 ; 100  |#endif
                            17254 ; 101  |
                            17255 ; 102  |extern WORD g_wVBRTOCTable[VBR_TOC_SIZE];
                            17256 ; 103  |
                            17257 ; 104  |typedef struct {
                            17258 ; 105  |    WORD        iTitleBufferLength;
                            17259 ; 106  |        UCS3       *wTitle;        // Title of Song
                            17260 ; 107  |    WORD        iArtistBufferLength;
                            17261 ; 108  |    UCS3       *wArtist;
                            17262 ; 109  |    WORD        iAlbumBufferLength;
                            17263 ; 110  |    UCS3       *wAlbum;
                            17264 ; 111  |#ifdef USE_PLAYLIST3
                            17265 ; 112  |    WORD        iGenreBufferLength;
                            17266 ; 113  |    UCS3       *wGenre;
                            17267 ; 114  |    WORD        iYearBufferLength;
                            17268 ; 115  |    UCS3       *wYear;
                            17269 ; 116  |    WORD        wTrackNum;
                            17270 ; 117  |#endif
                            17271 ; 118  |    BYTE       btGenre;       // Genre of audio file -- if MP3, use the ID3v1 tag byte
                            17272 ; 119  |        WORD       wSampRate;     // Sample Rate of song (Hz)
                            17273 ; 120  |        WORD       wNumChannels;
                            17274 ; 121  |        WORD       wBitRate;      // Bitrate of song (for MP3 VBR, this will be first bitrate found)
                            17275 ; 122  |        LONG       iTime;                 // Length of song in seconds
                            17276 ; 123  |        DWORD      dwStartPos;    // Position where audio starts. (if required by the decoder)
                            17277 ; 124  |        DWORD      dwNumBytes;    // Total Bytes in audio part of song
                            17278 ; 125  |    DWORD      dwDataBytes;   // for wma; (total bytes - header bytes)
                            17279 ; 126  |        DWORD      dwNumFrames;   // See note below on frames
                            17280 ; 127  |        BOOL       bVBR;                  // 0 = CBR or does not apply , 1 = VBR (**see question below**)
                            17281 ; 128  |        INT                iFileType;     // 0 = unknown, 1 = MP3, 2 = WMA, 4 = AAC, 8 = IMA ADPCM, etc (use defines below)
                            17282 ; 129  |        INT                iResourceNum;  // Resource number of the decoder that needed for this file
                            17283 ; 130  |} FILE_META_DATA;
                            17284 ; 131  |
                            17285 ; 132  |// File Type Defines (use for iFileType) -- matches bit defines in sysequ.inc
                            17286 ; 133  |#define UNKNOWN_TYPE   0
                            17287 ; 134  |#define MP3_TYPE       1
                            17288 ; 135  |#define WMA_TYPE       2
                            17289 ; 136  |#define AAC_TYPE       4
                            17290 ; 137  |#define IMA_ADPCM_TYPE 8
                            17291 ; 138  |#define MS_ADPCM_TYPE  16
                            17292 ; 139  |#define PCM_WAV_TYPE   32
                            17293 ; 140  |#define ASF_TYPE       64
                            17294 ; 141  |#define AUDIBLE_ACELP_TYPE 128
                            17295 ; 142  |#define AUDIBLE_MP3_TYPE   256          // 9/28/04 mmiu
                            17296 ; 143  |
                            17297 ; 144  |#define SMV_ADPCM_TYPE 512
                            17298 ; 145  |
                            17299 ; 146  |
                            17300 ; 147  |//////SRS WOW DEFS/////////////////////////////////////////////////////////////
                            17301 ; 148  |// Sample rates
                            17302 ; 149  |#ifdef WOW
                            17303 ; 150  |#define SR_48KHZ        48000
                            17304 ; 151  |#define SR_44KHZ        44100
                            17305 ; 152  |#define SR_32KHZ        32000
                            17306 ; 153  |#define SR_24KHZ        24000
                            17307 ; 154  |#define SR_22KHZ        22050
                            17308 ; 155  |#define SR_16KHZ        16000
                            17309 ; 156  |#define SR_12KHZ        12000
                            17310 ; 157  |#define SR_11KHZ        11025
                            17311 ; 158  |#define SR_8KHZ          8000
                            17312 ; 159  |#endif
                            17313 ; 160  |
                            17314 ; 161  |
                            17315 ; 162  |///////////////////////////////////////////////////////////////////////////////
                            17316 ; 163  |// MetaData prototypes
                            17317 ; 164  |///////////////////////////////////////////////////////////////////////////////
                            17318 ; 165  |
                            17319 ; 166  |RETCODE _reentrant GetFileMetaData(INT PackedPathNameAddress, INT btCurrentDevice, FILE_META_DATA *MetaData);
                            17320 ; 167  |#ifdef USE_PLAYLIST3
                            17321 ; 168  |INT _reentrant GetRelativePath(int highlight_index, int browse_type, INT* PackedPathNameAddress);
                            17322 ; 169  |INT _reentrant RetrieveSongInfo(INT a, INT b, INT *p_path);
                            17323 ; 170  |#endif
                            17324 ; 171  |
                            17325 ; 172  |#endif // #ifndef _METADATA_H
                            17326 
                            17328 
                            17329 ; 8    |
                            17330 ; 9    |#define MAX_NUM_DIR 1           //max supported directories including all subdirectories
                            17331 ; 10   |#define MAX_NUM_FILES   1       //max supported files
                            17332 ; 11   |#define MAX_SORT_ENTRIES_PER_DIRECTORY  15
                            17333 ; 12   |
                            17334 ; 13   |#define MAX_RECORDS_PER_DIRECTORY   4096        //calculated from the bits in the m_iRecordNum field in the following data structures.
                            17335 ; 14   |                                                                                        //An entry can have multiple records in the FAT for LFNs.
                            17336 ; 15   |                                                                                        //Records more than this number will not be included in the playlist content
                            17337 ; 16   |
                            17338 ; 17   |#define SFN_LENGTH      13      //8.3\ + NULL
                            17339 ; 18   |
                            17340 ; 19   |#define  _MAX_DIR_DEPTH 8
                            17341 ; 20   |#define  MAX_DIRNAME_LENGTH ((SFN_LENGTH*_MAX_DIR_DEPTH)+1)
                            17342 ; 21   |
                            17343 ; 22   |struct Bookmark{
                            17344 ; 23   |        INT       m_iTracknum;
                            17345 ; 24   |        DWORD m_dwTrackPosBytes;
                            17346 ; 25   |}; //this will save the num and position of the song selected for bookmark
                            17347 ; 26   |
                            17348 ; 27   |
                            17349 ; 28   |typedef struct{
                            17350 ; 29   |    unsigned int    m_pNext:16;                 //points to the next inline DirEntry. 
                            17351 ; 30   |        unsigned int    m_bAllocated:1; //1=allocated, 0=free.
                            17352 ; 31   |    unsigned int    m_iDevice:1;
                            17353 ; 32   |        unsigned int    m_bIsRoot:1;    //1=ROOT directory, 0= Any directory except ROOT.
                            17354 ; 33   |////////////////////////////////////////////////////////////////////////////////////////////
                            17355 ; 34   |    unsigned int    m_pDirContents:16;  //points to the first content which is a dir.
                            17356 ; 35   |///////////////////////////////////////////////////////////////////////////////////////////
                            17357 ; 36   |        unsigned int    m_pFileContents:16; //pointer in FileEntryPool where the file contents for this directory begin.
                            17358 ; 37   |////////////////////////////////////////////////////////////////////////////////////////////
                            17359 ; 38   |        unsigned int    m_iDirSector1:21;
                            17360 ; 39   |////////////////////////////////////////////////////////////////////////////////////////////
                            17361 ; 40   |        unsigned int    m_iDirOffset:12;
                            17362 ; 41   |        unsigned int    m_iRecordNum:12;        //record number of the directory record (LFN use).
                            17363 ; 42   |
                            17364 ; 43   |        unsigned int    m_iDirSector2:11;
                            17365 ; 44   |        //!! The above are implicitly used as a struct*. Using INT bitfields to save memory !!!
                            17366 ; 45   |////////////////////////////////////////////////////////////////////////////////////////////    
                            17367 ; 46   |#ifdef DEBUG_SFN
                            17368 ; 47   |        _packed BYTE name[SFN_LENGTH];
                            17369 ; 48   |#endif
                            17370 ; 49   |}DirEntry;
                            17371 ; 50   |
                            17372 ; 51   |typedef struct{
                            17373 ; 52   |        unsigned int    m_bAllocated:1; //1=allocated, 0=free.
                            17374 ; 53   |        unsigned int    m_bCurrentPlayset:1;    //1=Belongs to the current playset.
                            17375 ; 54   |        unsigned int    m_bTrackPlayed:1;               //Indicates if the track was played atleast once. Currently not used.
                            17376 ; 55   |        unsigned int    m_iDirSector1:21;
                            17377 ; 56   |//////////////////////////////////////////////////////////////////////////////////////////////////////
                            17378 ; 57   |        unsigned int    m_iTrackOrder:10;               //Order of this track in the current playset.
                            17379 ; 58   |        unsigned int    m_iDirOffset:12;
                            17380 ; 59   |//////////////////////////////////////////////////////////////////////////////////////////////////////
                            17381 ; 60   |        unsigned int    m_iDevice:1;
                            17382 ; 61   |        unsigned int    m_iRecordNum:12;        //Record number of the file record (LFN use).
                            17383 ; 62   |        unsigned int    m_iDirSector2:11;
                            17384 ; 63   |//////////////////////////////////////////////////////////////////////////////////////////////////////
                            17385 ; 64   |        unsigned int    m_pNext:16;             // //points to the next inline file.
                            17386 ; 65   |//////////////////////////////////////////////////////////////////////////////////////////////////////
                            17387 ; 66   |#ifdef DEBUG_SFN
                            17388 ; 67   |        _packed BYTE name[SFN_LENGTH];
                            17389 ; 68   |#endif
                            17390 ; 69   |}FileEntry;
                            17391 
                            17436 
                            17437 ; 70   |
                            17438 ; 71   |typedef struct{
                            17439 ; 72   |        DirEntry _X* pDirEntry; //Start traversing from this directory entry
                            17440 ; 73   |        unsigned int    iReason;
                            17441 ; 74   |        unsigned int iDevice;
                            17442 ; 75   |        unsigned int iPlayset;
                            17443 ; 76   |        unsigned int iDepth;
                            17444 ; 77   |        unsigned int iTrackOrder;
                            17445 ; 78   |        unsigned int iTrackNum;
                            17446 ; 79   |        FileEntry* pFileEntry;
                            17447 ; 80   |        DirEntry _X* DirLinks[_MAX_DIR_DEPTH];  //maintains a dynamic list of directory links within the recursion
                            17448 ; 81   |        unsigned int    iTotalLinks;
                            17449 ; 82   |}TraverseTreeParams;
                            17450 ; 83   |
                            17451 ; 84   |typedef struct{
                            17452 ; 85   |        unsigned int EntryType;                         //TYPE_DIR or TYPE_FILE
                            17453 ; 86   |        FileEntry* pFileEntry;          //used if TYPE_FILE
                            17454 ; 87   |        DirEntry _X* pDirEntry;                 //used if TYPE_DIR
                            17455 ; 88   |        unsigned int iTrackNum;
                            17456 ; 89   |        unsigned int iTrackOrder;
                            17457 ; 90   |        DirEntry _X* DirLinks[_MAX_DIR_DEPTH];
                            17458 ; 91   |        unsigned int iTotalLinks;
                            17459 ; 92   |}EntryAccessInfo;
                            17460 ; 93   |
                            17461 ; 94   |typedef struct{
                            17462 ; 95   |        void* pEntry;
                            17463 ; 96   |        _packed BYTE name[SFN_LENGTH];
                            17464 ; 97   |}SFNStorage;
                            17465 ; 98   |
                            17466 ; 99   |extern DirEntry _X g_DirEntryPerDevice[];               //ROOT(s)
                            17467 ; 100  |extern DirEntry _X g_DirEntryPool[];            //Pool of directory entries, Does not contain files.
                            17468 ; 101  |extern FileEntry g_FileEntryPool[];
                            17469 
                            17484 
                            17485 ; 102  |extern EntryAccessInfo g_CurrentTrack;
                            17486 ; 103  |extern int g_iPlaylistRepeat;
                            17487 ; 104  |extern int g_bPlaylistShuffle;
                            17488 
                            17496 
                            17497 ; 105  |extern SFNStorage g_TempSFNSpace[];
                            17498 ; 106  |extern int g_iTotalTracks;
                            17499 ; 107  |
                            17500 ; 108  |extern int g_iPlaySet;
                            17501 ; 109  |
                            17502 ; 110  |extern struct Bookmark g_MarkerMusic, g_MarkerVoice;
                            17503 ; 111  |extern int g_iTotalDir;
                            17504 ; 112  |extern int g_iTotalFiles;
                            17505 ; 113  |
                            17506 ; 114  |void _reentrant ML_building_engine_init_playlist3(void);
                            17507 ; 115  |void _reentrant ML_voice_build_engine_init_playlist3(void);
                            17508 ; 116  |void _reentrant ML_merging_engine_init_playlist3(void);
                            17509 ; 117  |_reentrant void Rebuild_GetMetaData(WORD wMode,int ignored1,int*ignored2);
                            17510 ; 118  |_reentrant void Rebuild_GetFileMetaData(INT PackedPathNameAddress, INT btCurrentDevice, FILE_META_DATA *MetaData);
                            17511 ; 119  |_reentrant RETCODE AddDirToLibrary(INT iDrive, INT iDirDepth);
                            17512 ; 120  |RETCODE _reentrant ML_GetLFN(DWORD dwFastKey, INT iRecordNum, UCS3 *pBuf);
                            17513 ; 121  |
                            17514 ; 122  |#endif
                            17515 
                            17517 
                            17518 ; 5    |#include "musiclib_ghdr.h"
                            17519 
                            17521 
                            17522 ; 1    |#ifndef MUSICLIB_GHDR_H
                            17523 ; 2    |#define MUSICLIB_GHDR_H
                            17524 ; 3    |
                            17525 ; 4    |#ifdef __cplusplus
                            17526 ; 5    |extern "C" {
                            17527 ; 6    |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  69

M:ADDR CODE           CYCLES LINE SOURCELINE
                            17528 ; 7    |
                            17529 ; 8    |/*==================================================================================================
                            17530 ; 9    |
                            17531 ; 10   |                                        General Description
                            17532 ; 11   |
                            17533 ; 12   |====================================================================================================
                            17534 ; 13   |
                            17535 ; 14   |                               Sigmatel Inc Confidential Proprietary
                            17536 ; 15   |                               (c) Copyright Sigmatel Inc 2004, All Rights Reserved
                            17537 ; 16   |
                            17538 ; 17   |HEADER NAME: mf_sf_filename.h   AUTHOR: Developer Name      CREATION DATE: DD/MM/YYYY
                            17539 ; 18   |
                            17540 ; 19   |PRODUCT NAMES: All
                            17541 ; 20   |
                            17542 ; 21   |GENERAL DESCRIPTION:
                            17543 ; 22   |
                            17544 ; 23   |    General description of this grouping of functions.
                            17545 ; 24   |
                            17546 ; 25   |Portability: All
                            17547 ; 26   |
                            17548 ; 27   |
                            17549 ; 28   |Revision History:
                            17550 ; 29   |
                            17551 ; 30   |                         Modification        Tracking
                            17552 ; 31   |Author                       Date             Number           Description of Changes
                            17553 ; 32   |---------------------    ------------        ----------        -------------------------------------
                            17554 ; 33   |Developer Name            DD/MM/YYYY         PDaaaxxxxx        brief description of changes made
                            17555 ; 34   |
                            17556 ; 35   |
                            17557 ; 36   |====================================================================================================
                            17558 ; 37   |                                            DESCRIPTION
                            17559 ; 38   |====================================================================================================
                            17560 ; 39   |
                            17561 ; 40   |GLOBAL FUNCTIONS:
                            17562 ; 41   |    MF_global_func_name()
                            17563 ; 42   |
                            17564 ; 43   |TRACEABILITY MATRIX:
                            17565 ; 44   |    None
                            17566 ; 45   |
                            17567 ; 46   |==================================================================================================*/
                            17568 ; 47   |
                            17569 ; 48   |/*==================================================================================================
                            17570 ; 49   |                                                                Conditional Compilation Directives
                            17571 ; 50   |==================================================================================================*/
                            17572 ; 51   |#ifdef WIN32
                            17573 ; 52   |#define _PC_SIMULATION_
                            17574 ; 53   |#else
                            17575 ; 54   |#define _RUNNING_IN_EMBEDDED_
                            17576 ; 55   |#endif  // WIN32
                            17577 ; 56   |
                            17578 ; 57   |#if 1
                            17579 ; 58   |#define _NEWMUSIC_      /* install new music list */
                            17580 ; 59   |#endif
                            17581 ; 60   |
                            17582 ; 61   |#if 1
                            17583 ; 62   |#define _AUDIBLE_       /* install audible list */
                            17584 ; 63   |#endif
                            17585 ; 64   |
                            17586 ; 65   |#if 1
                            17587 ; 66   |#define _ONTHEGO_       /* install on the go list */
                            17588 ; 67   |#endif
                            17589 ; 68   |
                            17590 ; 69   |#ifdef PL3_FB
                            17591 ; 70   |#define _FOLDER_BROWSE_ // install folder browsing
                            17592 ; 71   |#endif
                            17593 ; 72   |
                            17594 ; 73   |#if 1
                            17595 ; 74   |#define _SUPPORT_2000_SONGS_
                            17596 ; 75   |#endif
                            17597 ; 76   |
                            17598 ; 77   |/*==================================================================================================
                            17599 ; 78   |                                           INCLUDE FILES
                            17600 ; 79   |==================================================================================================*/
                            17601 ; 80   |#ifdef _RUNNING_IN_EMBEDDED_
                            17602 ; 81   |#define OEM_SEEK_CUR    SEEK_CUR
                            17603 ; 82   |#define OEM_SEEK_SET    SEEK_SET
                            17604 ; 83   |#define OEM_SEEK_END    SEEK_END
                            17605 ; 84   |#else
                            17606 ; 85   |#define _X
                            17607 ; 86   |#define _Y
                            17608 ; 87   |#define _packed
                            17609 ; 88   |
                            17610 ; 89   |#define _asmfunc
                            17611 ; 90   |#define _reentrant
                            17612 ; 91   |
                            17613 ; 92   |#define OEM_SEEK_CUR    1
                            17614 ; 93   |#define OEM_SEEK_SET    0
                            17615 ; 94   |#define OEM_SEEK_END    2
                            17616 ; 95   |#endif  // _RUNNING_IN_EMBEDDED_
                            17617 ; 96   |
                            17618 ; 97   |#include "types.h"
                            17619 
                            17621 
                            17622 ; 1    |////////////////////////////////////////////////////////////////////////////////
                            17623 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                            17624 ; 3    |//
                            17625 ; 4    |// Filename: types.h
                            17626 ; 5    |// Description: Standard data types
                            17627 ; 6    |////////////////////////////////////////////////////////////////////////////////
                            17628 ; 7    |
                            17629 ; 8    |#ifndef _TYPES_H
                            17630 ; 9    |#define _TYPES_H
                            17631 ; 10   |
                            17632 ; 11   |// TODO:  move this outta here!
                            17633 ; 12   |#if !defined(NOERROR)
                            17634 ; 13   |#define NOERROR 0
                            17635 ; 14   |#define SUCCESS 0
                            17636 ; 15   |#endif 
                            17637 ; 16   |#if !defined(SUCCESS)
                            17638 ; 17   |#define SUCCESS  0
                            17639 ; 18   |#endif
                            17640 ; 19   |#if !defined(ERROR)
                            17641 ; 20   |#define ERROR   -1
                            17642 ; 21   |#endif
                            17643 ; 22   |#if !defined(FALSE)
                            17644 ; 23   |#define FALSE 0
                            17645 ; 24   |#endif
                            17646 ; 25   |#if !defined(TRUE)
                            17647 ; 26   |#define TRUE  1
                            17648 ; 27   |#endif
                            17649 ; 28   |
                            17650 ; 29   |#if !defined(NULL)
                            17651 ; 30   |#define NULL 0
                            17652 ; 31   |#endif
                            17653 ; 32   |
                            17654 ; 33   |#define MAX_INT     0x7FFFFF
                            17655 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                            17656 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                            17657 ; 36   |#define MAX_ULONG   (-1) 
                            17658 ; 37   |
                            17659 ; 38   |#define WORD_SIZE   24              // word size in bits
                            17660 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                            17661 ; 40   |
                            17662 ; 41   |
                            17663 ; 42   |#define BYTE    unsigned char       // btVarName
                            17664 ; 43   |#define CHAR    signed char         // cVarName
                            17665 ; 44   |#define USHORT  unsigned short      // usVarName
                            17666 ; 45   |#define SHORT   unsigned short      // sVarName
                            17667 ; 46   |#define WORD    unsigned int        // wVarName
                            17668 ; 47   |#define INT     signed int          // iVarName
                            17669 ; 48   |#define DWORD   unsigned long       // dwVarName
                            17670 ; 49   |#define LONG    signed long         // lVarName
                            17671 ; 50   |#define BOOL    unsigned int        // bVarName
                            17672 ; 51   |#define FRACT   _fract              // frVarName
                            17673 ; 52   |#define LFRACT  long _fract         // lfrVarName
                            17674 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                            17675 ; 54   |#define FLOAT   float               // fVarName
                            17676 ; 55   |#define DBL     double              // dVarName
                            17677 ; 56   |#define ENUM    enum                // eVarName
                            17678 ; 57   |#define CMX     _complex            // cmxVarName
                            17679 ; 58   |typedef WORD UCS3;                   // 
                            17680 ; 59   |
                            17681 ; 60   |#define UINT16  unsigned short
                            17682 ; 61   |#define UINT8   unsigned char   
                            17683 ; 62   |#define UINT32  unsigned long
                            17684 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            17685 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            17686 ; 65   |#define WCHAR   UINT16
                            17687 ; 66   |
                            17688 ; 67   |//UINT128 is 16 bytes or 6 words
                            17689 ; 68   |typedef struct UINT128_3500 {   
                            17690 ; 69   |    int val[6];     
                            17691 ; 70   |} UINT128_3500;
                            17692 ; 71   |
                            17693 ; 72   |#define UINT128   UINT128_3500
                            17694 ; 73   |
                            17695 ; 74   |// Little endian word packed byte strings:   
                            17696 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            17697 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            17698 ; 77   |// Little endian word packed byte strings:   
                            17699 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            17700 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            17701 ; 80   |
                            17702 ; 81   |// Declare Memory Spaces To Use When Coding
                            17703 ; 82   |// A. Sector Buffers
                            17704 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                            17705 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                            17706 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                            17707 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                            17708 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                            17709 ; 88   |// B. Media DDI Memory
                            17710 ; 89   |#define MEDIA_DDI_MEM _Y
                            17711 ; 90   |
                            17712 ; 91   |
                            17713 ; 92   |
                            17714 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                            17715 ; 94   |// Examples of circular pointers:
                            17716 ; 95   |//    INT CIRC cpiVarName
                            17717 ; 96   |//    DWORD CIRC cpdwVarName
                            17718 ; 97   |
                            17719 ; 98   |#define RETCODE INT                 // rcVarName
                            17720 ; 99   |
                            17721 ; 100  |// generic bitfield structure
                            17722 ; 101  |struct Bitfield {
                            17723 ; 102  |    unsigned int B0  :1;
                            17724 ; 103  |    unsigned int B1  :1;
                            17725 ; 104  |    unsigned int B2  :1;
                            17726 ; 105  |    unsigned int B3  :1;
                            17727 ; 106  |    unsigned int B4  :1;
                            17728 ; 107  |    unsigned int B5  :1;
                            17729 ; 108  |    unsigned int B6  :1;
                            17730 ; 109  |    unsigned int B7  :1;
                            17731 ; 110  |    unsigned int B8  :1;
                            17732 ; 111  |    unsigned int B9  :1;
                            17733 ; 112  |    unsigned int B10 :1;
                            17734 ; 113  |    unsigned int B11 :1;
                            17735 ; 114  |    unsigned int B12 :1;
                            17736 ; 115  |    unsigned int B13 :1;
                            17737 ; 116  |    unsigned int B14 :1;
                            17738 ; 117  |    unsigned int B15 :1;
                            17739 ; 118  |    unsigned int B16 :1;
                            17740 ; 119  |    unsigned int B17 :1;
                            17741 ; 120  |    unsigned int B18 :1;
                            17742 ; 121  |    unsigned int B19 :1;
                            17743 ; 122  |    unsigned int B20 :1;
                            17744 ; 123  |    unsigned int B21 :1;
                            17745 ; 124  |    unsigned int B22 :1;
                            17746 ; 125  |    unsigned int B23 :1;
                            17747 ; 126  |};
                            17748 ; 127  |
                            17749 ; 128  |union BitInt {
                            17750 ; 129  |        struct Bitfield B;
                            17751 ; 130  |        int        I;
                            17752 ; 131  |};
                            17753 ; 132  |
                            17754 ; 133  |#define MAX_MSG_LENGTH 10
                            17755 ; 134  |struct CMessage
                            17756 ; 135  |{
                            17757 ; 136  |        unsigned int m_uLength;
                            17758 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                            17759 ; 138  |};
                            17760 ; 139  |
                            17761 ; 140  |typedef struct {
                            17762 ; 141  |    WORD m_wLength;
                            17763 ; 142  |    WORD m_wMessage;
                            17764 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                            17765 ; 144  |} Message;
                            17766 ; 145  |
                            17767 ; 146  |struct MessageQueueDescriptor
                            17768 ; 147  |{
                            17769 ; 148  |        int *m_pBase;
                            17770 ; 149  |        int m_iModulo;
                            17771 ; 150  |        int m_iSize;
                            17772 ; 151  |        int *m_pHead;
                            17773 ; 152  |        int *m_pTail;
                            17774 ; 153  |};
                            17775 ; 154  |
                            17776 ; 155  |struct ModuleEntry
                            17777 ; 156  |{
                            17778 ; 157  |    int m_iSignaledEventMask;
                            17779 ; 158  |    int m_iWaitEventMask;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  70

M:ADDR CODE           CYCLES LINE SOURCELINE
                            17780 ; 159  |    int m_iResourceOfCode;
                            17781 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                            17782 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                            17783 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                            17784 ; 163  |    int m_uTimeOutHigh;
                            17785 ; 164  |    int m_uTimeOutLow;
                            17786 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                            17787 ; 166  |};
                            17788 ; 167  |
                            17789 ; 168  |union WaitMask{
                            17790 ; 169  |    struct B{
                            17791 ; 170  |        unsigned int m_bNone     :1;
                            17792 ; 171  |        unsigned int m_bMessage  :1;
                            17793 ; 172  |        unsigned int m_bTimer    :1;
                            17794 ; 173  |        unsigned int m_bButton   :1;
                            17795 ; 174  |    } B;
                            17796 ; 175  |    int I;
                            17797 ; 176  |} ;
                            17798 ; 177  |
                            17799 ; 178  |
                            17800 ; 179  |struct Button {
                            17801 ; 180  |        WORD wButtonEvent;
                            17802 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                            17803 ; 182  |};
                            17804 ; 183  |
                            17805 ; 184  |struct Message {
                            17806 ; 185  |        WORD wMsgLength;
                            17807 ; 186  |        WORD wMsgCommand;
                            17808 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                            17809 ; 188  |};
                            17810 ; 189  |
                            17811 ; 190  |union EventTypes {
                            17812 ; 191  |        struct CMessage msg;
                            17813 ; 192  |        struct Button Button ;
                            17814 ; 193  |        struct Message Message;
                            17815 ; 194  |};
                            17816 ; 195  |
                            17817 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                            17818 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                            17819 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                            17820 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                            17821 ; 200  |
                            17822 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                            17823 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                            17824 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                            17825 ; 204  |
                            17826 ; 205  |#if DEBUG
                            17827 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                            17828 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                            17829 ; 208  |#else 
                            17830 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                            17831 ; 210  |#define DebugBuildAssert(x)    
                            17832 ; 211  |#endif
                            17833 ; 212  |
                            17834 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                            17835 ; 214  |//  #pragma asm
                            17836 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                            17837 ; 216  |//  #pragma endasm
                            17838 ; 217  |
                            17839 ; 218  |
                            17840 ; 219  |#ifdef COLOR_262K
                            17841 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                            17842 ; 221  |#elif defined(COLOR_65K)
                            17843 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                            17844 ; 223  |#else
                            17845 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                            17846 ; 225  |#endif
                            17847 ; 226  |    
                            17848 ; 227  |#endif // #ifndef _TYPES_H
                            17849 
                            17851 
                            17852 ; 98   |#include "exec.h"
                            17853 
                            17855 
                            17856 ; 1    |#ifndef EXEC_H
                            17857 ; 2    |#define EXEC_H
                            17858 ; 3    |
                            17859 ; 4    |
                            17860 ; 5    |void _reentrant SysPostMessage(int iLength,...);
                            17861 ; 6    |int _asmfunc GetMessage(struct MessageQueueDescriptor*,struct CMessage * );
                            17862 ; 7    |long _asmfunc SysGetCurrentTime(void);
                            17863 ; 8    |
                            17864 ; 9    |
                            17865 ; 10   |#endif
                            17866 
                            17868 
                            17869 ; 99   |#include "messages.h"
                            17870 
                            17872 
                            17873 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                            17874 ; 2    |// Copyright(C) SigmaTel, Inc. 2000
                            17875 ; 3    |// Message defs
                            17876 ; 4    |/////////////////////////////////////////////////////////////////////////////////
                            17877 ; 5    |
                            17878 ; 6    |#if (!defined(MSGEQU_INC))
                            17879 ; 7    |#define MSGEQU_INC 1
                            17880 ; 8    |
                            17881 ; 9    |
                            17882 ; 10   |#define MAX_MODULE_SIZE   (lc_u_eP_Module_overlay-lc_u_bP_Module_overlay)*3
                            17883 ; 11   |
                            17884 ; 12   |
                            17885 ; 13   |#define MSG_TYPE_DECODER 0x000000
                            17886 ; 14   |#define MSG_TYPE_ENCODER 0x010000
                            17887 ; 15   |#define MSG_TYPE_PARSER 0x020000
                            17888 ; 16   |#define MSG_TYPE_LCD 0x030000
                            17889 ; 17   |#define MSG_TYPE_MIXER 0x040000
                            17890 ; 18   |#define MSG_TYPE_SYSTEM 0x050000
                            17891 ; 19   |#define MSG_TYPE_MENU 0x060000
                            17892 ; 20   |#define MSG_TYPE_LED 0x070000
                            17893 ; 21   |#define MSG_TYPE_TUNER 0x080000
                            17894 ; 22   |#define MSG_TYPE_CHARLCD 0x030000
                            17895 ; 23   |#define MSG_TYPE_SOFT_TIMER 0x090000
                            17896 ; 24   |// Equalizer and other effects
                            17897 ; 25   |#define MSG_TYPE_GEQ 0x0a0000             
                            17898 ; 26   |#if (defined(USE_PLAYLIST3))
                            17899 ; 27   |#define MSG_TYPE_MUSICLIB_PLAY 0x0b0000
                            17900 ; 28   |#define MSG_TYPE_MUSICLIB_BROWSE 0x0c0000
                            17901 ; 29   |#define MSG_TYPE_MUSICLIB_PLAYALLNEXT 0x0d0000
                            17902 ; 30   |#define MSG_TYPE_MUSICLIB_PLAYALLPREV 0x0e0000
                            17903 ; 31   |#define MSG_TYPE_MUSICLIB_SHUFFLE 0x0f0000
                            17904 ; 32   |#define MSG_TYPE_MUSICLIB_VOICE 0x100000
                            17905 ; 33   |#define MSG_TYPE_MUSICLIB_VOICEPLAY 0x110000
                            17906 ; 34   |#define MSG_TYPE_MUSICLIB_MERGE 0x120000
                            17907 ; 35   |#endif // IF (@def(USE_PLAYLIST3))
                            17908 ; 36   |#if defined(USE_PLAYLIST5)
                            17909 ; 37   |#define MSG_TYPE_PL5_PLAYBACK 0x0b0000
                            17910 ; 38   |#define MSG_TYPE_PL5_BROWSE 0x0c0000
                            17911 ; 39   |#endif // if @def('USE_PLAYLIST5')
                            17912 ; 40   |
                            17913 ; 41   |// Message Structure Offsets
                            17914 ; 42   |#define MSG_Length 0
                            17915 ; 43   |#define MSG_ID 1
                            17916 ; 44   |#define MSG_Argument1 2
                            17917 ; 45   |#define MSG_Argument2 3
                            17918 ; 46   |#define MSG_Argument3 4
                            17919 ; 47   |#define MSG_Argument4 5
                            17920 ; 48   |#define MSG_Argument5 6
                            17921 ; 49   |#define MSG_Argument6 7
                            17922 ; 50   |
                            17923 ; 51   |
                            17924 ; 52   |
                            17925 ; 53   |// LCD Message IDs
                            17926 ; 54   |#define LCD_FIRST_MSG_ID MSG_TYPE_LCD+0
                            17927 ; 55   |#define LCD_CLEAR_RANGE MSG_TYPE_LCD+0
                            17928 ; 56   |#define LCD_PRINT_RANGE_RSRC MSG_TYPE_LCD+1
                            17929 ; 57   |#define LCD_PRINT_RANGE_ADDR MSG_TYPE_LCD+2
                            17930 ; 58   |#define LCD_PRINT_RANGE_INV_RSRC MSG_TYPE_LCD+3
                            17931 ; 59   |#define LCD_PRINT_RANGE_INV_ADDR MSG_TYPE_LCD+4
                            17932 ; 60   |#define LCD_PRINT_RANGE_FILE MSG_TYPE_LCD+5
                            17933 ; 61   |#define LCD_PRINT_RANGE_INV_FILE MSG_TYPE_LCD+6
                            17934 ; 62   |#define LCD_PRINT_STRING_RSRC MSG_TYPE_LCD+7
                            17935 ; 63   |#define LCD_PRINT_STRING_ADDR MSG_TYPE_LCD+8
                            17936 ; 64   |#define LCD_PRINT_STRING_INV_RSRC MSG_TYPE_LCD+9
                            17937 ; 65   |#define LCD_PRINT_STRING_INV_ADDR MSG_TYPE_LCD+10
                            17938 ; 66   |#define LCD_SCROLL_DISPLAY MSG_TYPE_LCD+11
                            17939 ; 67   |#define LCD_READ_LCD_ADDR MSG_TYPE_LCD+12
                            17940 ; 68   |#define LCD_SET_CONTRAST MSG_TYPE_LCD+13
                            17941 ; 69   |#define LCD_INC_CONTRAST MSG_TYPE_LCD+14
                            17942 ; 70   |#define LCD_DEC_CONTRAST MSG_TYPE_LCD+15
                            17943 ; 71   |#define LCD_BACKLIGHT_ON MSG_TYPE_LCD+16
                            17944 ; 72   |#define LCD_BACKLIGHT_OFF MSG_TYPE_LCD+17
                            17945 ; 73   |#define LCD_SET_FONT MSG_TYPE_LCD+18
                            17946 ; 74   |#define LCD_PRINT_NUMBER MSG_TYPE_LCD+19
                            17947 ; 75   |#define LCD_PRINT_TIME MSG_TYPE_LCD+20
                            17948 ; 76   |#define LCD_PRINT_TIME_LONG MSG_TYPE_LCD+21
                            17949 ; 77   |#define LCD_PRINT_STRING_UNICODE_INV_ADDR MSG_TYPE_LCD+22
                            17950 ; 78   |#define LCD_PRINT_STRING_UNICODE_ADDR MSG_TYPE_LCD+23
                            17951 ; 79   |#define LCD_PRINT_STRING_UNICODE_INV_RSRC MSG_TYPE_LCD+24
                            17952 ; 80   |#define LCD_PRINT_STRING_UNICODE_RSRC MSG_TYPE_LCD+25
                            17953 ; 81   |#define LCD_BEGIN_FRAME MSG_TYPE_LCD+26
                            17954 ; 82   |#define LCD_END_FRAME MSG_TYPE_LCD+27
                            17955 ; 83   |#define LCD_PRINT_NUMBER_INV MSG_TYPE_LCD+28
                            17956 ; 84   |#define LCD_PRINT_TIME_INV MSG_TYPE_LCD+29
                            17957 ; 85   |#define LCD_PRINT_TIME_LONG_INV MSG_TYPE_LCD+30
                            17958 ; 86   |#define LCD_SET_FRAMEBUFFER MSG_TYPE_LCD+31
                            17959 ; 87   |//send a NULL as Param1 to return to root frame buffer
                            17960 ; 88   |#define LCD_PUSH_MASK MSG_TYPE_LCD+32
                            17961 ; 89   |//Param1 = left
                            17962 ; 90   |//Param2 = top
                            17963 ; 91   |//Param3 = right
                            17964 ; 92   |//Param4 = bottom
                            17965 ; 93   |#define LCD_POP_MASK MSG_TYPE_LCD+33
                            17966 ; 94   |#define LCD_PRINT_UNICODE_CHAR MSG_TYPE_LCD+34
                            17967 ; 95   |#define LCD_PRINT_UNICODE_CHAR_INV MSG_TYPE_LCD+35
                            17968 ; 96   |#define LCD_DISPLAY_HISTOGRAM MSG_TYPE_LCD+36
                            17969 ; 97   |#define LCD_PRINT_TIME_L_1DIG_HR MSG_TYPE_LCD+37
                            17970 ; 98   |#define LCD_SET_ICON MSG_TYPE_LCD+38
                            17971 ; 99   |
                            17972 ; 100  |#define LCD_CLEAR_RANGE_BUFFER MSG_TYPE_LCD+39
                            17973 ; 101  |#define LCD_PRINT_RANGE_RSRC_BUFFER MSG_TYPE_LCD+40
                            17974 ; 102  |#define LCD_PRINT_RANGE_INV_RSRC_BUFFER MSG_TYPE_LCD+41
                            17975 ; 103  |#define LCD_PRINT_RANGE_ADDR_BUFFER MSG_TYPE_LCD+42
                            17976 ; 104  |#define LCD_PRINT_RANGE_INV_ADDR_BUFFER MSG_TYPE_LCD+43
                            17977 ; 105  |#define LCD_PRINT_STRING_RSRC_BUFFER MSG_TYPE_LCD+44
                            17978 ; 106  |#define LCD_PRINT_STRING_INV_RSRC_BUFFER MSG_TYPE_LCD+45
                            17979 ; 107  |#define LCD_PRINT_STRING_ADDR_BUFFER MSG_TYPE_LCD+46
                            17980 ; 108  |#define LCD_PRINT_STRING_INV_ADDR_BUFFER MSG_TYPE_LCD+47
                            17981 ; 109  |#define LCD_PRINT_NUMBER_BUFFER MSG_TYPE_LCD+48
                            17982 ; 110  |#define LCD_PRINT_NUMBER_INV_BUFFER MSG_TYPE_LCD+49
                            17983 ; 111  |#define LCD_PRINT_TIME_BUFFER MSG_TYPE_LCD+50
                            17984 ; 112  |#define LCD_PRINT_TIME_INV_BUFFER MSG_TYPE_LCD+51
                            17985 ; 113  |#define LCD_PRINT_TIME_LONG_BUFFER MSG_TYPE_LCD+52
                            17986 ; 114  |#define LCD_PRINT_TIME_LONG_INV_BUFFER MSG_TYPE_LCD+53
                            17987 ; 115  |#define LCD_PRINT_STRING_UNICODE_ADDR_BUFFER MSG_TYPE_LCD+54
                            17988 ; 116  |#define LCD_PRINT_STRING_UNICODE_INV_ADDR_BUFFER MSG_TYPE_LCD+55
                            17989 ; 117  |#define LCD_PRINT_STRING_UNICODE_RSRC_BUFFER MSG_TYPE_LCD+56
                            17990 ; 118  |#define LCD_PRINT_STRING_UNICODE_INV_RSRC_BUFFER MSG_TYPE_LCD+57
                            17991 ; 119  |#define LCD_PRINT_UNICODE_CHAR_BUFFER MSG_TYPE_LCD+58
                            17992 ; 120  |#define LCD_PRINT_UNICODE_CHAR_INV_BUFFER MSG_TYPE_LCD+59
                            17993 ; 121  |#define LCD_PRINT_TIME_L_1DIG_HR_BUFFER MSG_TYPE_LCD+60
                            17994 ; 122  |#define LCD_SET_BUFFER_COLOR MSG_TYPE_LCD+61
                            17995 ; 123  |#define LCD_FORCE_BUFFER_UPDATE MSG_TYPE_LCD+62
                            17996 ; 124  |#define LCD_SET_BUFFER_WINDOW MSG_TYPE_LCD+63
                            17997 ; 125  |#define LCD_SET_COLOR MSG_TYPE_LCD+64
                            17998 ; 126  |#define LCD_SET_BUFFER_POSITION MSG_TYPE_LCD+65
                            17999 ; 127  |
                            18000 ; 128  |#define LCD_TEMP_CONTRAST MSG_TYPE_LCD+66
                            18001 ; 129  |
                            18002 ; 130  |#if defined(CLCD_16BIT)
                            18003 ; 131  |#define LCD_16BIT_ON MSG_TYPE_LCD+67
                            18004 ; 132  |#define LCD_16BIT_OFF MSG_TYPE_LCD+68
                            18005 ; 133  |
                            18006 ; 134  |#define LCD_LAST_MSG_ID MSG_TYPE_LCD+68
                            18007 ; 135  |#else 
                            18008 ; 136  |#define LCD_LAST_MSG_ID MSG_TYPE_LCD+66
                            18009 ; 137  |#endif
                            18010 ; 138  |
                            18011 ; 139  |// If you change the LCD message ID's then you must
                            18012 ; 140  |// also change the jump table in lcdapi.asm
                            18013 ; 141  |
                            18014 ; 142  |// Character LCD Message IDs
                            18015 ; 143  |#define CHARLCD_FIRST_MSG_ID MSG_TYPE_CHARLCD+0
                            18016 ; 144  |#define CHARLCD_CLEAR_RANGE MSG_TYPE_CHARLCD+0
                            18017 ; 145  |#define CHARLCD_PRINT_RSRC MSG_TYPE_CHARLCD+1
                            18018 ; 146  |#define CHARLCD_PRINT_INV_RSRC MSG_TYPE_CHARLCD+2
                            18019 ; 147  |#define CHARLCD_PRINT_ASCII_CHAR MSG_TYPE_CHARLCD+3
                            18020 ; 148  |#define CHARLCD_PRINT_ASCII_INV_CHAR MSG_TYPE_CHARLCD+4
                            18021 ; 149  |#define CHARLCD_PRINT_STRING_RSRC MSG_TYPE_CHARLCD+5
                            18022 ; 150  |#define CHARLCD_PRINT_STRING_INV_RSRC MSG_TYPE_CHARLCD+6
                            18023 ; 151  |#define CHARLCD_PRINT_STRING_ADDR MSG_TYPE_CHARLCD+7
                            18024 ; 152  |#define CHARLCD_PRINT_STRING_INV_ADDR MSG_TYPE_CHARLCD+8
                            18025 ; 153  |#define CHARLCD_SCROLL_DISPLAY MSG_TYPE_CHARLCD+9
                            18026 ; 154  |#define CHARLCD_READ_LCD_ADDR MSG_TYPE_CHARLCD+10
                            18027 ; 155  |#define CHARLCD_SET_CURSOR MSG_TYPE_CHARLCD+11
                            18028 ; 156  |#define CHARLCD_SET_FONT MSG_TYPE_CHARLCD+12
                            18029 ; 157  |#define CHARLCD_PRINT_NUMBER MSG_TYPE_CHARLCD+13
                            18030 ; 158  |#define CHARLCD_PRINT_TIME MSG_TYPE_CHARLCD+14
                            18031 ; 159  |#define CHARLCD_SET_BATTERY MSG_TYPE_CHARLCD+15
                            18032 ; 160  |#define CHARLCD_SET_EQ MSG_TYPE_CHARLCD+16
                            18033 ; 161  |#define CHARLCD_SET_ICON MSG_TYPE_CHARLCD+17
                            18034 ; 162  |#define CHARLCD_SET_PLAYMODE MSG_TYPE_CHARLCD+18
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  71

M:ADDR CODE           CYCLES LINE SOURCELINE
                            18035 ; 163  |#define CHARLCD_SET_PLAYSTATE MSG_TYPE_CHARLCD+19
                            18036 ; 164  |#define CHARLCD_SET_VOLUME MSG_TYPE_CHARLCD+20
                            18037 ; 165  |#define CHARLCD_CLEAR_DISPLAY MSG_TYPE_CHARLCD+21
                            18038 ; 166  |#define CHARLCD_LAST_MSG_ID MSG_TYPE_CHARLCD+21
                            18039 ; 167  |// If you change the cHARACTER LCD message ID's then you must
                            18040 ; 168  |// also change the jump table in lcdapi.asm
                            18041 ; 169  |
                            18042 ; 170  |// Decoder Message IDs
                            18043 ; 171  |#define DECODER_FIRST_MSG_ID MSG_TYPE_DECODER+0
                            18044 ; 172  |#define DECODER_RESET MSG_TYPE_DECODER+0
                            18045 ; 173  |#define DECODER_SET_DIR MSG_TYPE_DECODER+1
                            18046 ; 174  |#define DECODER_PLAY MSG_TYPE_DECODER+2
                            18047 ; 175  |#define DECODER_STOP MSG_TYPE_DECODER+3
                            18048 ; 176  |#define DECODER_FFWD MSG_TYPE_DECODER+4
                            18049 ; 177  |#define DECODER_RWND MSG_TYPE_DECODER+5
                            18050 ; 178  |#define DECODER_NEXT_SONG MSG_TYPE_DECODER+6
                            18051 ; 179  |#define DECODER_PREV_SONG MSG_TYPE_DECODER+7
                            18052 ; 180  |#define DECODER_TIME_MODE MSG_TYPE_DECODER+8
                            18053 ; 181  |#define DECODER_AB_MODE MSG_TYPE_DECODER+9
                            18054 ; 182  |#define DECODER_SET_EQ MSG_TYPE_DECODER+10
                            18055 ; 183  |#define DECODER_GET_SONG_INFO MSG_TYPE_DECODER+11
                            18056 ; 184  |#define DECODER_NEXT_CHAPTER MSG_TYPE_DECODER+12
                            18057 ; 185  |#define DECODER_PREV_CHAPTER MSG_TYPE_DECODER+13
                            18058 ; 186  |#define DECODER_LAST_MSG_ID MSG_TYPE_DECODER+13
                            18059 ; 187  |// If you change the Decoder message ID's, then you must
                            18060 ; 188  |// also change the jump table in decoder_overlay.asm
                            18061 ; 189  |// and in dec_adpcm_overlay.asm.
                            18062 ; 190  |
                            18063 ; 191  |// Encoder Message IDs
                            18064 ; 192  |#define ENCODER_FIRST_MSG_ID MSG_TYPE_ENCODER+0
                            18065 ; 193  |#define ENCODER_RECORD MSG_TYPE_ENCODER+0
                            18066 ; 194  |#define ENCODER_STOP MSG_TYPE_ENCODER+1
                            18067 ; 195  |#define ENCODER_TIME_MODE MSG_TYPE_ENCODER+2
                            18068 ; 196  |#define ENCODER_LAST_MSG_ID MSG_TYPE_ENCODER+3
                            18069 ; 197  |// If you change the Encoder message ID's, then you must
                            18070 ; 198  |// also change the jump table in all encoder overlay modules.
                            18071 ; 199  |
                            18072 ; 200  |// Parser Message IDs
                            18073 ; 201  |#define PARSER_FIRST_MSG_ID MSG_TYPE_PARSER+0
                            18074 ; 202  |#define PARSER_NEXT_SONG MSG_TYPE_PARSER+0
                            18075 ; 203  |#define PARSER_PREV_SONG MSG_TYPE_PARSER+1
                            18076 ; 204  |#define PARSER_REPEAT MSG_TYPE_PARSER+2
                            18077 ; 205  |#define PARSER_RANDOM MSG_TYPE_PARSER+3
                            18078 ; 206  |#define PARSER_STOP MSG_TYPE_PARSER+4
                            18079 ; 207  |#define PARSER_DEVICE_ENUMERATE MSG_TYPE_PARSER+5
                            18080 ; 208  |#define PARSER_SET_CURRENT_SONG MSG_TYPE_PARSER+6
                            18081 ; 209  |#define PARSER_LAST_MSG_ID MSG_TYPE_PARSER+6
                            18082 ; 210  |// If you change the Parser message ID's, then you must
                            18083 ; 211  |// also change the jump table in parser.asm
                            18084 ; 212  |
                            18085 ; 213  |// Button Message IDs
                            18086 ; 214  |//BUTTON_FIRST_MSG_ID      equ     MSG_TYPE_BUTTON+0
                            18087 ; 215  |//BUTTON_BUTTONS_ON        equ     MSG_TYPE_BUTTON+0
                            18088 ; 216  |//BUTTON_BUTTONS_OFF       equ     MSG_TYPE_BUTTON+1
                            18089 ; 217  |//BUTTON_HOLD              equ     MSG_TYPE_BUTTON+2
                            18090 ; 218  |//BUTTON_HOLD_RELEASE      equ     MSG_TYPE_BUTTON+3
                            18091 ; 219  |//BUTTON_LAST_MSG_ID       equ     MSG_TYPE_BUTTON+3
                            18092 ; 220  |
                            18093 ; 221  |// Mixer Message IDs
                            18094 ; 222  |#define MIXER_FIRST_MSG_ID MSG_TYPE_MIXER+0
                            18095 ; 223  |#define MIXER_MASTER_INCR MSG_TYPE_MIXER+0
                            18096 ; 224  |#define MIXER_MASTER_DECR MSG_TYPE_MIXER+1
                            18097 ; 225  |#define MIXER_MASTER_SETLVL MSG_TYPE_MIXER+2
                            18098 ; 226  |#define MIXER_MASTER_MUTE MSG_TYPE_MIXER+3
                            18099 ; 227  |#define MIXER_MASTER_UNMUTE MSG_TYPE_MIXER+4
                            18100 ; 228  |#define MIXER_MASTER_FADE_OUT MSG_TYPE_MIXER+5
                            18101 ; 229  |#define MIXER_MASTER_FADE_IN MSG_TYPE_MIXER+6
                            18102 ; 230  |#define MIXER_MASTER_BAL_RIGHT MSG_TYPE_MIXER+7
                            18103 ; 231  |#define MIXER_MASTER_BAL_LEFT MSG_TYPE_MIXER+8
                            18104 ; 232  |#define MIXER_MIC_INCR MSG_TYPE_MIXER+9
                            18105 ; 233  |#define MIXER_MIC_DECR MSG_TYPE_MIXER+10
                            18106 ; 234  |#define MIXER_MIC_SETLVL MSG_TYPE_MIXER+11
                            18107 ; 235  |#define MIXER_MIC_MUTE MSG_TYPE_MIXER+12
                            18108 ; 236  |#define MIXER_MIC_UNMUTE MSG_TYPE_MIXER+13
                            18109 ; 237  |#define MIXER_MIC_BOOST MSG_TYPE_MIXER+14
                            18110 ; 238  |#define MIXER_MIC_UNBOOST MSG_TYPE_MIXER+15
                            18111 ; 239  |#define MIXER_LINE_INCR MSG_TYPE_MIXER+16
                            18112 ; 240  |#define MIXER_LINE_DECR MSG_TYPE_MIXER+17
                            18113 ; 241  |#define MIXER_LINE_SETLVL MSG_TYPE_MIXER+18
                            18114 ; 242  |#define MIXER_LINE_MUTE MSG_TYPE_MIXER+19
                            18115 ; 243  |#define MIXER_LINE_UNMUTE MSG_TYPE_MIXER+20
                            18116 ; 244  |#define MIXER_FM_INCR MSG_TYPE_MIXER+21
                            18117 ; 245  |#define MIXER_FM_DECR MSG_TYPE_MIXER+22
                            18118 ; 246  |#define MIXER_FM_SETLVL MSG_TYPE_MIXER+23
                            18119 ; 247  |#define MIXER_FM_MUTE MSG_TYPE_MIXER+24
                            18120 ; 248  |#define MIXER_FM_UNMUTE MSG_TYPE_MIXER+25
                            18121 ; 249  |#define MIXER_DAC_INCR MSG_TYPE_MIXER+26
                            18122 ; 250  |#define MIXER_DAC_DECR MSG_TYPE_MIXER+27
                            18123 ; 251  |#define MIXER_DAC_SETLVL MSG_TYPE_MIXER+28
                            18124 ; 252  |#define MIXER_DAC_MUTE MSG_TYPE_MIXER+29
                            18125 ; 253  |#define MIXER_DAC_UNMUTE MSG_TYPE_MIXER+30
                            18126 ; 254  |#define MIXER_ADC_SELECT MSG_TYPE_MIXER+31
                            18127 ; 255  |#define MIXER_ADC_INCR MSG_TYPE_MIXER+32
                            18128 ; 256  |#define MIXER_ADC_DECR MSG_TYPE_MIXER+33
                            18129 ; 257  |#define MIXER_ADC_SETLVL MSG_TYPE_MIXER+34
                            18130 ; 258  |#define MIXER_ADC_MUTE MSG_TYPE_MIXER+35
                            18131 ; 259  |#define MIXER_ADC_UNMUTE MSG_TYPE_MIXER+36
                            18132 ; 260  |#define MIXER_REC_SELECT MSG_TYPE_MIXER+37
                            18133 ; 261  |#define MIXER_POWER_DOWN MSG_TYPE_MIXER+38
                            18134 ; 262  |#define ENABLE_RIGHT_CH MSG_TYPE_MIXER+39
                            18135 ; 263  |#define DISABLE_RIGHT_CH MSG_TYPE_MIXER+40
                            18136 ; 264  |#define MIXER_LAST_MSG_ID MSG_TYPE_MIXER+40
                            18137 ; 265  |// If you change the mixer message ID's then you must
                            18138 ; 266  |// also change the jump table in mixer.asm
                            18139 ; 267  |#define MIXER_ON 0
                            18140 ; 268  |#define MIXER_OFF 1
                            18141 ; 269  |
                            18142 ; 270  |
                            18143 ; 271  |// System Message IDs
                            18144 ; 272  |#define SYSTEM_FIRST_MSG_ID MSG_TYPE_SYSTEM+0
                            18145 ; 273  |#define SYSTEM_SHUTDOWN MSG_TYPE_SYSTEM+0
                            18146 ; 274  |#define SYSTEM_SHUTDOWN_FALSE MSG_TYPE_SYSTEM+1
                            18147 ; 275  |#define SYSTEM_SHUTDOWN_FINAL MSG_TYPE_SYSTEM+2
                            18148 ; 276  |#define SYSTEM_LAST_MSG_ID MSG_TYPE_SYSTEM+2
                            18149 ; 277  |// If you change the system message ID's then you must
                            18150 ; 278  |// also change the jump table in systemapi.asm
                            18151 ; 279  |
                            18152 ; 280  |// Menu IDs
                            18153 ; 281  |#define MENU_FIRST_MSG_ID MSG_TYPE_MENU+0
                            18154 ; 282  |#define MENU_BUTTON_EVENT MSG_TYPE_MENU+0
                            18155 ; 283  |#define MENU_DECODER_STATE_CHNG MSG_TYPE_MENU+1
                            18156 ; 284  |#define MENU_RECORDER_STATE_CHNG MSG_TYPE_MENU+2
                            18157 ; 285  |//sub parameters for this message:
                            18158 ; 286  |#define RECORDER_START 0
                            18159 ; 287  |#define RECORDER_PAUSE 0x2000
                            18160 ; 288  |#define RECORDER_RESUME 0x4000
                            18161 ; 289  |#define RECORDER_STOP_NORMAL 0x8000
                            18162 ; 290  |#define RECORDER_STOP_FILE_ERROR 0x8001
                            18163 ; 291  |#define RECORDER_STOP_OUT_OF_SPACE 0x8002
                            18164 ; 292  |#define RECORDER_STOP_LOW_BATTERY 0x8003
                            18165 ; 293  |#define MENU_SONG_TIME_CHNG MSG_TYPE_MENU+3
                            18166 ; 294  |#define MENU_AB_MODE_OFF MSG_TYPE_MENU+4
                            18167 ; 295  |#define MENU_BATTERY_CHNG MSG_TYPE_MENU+5
                            18168 ; 296  |#define MENU_SCROLL_TITLE MSG_TYPE_MENU+6
                            18169 ; 297  |#define MENU_AUTO_SHUTDOWN MSG_TYPE_MENU+7
                            18170 ; 298  |#define MENU_MSG_MEDIA_CHANGED MSG_TYPE_MENU+8
                            18171 ; 299  |#define MENU_MSG_MEDIA_OVER_CUR MSG_TYPE_MENU+9
                            18172 ; 300  |#define MENU_TUNER_TUNED MSG_TYPE_MENU+10
                            18173 ; 301  |#define MENU_MSG_ENC_LOW_SPACE MSG_TYPE_MENU+11
                            18174 ; 302  |#define MENU_MSG_EQ_SETTINGS MSG_TYPE_MENU+12
                            18175 ; 303  |#define MENU_RECORDER_WRITE_DATA MSG_TYPE_MENU+13
                            18176 ; 304  |#define MENU_SONG_TRACK_CHNG MSG_TYPE_MENU+14
                            18177 ; 305  |#define MENU_SET_SONG_POSITION MSG_TYPE_MENU+15
                            18178 ; 306  |#define MENU_UPDATE_CHAPTER_INFO MSG_TYPE_MENU+16
                            18179 ; 307  |#define MENU_USB_CONNECTED MSG_TYPE_MENU+17
                            18180 ; 308  |#define MENU_MSG_LYRICS_SYNC_AB MSG_TYPE_MENU+18
                            18181 ; 309  |#define MENU_MSG_LYRICS_UPDATE MSG_TYPE_MENU+19
                            18182 ; 310  |#define MENU_TUNER_REFRESH_DISPLAY MSG_TYPE_MENU+20
                            18183 ; 311  |#define MENU_TUNER_DIRTY_FLASH MSG_TYPE_MENU+21
                            18184 ; 312  |#define MENU_LAST_MSG_ID MSG_TYPE_MENU+21
                            18185 ; 313  |
                            18186 ; 314  |// Note that other versions of this file have different msg equates.
                            18187 ; 315  |// If you change the system message ID's then you must
                            18188 ; 316  |// also change the jump table in all menu *.asm
                            18189 ; 317  |
                            18190 ; 318  |// LED Message IDs
                            18191 ; 319  |#define LED_FIRST_MSG_ID MSG_TYPE_LED+0
                            18192 ; 320  |#define LED_CONTROL MSG_TYPE_LED+0
                            18193 ; 321  |#define LED_RESET MSG_TYPE_LED+1
                            18194 ; 322  |#define LED_DLY_ON_CONTROL MSG_TYPE_LED+2
                            18195 ; 323  |#define LED_LAST_MSG_ID MSG_TYPE_LED+2
                            18196 ; 324  |// If you change the LeD message ID's then you must
                            18197 ; 325  |// also change the jump table in ledapi.asm
                            18198 ; 326  |
                            18199 ; 327  |#if (!defined(REMOVE_FM))
                            18200 ; 328  |// FM Tuner Message IDs
                            18201 ; 329  |#define TUNER_FIRST_MSG_ID MSG_TYPE_TUNER+0
                            18202 ; 330  |#define TUNER_TUNE_FREQUENCY MSG_TYPE_TUNER+0
                            18203 ; 331  |#define TUNER_TUNE_MANUAL_UP MSG_TYPE_TUNER+1
                            18204 ; 332  |#define TUNER_TUNE_MANUAL_DOWN MSG_TYPE_TUNER+2
                            18205 ; 333  |#define TUNER_TUNE_SEARCH_UP MSG_TYPE_TUNER+3
                            18206 ; 334  |#define TUNER_TUNE_SEARCH_DOWN MSG_TYPE_TUNER+4
                            18207 ; 335  |#define TUNER_FORCED_MONO MSG_TYPE_TUNER+5
                            18208 ; 336  |#define TUNER_RESET MSG_TYPE_TUNER+6
                            18209 ; 337  |#define TUNER_POWER_ON MSG_TYPE_TUNER+7
                            18210 ; 338  |#define TUNER_POWER_OFF MSG_TYPE_TUNER+8
                            18211 ; 339  |#define TUNER_SET_SENSITIVITY MSG_TYPE_TUNER+9
                            18212 ; 340  |//one parameter--the sensitivity in uV
                            18213 ; 341  |#define TUNER_GET_STATES MSG_TYPE_TUNER+10
                            18214 ; 342  |#define TUNER_MUTE_OUTPUTS MSG_TYPE_TUNER+11
                            18215 ; 343  |#define TUNER_PRESET_STATION MSG_TYPE_TUNER+12
                            18216 ; 344  |#define TUNER_TUNE_TO_PRESET MSG_TYPE_TUNER+13
                            18217 ; 345  |#define TUNER_SET_PRESET MSG_TYPE_TUNER+14
                            18218 ; 346  |#define TUNER_ERASE_PRESET MSG_TYPE_TUNER+15
                            18219 ; 347  |#define TUNER_LAST_MSG_ID MSG_TYPE_TUNER+15
                            18220 ; 348  |#endif
                            18221 ; 349  |
                            18222 ; 350  |#define SOFT_TIMER_FIRST_MSG_ID MSG_TYPE_SOFT_TIMER+0
                            18223 ; 351  |#define SOFT_TIMER_SET_TIMER MSG_TYPE_SOFT_TIMER+1
                            18224 ; 352  |#define SOFT_TIMER_KILL_TIMER MSG_TYPE_SOFT_TIMER+2
                            18225 ; 353  |#define SOFT_TIMER_LAST_MSG_ID MSG_TYPE_SOFT_TIMER+2
                            18226 ; 354  |
                            18227 ; 355  |
                            18228 ; 356  |#define GEQ_FIRST_MSG_ID MSG_TYPE_GEQ+0
                            18229 ; 357  |#define GEQ_SET_EQ MSG_TYPE_GEQ+0
                            18230 ; 358  |#define GEQ_SET_EQ_LEGACY MSG_TYPE_GEQ+1
                            18231 ; 359  |#define GEQ_SET_ALL_BAND_GAINS MSG_TYPE_GEQ+2
                            18232 ; 360  |#define GEQ_SET_GAIN MSG_TYPE_GEQ+3
                            18233 ; 361  |#define GEQ_SET_COEFFICIENTS MSG_TYPE_GEQ+4
                            18234 ; 362  |#define GEQ_SET_PARAM MSG_TYPE_GEQ+5
                            18235 ; 363  |#define GEQ_GET_SETTINGS MSG_TYPE_GEQ+6
                            18236 ; 364  |#define GEQ_LAST_MSG_ID MSG_TYPE_GEQ+6
                            18237 ; 365  |
                            18238 ; 366  |#if (defined(USE_PLAYLIST3))
                            18239 ; 367  |// Music Library
                            18240 ; 368  |#define MUSICLIB_PLAY_FIRST_MSG_ID MSG_TYPE_MUSICLIB_PLAY+0
                            18241 ; 369  |#define MUSICLIB_START_PLAY_SONG MSG_TYPE_MUSICLIB_PLAY+0
                            18242 ; 370  |#define MUSICLIB_START_PLAY_ALL_SONG MSG_TYPE_MUSICLIB_PLAY+1
                            18243 ; 371  |#define MUSICLIB_PLAY_SETSHUFFLE MSG_TYPE_MUSICLIB_PLAY+2
                            18244 ; 372  |#define MUSICLIB_PLAY_RESUME MSG_TYPE_MUSICLIB_PLAY+3
                            18245 ; 373  |#define MUSICLIB_PLAY_CURRENT_SIZE MSG_TYPE_MUSICLIB_PLAY+4
                            18246 ; 374  |#define MUSICLIB_PLAY_LAST_MSG_ID MSG_TYPE_MUSICLIB_PLAY+4
                            18247 ; 375  |
                            18248 ; 376  |#define MUSICLIB_BROWSE_FIRST_MSG_ID MSG_TYPE_MUSICLIB_BROWSE+0
                            18249 ; 377  |#define MUSICLIB_BROWSE_SETROOT MSG_TYPE_MUSICLIB_BROWSE+0
                            18250 ; 378  |#define MUSICLIB_BROWSE_BROWSEMENU MSG_TYPE_MUSICLIB_BROWSE+1
                            18251 ; 379  |#define MUSICLIB_BROWSE_DOWNLIST MSG_TYPE_MUSICLIB_BROWSE+2
                            18252 ; 380  |#define MUSICLIB_BROWSE_UPLIST MSG_TYPE_MUSICLIB_BROWSE+3
                            18253 ; 381  |#define MUSICLIB_BROWSE_UPMENU MSG_TYPE_MUSICLIB_BROWSE+4
                            18254 ; 382  |#define MUSICLIB_BROWSE_SONGNUMBER MSG_TYPE_MUSICLIB_BROWSE+5
                            18255 ; 383  |#define MUSICLIB_BROWSE_ON_THE_FLY_GET_STATUS MSG_TYPE_MUSICLIB_BROWSE+6
                            18256 ; 384  |#define MUSICLIB_BROWSE_ON_THE_FLY_ADD_ITEM MSG_TYPE_MUSICLIB_BROWSE+7
                            18257 ; 385  |#define MUSICLIB_BROWSE_ON_THE_FLY_DELETE_ITEM MSG_TYPE_MUSICLIB_BROWSE+8
                            18258 ; 386  |#define MUSICLIB_BROWSE_ON_THE_FLY_DELETE_ALL MSG_TYPE_MUSICLIB_BROWSE+9
                            18259 ; 387  |#define MUSICLIB_BROWSE_LAST_MSG_ID MSG_TYPE_MUSICLIB_BROWSE+9
                            18260 ; 388  |
                            18261 ; 389  |#define MUSICLIB_PLAYALLNEXT_FIRST_MSG_ID MSG_TYPE_MUSICLIB_PLAYALLNEXT+0
                            18262 ; 390  |#define MUSICLIB_PLAYNEXTSONG MSG_TYPE_MUSICLIB_PLAYALLNEXT+0
                            18263 ; 391  |#define MUSICLIB_PLAYALLNEXT_LAST_MSG_ID MSG_TYPE_MUSICLIB_PLAYALLNEXT+0
                            18264 ; 392  |
                            18265 ; 393  |#define MUSICLIB_PLAYALLPREV_FIRST_MSG_ID MSG_TYPE_MUSICLIB_PLAYALLPREV+0
                            18266 ; 394  |#define MUSICLIB_PLAYPREVIOUSSONG MSG_TYPE_MUSICLIB_PLAYALLPREV+0
                            18267 ; 395  |#define MUSICLIB_PLAYALLPREV_LAST_MSG_ID MSG_TYPE_MUSICLIB_PLAYALLPREV+0
                            18268 ; 396  |
                            18269 ; 397  |#define MUSICLIB_SHUFFLE_FIRST_MSG_ID MSG_TYPE_MUSICLIB_SHUFFLE+0
                            18270 ; 398  |#define MUSICLIB_SHUFFLE_NEXT MSG_TYPE_MUSICLIB_SHUFFLE+0
                            18271 ; 399  |#define MUSICLIB_SHUFFLE_LAST_MSG_ID MSG_TYPE_MUSICLIB_SHUFFLE+0
                            18272 ; 400  |
                            18273 ; 401  |#define MUSICLIB_VOICE_FIRST_MSG_ID MSG_TYPE_MUSICLIB_VOICE+0
                            18274 ; 402  |#define MUSICLIB_VOICE_BROWSEMENU MSG_TYPE_MUSICLIB_VOICE+0
                            18275 ; 403  |#define MUSICLIB_VOICE_DOWNLIST MSG_TYPE_MUSICLIB_VOICE+1
                            18276 ; 404  |#define MUSICLIB_VOICE_UPLIST MSG_TYPE_MUSICLIB_VOICE+2
                            18277 ; 405  |#define MUSICLIB_VOICE_UPMENU MSG_TYPE_MUSICLIB_VOICE+3
                            18278 ; 406  |#define MUSICLIB_VOICE_VOICENUMBER MSG_TYPE_MUSICLIB_VOICE+4
                            18279 ; 407  |#define MUSICLIB_VOICE_LAST_MSG_ID MSG_TYPE_MUSICLIB_VOICE+4
                            18280 ; 408  |
                            18281 ; 409  |#define MUSICLIB_VOICEPLAY_FIRST_MSG_ID MSG_TYPE_MUSICLIB_VOICEPLAY+0
                            18282 ; 410  |#define MUSICLIB_START_PLAY_VOICE MSG_TYPE_MUSICLIB_VOICEPLAY+0
                            18283 ; 411  |#define MUSICLIB_VOICEPLAY_LAST_MSG_ID MSG_TYPE_MUSICLIB_VOICEPLAY+0
                            18284 ; 412  |
                            18285 ; 413  |#define MUSICLIB_MERGE_FIRST_MSG_ID MSG_TYPE_MUSICLIB_MERGE+0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  72

M:ADDR CODE           CYCLES LINE SOURCELINE
                            18286 ; 414  |#define MUSICLIB_MERGE_SONG MSG_TYPE_MUSICLIB_MERGE+0
                            18287 ; 415  |#define MUSICLIB_MERGE_ALL_SONG MSG_TYPE_MUSICLIB_MERGE+1
                            18288 ; 416  |#define MUSICLIB_MERGE_RESUME MSG_TYPE_MUSICLIB_MERGE+2
                            18289 ; 417  |#define MUSICLIB_MERGE_LAST_MSG_ID MSG_TYPE_MUSICLIB_MERGE+2
                            18290 ; 418  |#endif // IF (@def(USE_PLAYLIST3))
                            18291 ; 419  |
                            18292 ; 420  |#if defined(USE_PLAYLIST5)
                            18293 ; 421  |#define PL5_PL_FIRST_MSG_ID MSG_TYPE_PL5_PLAYBACK+0
                            18294 ; 422  |#define PL5_PL_MSG_RESET MSG_TYPE_PL5_PLAYBACK+0
                            18295 ; 423  |#define PL5_PL_MSG_CDSEARCHING MSG_TYPE_PL5_PLAYBACK+1
                            18296 ; 424  |#define PL5_PL_MSG_START MSG_TYPE_PL5_PLAYBACK+2
                            18297 ; 425  |#define PL5_PL_MSG_STOP MSG_TYPE_PL5_PLAYBACK+3
                            18298 ; 426  |#define PL5_PL_MSG_PAUSE MSG_TYPE_PL5_PLAYBACK+4
                            18299 ; 427  |#define PL5_PL_MSG_RESUME MSG_TYPE_PL5_PLAYBACK+5
                            18300 ; 428  |#define PL5_PL_MSG_DELETE MSG_TYPE_PL5_PLAYBACK+6
                            18301 ; 429  |#define PL5_PL_MSG_PLAY MSG_TYPE_PL5_PLAYBACK+7
                            18302 ; 430  |#define PL5_PL_MSG_DISCNT MSG_TYPE_PL5_PLAYBACK+8
                            18303 ; 431  |#define PL5_PL_MSG_ENACNT MSG_TYPE_PL5_PLAYBACK+9
                            18304 ; 432  |#define PL5_PL_LAST_MSG_ID MSG_TYPE_PL5_PLAYBACK+9
                            18305 ; 433  |
                            18306 ; 434  |#define PL5_BR_FIRST_MSG_ID MSG_TYPE_PL5_BROWSE+0
                            18307 ; 435  |#define PL5_BR_MSG_RESET MSG_TYPE_PL5_BROWSE+0
                            18308 ; 436  |#define PL5_BR_MSG_CDBROWSING MSG_TYPE_PL5_BROWSE+1
                            18309 ; 437  |#define PL5_BR_MSG_START MSG_TYPE_PL5_BROWSE+2
                            18310 ; 438  |#define PL5_BR_MSG_STOP MSG_TYPE_PL5_BROWSE+3
                            18311 ; 439  |#define PL5_BR_MSG_PAUSE MSG_TYPE_PL5_BROWSE+4
                            18312 ; 440  |#define PL5_BR_MSG_RESUME MSG_TYPE_PL5_BROWSE+5
                            18313 ; 441  |#define PL5_BR_MSG_DELETE MSG_TYPE_PL5_BROWSE+6
                            18314 ; 442  |#define PL5_BR_LAST_MSG_ID MSG_TYPE_PL5_BROWSE+6
                            18315 ; 443  |#endif // if @def('USE_PLAYLIST5')
                            18316 ; 444  |// Events
                            18317 ; 445  |// No event
                            18318 ; 446  |#define EVENT_NONE 0x000001   
                            18319 ; 447  |// A message has been posted
                            18320 ; 448  |#define EVENT_MESSAGE 0x000002   
                            18321 ; 449  |// Run if wait time elapsed
                            18322 ; 450  |#define EVENT_TIMER 0x000004   
                            18323 ; 451  |// Run if a button event occured
                            18324 ; 452  |#define EVENT_BUTTON 0x000008   
                            18325 ; 453  |// Run if a background event occured
                            18326 ; 454  |#define EVENT_BACKGROUND 0x000010   
                            18327 ; 455  |// The executive should immediately repeat this module
                            18328 ; 456  |#define EVENT_REPEAT 0x000020   
                            18329 ; 457  |// Run the module's init routine
                            18330 ; 458  |#define EVENT_INIT 0x800000   
                            18331 ; 459  |
                            18332 ; 460  |#define EVENT_NONE_BITPOS 0
                            18333 ; 461  |#define EVENT_MESSAGE_BITPOS 1
                            18334 ; 462  |#define EVENT_TIMER_BITPOS 2
                            18335 ; 463  |#define EVENT_BUTTON_BITPOS 3
                            18336 ; 464  |#define EVENT_BACKGROUND_BITPOS 4
                            18337 ; 465  |#define EVENT_REPEAT_BITPOS 5
                            18338 ; 466  |#define EVENT_INIT_BITPOS 23
                            18339 ; 467  |
                            18340 ; 468  |// Parser Message Buffers
                            18341 ; 469  |#define ParserPlayBit 0
                            18342 ; 470  |#define ButtonPressBit 1
                            18343 ; 471  |#define ParserRwndBit 1
                            18344 ; 472  |#define ParserFfwdBit 2
                            18345 ; 473  |
                            18346 ; 474  |//NextSong Message Parameters
                            18347 ; 475  |// ButtonPressBit1 set to denote button was pressed.
                            18348 ; 476  |#define NEXT_SONG 2             
                            18349 ; 477  |// ButtonPressBit1 cleared
                            18350 ; 478  |#define NEXT_SONG_PLAY_EOF 1          
                            18351 ; 479  |// ButtonPressBit1 set
                            18352 ; 480  |#define NEXT_SONG_PLAY_BUTTON 3          
                            18353 ; 481  |// NextSong + Ffwd
                            18354 ; 482  |#define NEXT_SONG_FFWD 4          
                            18355 ; 483  |
                            18356 ; 484  |//PrevSong Message Parameters
                            18357 ; 485  |// PrevSong + Stopped
                            18358 ; 486  |#define PREV_SONG 0          
                            18359 ; 487  |// PrevSong + Play
                            18360 ; 488  |#define PREV_SONG_PLAY 1          
                            18361 ; 489  |// PrevSong + Rwnd
                            18362 ; 490  |#define PREV_SONG_RWND 2          
                            18363 ; 491  |
                            18364 ; 492  |
                            18365 ; 493  |
                            18366 ; 494  |
                            18367 ; 495  |#endif // IF (!@def(MSGEQU_INC))
                            18368 ; 496  |
                            18369 ; 497  |
                            18370 
                            18372 
                            18373 ; 100  |#include "project.h"
                            18374 
                            18376 
                            18377 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                            18378 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                            18379 ; 3    |//  Filename: project.inc
                            18380 ; 4    |//  Description: 
                            18381 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                            18382 ; 6    |
                            18383 ; 7    |#if (!defined(_PROJECT_INC))
                            18384 ; 8    |#define _PROJECT_INC 1
                            18385 ; 9    |
                            18386 ; 10   |#if defined(STMP_BUILD_PLAYER)
                            18387 ; 11   |#include "hwequ.h"
                            18388 ; 12   |#else 
                            18389 ; 13   |//include "regscodec.inc"
                            18390 ; 14   |#endif
                            18391 ; 15   |
                            18392 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                            18393 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults ON) & 
                            18394 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm. STMP00012148
                            18395 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal). 
                            18396 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's specs can 
                            18397 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player mode.  
                            18398 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                            18399 ; 23   |
                            18400 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                            18401 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                            18402 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                            18403 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define below by defining
                            18404 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                            18405 ; 29   |#define ATTEMPT_FAST_BOOT 1
                            18406 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                            18407 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot config above- 
                            18408 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down threshholds by maybe 50mV.
                            18409 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed.
                            18410 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                            18411 ; 35   |
                            18412 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                            18413 ; 37   |// MEDIA DEFINITIONS
                            18414 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                            18415 ; 39   |
                            18416 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                            18417 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                            18418 ; 42   |#if defined(NAND1)
                            18419 ; 43   |#define SM_INTERNAL_CHIPS 1
                            18420 ; 44   |#else 
                            18421 ; 45   |#if defined(NAND2)
                            18422 ; 46   |#define SM_INTERNAL_CHIPS 2
                            18423 ; 47   |#else 
                            18424 ; 48   |#if defined(NAND3)
                            18425 ; 49   |#define SM_INTERNAL_CHIPS 3
                            18426 ; 50   |#else 
                            18427 ; 51   |#if defined(NAND4)
                            18428 ; 52   |#define SM_INTERNAL_CHIPS 4
                            18429 ; 53   |#else 
                            18430 ; 54   |#define SM_INTERNAL_CHIPS 1
                            18431 ; 55   |#endif
                            18432 ; 56   |#endif
                            18433 ; 57   |#endif
                            18434 ; 58   |#endif
                            18435 ; 59   |
                            18436 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                            18437 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                            18438 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it reads 0.  
                            18439 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                            18440 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it reads 1.
                            18441 ; 65   |//*** comment out if active high ****
                            18442 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                            18443 ; 67   |
                            18444 ; 68   |#if defined(SMEDIA)
                            18445 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                            18446 ; 70   |#define NUM_SM_EXTERNAL 1
                            18447 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                            18448 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                            18449 ; 73   |#else 
                            18450 ; 74   |#if defined(MMC)
                            18451 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                            18452 ; 76   |#define NUM_SM_EXTERNAL 0
                            18453 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                            18454 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                            18455 ; 79   |#else 
                            18456 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                            18457 ; 81   |#define NUM_SM_EXTERNAL 0
                            18458 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                            18459 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                            18460 ; 84   |#endif
                            18461 ; 85   |#endif
                            18462 ; 86   |
                            18463 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                            18464 ; 88   |// Mass Storage Class definitions
                            18465 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                            18466 ; 90   |// Set to 0 if Composite Device build is desired.    
                            18467 ; 91   |#define MULTI_LUN_BUILD 1   
                            18468 ; 92   |
                            18469 ; 93   |////////////////////////////////////////////////////////////////////////////////
                            18470 ; 94   |//  SCSI
                            18471 ; 95   |#if (MULTI_LUN_BUILD==0)
                            18472 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                            18473 ; 97   |    #define SCSI_NUM_TARGETS                        2
                            18474 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                            18475 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                            18476 ; 100  |  #else
                            18477 ; 101  |    #define SCSI_NUM_TARGETS                        1
                            18478 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                            18479 ; 103  |  #endif
                            18480 ; 104  |#else
                            18481 ; 105  |    #define SCSI_NUM_TARGETS                        1
                            18482 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                            18483 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                            18484 ; 108  |  #else
                            18485 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                            18486 ; 110  |  #endif
                            18487 ; 111  |#endif
                            18488 ; 112  |
                            18489 ; 113  |
                            18490 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                            18491 ; 115  |
                            18492 ; 116  |
                            18493 ; 117  |////////////////////////////////////////////////////////////////////////////////
                            18494 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                            18495 ; 119  |////////////////////////////////////////////////////////////////////////////////
                            18496 ; 120  |#ifdef MMC
                            18497 ; 121  |#ifdef MTP_BUILD
                            18498 ; 122  |// --------------------
                            18499 ; 123  |// MTP and MMC
                            18500 ; 124  |// --------------------
                            18501 ; 125  |#define NUM_LOGICAL_MEDIA       2
                            18502 ; 126  |#define NUM_LOGICAL_DRIVES      8
                            18503 ; 127  |#else  // ifndef MTP_BUILD
                            18504 ; 128  |#ifdef STMP_BUILD_PLAYER
                            18505 ; 129  |// --------------------
                            18506 ; 130  |// Player and MMC
                            18507 ; 131  |// --------------------
                            18508 ; 132  |#else
                            18509 ; 133  |// --------------------
                            18510 ; 134  |// USBMSC and MMC
                            18511 ; 135  |// --------------------
                            18512 ; 136  |#define NUM_LOGICAL_MEDIA       3
                            18513 ; 137  |#define NUM_LOGICAL_DRIVES      8
                            18514 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                            18515 ; 139  |#endif // ifdef MTP_BUILD
                            18516 ; 140  |#else  // ifndef MMC
                            18517 ; 141  |#ifdef MTP_BUILD
                            18518 ; 142  |// --------------------
                            18519 ; 143  |// MTP and NAND only
                            18520 ; 144  |// --------------------
                            18521 ; 145  |#define NUM_LOGICAL_MEDIA       1
                            18522 ; 146  |#define NUM_LOGICAL_DRIVES      7
                            18523 ; 147  |#else  // ifndef MTP_BUILD
                            18524 ; 148  |#ifdef STMP_BUILD_PLAYER
                            18525 ; 149  |// --------------------
                            18526 ; 150  |// Player and NAND only
                            18527 ; 151  |// --------------------
                            18528 ; 152  |#else
                            18529 ; 153  |// --------------------
                            18530 ; 154  |// USBMSC and NAND only
                            18531 ; 155  |// --------------------
                            18532 ; 156  |#define NUM_LOGICAL_MEDIA       2
                            18533 ; 157  |#define NUM_LOGICAL_DRIVES      7
                            18534 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                            18535 ; 159  |#endif // ifdef MTP_BUILD
                            18536 ; 160  |#endif // ifdef MMC 
                            18537 ; 161  |
                            18538 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  73

M:ADDR CODE           CYCLES LINE SOURCELINE
                            18539 ; 163  |#if (defined(MTP_BUILD))
                            18540 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                            18541 ; 165  |
                            18542 ; 166  |////!
                            18543 ; 167  |////! This varible holds the watchdog count for the store flush.
                            18544 ; 168  |////!
                            18545 ; 169  |///
                            18546 ; 170  |#include <types.h>
                            18547 ; 171  |extern volatile INT g_StoreWatchDogCount;
                            18548 ; 172  |extern const INT g_StoreWatchDogTimeout;
                            18549 ; 173  |#endif
                            18550 ; 174  |
                            18551 ; 175  |////////////////////////////////////////////////////////////////////////////////
                            18552 ; 176  |// These are needed here for Mass Storage Class
                            18553 ; 177  |// Needs to be cleaned up
                            18554 ; 178  |////////////////////////////////////////////////////////////////////////////////
                            18555 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                            18556 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                            18557 ; 181  |#define SCRATCH_USER_X_SIZE 512
                            18558 ; 182  |
                            18559 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                            18560 ; 184  |
                            18561 ; 185  |#endif
                            18562 ; 186  |
                            18563 ; 187  |
                            18564 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                            18565 ; 189  |// SmartMedia/NAND defs
                            18566 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                            18567 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                            18568 ; 192  |
                            18569 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                            18570 ; 194  |// Sysloadresources defs
                            18571 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                            18572 ; 196  |
                            18573 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                            18574 ; 198  |// MMC defs
                            18575 ; 199  |#define MMC_MAX_PARTITIONS 1
                            18576 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                            18577 ; 201  |
                            18578 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                            18579 ; 203  |// SPI defs
                            18580 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                            18581 ; 205  |
                            18582 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                            18583 ; 207  |// Global media defs
                            18584 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                            18585 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                            18586 ; 210  |
                            18587 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                            18588 ; 212  |// DO NOT CHANGE THESE!!!
                            18589 ; 213  |#define SM_MAX_PARTITIONS 4
                            18590 ; 214  |#define MAX_HANDLES 2
                            18591 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                            18592 ; 216  |
                            18593 ; 217  |
                            18594 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                            18595 ; 219  |// Battery LRADC Values 
                            18596 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                            18597 ; 221  |// brownout trip point in mV (moved by RS)
                            18598 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                            18599 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                            18600 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                            18601 ; 225  |//     audio recording to media.
                            18602 ; 226  |#define BATT_SAFETY_MARGIN 10
                            18603 ; 227  |
                            18604 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                            18605 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline voltage to do a refresh.
                            18606 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                            18607 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                            18608 ; 232  |
                            18609 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc presence.
                            18610 ; 234  |
                            18611 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                            18612 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat check.
                            18613 ; 237  |#if (!defined(CLCD))
                            18614 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                            18615 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                            18616 ; 240  |#else 
                            18617 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                            18618 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                            18619 ; 243  |#endif
                            18620 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                            18621 ; 245  |
                            18622 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                            18623 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIon.
                            18624 ; 248  |// See mp3 encoder overlay.
                            18625 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                            18626 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                            18627 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                            18628 ; 252  |
                            18629 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                            18630 ; 254  |// Voice recording filenames
                            18631 ; 255  |// number of digits in filename Vxxx.wav
                            18632 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                            18633 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                            18634 ; 258  |
                            18635 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                            18636 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                            18637 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                            18638 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                            18639 ; 263  |#if defined(DEVICE_3500)
                            18640 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                            18641 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                            18642 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                            18643 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, & demo player)
                            18644 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                            18645 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                            18646 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                            18647 ; 271  |
                            18648 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn when bias not yet ready.
                            18649 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                            18650 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevention if you use rec button from outside voice menu.
                            18651 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latency in the record-from-music-menu use-case.
                            18652 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                            18653 ; 277  |
                            18654 ; 278  |#else 
                            18655 ; 279  |// STMP3410
                            18656 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                            18657 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                            18658 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                            18659 ; 283  |#endif
                            18660 ; 284  |
                            18661 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                            18662 ; 286  |// Number of available soft timers
                            18663 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                            18664 ; 288  |#if defined(SYNC_LYRICS)
                            18665 ; 289  |#define SOFT_TIMERS 10
                            18666 ; 290  |#else 
                            18667 ; 291  |#if defined(JPEG_DECODER)
                            18668 ; 292  |#define SOFT_TIMERS 10
                            18669 ; 293  |#else 
                            18670 ; 294  |#define SOFT_TIMERS 9
                            18671 ; 295  |#endif
                            18672 ; 296  |#endif
                            18673 ; 297  |
                            18674 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                            18675 ; 299  |//  sizes
                            18676 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                            18677 ; 301  |#if defined(MMC)
                            18678 ; 302  |#if defined(USE_PLAYLIST5)
                            18679 ; 303  |#define MENU_STACK_SIZE 1500
                            18680 ; 304  |#else 
                            18681 ; 305  |#define MENU_STACK_SIZE 1250
                            18682 ; 306  |#endif //if @def('USE_PLAYLIST5')
                            18683 ; 307  |#else 
                            18684 ; 308  |#if defined(USE_PLAYLIST5)
                            18685 ; 309  |#define MENU_STACK_SIZE 1500
                            18686 ; 310  |#else 
                            18687 ; 311  |#define MENU_STACK_SIZE 1250
                            18688 ; 312  |#endif //if @def('USE_PLAYLIST5')
                            18689 ; 313  |#endif //if @def('MMC')
                            18690 ; 314  |
                            18691 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 750 else 550 for other builds? TOVERIFY. MYALLOC
                            18692 ; 316  |// 
                            18693 ; 317  |#define STACK_L1_SIZE 750
                            18694 ; 318  |#define STACK_L2_SIZE 100
                            18695 ; 319  |#define STACK_L3_SIZE 160
                            18696 ; 320  |
                            18697 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                            18698 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                            18699 ; 323  |// is ok with switching code.
                            18700 ; 324  |#if defined(MTP_BUILD)
                            18701 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                            18702 ; 326  |#endif
                            18703 ; 327  |
                            18704 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                            18705 ; 329  |// maximum number of nested funclets 
                            18706 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                            18707 ; 331  |#define MAX_NESTED_FUNCLET 6 
                            18708 ; 332  |
                            18709 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                            18710 ; 334  |//    LCD DEFINITIONS
                            18711 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                            18712 ; 336  |
                            18713 ; 337  |#define SPACE_CHAR 0x000020          
                            18714 ; 338  |#define ZERO_CHAR 0x000030
                            18715 ; 339  |#define COLON_CHAR 0x00003A
                            18716 ; 340  |#define PERIOD_CHAR 0x00002E
                            18717 ; 341  |
                            18718 ; 342  |#if (defined(S6B33B0A_LCD))
                            18719 ; 343  |#define LCD_X_SIZE 128
                            18720 ; 344  |#define LCD_Y_SIZE 159
                            18721 ; 345  |#endif
                            18722 ; 346  |
                            18723 ; 347  |#if (defined(SED15XX_LCD))
                            18724 ; 348  |#define LCD_X_SIZE 128
                            18725 ; 349  |#define LCD_Y_SIZE 64
                            18726 ; 350  |#endif
                            18727 ; 351  |
                            18728 ; 352  |
                            18729 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                            18730 ; 354  |//   Details on Customizing Contrast
                            18731 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                            18732 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                            18733 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                            18734 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                            18735 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                            18736 ; 360  |//   unless the ezact sequence is remembered.
                            18737 ; 361  |//   To find out what range your player supports: 
                            18738 ; 362  |//   change these equs to full range or comment out (full range is default)
                            18739 ; 363  |//;;;;;;
                            18740 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                            18741 ; 365  |// recommended calibration using player -- uncomment 
                            18742 ; 366  |//;;;;;;
                            18743 ; 367  |//CONTRAST_CALIBRATION    equ  1
                            18744 ; 368  |////////////////////////////
                            18745 ; 369  |#if (defined(DEMO_HW))
                            18746 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi LCD (June6'05)
                            18747 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                            18748 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                            18749 ; 373  |#else 
                            18750 ; 374  |
                            18751 ; 375  |#if (defined(S6B33B0A_LCD))
                            18752 ; 376  |#define LCD_MAX_CONTRAST 210
                            18753 ; 377  |#define LCD_MIN_CONTRAST 160    
                            18754 ; 378  |#endif
                            18755 ; 379  |
                            18756 ; 380  |#if (defined(SED15XX_LCD))
                            18757 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                            18758 ; 382  |// Engineering board regs support range [17-37].
                            18759 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                            18760 ; 384  |//   One default contrast range [24-42] works for both.
                            18761 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                            18762 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                            18763 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                            18764 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                            18765 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                            18766 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                            18767 ; 391  |
                            18768 ; 392  |#if (defined(NEWSHINGYIH))
                            18769 ; 393  |#define LCD_MAX_CONTRAST 250
                            18770 ; 394  |#define LCD_MIN_CONTRAST 0
                            18771 ; 395  |#else 
                            18772 ; 396  |//-----
                            18773 ; 397  |// Near optimal for OLD LCD with NEW file. 
                            18774 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for both LCDs.
                            18775 ; 399  |#define LCD_MAX_CONTRAST 250
                            18776 ; 400  |#define LCD_MIN_CONTRAST 0
                            18777 ; 401  |
                            18778 ; 402  |//=====
                            18779 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                            18780 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this historic ver.
                            18781 ; 405  |//LCD_MAX_CONTRAST equ 42
                            18782 ; 406  |//LCD_MIN_CONTRAST equ 24 
                            18783 ; 407  |
                            18784 ; 408  |#endif
                            18785 ; 409  |#endif
                            18786 ; 410  |
                            18787 ; 411  |#endif
                            18788 ; 412  |
                            18789 ; 413  |//////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  74

M:ADDR CODE           CYCLES LINE SOURCELINE
                            18790 ; 414  |// The default value of the lcd contrast in % of range
                            18791 ; 415  |//   the default value is used when no settings.dat is available
                            18792 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                            18793 ; 417  |
                            18794 ; 418  |#if (defined(S6B33B0A_LCD))
                            18795 ; 419  |// 60% of range is default value
                            18796 ; 420  |#define DEFAULT_CONTRAST 50 
                            18797 ; 421  |#endif
                            18798 ; 422  |
                            18799 ; 423  |#if (defined(SED15XX_LCD))
                            18800 ; 424  |// % of range is default value (was 60%)
                            18801 ; 425  |#define DEFAULT_CONTRAST 50 
                            18802 ; 426  |#endif
                            18803 ; 427  |
                            18804 ; 428  |
                            18805 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                            18806 ; 430  |// make lower when doing calibration
                            18807 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                            18808 ; 432  |
                            18809 ; 433  |
                            18810 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                            18811 ; 435  |// For FFWD and RWND
                            18812 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                            18813 ; 437  |#define SECONDS_TO_SKIP 1
                            18814 ; 438  |#define SECONDS_TO_SKIP1 3
                            18815 ; 439  |#define SECONDS_TO_SKIP2 6
                            18816 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                            18817 ; 441  |#define PREV_SONG_THRESHOLD 5  
                            18818 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            18819 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                            18820 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            18821 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                            18822 ; 446  |
                            18823 ; 447  |// For audible FFW/RWD
                            18824 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                            18825 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                            18826 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                            18827 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                            18828 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            18829 ; 453  |#define LEVEL1_BOUNDARY 17 
                            18830 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            18831 ; 455  |#define LEVEL2_BOUNDARY 33 
                            18832 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                            18833 ; 457  |#define LEVEL3_BOUNDARY 50 
                            18834 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                            18835 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                            18836 ; 460  |// Short Song Time, songs too short to play.
                            18837 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                            18838 ; 462  |
                            18839 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                            18840 ; 464  |// MP3 Sync Values
                            18841 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                            18842 ; 466  |// # bytes to look for sync before marking it bad
                            18843 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                            18844 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                            18845 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                            18846 ; 470  |// once we have sync'd, the isr should be called this frequently
                            18847 ; 471  |#define MP3_DECODERISR_FAST 7500  
                            18848 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                            18849 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                            18850 ; 474  |
                            18851 ; 475  |
                            18852 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                            18853 ; 477  |//// Multi-Stage Volume Control Definitions
                            18854 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                            18855 ; 479  |//// Use Multi-Stage Volume
                            18856 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                            18857 ; 481  |
                            18858 ; 482  |//// Master Volume definitions
                            18859 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                            18860 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                            18861 ; 485  |
                            18862 ; 486  |//// DAC-Mode definitions
                            18863 ; 487  |//// Adjusts 0dB point
                            18864 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                            18865 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                            18866 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines above.
                            18867 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                            18868 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provides 1.5 dB gain on Stmp34x0; 
                            18869 ; 493  |//                                               Max gain possible: 8 step diff would provide +12dB gain.   
                            18870 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                            18871 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                            18872 ; 496  |
                            18873 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                            18874 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                            18875 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                            18876 ; 500  |
                            18877 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not the default
                            18878 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoint.
                            18879 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                            18880 ; 504  |
                            18881 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the default
                            18882 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                            18883 ; 507  |
                            18884 ; 508  |
                            18885 ; 509  |//// Line In definitions (used for Line-In 1)
                            18886 ; 510  |//// 0dB point of the Line In
                            18887 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                            18888 ; 512  |//// Minimum volume of Line In
                            18889 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                            18890 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                            18891 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                            18892 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                            18893 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                            18894 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS+1)
                            18895 ; 519  |
                            18896 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                            18897 ; 521  |//// 0dB point of the Line In
                            18898 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                            18899 ; 523  |//// Minimum volume of Line In
                            18900 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                            18901 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                            18902 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                            18903 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                            18904 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                            18905 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                            18906 ; 530  |
                            18907 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                            18908 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid deadlock states & recovers. 
                            18909 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                            18910 ; 534  |#define FM_WATCHDOG_ENABLE 1
                            18911 ; 535  |
                            18912 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                            18913 ; 537  |////
                            18914 ; 538  |////! This varible holds the lcd display state for the mtp project.
                            18915 ; 539  |////
                            18916 ; 540  |///
                            18917 ; 541  |#include <types.h>
                            18918 ; 542  |extern volatile WORD g_wActivityState;
                            18919 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                            18920 ; 544  |
                            18921 ; 545  |void _reentrant Init5VSense(void);
                            18922 ; 546  |void _reentrant ServiceDCDC(void);
                            18923 ; 547  |
                            18924 ; 548  |////////////////////////////////////////////////////////////////////////////
                            18925 ; 549  |//// JPEG Thumbnail Mode Setting
                            18926 ; 550  |//// number of column in thumbnail mode
                            18927 ; 551  |#define THUMBNAIL_X 2           
                            18928 ; 552  |//// number of row in  thumbnail mode
                            18929 ; 553  |#define THUMBNAIL_Y 2           
                            18930 ; 554  |//// thumbnail boundary offset x
                            18931 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                            18932 ; 556  |//// thumbnail boundary offset y
                            18933 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                            18934 ; 558  |
                            18935 ; 559  |#endif // if (!@def(_PROJECT_INC))
                            18936 ; 560  |
                            18937 
                            18939 
                            18940 ; 101  |
                            18941 ; 102  |/*==================================================================================================
                            18942 ; 103  |                                             CONSTANTS
                            18943 ; 104  |==================================================================================================*/
                            18944 ; 105  |/* The bit mask for 2 bits Unicode Flag selection in "uint8 unicode".
                            18945 ; 106  |Variable Represented            Bits used in "uint8 unicode"
                            18946 ; 107  |Artistname                              1:0
                            18947 ; 108  |Albumname                               3:2
                            18948 ; 109  |Genrename                               5:4
                            18949 ; 110  |Songname                                7:6
                            18950 ; 111  |----------------------------------------------------------
                            18951 ; 112  |    Value (2 bits)                      Meanings
                            18952 ; 113  |    0                                   RAW and All ASCII
                            18953 ; 114  |    1                                   Uni-code
                            18954 ; 115  |    2                                   Mixed, non-unicode
                            18955 ; 116  |
                            18956 ; 117  |    3(Genre only)               Genre is ID3v1 spec=>number
                            18957 ; 118  |*/
                            18958 ; 119  |#define BITMASK_ARTIST  (0x03)
                            18959 ; 120  |#define BITMASK_ALBUM   (0x0C)
                            18960 ; 121  |#define BITMASK_GENRE   (0x30)
                            18961 ; 122  |#define BITMASK_SONG    (0xC0)
                            18962 ; 123  |
                            18963 ; 124  |#define BITCHK_ARTIST_ALLASCII  (0x0)
                            18964 ; 125  |#define BITCHK_ALBUM_ALLASCII   (0x0)
                            18965 ; 126  |#define BITCHK_GENRE_ALLASCII   (0x0)
                            18966 ; 127  |#define BITCHK_SONG_ALLASCII    (0x0)
                            18967 ; 128  |
                            18968 ; 129  |#define BITCHK_ARTIST_UNICODE   (0x01)
                            18969 ; 130  |#define BITCHK_ALBUM_UNICODE    (0x04)
                            18970 ; 131  |#define BITCHK_GENRE_UNICODE    (0x10)
                            18971 ; 132  |#define BITCHK_SONG_UNICODE             (0x40)
                            18972 ; 133  |
                            18973 ; 134  |#define BITCHK_ARTIST_MIXCODE   (0x02)
                            18974 ; 135  |#define BITCHK_ALBUM_MIXCODE    (0x08)
                            18975 ; 136  |#define BITCHK_GENRE_MIXCODE    (0x20)
                            18976 ; 137  |#define BITCHK_SONG_MIXCODE             (0x80)
                            18977 ; 138  |
                            18978 ; 139  |#define BITCHK_GENRE_ID3V1              (0x30)
                            18979 ; 140  |
                            18980 ; 141  |#define UNKNOWN_YEAR_CODE               (1)     /* set a very large number */
                            18981 ; 142  |
                            18982 ; 143  |#define INDEX_EOF       0xFFF
                            18983 ; 144  |#ifdef _FOLDER_BROWSE_
                            18984 ; 145  |#define INDEX_ROOT  0xffe
                            18985 ; 146  |#define UNKNOWN_RECORD  0xfff
                            18986 ; 147  |#endif  // _FOLDER_BROWSE_
                            18987 ; 148  |
                            18988 ; 149  |/* Constant for item_type */
                            18989 ; 150  |#define         ITEM_ARTIST                     0
                            18990 ; 151  |#define         ITEM_ALBUM                      1
                            18991 ; 152  |#define         ITEM_GENRE                      2
                            18992 ; 153  |#define         ITEM_TRACK                      3
                            18993 ; 154  |#define         ITEM_YEAR                       4
                            18994 ; 155  |#define         ITEM_SONG_INFO_ARTIST   5
                            18995 ; 156  |#define         ITEM_SONG_INFO_ALBUM    6
                            18996 ; 157  |#define         ITEM_SONG_INFO_GENRE    7
                            18997 ; 158  |#define         ITEM_SONG_INFO_YEAR             9
                            18998 ; 159  |#ifdef _NEWMUSIC_
                            18999 ; 160  |#define         ITEM_1DAY                       10
                            19000 ; 161  |#define         ITEM_1WEEK                      11
                            19001 ; 162  |#define         ITEM_1MONTH                     12
                            19002 ; 163  |#endif
                            19003 ; 164  |#ifdef _AUDIBLE_
                            19004 ; 165  |#define         ITEM_AUDIBLE            13
                            19005 ; 166  |#endif
                            19006 ; 167  |#define         ITEM_ON_THE_GO          14
                            19007 ; 168  |
                            19008 ; 169  |#define         ITEM_VOICE                      15
                            19009 ; 170  |#define         ITEM_FMREC                      16
                            19010 ; 171  |#define         ITEM_PHOTO                      17
                            19011 ; 172  |#ifdef _FOLDER_BROWSE_
                            19012 ; 173  |#define         ITEM_INTERNAL           18
                            19013 ; 174  |#define         ITEM_EXTERNAL       19
                            19014 ; 175  |#endif  // _FOLDER_BROWSE_
                            19015 ; 176  |#define     ITEM_UNKNOWN        0xff
                            19016 ; 177  |
                            19017 ; 178  |/*
                            19018 ; 179  |input parameter for void ML_AddEntryToLibrary(uint24 Media_type, RAM_SONG_INFO_T *song_info, int16 option);
                            19019 ; 180  |option input.
                            19020 ; 181  |*/
                            19021 ; 182  |#define         ADD_OPTION_MUSIC        (0x00)
                            19022 ; 183  |#define         ADD_OPTION_VOICE        (0x01)
                            19023 ; 184  |#define         ADD_OPTION_AUDIBLE      (0x02)
                            19024 ; 185  |#ifdef _FOLDER_BROWSE_
                            19025 ; 186  |#define     ADD_OPTION_DIR      (0x03)
                            19026 ; 187  |#endif  // _FOLDER_BROWSE_
                            19027 ; 188  |
                            19028 ; 189  |/* Constant for key action */
                            19029 ; 190  |#define         ACTION_OK                               0               /* Press OK button */
                            19030 ; 191  |#define         ACTION_BACK                             1               /* Press BACK button */
                            19031 ; 192  |#define         ACTION_UP                               2               /* Press UP button */
                            19032 ; 193  |#define         ACTION_DOWN                             3               /* Press DOWN button */
                            19033 ; 194  |#define         ACTION_PLAYALL                  4               /* Play All function */
                            19034 ; 195  |#define         ACTION_MENU                             5               /* Back the browsing tree to root */
                            19035 ; 196  |
                            19036 ; 197  |#define     PLAYMODE_CURRENT_PLAYMODE_BITPOS    0
                            19037 ; 198  |#define     PLAYMODE_LAST_PLAYMODE_BITPOS       1
                            19038 ; 199  |#define     PLAYMODE_REPEAT_BITPOS              2
                            19039 ; 200  |#define     PLAYMODE_MEDIA_BITPOS               3
                            19040 ; 201  |
                            19041 ; 202  |#define         NO_SD                                   0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  75

M:ADDR CODE           CYCLES LINE SOURCELINE
                            19042 ; 203  |#define         HAS_SD                                  1
                            19043 ; 204  |
                            19044 ; 205  |#define         PLAY_NORMAL                             0
                            19045 ; 206  |#define         PLAY_SHUFFLE                    1
                            19046 ; 207  |
                            19047 ; 208  |#define     PLAY_REPEAT_OFF         0
                            19048 ; 209  |#define     PLAY_REPEAT_ON          1
                            19049 ; 210  |
                            19050 ; 211  |#define     PLAY_SELECT_FLASH       0
                            19051 ; 212  |#define     PLAY_SELECT_SD          1
                            19052 ; 213  |
                            19053 ; 214  |#define         SHUFFLE_NEXT_SONG                       0
                            19054 ; 215  |#define         SHUFFLE_PREVIOUS_SONG       1
                            19055 ; 216  |
                            19056 ; 217  |#define         ON_THE_GO_EXIST                 0
                            19057 ; 218  |#define         ON_THE_GO_FULL                  1
                            19058 ; 219  |#define         ON_THE_GO_FREE                  2
                            19059 ; 220  |#define         ON_THE_GO_DEL_PLAYING   3
                            19060 ; 221  |#define         ON_THE_GO_DEL_SMALLER_ID    4
                            19061 ; 222  |
                            19062 ; 223  |#define         REC_VOICE_TYPE                  0
                            19063 ; 224  |#define         REC_FMREC_TYPE                  1
                            19064 ; 225  |#define         REC_PHOTO_TYPE                  2
                            19065 ; 226  |#define         VOICE_FILE_ADD                  0
                            19066 ; 227  |#define         VOICE_FILE_DEL                  1
                            19067 ; 228  |
                            19068 ; 229  |#define         MAX_BROWSE_WINDOW_SIZE  (8)
                            19069 ; 230  |#define         BROWSE_WINDOW_SIZE              (4)
                            19070 ; 231  |/* maximum number of song file, should not be larger than 2048 each for on-board
                            19071 ; 232  |flash or external SD card */
                            19072 ; 233  |#ifdef _SUPPORT_2000_SONGS_
                            19073 ; 234  |#define MAX_NUM_OF_SONG (2000)
                            19074 ; 235  |#else
                            19075 ; 236  |#define MAX_NUM_OF_SONG (1000)
                            19076 ; 237  |#endif // _SUPPORT_2000_SONGS_
                            19077 ; 238  |
                            19078 ; 239  |/* number of byte in one DSP word */
                            19079 ; 240  |#define NUM_OF_BYTE_IN_ONE_WORD (3)
                            19080 ; 241  |#define LEN_OF_NAME_IN_BYTE (120) /* must be an integer multiple of 3 */
                            19081 ; 242  |/* length of file pathname in byte, assuming directory and file in 8.3 format, there
                            19082 ; 243  |are 10 level directory structure */
                            19083 ; 244  |#define LEN_OF_FILEPATH_IN_BYTE (129) /* must be an integer multiple of 3 */
                            19084 ; 245  |#define LEN_OF_LONG_FILENAME_IN_BYTE (129) /* must be an integer multiple of 3 */
                            19085 ; 246  |
                            19086 ; 247  |/* number of list in new music, 1-day, 1-week, 1-month */
                            19087 ; 248  |#define NUM_OF_LIST_IN_NEW_MUSIC (3)
                            19088 ; 249  |/* number of songs in each new music list */
                            19089 ; 250  |#define NUM_OF_SONG_IN_NEW_MUSIC (40)
                            19090 ; 251  |#define NUM_OF_SONG_IN_NEW_MUSIC_DAY (20)
                            19091 ; 252  |#define NUM_OF_SONG_IN_NEW_MUSIC_WEEK (30)
                            19092 ; 253  |#define NUM_OF_SONG_IN_NEW_MUSIC_MONTH (40)
                            19093 ; 254  |/* number of songs in the on-the-fly list */
                            19094 ; 255  |#define NUM_OF_SONG_IN_ON_THE_FLY (30)
                            19095 ; 256  |/* number of files audible list */
                            19096 ; 257  |#define NUM_OF_AUDIBLE_FILE (250)
                            19097 ; 258  |
                            19098 ; 259  |#define MAX_NUM_OF_VOICE (1000)
                            19099 ; 260  |#define LEN_OF_VOICE_NAME_IN_BYTE (LEN_OF_NAME_IN_BYTE) /* must be an integer multiple of 3 */
                            19100 ; 261  |#define LEN_OF_VOICE_FILEPATH_IN_BYTE (LEN_OF_FILEPATH_IN_BYTE) /* must be an integer multiple of 3 */
                            19101 ; 262  |
                            19102 ; 263  |#define MAX_NUM_OF_FMREC (MAX_NUM_OF_VOICE)     /* _must_be_equal_voice_num_ */
                            19103 ; 264  |#define MAX_NUM_OF_PHOTO (MAX_NUM_OF_VOICE)     /* _must_be_equal_voice_num_ */
                            19104 ; 265  |#ifdef _FOLDER_BROWSE_
                            19105 ; 266  |#define MAX_NUM_OF_DIR   (1000)
                            19106 ; 267  |#else
                            19107 ; 268  |#define MAX_NUM_OF_DIR   (1)
                            19108 ; 269  |#endif  // _FOLDER_BROWSE_
                            19109 ; 270  |#define LEN_OF_FMREC_NAME_IN_BYTE (LEN_OF_NAME_IN_BYTE) /* must be an integer multiple of 3 */
                            19110 ; 271  |#define LEN_OF_FMREC_FILEPATH_IN_BYTE (LEN_OF_FILEPATH_IN_BYTE) /* must be an integer multiple of 3 */
                            19111 ; 272  |
                            19112 ; 273  |#ifndef _MAX_DIR_DEPTH
                            19113 ; 274  |#define _MAX_DIR_DEPTH  8   // referred to "playlist3internal.h"
                            19114 ; 275  |#endif  // _MAX_DIR_DEPTH
                            19115 ; 276  |
                            19116 ; 277  |/*==================================================================================================*/
                            19117 ; 278  |
                            19118 ; 279  |
                            19119 ; 280  |/*==================================================================================================
                            19120 ; 281  |                                               MACROS
                            19121 ; 282  |==================================================================================================*/
                            19122 ; 283  |
                            19123 ; 284  |/*==================================================================================================
                            19124 ; 285  |                                               ENUMS
                            19125 ; 286  |==================================================================================================*/
                            19126 ; 287  |#define NUM_OF_MEDIA                            (2)
                            19127 ; 288  |#define MEDIA_TYPE_FLASH                        (0)
                            19128 ; 289  |#define MEDIA_TYPE_SD                           (1)
                            19129 ; 290  |/*==================================================================================================
                            19130 ; 291  |                                     STRUCTURES AND OTHER TYPEDEFS
                            19131 ; 292  |==================================================================================================*/
                            19132 ; 293  |
                            19133 ; 294  |typedef char    int8;
                            19134 ; 295  |typedef short   int16;
                            19135 ; 296  |typedef int     int24;
                            19136 ; 297  |typedef long    int32;
                            19137 ; 298  |
                            19138 ; 299  |typedef int     intx;
                            19139 ; 300  |
                            19140 ; 301  |typedef unsigned char   uint8;
                            19141 ; 302  |typedef unsigned short  uint16;
                            19142 ; 303  |typedef unsigned int    uint24;
                            19143 ; 304  |typedef unsigned long   uint32;
                            19144 
                            19148 
                            19149 ; 305  |
                            19150 ; 306  |/*
                            19151 ; 307  |Any missing information in the name fields will be filled with Unknown in Unicode format.
                            19152 ; 308  |artist_name[] = Unknown; unicode = 0x01;
                            19153 ; 309  |album_name[] = Unknown; unicode = 0x04;
                            19154 ; 310  |genre_name[] = Unknown; unicode = 0x08;
                            19155 ; 311  |song_name[] = Unknown; unicode = 0x0F;
                            19156 ; 312  |*/
                            19157 ; 313  |/*
                            19158 ; 314  |path_name[] _must_have_data_:
                            19159 ; 315  |path_name[] = (Max. 120 Characters);
                            19160 ; 316  |year range:
                            19161 ; 317  |year = 0x000000-0xFFFFFF;
                            19162 ; 318  |DOCUMENT CONTROL NUMBER : Version : 01.01
                            19163 ; 319  |Unknown track number:
                            19164 ; 320  |track_number = 0x7FFFFF;
                            19165 ; 321  |unicode refer to above #define BITMASK_*
                            19166 ; 322  |*/
                            19167 ; 323  |/*
                            19168 ; 324  |Interface of UI and Music Library
                            19169 ; 325  |1) If file was created in ID3V1 format genre, UI will convert it to Unicode string.
                            19170 ; 326  |
                            19171 ; 327  |2) Music Library expected to reserve 128x7 words RAM for UI mapping table.
                            19172 ; 328  |
                            19173 ; 329  |3) UI to Music Library variable passing length definition:
                            19174 ; 330  |        All ASCII Characters:
                            19175 ; 331  |                Max. Number of Bytes Stored = 120 Bytes
                            19176 ; 332  |                Max. Number of Characters Stored/Display = 40 Characters
                            19177 ; 333  |        Unicode Characters:
                            19178 ; 334  |                Max. Number of Bytes Stored = 120 Bytes
                            19179 ; 335  |                Max. Number of Characters Stored/Display = 40 Characters
                            19180 ; 336  |
                            19181 ; 337  |4) UI input data to Music Library in two formats.
                            19182 ; 338  |        Formats:        1) All ASCII (24 bits data)
                            19183 ; 339  |                                2) Unicode + Mix. Non -Unicode (16 bits data)
                            19184 ; 340  |
                            19185 ; 341  |5) UI calling function:
                            19186 ; 342  |COMP_OPT_REN void ML_AddEntryToLibrary(RAM_SONG_INFO_T *song_info, int16 option);
                            19187 ; 343  |        int16 option definition:
                            19188 ; 344  |                option  = 0 - song_info struct contains a mp3/wma format file.
                            19189 ; 345  |                                = 1 - song_info struct contains a voice format file.
                            19190 ; 346  |                                = 2 - song_info struct contains a audible format file.
                            19191 ; 347  |
                            19192 ; 348  |        i) Only mp3/wma file (option = 0, 2) files will be sorted,
                            19193 ; 349  |        ii) Voice and audible(option = 1) file will be store in a voice_list and audible_list separately.
                            19194 ; 350  |
                            19195 ; 351  |6) Modification Date:
                            19196 ; 352  |        uint24 g_file_time:
                            19197 ; 353  |                YYMMDD: 12 bits - Year, 6 bits - Month, 6 - bits Date
                            19198 ; 354  |*/
                            19199 ; 355  |
                            19200 ; 356  |/* struct to store the song information passed from UI, this struct will be placed in
                            19201 ; 357  |ghdr\musiclib_ghdr.h and included in UI files*/
                            19202 ; 358  |typedef struct _ram_song_info {
                            19203 ; 359  |        uint24 artist_name[LEN_OF_NAME_IN_BYTE/NUM_OF_BYTE_IN_ONE_WORD];
                            19204 ; 360  |        uint24 album_name[LEN_OF_NAME_IN_BYTE/NUM_OF_BYTE_IN_ONE_WORD];
                            19205 ; 361  |        uint24 genre_name[LEN_OF_NAME_IN_BYTE/NUM_OF_BYTE_IN_ONE_WORD];
                            19206 ; 362  |        uint24 song_name[LEN_OF_NAME_IN_BYTE/NUM_OF_BYTE_IN_ONE_WORD];
                            19207 ; 363  |        uint24 path_name[LEN_OF_FILEPATH_IN_BYTE/NUM_OF_BYTE_IN_ONE_WORD];
                            19208 ; 364  |    uint32 g_songFastKey;
                            19209 ; 365  |        uint24 dir_name[LEN_OF_LONG_FILENAME_IN_BYTE/NUM_OF_BYTE_IN_ONE_WORD];
                            19210 ; 366  |        uint24 year;
                            19211 ; 367  |        uint24 track_number;
                            19212 ; 368  |        uint8 unicode;
                            19213 ; 369  |} RAM_SONG_INFO_T;
                            19214 ; 370  |
                            19215 ; 371  |/* struct to store the group name: artist, album and genre, in the flash */
                            19216 ; 372  |typedef struct _flash_group_name {
                            19217 ; 373  |        uint24 name[LEN_OF_NAME_IN_BYTE/NUM_OF_BYTE_IN_ONE_WORD];
                            19218 ; 374  |        uint8 unicode;
                            19219 ; 375  |} FLASH_GROUP_NAME_T;
                            19220 ; 376  |
                            19221 ; 377  |// struct to store directories information passed from UI
                            19222 ; 378  |#ifdef _FOLDER_BROWSE_
                            19223 ; 379  |typedef struct _ml_DirInfo {
                            19224 ; 380  |        uint24  u8Unicode : 8;
                            19225 ; 381  |        uint24  u12DirDepth : 12;
                            19226 ; 382  |        uint24  u4Added : 4;            
                            19227 ; 383  |        INT     iDirRecord;
                            19228 ; 384  |        DWORD   dwFastKey;
                            19229 ; 385  |        uint24  u24PathName[LEN_OF_FILEPATH_IN_BYTE/NUM_OF_BYTE_IN_ONE_WORD];
                            19230 ; 386  |} ML_DIRINFO_T;
                            19231 ; 387  |#endif  // _FOLDER_BROWSE_
                            19232 ; 388  |
                            19233 ; 389  |/*==================================================================================================
                            19234 ; 390  |                                 GLOBAL VARIABLE DECLARATIONS
                            19235 ; 391  |==================================================================================================*/
                            19236 ; 392  |extern uint24   IsPlayOnTheGo;
                            19237 
                            19243 
                            19244 ; 393  |extern FLASH_GROUP_NAME_T   browse_item_name[];
                            19245 ; 394  |extern uint24   merge_id_list_flash[];
                            19246 ; 395  |extern uint24   merge_id_list_sd[];
                            19247 ; 396  |extern INT _X   g_iBrowseWindowSize;
                            19248 ; 397  |#ifdef _FOLDER_BROWSE_
                            19249 
                            19262 
                            19263 ; 398  |extern ML_DIRINFO_T g_tDirInfoBuffer[_MAX_DIR_DEPTH];
                            19264 ; 399  |extern uint24       g_u24DirName[LEN_OF_NAME_IN_BYTE/NUM_OF_BYTE_IN_ONE_WORD];
                            19265 ; 400  |extern uint24       g_u24BrowseNumOfDirInDir[];
                            19266 ; 401  |#endif  // _FOLDER_BROWSE_
                            19267 ; 402  |extern INT _X    *sec_temp_buf_X;
                            19268 ; 403  |extern uint24   playMode;   /* bit 0 = current play mode; bit 1 = last play mode ; bit 2 = repeat on/off(0=off/1=on) */
                            19269 ; 404  |
                            19270 ; 405  |/*==================================================================================================
                            19271 ; 406  |                                        FUNCTION PROTOTYPES
                            19272 ; 407  |==================================================================================================*/
                            19273 ; 408  |
                            19274 ; 409  |///////////////////////////////////////////////////////////////////////
                            19275 ; 410  |//! \brief
                            19276 ; 411  |//!
                            19277 ; 412  |//! \fntype Function
                            19278 ; 413  |//!
                            19279 ; 414  |//! Called by UI, to initialize the parameters before insert any item.
                            19280 ; 415  |//! Call only once before inserting items. Call once for each media.
                            19281 ; 416  |//!
                            19282 ; 417  |//! \param[in]  none
                            19283 ; 418  |//!
                            19284 ; 419  |//! \return
                            19285 ; 420  |//!
                            19286 ; 421  |///////////////////////////////////////////////////////////////////////
                            19287 ; 422  |void ML_InitLibraryParameter(void);
                            19288 ; 423  |
                            19289 ; 424  |///////////////////////////////////////////////////////////////////////
                            19290 ; 425  |//! \brief
                            19291 ; 426  |//!
                            19292 ; 427  |//! \fntype Function
                            19293 ; 428  |//!
                            19294 ; 429  |//! Called by UI, the AddEntryToLibrary is the music library building
                            19295 ; 430  |//! algorithms for the flash-type memory and SD memory by sorting the song information
                            19296 ; 431  |//! by, but not limited to, album, artist, genre, year and track. Called once for each song,
                            19297 ; 432  |//! the song information is recorded in music library.
                            19298 ; 433  |//!
                            19299 ; 434  |//! \param[in]  uint24 Media_type - Possible values: MEDIA_TYPE_FLASH(=0); MEDIA_TYPE_SD(=1)
                            19300 ; 435  |//! \param[in]  RAM_SONG_INFO_T *song_info - Structure to store the song information passed from UI, this structure is defined in ghdr\musiclib_ghdr.h and included in UI files)
                            19301 ; 436  |//! \param[in]  int16 option - option = 0 -- song_info struct contains a mp3, wma or wav format file.
                            19302 ; 437  |//!
                            19303 ; 438  |//! \return
                            19304 ; 439  |//!
                            19305 ; 440  |///////////////////////////////////////////////////////////////////////
                            19306 ; 441  |void ML_AddEntryToLibrary(uint24 Media_type, RAM_SONG_INFO_T *song_info, int16 option);
                            19307 
                            19321 
                            19322 ; 442  |
                            19323 ; 443  |///////////////////////////////////////////////////////////////////////
                            19324 ; 444  |//! \brief
                            19325 ; 445  |//!
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  76

M:ADDR CODE           CYCLES LINE SOURCELINE
                            19326 ; 446  |//! \fntype Function
                            19327 ; 447  |//!
                            19328 ; 448  |//! \param[in]
                            19329 ; 449  |//!
                            19330 ; 450  |//! \return
                            19331 ; 451  |//!
                            19332 ; 452  |///////////////////////////////////////////////////////////////////////
                            19333 ; 453  |#ifdef _FOLDER_BROWSE_
                            19334 ; 454  |_reentrant void ML_AddDirEntryToLibrary(uint24 u24MediaType, ML_DIRINFO_T *ptDirInfo, int16 i16Option);
                            19335 ; 455  |#endif  // _FOLDER_BROWSE_
                            19336 ; 456  |
                            19337 ; 457  |///////////////////////////////////////////////////////////////////////
                            19338 ; 458  |//! \brief
                            19339 ; 459  |//!
                            19340 ; 460  |//! \fntype Function
                            19341 ; 461  |//!
                            19342 ; 462  |//! Called by UI, flush sorted and associate list to flash when no
                            19343 ; 463  |//! more song needed to be added for that media. This function finalizes the building of
                            19344 ; 464  |//! music library for that particular media.
                            19345 ; 465  |//!
                            19346 ; 466  |//! \param[in]  uint24 Media_type - Possible values: MEDIA_TYPE_FLASH(=0); MEDIA_TYPE_SD(=1)
                            19347 ; 467  |//!
                            19348 ; 468  |//! \return
                            19349 ; 469  |//!
                            19350 ; 470  |//! \note   Bulid the library first (call ML_AddEntryToLibrary) before calling this
                            19351 ; 471  |//!         function.
                            19352 ; 472  |///////////////////////////////////////////////////////////////////////
                            19353 ; 473  |_reentrant INT ML_FlushLibraryToFlash(INT Media_type, INT b, INT *c);
                            19354 ; 474  |
                            19355 ; 475  |///////////////////////////////////////////////////////////////////////
                            19356 ; 476  |//! \brief
                            19357 ; 477  |//!
                            19358 ; 478  |//! \fntype Function
                            19359 ; 479  |//!
                            19360 ; 480  |//! \param[in]
                            19361 ; 481  |//!
                            19362 ; 482  |//! \return
                            19363 ; 483  |//!
                            19364 ; 484  |///////////////////////////////////////////////////////////////////////
                            19365 ; 485  |#ifdef _NEWMUSIC_
                            19366 ; 486  |void ML_UpdateNewMusic(void);
                            19367 ; 487  |#endif
                            19368 ; 488  |
                            19369 ; 489  |///////////////////////////////////////////////////////////////////////
                            19370 ; 490  |//! \brief
                            19371 ; 491  |//!
                            19372 ; 492  |//! \fntype Function
                            19373 ; 493  |//!
                            19374 ; 494  |//! Called by UI, to initialize the file access mechanism for all music
                            19375 ; 495  |//! library operation if the music.lib file and the music.sec file exist (call
                            19376 ; 496  |//! ML_BuildSecTableFile() if these files do not exist).
                            19377 ; 497  |//!
                            19378 ; 498  |//! \param[in]  none
                            19379 ; 499  |//!
                            19380 ; 500  |//! \return
                            19381 ; 501  |//!
                            19382 ; 502  |//! \note   Either ML_Buildl2SecTable(void) or ML_BuildSecTableFile(void)
                            19383 ; 503  |//!         must be called before calling any other music library functions.
                            19384 ; 504  |///////////////////////////////////////////////////////////////////////
                            19385 ; 505  |_reentrant INT ML_Buildl2SecTable(INT a, INT b, INT *c);
                            19386 ; 506  |
                            19387 ; 507  |///////////////////////////////////////////////////////////////////////
                            19388 ; 508  |//! \brief
                            19389 ; 509  |//!
                            19390 ; 510  |//! \fntype Function
                            19391 ; 511  |//!
                            19392 ; 512  |//! Called by UI, to initialize the file access mechanism for all music
                            19393 ; 513  |//! library operation.
                            19394 ; 514  |//! Two system files (music.lib and music.sec) is created.
                            19395 ; 515  |//! Call this only if intended to generate / refresh these files, or if the music.lib file and the
                            19396 ; 516  |//! music.sec file do not exist.
                            19397 ; 517  |//!
                            19398 ; 518  |//! \param[in]  none
                            19399 ; 519  |//!
                            19400 ; 520  |//! \return
                            19401 ; 521  |//!
                            19402 ; 522  |//! \note   Either ML_Buildl2SecTable(void) or ML_BuildSecTableFile(void)
                            19403 ; 523  |//!         must be called before calling any other music library functions.
                            19404 ; 524  |///////////////////////////////////////////////////////////////////////
                            19405 ; 525  |_reentrant INT ML_BuildSecTableFile(INT a, INT b, INT *c);
                            19406 ; 526  |
                            19407 ; 527  |///////////////////////////////////////////////////////////////////////
                            19408 ; 528  |//! \brief
                            19409 ; 529  |//!
                            19410 ; 530  |//! \fntype Function
                            19411 ; 531  |//!
                            19412 ; 532  |//! Preload the list, prepare for renew.
                            19413 ; 533  |//! IsColdBoot=TRUE: loads the list content and the path name to the on_the_fly_list
                            19414 ; 534  |//! structure in RAM.
                            19415 ; 535  |//! IsColdBoot=FALSE: updates the path name only, to the on_the_fly_list structure
                            19416 ; 536  |//! in RAM.
                            19417 ; 537  |//!
                            19418 ; 538  |//! \param[in]  uint24 IsColdBoot - Possible values: TRUE or FALSE
                            19419 ; 539  |//!
                            19420 ; 540  |//! \return
                            19421 ; 541  |//!
                            19422 ; 542  |//! \note   Use IsColdBoot=TRUE only once when the machine boot-up, other
                            19423 ; 543  |//!         time when you need to renew the list, use IsColdBoot=FALSE instead.
                            19424 ; 544  |///////////////////////////////////////////////////////////////////////
                            19425 ; 545  |void ML_LoadOnTheGo(uint24 IsColdBoot);
                            19426 ; 546  |
                            19427 ; 547  |///////////////////////////////////////////////////////////////////////
                            19428 ; 548  |//! \brief
                            19429 ; 549  |//!
                            19430 ; 550  |//! \fntype Function
                            19431 ; 551  |//!
                            19432 ; 552  |//! Save the list to flash memory.
                            19433 ; 553  |//!
                            19434 ; 554  |//! \param[in]
                            19435 ; 555  |//!
                            19436 ; 556  |//! \return
                            19437 ; 557  |//!
                            19438 ; 558  |//! \note   It is recommended to save the list as soon as possible after it was
                            19439 ; 559  |//!         changed by the user.
                            19440 ; 560  |///////////////////////////////////////////////////////////////////////
                            19441 ; 561  |void ML_SaveOnTheGo(void);      /* call at shutdownmenu.c to save the list */
                            19442 ; 562  |
                            19443 ; 563  |///////////////////////////////////////////////////////////////////////
                            19444 ; 564  |//! \brief
                            19445 ; 565  |//!
                            19446 ; 566  |//! \fntype Function
                            19447 ; 567  |//! When the Music Lib is rebuilding, the path of each song is
                            19448 ; 568  |//! compared with the path stored in the on_the_fly_list structure, to decide if it was in the
                            19449 ; 569  |//! list before, if so the ID is replaced by the new songID, and the song is keep in the list.
                            19450 ; 570  |//! Otherwise the song is deleted.
                            19451 ; 571  |//!
                            19452 ; 572  |//! \param[in]  uint24 Media_type - Possible values: MEDIA_TYPE_FLASH(=0); MEDIA_TYPE_SD(=1)
                            19453 ; 573  |//! \param[in]  uint24 _X * temp_path - Input value, the path of song to be checked.
                            19454 ; 574  |//! \param[in]  uint24 newID - Input value, the new songID of the song.
                            19455 ; 575  |//!
                            19456 ; 576  |//! \return
                            19457 ; 577  |//!
                            19458 ; 578  |///////////////////////////////////////////////////////////////////////
                            19459 ; 579  |void ML_ChkOnTheGo(uint24 Media_type, uint24 _X * temp_path, uint24 newID);
                            19460 ; 580  |
                            19461 ; 581  |///////////////////////////////////////////////////////////////////////
                            19462 ; 582  |//! \brief
                            19463 ; 583  |//!
                            19464 ; 584  |//! \fntype Function
                            19465 ; 585  |//!
                            19466 ; 586  |//! Set a flag for all the songs of Media_type to be keep or delete
                            19467 ; 587  |//! in the ML_UpdateOnTheGo().
                            19468 ; 588  |//!
                            19469 ; 589  |//! \param[in]  uint24 Media_type - Possible values: MEDIA_TYPE_FLASH(=0); MEDIA_TYPE_SD(=1)
                            19470 ; 590  |//! \param[in]  uint24 value - Possible values: TRUE (song will be keep in the list); INDEX_EOF (song will be deleted)
                            19471 ; 591  |//!
                            19472 ; 592  |//! \return
                            19473 ; 593  |//!
                            19474 ; 594  |///////////////////////////////////////////////////////////////////////
                            19475 ; 595  |void ML_ChOnTheGo(uint24 Media_type, uint24 value);
                            19476 ; 596  |
                            19477 ; 597  |///////////////////////////////////////////////////////////////////////
                            19478 ; 598  |//! \brief
                            19479 ; 599  |//!
                            19480 ; 600  |//! \fntype Function
                            19481 ; 601  |//!
                            19482 ; 602  |//! Before the list can be browse, call this function to finalize the list.
                            19483 ; 603  |//!
                            19484 ; 604  |//! \param[in]  none
                            19485 ; 605  |//!
                            19486 ; 606  |//! \return
                            19487 ; 607  |//!
                            19488 ; 608  |///////////////////////////////////////////////////////////////////////
                            19489 ; 609  |void ML_UpdateOnTheGo(void);
                            19490 ; 610  |
                            19491 ; 611  |///////////////////////////////////////////////////////////////////////
                            19492 ; 612  |//! \brief
                            19493 ; 613  |//!
                            19494 ; 614  |//! \fntype Function
                            19495 ; 615  |//!
                            19496 ; 616  |//! Called by UI, to initialize the parameters before insert any item.
                            19497 ; 617  |//! Call only once before inserting items. Call once for each media.
                            19498 ; 618  |//!
                            19499 ; 619  |//! \param[in]  none
                            19500 ; 620  |//!
                            19501 ; 621  |//! \return
                            19502 ; 622  |//!
                            19503 ; 623  |///////////////////////////////////////////////////////////////////////
                            19504 ; 624  |void ML_InitVoiceParameter(void);
                            19505 ; 625  |
                            19506 ; 626  |///////////////////////////////////////////////////////////////////////
                            19507 ; 627  |//! \brief
                            19508 ; 628  |//!
                            19509 ; 629  |//! \fntype Function
                            19510 ; 630  |//!
                            19511 ; 631  |//! \param[in]
                            19512 ; 632  |//!
                            19513 ; 633  |//! \return
                            19514 ; 634  |//!
                            19515 ; 635  |///////////////////////////////////////////////////////////////////////
                            19516 ; 636  |void ML_LoadVoiceParameter(uint24 Rec_type);
                            19517 ; 637  |
                            19518 ; 638  |///////////////////////////////////////////////////////////////////////
                            19519 ; 639  |//! \brief
                            19520 ; 640  |//!
                            19521 ; 641  |//! \fntype Function
                            19522 ; 642  |//!
                            19523 ; 643  |//! Called by UI, the ML_AddEntryToVoice is the voice library
                            19524 ; 644  |//! building algorithms for the flash-type memory by sorting the voice files by file names.
                            19525 ; 645  |//! Called once for each voice file, the information is recorded in music library.
                            19526 ; 646  |//!
                            19527 ; 647  |//! \param[in]  uint24 Rec_type - Possible values: REC_VOICE_TYPE(=0); REC_FMREC_TYPE(=1)
                            19528 ; 648  |//! \param[in]  RAM_SONG_INFO_T *song_info - struct to store the song information passed from UI, this struct will be placed in ghdr\musiclib_ghdr.h and included in UI files
                            19529 ; 649  |//! \param[in]  uint24 action - option = 0 // always set zero
                            19530 ; 650  |//!
                            19531 ; 651  |//! \return
                            19532 ; 652  |//!
                            19533 ; 653  |///////////////////////////////////////////////////////////////////////
                            19534 ; 654  |void ML_AddEntryToVoice(uint24 Rec_type, RAM_SONG_INFO_T *song_info, uint24 action);
                            19535 ; 655  |
                            19536 ; 656  |///////////////////////////////////////////////////////////////////////
                            19537 ; 657  |//! \brief
                            19538 ; 658  |//!
                            19539 ; 659  |//! \fntype Function
                            19540 ; 660  |//!
                            19541 ; 661  |//! Called by UI, flush sorted and associate list to flash when no
                            19542 ; 662  |//! more voice needed to be added for that media. This function finalizes the voice building
                            19543 ; 663  |//! of music library for that particular media.
                            19544 ; 664  |//!
                            19545 ; 665  |//! \param[in]  uint24 Rec_type - Possible values: REC_VOICE_TYPE(=0); REC_FMREC_TYPE(=1)
                            19546 ; 666  |//!
                            19547 ; 667  |//! \return
                            19548 ; 668  |//!
                            19549 ; 669  |//! \note   Bulid the library first (call ML_AddEntryToVoice) before calling this
                            19550 ; 670  |//!         function.
                            19551 ; 671  |///////////////////////////////////////////////////////////////////////
                            19552 ; 672  |void ML_FlushVoiceToFlash(uint24 Rec_type);
                            19553 ; 673  |
                            19554 ; 674  |///////////////////////////////////////////////////////////////////////
                            19555 ; 675  |//! \brief
                            19556 ; 676  |//!
                            19557 ; 677  |//! \fntype Function
                            19558 ; 678  |//!
                            19559 ; 679  |//! Called by UI, the merge the music library tables album,
                            19560 ; 680  |//! artist, genre, song and year.
                            19561 ; 681  |//!
                            19562 ; 682  |//! \param[in]  none
                            19563 ; 683  |//!
                            19564 ; 684  |//! \return
                            19565 ; 685  |//!
                            19566 ; 686  |///////////////////////////////////////////////////////////////////////
                            19567 ; 687  |void ML_MergeLibraryTables(void);
                            19568 ; 688  |
                            19569 ; 689  |///////////////////////////////////////////////////////////////////////
                            19570 ; 690  |//! \brief
                            19571 ; 691  |//!
                            19572 ; 692  |//! \fntype Function
                            19573 ; 693  |//!
                            19574 ; 694  |//! Called by UI, the merge the music library tables album,
                            19575 ; 695  |//! artist, genre, song and year.
                            19576 ; 696  |//!
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  77

M:ADDR CODE           CYCLES LINE SOURCELINE
                            19577 ; 697  |//! \param[in]  none
                            19578 ; 698  |//!
                            19579 ; 699  |//! \return
                            19580 ; 700  |//!
                            19581 ; 701  |///////////////////////////////////////////////////////////////////////
                            19582 ; 702  |INT _reentrant PathFormationPartial(_packed BYTE* dst, _packed BYTE* src, int iDepth);
                            19583 ; 703  |INT _reentrant PathFormation(_packed BYTE* dst, _packed BYTE* src, int iDepth);
                            19584 ; 704  |_reentrant void TrimUnicodeString(UCS3* pString);
                            19585 ; 705  |_reentrant void TrimPackedString(UCS3* pString);
                            19586 ; 706  |
                            19587 ; 707  |///////////////////////////////////////////////////////////////////////
                            19588 ; 708  |//! \brief
                            19589 ; 709  |//!
                            19590 ; 710  |//! \fntype Function
                            19591 ; 711  |//!
                            19592 ; 712  |//! \param[in]
                            19593 ; 713  |//!
                            19594 ; 714  |//! \return
                            19595 ; 715  |//!
                            19596 ; 716  |///////////////////////////////////////////////////////////////////////
                            19597 ; 717  |_reentrant void ML_FlushSortedListToFlash(uint24 u24MediaType);
                            19598 ; 718  |
                            19599 ; 719  |/*================================================================================================*/
                            19600 ; 720  |
                            19601 ; 721  |// Siukoon 2005-02-28
                            19602 ; 722  |#define MUSICLIB_STDRIVE_NUMBER     (0)
                            19603 ; 723  |#ifdef _SUPPORT_2000_SONGS_
                            19604 ; 724  |#define MUSICLIB_FILESIZE_IN_BYTE   (4194304L*2) // (SINGLE_DATABASE_SIZE*BYTE_PER_SECTOR)*2
                            19605 ; 725  |#else
                            19606 ; 726  |#define MUSICLIB_FILESIZE_IN_BYTE   (2097152L*2) // (SINGLE_DATABASE_SIZE*BYTE_PER_SECTOR)*2
                            19607 ; 727  |#endif  // _SUPPORT_2000_SONGS_
                            19608 ; 728  |#define MUSICLIB_FLASHPART_FILESIZE_IN_BYTE   (MUSICLIB_FILESIZE_IN_BYTE/2)
                            19609 ; 729  |#define WORD_PER_SECTOR             (171)
                            19610 ; 730  |#define BYTE_PER_SECTOR             (512)
                            19611 ; 731  |#define MUSICLIB_FILESIZE_IN_SECTOR (MUSICLIB_FILESIZE_IN_BYTE/BYTE_PER_SECTOR)
                            19612 ; 732  |#define MUSICLIB_FLASHPART_FILESIZE_IN_SECTOR (MUSICLIB_FLASHPART_FILESIZE_IN_BYTE/BYTE_PER_SECTOR)
                            19613 ; 733  |
                            19614 ; 734  |#define LB_BYTE_PER_SECTOR          (2048)
                            19615 ; 735  |#define LB_MUSICLIB_FILESIZE_IN_SECTOR (MUSICLIB_FILESIZE_IN_BYTE/LB_BYTE_PER_SECTOR)
                            19616 ; 736  |#define LB_MUSICLIB_FLASHPART_FILESIZE_IN_SECTOR (MUSICLIB_FLASHPART_FILESIZE_IN_BYTE/LB_BYTE_PER_SECTOR)
                            19617 ; 737  |
                            19618 ; 738  |#define MUSICLIB_FAT_ERROR_NOT_ENOUGH_MEDIA_SPACE       1
                            19619 ; 739  |#define MUSICLIB_FAT_ERROR_CREATE_FILE                  2
                            19620 ; 740  |#define MUSICLIB_FAT_ERROR_DELETE_FILE                  3
                            19621 ; 741  |#define MUSICLIB_FAT_ERROR_OPEN_FILE                    4
                            19622 ; 742  |
                            19623 ; 743  |/////////////////////
                            19624 ; 744  |
                            19625 ; 745  |#define LONG_SIZE_IN_BYTE                               (6)
                            19626 ; 746  |
                            19627 ; 747  |#ifdef _SUPPORT_2000_SONGS_
                            19628 ; 748  |#define SEC_TABLE_SIZE_IN_LONG                  (16384) // DATABASE_SIZE
                            19629 ; 749  |#else
                            19630 ; 750  |#define SEC_TABLE_SIZE_IN_LONG                  (8192)  // DATABASE_SIZE
                            19631 ; 751  |#endif // _SUPPORT_2000_SONGS_
                            19632 ; 752  |#define SEC_TABLE_SIZE_IN_BYTE                  (SEC_TABLE_SIZE_IN_LONG*LONG_SIZE_IN_BYTE)
                            19633 ; 753  |
                            19634 ; 754  |#define SEC_TABLE_FLASHPART_SIZE_IN_LONG        (SEC_TABLE_SIZE_IN_LONG/2)
                            19635 ; 755  |#define SEC_TABLE_FLASHPART_SIZE_IN_BYTE        (SEC_TABLE_SIZE_IN_BYTE/2)
                            19636 ; 756  |
                            19637 ; 757  |#define NUM_OF_LONG_PER_512SEC          (85)    // 512/6=>85
                            19638 ; 758  |#ifdef _SUPPORT_2000_SONGS_
                            19639 ; 759  |#define NUM_OF_LEVEL2_SEC                               (194)   /* 97x2 */
                            19640 ; 760  |#define NUM_OF_LEVEL2_FLASHPART_SEC             (97)    /* 8192/85 */
                            19641 ; 761  |#else
                            19642 ; 762  |#define NUM_OF_LEVEL2_SEC                               (98)    /* 49x2 */
                            19643 ; 763  |#define NUM_OF_LEVEL2_FLASHPART_SEC             (49)    /* 4096/85 */
                            19644 ; 764  |#endif // _SUPPORT_2000_SONGS_
                            19645 ; 765  |#define LEVEL2_TABLE_SIZE                               (NUM_OF_LEVEL2_SEC*2)
                            19646 ; 766  |#define SEC_TABLE_FLASH_START_SEC               (0x00)
                            19647 ; 767  |#define SEC_TABLE_SD_START_SEC                  (NUM_OF_LEVEL2_FLASHPART_SEC)
                            19648 ; 768  |
                            19649 ; 769  |#define SEC_TABLE_FILESIZE_IN_BYTE              (BYTE_PER_SECTOR*NUM_OF_LEVEL2_SEC)
                            19650 ; 770  |#ifdef _SUPPORT_2000_SONGS_
                            19651 ; 771  |#define BYTE_FILL_INTERDB_GAP                   (320)   // 512-((8192-(85*96))*6)
                            19652 ; 772  |#else
                            19653 ; 773  |#define BYTE_FILL_INTERDB_GAP                   (((NUM_OF_LEVEL2_FLASHPART_SEC*NUM_OF_LONG_PER_512SEC)-SEC_TABLE_FLASHPART_SIZE_IN_LONG)*LONG_SIZE_IN_BYTE+2)
                            19654 ; 774  |#endif  // _SUPPORT_2000_SONGS_
                            19655 ; 775  |
                            19656 ; 776  |#define LB_SEC_TABLE_SIZE_IN_LONG                       (LB_MUSICLIB_FILESIZE_IN_SECTOR)
                            19657 ; 777  |#define LB_SEC_TABLE_SIZE_IN_BYTE                       (LB_SEC_TABLE_SIZE_IN_LONG*LONG_SIZE_IN_BYTE)
                            19658 ; 778  |
                            19659 ; 779  |#define LB_SEC_TABLE_FLASHPART_SIZE_IN_LONG     (LB_SEC_TABLE_SIZE_IN_LONG/2)
                            19660 ; 780  |#define LB_SEC_TABLE_FLASHPART_SIZE_IN_BYTE     (LB_SEC_TABLE_SIZE_IN_BYTE/2)
                            19661 ; 781  |
                            19662 ; 782  |#define NUM_OF_LONG_PER_2048SEC                     (341)   // 2048/6=>341
                            19663 ; 783  |#ifdef _SUPPORT_2000_SONGS_
                            19664 ; 784  |#define NUM_OF_LEVEL2_2048SEC                           (49)    // 16384/341=>49
                            19665 ; 785  |#define NUM_OF_LEVEL2_FLASHPART_2048SEC         (25)    /* 8192/341=>25 */
                            19666 ; 786  |#else
                            19667 ; 787  |#define NUM_OF_LEVEL2_2048SEC                           (25)    // 8192/341=>25
                            19668 ; 788  |#define NUM_OF_LEVEL2_FLASHPART_2048SEC         (13)    /* 4096/341=>13 */
                            19669 ; 789  |#endif // _SUPPORT_2000_SONGS_
                            19670 ; 790  |
                            19671 ; 791  |#ifdef _SUPPORT_2000_SONGS_
                            19672 ; 792  |#define BYTE_FILL_INTERDB_GAP_2048                      (2000)  // 2048-((8192-(341*24))*6)
                            19673 ; 793  |#define BYTE_FILL_INTERDB_2ND_GAP_2048      (2532)  // 99328-96796
                            19674 ; 794  |#else
                            19675 ; 795  |#define BYTE_FILL_INTERDB_GAP_2048                      (((341-4)*6)+2) //2024
                            19676 ; 796  |#define BYTE_FILL_INTERDB_2ND_GAP_2048      (2556)  // 50176-47620
                            19677 ; 797  |#endif // _SUPPORT_2000_SONGS_
                            19678 ; 798  |
                            19679 ; 799  |#ifdef __cplusplus
                            19680 ; 800  |}
                            19681 ; 801  |#endif
                            19682 ; 802  |
                            19683 ; 803  |#endif  /* MUSICLIB_GHDR_H */
                            19684 
                            19686 
                            19687 ; 6    |#include "fsapi.h"
                            19688 
                            19690 
                            19691 ; 1    |#ifndef _FSAPI_H_
                            19692 ; 2    |#define _FSAPI_H_
                            19693 ; 3    |#include "filespec.h"
                            19694 ; 4    |extern _reentrant LONG Ftell(INT HandleNumber);
                            19695 ; 5    |extern _reentrant LONG Feof(INT HandleNumber);
                            19696 ; 6    |extern _reentrant INT *Fputs(INT HandleNumber,INT *Buffer);
                            19697 ; 7    |extern _reentrant LONG Fread(INT HandleNumber,INT *Buffer,LONG NumBytesToRead,INT Source_Memory,INT MOdulo);
                            19698 ; 8    |extern _reentrant INT Fgetc(INT HandleNumber);
                            19699 ; 9    |extern _reentrant INT Fputc(INT HandleNumber,INT ByteToWrite);
                            19700 ; 10   |extern _reentrant LONG ReadDirectoryRecord(INT HandleNumber,INT RecordNumber,INT *Buffer);
                            19701 ; 11   |extern _reentrant INT Fseek(INT HandleNumber,LONG NumBytesToSeek,INT SeekPosition);
                            19702 ; 12   |extern _reentrant INT Fopen(_packed char *filepath,_packed char *mode);
                            19703 ; 13   |extern _reentrant LONG Fwrite(INT HandleNumber,INT  *Buffer,LONG NumBytesToWrite,INT Source_Memory,INT MOdulo);
                            19704 ; 14   |extern _reentrant LONG Totalfreecluster(INT DeviceNum);
                            19705 ; 15   |extern _reentrant INT Rmdir(_packed char *filepath);
                            19706 ; 16   |extern _reentrant INT Rmdirw(_packed char *filepath);
                            19707 ; 17   |extern _reentrant INT Mkdir(_packed char *filepath);
                            19708 ; 18   |
                            19709 ; 19   |        //      SGTL-HK 27-05-2005
                            19710 ; 20   |extern _reentrant INT Mkdirw(UCS3 *filepath);
                            19711 ; 21   |
                            19712 ; 22   |extern _reentrant INT Chdir(_packed char *filepath);
                            19713 ; 23   |extern _reentrant INT FastOpen(LONG Key,_packed char *mode);
                            19714 ; 24   |
                            19715 ; 25   |extern _reentrant INT Setcwd(_packed char *filepath, _packed char *gCworkingDir,INT index,INT length);
                            19716 ; 26   |extern _reentrant _packed char *Getcwd(void);
                            19717 ; 27   |extern  _reentrant _packed char *Fgets(INT HandleNumber,INT NumBytesToRead, _packed char *Buffer);
                            19718 ; 28   |extern INT  FSInit(INT _X *bufx, INT _Y *bufy, INT maxdevices, INT maxhandles, INT maxcaches);
                            19719 ; 29   |extern INT  FlushCache(void);
                            19720 ; 30   |extern _reentrant INT FsShutDown(void);
                            19721 ; 31   |extern _reentrant LONG GetFileSize(INT HandleNumber);
                            19722 ; 32   |
                            19723 ; 33   |extern _reentrant INT filegetattrib(_packed char *FilePath);
                            19724 ; 34   |extern _reentrant INT Fopenw(INT *filepath,_packed char *mode);
                            19725 ; 35   |extern _reentrant INT Fremove(_packed char *filepath);
                            19726 ; 36   |extern _reentrant INT Fremovew(_packed char *filepath);
                            19727 ; 37   |extern _reentrant void DBCSToUnicode(_packed unsigned char *pDBCS, WORD *pUnicode,INT iLength);
                            19728 ; 38   |extern INT FlushCache(void);
                            19729 ; 39   |extern _reentrant INT DeleteTree(_packed char *Path);
                            19730 ; 40   |extern _reentrant INT Fclose(INT HandleNumber);
                            19731 ; 41   |extern INT FSMediaPresent(INT DeviceNum);
                            19732 ; 42   |extern INT FSFATType (INT DeviceNum);
                            19733 ; 43   |extern  INT _reentrant  GetVolumeLabel(_packed char *Buffer,INT DeviceNum);
                            19734 ; 44   |extern _reentrant INT SetVolumeLabel(_packed char *Buffer,INT DeviceNum);
                            19735 ; 45   |extern _reentrant LONG FgetFastHandle(INT HandleNumber);
                            19736 ; 46   |
                            19737 ; 47   |extern _reentrant INT ConstructLongFileName(INT HandleNumber, INT RecordNumber, INT *LFNBuffer);
                            19738 ; 48   |extern _reentrant void Uppercase(_packed char *file); 
                            19739 ; 49   |extern _reentrant INT FindNext(INT HandleNumber,Finddata *_finddata);
                            19740 ; 50   |extern _reentrant INT FindFirst(Finddata *_finddata,_packed char *FileName);
                            19741 ; 51   |extern _reentrant void ClearData(Finddata *_finddata);
                            19742 ; 52   |extern _reentrant INT GetShortfilename(LONG Key,INT *Buffer);
                            19743 ; 53   |
                            19744 ; 54   |
                            19745 ; 55   |
                            19746 ; 56   |
                            19747 ; 57   |typedef struct
                            19748 ; 58   |{
                            19749 ; 59   |
                            19750 ; 60   |INT             Day;
                            19751 ; 61   |INT             Month;
                            19752 ; 62   |INT             Year;
                            19753 ; 63   |}DIR_DATE;
                            19754 ; 64   |
                            19755 ; 65   |
                            19756 ; 66   |typedef struct
                            19757 ; 67   |{
                            19758 ; 68   |
                            19759 ; 69   |INT             Second;
                            19760 ; 70   |INT             Minute;
                            19761 ; 71   |INT             Hour;
                            19762 ; 72   |}DIR_TIME;
                            19763 ; 73   |
                            19764 ; 74   |
                            19765 ; 75   |typedef struct
                            19766 ; 76   |{
                            19767 ; 77   |LONG CurrentOffset;     
                            19768 ; 78   |LONG CurrentCluster;
                            19769 ; 79   |}HANDLECONTEXT;
                            19770 ; 80   |
                            19771 ; 81   |extern _reentrant INT filesetattrib(INT HandleNumber,INT dirattribute);
                            19772 ; 82   |extern _reentrant INT filesetdate(_packed char *FilePath,INT crt_mod_date_time_para,DIR_DATE *dirdate,DIR_TIME *dirtime);
                            19773 ; 83   |extern _reentrant INT filegetdate(INT HandleNumber,INT crt_mod_date_time_para,DIR_DATE *dirdate,DIR_TIME *dirtime);
                            19774 ; 84   |#endif
                            19775 
                            19777 
                            19778 ; 7    |////////////////////////////////////////////////////////////////////////////////
                            19779 ; 8    |//  Equates
                            19780 ; 9    |////////////////////////////////////////////////////////////////////////////////
                            19781 ; 10   |//Traversal return types
                            19782 ; 11   |#define PLAYLIST_END_TRAVERSAL_SUCCESS  (PLAYLIST_LAST_RETCODE + 1)
                            19783 ; 12   |#define PLAYLIST_END_TRAVERSAL_FAILURE  (PLAYLIST_LAST_RETCODE + 2)
                            19784 ; 13   |#define PLAYLIST_FILE_LOCATE_SUCCESS    (PLAYLIST_LAST_RETCODE + 3)
                            19785 ; 14   |
                            19786 ; 15   |#define PLAYSET_MUSIC 0
                            19787 ; 16   |#define PLAYSET_VOICE 1
                            19788 ; 17   |#define PLAYSET_FOLDER_PLAY 2
                            19789 ; 18   |#define PLAYSET_FAVORITES 3
                            19790 ; 19   |
                            19791 ; 20   |#define PLAYLIST_REPEAT_OFF     0
                            19792 ; 21   |#define PLAYLIST_REPEAT_ALL     1
                            19793 ; 22   |#define PLAYLIST_REPEAT_ONE     2
                            19794 ; 23   |
                            19795 ; 24   |#define SELECT_TRACKS   0
                            19796 ; 25   |#define ORDER_TRACKS    1
                            19797 ; 26   |#define BUILD_FILE_LINKS        2
                            19798 ; 27   |#define RESTORE_BOOKMARK 3
                            19799 ; 28   |        //      SGTL-HK 28-10-2004
                            19800 ; 29   |#define BUILD_DIR_LINKS         4
                            19801 ; 30   |
                            19802 ; 31   |
                            19803 ; 32   |#define ATTR_UNACCEPTABLE  (ATTR_HIDDEN|ATTR_SYSTEM|ATTR_VOLUME_ID)
                            19804 ; 33   |
                            19805 ; 34   |#define DIR_SEPARATOR   0x00002f        // "\"
                            19806 ; 35   |#define ROOT_SEPARATOR  0x002f3A        // ":\" swizzled
                            19807 ; 36   |
                            19808 ; 37   |#define DEPTH_VOICE_DIR 1       //depth of voice directory
                            19809 ; 38   |
                            19810 ; 39   |#define TYPE_DIR 0
                            19811 ; 40   |#define TYPE_FILE 1
                            19812 ; 41   |
                            19813 ; 42   |#define IS_TRASH        0
                            19814 ; 43   |#define IS_VOICE_DIR 1
                            19815 ; 44   |#define IS_VALID_AUDIO 2
                            19816 ; 45   |#define IS_VOICE_FILE  3
                            19817 ; 46   |
                            19818 ; 47   |//List containing audio file extensions
                            19819 ; 48   |#define WMA_FILE_EXT     0x414D57
                            19820 ; 49   |#define MP3_FILE_EXT     0x33504d
                            19821 ; 50   |#define WAV_FILE_EXT     0x564157
                            19822 ; 51   |#define MP4_FILE_EXT     0x34504d
                            19823 ; 52   |#define M4A_FILE_EXT     0x41344d
                            19824 ; 53   |#define ASF_FILE_EXT     0x465341
                            19825 ; 54   |#define AUDIBLE_FILE_EXT         0x004141
                            19826 ; 55   |#define JPG_FILE_EXT     0x47504a
                            19827 ; 56   |#define BMP_FILE_EXT     0x504d42
                            19828 ; 57   |#define SMV_FILE_EXT     0x564d53
                            19829 ; 58   |
                            19830 ; 59   |#define VOICE_PATH_0    0x2f3a61        // a:/ in dyslexical order
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  78

M:ADDR CODE           CYCLES LINE SOURCELINE
                            19831 ; 60   |#define VOICE_PATH_1    0x494f56        // VOI in dyslexical order
                            19832 ; 61   |#define VOICE_PATH_2    0x2f4543        // CE/ in dyslexical order
                            19833 ; 62   |#define VOICE_PATH_3    0x000000        // terminating 0
                            19834 ; 63   |
                            19835 ; 64   |#define FM_PATH_0               0x2f3a61        // a:/ in dyslexical order
                            19836 ; 65   |#define FM_PATH_1               0x2f4d46        // FM/ in dyslexical order
                            19837 ; 66   |#define FM_PATH_2               0x000000        // terminating 0
                            19838 ; 67   |
                            19839 ; 68   |#define LINEIN_PATH_0   0x2f3a61        // a:/ in dyslexical order
                            19840 ; 69   |#define LINEIN_PATH_1   0x4e494c        // LIN in dyslexical order
                            19841 ; 70   |#define LINEIN_PATH_2   0x492d45        // E-I in dyslexical order
                            19842 ; 71   |#define LINEIN_PATH_3   0x002f4e        // N/  in dyslexical order
                            19843 ; 72   |
                            19844 ; 73   |#define NAME_SFN        0
                            19845 ; 74   |#define NAME_LFN        1
                            19846 ; 75   |//Error code for unsupported file Names or Extensions
                            19847 ; 76   |#define META_DATA_FILE_NOT_SUPPORTED        (WORD)(0x101)
                            19848 ; 77   |
                            19849 ; 78   |#define FINDDATA_CACHE_SIZE   20
                            19850 ; 79   |
                            19851 ; 80   |// this number is used to skip mac resource fork files when loading the playlist
                            19852 ; 81   |// the resource SFN start with _ end with the same extension (i.e. mp3)
                            19853 ; 82   |// a SMALL sample of test files shows that the resource file is typically 82 bytes.
                            19854 ; 83   |#define MAC_RESOURCE_NUM_BYTES   512
                            19855 ; 84   |
                            19856 ; 85   |extern int g_iPlaylistRepeat;
                            19857 ; 86   |extern int g_bPlaylistShuffle;
                            19858 ; 87   |extern DWORD dStart, dEnd, dDiff;       //for timing measurements
                            19859 ; 88   |extern _packed BYTE DirPath[MAX_DIRNAME_LENGTH];
                            19860 ; 89   |extern BOOL g_Rebuild;
                            19861 ; 90   |extern RAM_SONG_INFO_T  song_info;
                            19862 ; 91   |extern INT  g_file_time;
                            19863 ; 92   |extern INT  g_unicode;
                            19864 ; 93   |extern DWORD    g_dwFastKey;
                            19865 ; 94   |extern INT  g_iRecordNum;
                            19866 ; 95   |extern DWORD    g_FileKey;
                            19867 ; 96   |extern DIR_DATE g_dirdate;
                            19868 ; 97   |extern DIR_TIME g_dirtime;
                            19869 ; 98   |extern INT  *pHighestNumber;
                            19870 ; 99   |extern INT  g_iHighestVoiceNumber;
                            19871 ; 100  |extern INT  g_iHighestFMNumber;
                            19872 ; 101  |extern INT  g_iHighestLineNumber;
                            19873 ; 102  |
                            19874 ; 103  |INT _reentrant Playlist_GetPlaySet(void);
                            19875 ; 104  |INT _reentrant Playlist_SetPlaySet(INT, INT, INT*);
                            19876 ; 105  |INT _reentrant Playlist_Initialize(INT, INT, INT*);
                            19877 ; 106  |INT _reentrant Playlist_BuildMusicLib(INT iIgnored1, INT iIgnored2, INT* pIgnored);
                            19878 ; 107  |_reentrant RETCODE Playlist_PopulateMusicLib(int iDevice, int iDepth, DWORD dwDirKey,INT RecordNumber);
                            19879 ; 108  |_reentrant INT Playlist_SetPlaySet(INT , INT, INT*);
                            19880 ; 109  |void _reentrant Playlist_ResetPlayset(void);
                            19881 ; 110  |BOOL _reentrant Playlist_ValidateEntry(INT iEntryType,INT iReason, INT* pPtr);
                            19882 ; 111  |
                            19883 ; 112  |///////////////////////////////////////////////////////////////////////////////////////////////////////////
                            19884 ; 113  |/////playlist3 helper functions
                            19885 ; 114  |//////////////////////////////////////////////////////////////////////////////////////////////////////////
                            19886 ; 115  |BOOL _reentrant Playlist_IsValidAudioFile(LONG lFileSize, _packed BYTE* pFileName);
                            19887 ; 116  |_reentrant INT Playlist_GetFileExtention(INT iIgnored1, INT iIgnored2, INT* pPtr);
                            19888 ; 117  |_reentrant BOOL IsTrashDir(_packed BYTE* pszName);
                            19889 ; 118  |_reentrant DWORD Playlist_GenerateFastKey(INT iDevice,LONG DirSector,INT iDirOffset);
                            19890 ; 119  |_reentrant INT ExtractDirSector1(DWORD Key);
                            19891 ; 120  |_reentrant INT ExtractDirSector2(DWORD Key);
                            19892 ; 121  |_reentrant INT ExtractDirOffset(DWORD Key);
                            19893 ; 122  |_reentrant RETCODE Playlist_GetRootString(_packed BYTE* pBuffer, INT iDevice);
                            19894 ; 123  |_reentrant RETCODE Playlist_LocateFileEntryFromName(INT iUnused1, INT iUnused2, INT* pPtr);
                            19895 ; 124  |_reentrant INT Playlist_LocateDirEntryFromName(INT iUnused1, INT iUnused2, INT* pPtr);
                            19896 ; 125  |_reentrant BOOL IsVoiceDir(DirEntry _X* pDirEntry);
                            19897 ; 126  |_reentrant RETCODE Playlist_GetSFN(INT iEntryType , INT pEntry, INT* pName);
                            19898 ; 127  |_reentrant RETCODE Playlist_GetLFN(INT iEntryType , INT pEntry, INT* pName);
                            19899 ; 128  |INT _reentrant PathFormation(_packed BYTE* dst, _packed BYTE* src, int iDepth);
                            19900 ; 129  |
                            19901 ; 130  |DWORD GetDclkCount(void);
                            19902 ; 131  |
                            19903 ; 132  |_reentrant INT CopyFindFirst(int mDirEntry, int mfinddata, int *mFileSpec);
                            19904 ; 133  |_reentrant INT CopyFindNext(INT HandleNumber,int mfinddata, int* ptr);
                            19905 ; 134  |
                            19906 ; 135  |_reentrant void BuildVoiceFilePath(void);
                            19907 ; 136  |_reentrant void BuildFMFilePath(void);
                            19908 ; 137  |_reentrant void BuildLINEINFilePath(void);
                            19909 ; 138  |_reentrant void GetVoiceFastKey(WORD wFastKeyBitField);
                            19910 ; 139  |_reentrant INT AddSongToLibrary(int a, int drive, void* b);
                            19911 ; 140  |#endif
                            19912 
                            19914 
                            19915 ; 19   |#include "playerlib.h"
                            19916 
                            19918 
                            19919 ; 1    |#ifndef _PLAYERLIB_H
                            19920 ; 2    |#define _PLAYERLIB_H
                            19921 ; 3    |
                            19922 ; 4    |#include "types.h"
                            19923 
                            19925 
                            19926 ; 1    |////////////////////////////////////////////////////////////////////////////////
                            19927 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                            19928 ; 3    |//
                            19929 ; 4    |// Filename: types.h
                            19930 ; 5    |// Description: Standard data types
                            19931 ; 6    |////////////////////////////////////////////////////////////////////////////////
                            19932 ; 7    |
                            19933 ; 8    |#ifndef _TYPES_H
                            19934 ; 9    |#define _TYPES_H
                            19935 ; 10   |
                            19936 ; 11   |// TODO:  move this outta here!
                            19937 ; 12   |#if !defined(NOERROR)
                            19938 ; 13   |#define NOERROR 0
                            19939 ; 14   |#define SUCCESS 0
                            19940 ; 15   |#endif 
                            19941 ; 16   |#if !defined(SUCCESS)
                            19942 ; 17   |#define SUCCESS  0
                            19943 ; 18   |#endif
                            19944 ; 19   |#if !defined(ERROR)
                            19945 ; 20   |#define ERROR   -1
                            19946 ; 21   |#endif
                            19947 ; 22   |#if !defined(FALSE)
                            19948 ; 23   |#define FALSE 0
                            19949 ; 24   |#endif
                            19950 ; 25   |#if !defined(TRUE)
                            19951 ; 26   |#define TRUE  1
                            19952 ; 27   |#endif
                            19953 ; 28   |
                            19954 ; 29   |#if !defined(NULL)
                            19955 ; 30   |#define NULL 0
                            19956 ; 31   |#endif
                            19957 ; 32   |
                            19958 ; 33   |#define MAX_INT     0x7FFFFF
                            19959 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                            19960 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                            19961 ; 36   |#define MAX_ULONG   (-1) 
                            19962 ; 37   |
                            19963 ; 38   |#define WORD_SIZE   24              // word size in bits
                            19964 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                            19965 ; 40   |
                            19966 ; 41   |
                            19967 ; 42   |#define BYTE    unsigned char       // btVarName
                            19968 ; 43   |#define CHAR    signed char         // cVarName
                            19969 ; 44   |#define USHORT  unsigned short      // usVarName
                            19970 ; 45   |#define SHORT   unsigned short      // sVarName
                            19971 ; 46   |#define WORD    unsigned int        // wVarName
                            19972 ; 47   |#define INT     signed int          // iVarName
                            19973 ; 48   |#define DWORD   unsigned long       // dwVarName
                            19974 ; 49   |#define LONG    signed long         // lVarName
                            19975 ; 50   |#define BOOL    unsigned int        // bVarName
                            19976 ; 51   |#define FRACT   _fract              // frVarName
                            19977 ; 52   |#define LFRACT  long _fract         // lfrVarName
                            19978 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                            19979 ; 54   |#define FLOAT   float               // fVarName
                            19980 ; 55   |#define DBL     double              // dVarName
                            19981 ; 56   |#define ENUM    enum                // eVarName
                            19982 ; 57   |#define CMX     _complex            // cmxVarName
                            19983 ; 58   |typedef WORD UCS3;                   // 
                            19984 ; 59   |
                            19985 ; 60   |#define UINT16  unsigned short
                            19986 ; 61   |#define UINT8   unsigned char   
                            19987 ; 62   |#define UINT32  unsigned long
                            19988 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            19989 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                            19990 ; 65   |#define WCHAR   UINT16
                            19991 ; 66   |
                            19992 ; 67   |//UINT128 is 16 bytes or 6 words
                            19993 ; 68   |typedef struct UINT128_3500 {   
                            19994 ; 69   |    int val[6];     
                            19995 ; 70   |} UINT128_3500;
                            19996 ; 71   |
                            19997 ; 72   |#define UINT128   UINT128_3500
                            19998 ; 73   |
                            19999 ; 74   |// Little endian word packed byte strings:   
                            20000 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            20001 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            20002 ; 77   |// Little endian word packed byte strings:   
                            20003 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                            20004 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                            20005 ; 80   |
                            20006 ; 81   |// Declare Memory Spaces To Use When Coding
                            20007 ; 82   |// A. Sector Buffers
                            20008 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                            20009 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                            20010 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                            20011 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                            20012 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                            20013 ; 88   |// B. Media DDI Memory
                            20014 ; 89   |#define MEDIA_DDI_MEM _Y
                            20015 ; 90   |
                            20016 ; 91   |
                            20017 ; 92   |
                            20018 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                            20019 ; 94   |// Examples of circular pointers:
                            20020 ; 95   |//    INT CIRC cpiVarName
                            20021 ; 96   |//    DWORD CIRC cpdwVarName
                            20022 ; 97   |
                            20023 ; 98   |#define RETCODE INT                 // rcVarName
                            20024 ; 99   |
                            20025 ; 100  |// generic bitfield structure
                            20026 ; 101  |struct Bitfield {
                            20027 ; 102  |    unsigned int B0  :1;
                            20028 ; 103  |    unsigned int B1  :1;
                            20029 ; 104  |    unsigned int B2  :1;
                            20030 ; 105  |    unsigned int B3  :1;
                            20031 ; 106  |    unsigned int B4  :1;
                            20032 ; 107  |    unsigned int B5  :1;
                            20033 ; 108  |    unsigned int B6  :1;
                            20034 ; 109  |    unsigned int B7  :1;
                            20035 ; 110  |    unsigned int B8  :1;
                            20036 ; 111  |    unsigned int B9  :1;
                            20037 ; 112  |    unsigned int B10 :1;
                            20038 ; 113  |    unsigned int B11 :1;
                            20039 ; 114  |    unsigned int B12 :1;
                            20040 ; 115  |    unsigned int B13 :1;
                            20041 ; 116  |    unsigned int B14 :1;
                            20042 ; 117  |    unsigned int B15 :1;
                            20043 ; 118  |    unsigned int B16 :1;
                            20044 ; 119  |    unsigned int B17 :1;
                            20045 ; 120  |    unsigned int B18 :1;
                            20046 ; 121  |    unsigned int B19 :1;
                            20047 ; 122  |    unsigned int B20 :1;
                            20048 ; 123  |    unsigned int B21 :1;
                            20049 ; 124  |    unsigned int B22 :1;
                            20050 ; 125  |    unsigned int B23 :1;
                            20051 ; 126  |};
                            20052 ; 127  |
                            20053 ; 128  |union BitInt {
                            20054 ; 129  |        struct Bitfield B;
                            20055 ; 130  |        int        I;
                            20056 ; 131  |};
                            20057 ; 132  |
                            20058 ; 133  |#define MAX_MSG_LENGTH 10
                            20059 ; 134  |struct CMessage
                            20060 ; 135  |{
                            20061 ; 136  |        unsigned int m_uLength;
                            20062 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                            20063 ; 138  |};
                            20064 ; 139  |
                            20065 ; 140  |typedef struct {
                            20066 ; 141  |    WORD m_wLength;
                            20067 ; 142  |    WORD m_wMessage;
                            20068 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                            20069 ; 144  |} Message;
                            20070 ; 145  |
                            20071 ; 146  |struct MessageQueueDescriptor
                            20072 ; 147  |{
                            20073 ; 148  |        int *m_pBase;
                            20074 ; 149  |        int m_iModulo;
                            20075 ; 150  |        int m_iSize;
                            20076 ; 151  |        int *m_pHead;
                            20077 ; 152  |        int *m_pTail;
                            20078 ; 153  |};
                            20079 ; 154  |
                            20080 ; 155  |struct ModuleEntry
                            20081 ; 156  |{
                            20082 ; 157  |    int m_iSignaledEventMask;
                            20083 ; 158  |    int m_iWaitEventMask;
                            20084 ; 159  |    int m_iResourceOfCode;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  79

M:ADDR CODE           CYCLES LINE SOURCELINE
                            20085 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                            20086 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                            20087 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                            20088 ; 163  |    int m_uTimeOutHigh;
                            20089 ; 164  |    int m_uTimeOutLow;
                            20090 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                            20091 ; 166  |};
                            20092 ; 167  |
                            20093 ; 168  |union WaitMask{
                            20094 ; 169  |    struct B{
                            20095 ; 170  |        unsigned int m_bNone     :1;
                            20096 ; 171  |        unsigned int m_bMessage  :1;
                            20097 ; 172  |        unsigned int m_bTimer    :1;
                            20098 ; 173  |        unsigned int m_bButton   :1;
                            20099 ; 174  |    } B;
                            20100 ; 175  |    int I;
                            20101 ; 176  |} ;
                            20102 ; 177  |
                            20103 ; 178  |
                            20104 ; 179  |struct Button {
                            20105 ; 180  |        WORD wButtonEvent;
                            20106 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                            20107 ; 182  |};
                            20108 ; 183  |
                            20109 ; 184  |struct Message {
                            20110 ; 185  |        WORD wMsgLength;
                            20111 ; 186  |        WORD wMsgCommand;
                            20112 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                            20113 ; 188  |};
                            20114 ; 189  |
                            20115 ; 190  |union EventTypes {
                            20116 ; 191  |        struct CMessage msg;
                            20117 ; 192  |        struct Button Button ;
                            20118 ; 193  |        struct Message Message;
                            20119 ; 194  |};
                            20120 ; 195  |
                            20121 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                            20122 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                            20123 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                            20124 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                            20125 ; 200  |
                            20126 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                            20127 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                            20128 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                            20129 ; 204  |
                            20130 ; 205  |#if DEBUG
                            20131 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                            20132 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                            20133 ; 208  |#else 
                            20134 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                            20135 ; 210  |#define DebugBuildAssert(x)    
                            20136 ; 211  |#endif
                            20137 ; 212  |
                            20138 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                            20139 ; 214  |//  #pragma asm
                            20140 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                            20141 ; 216  |//  #pragma endasm
                            20142 ; 217  |
                            20143 ; 218  |
                            20144 ; 219  |#ifdef COLOR_262K
                            20145 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                            20146 ; 221  |#elif defined(COLOR_65K)
                            20147 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                            20148 ; 223  |#else
                            20149 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                            20150 ; 225  |#endif
                            20151 ; 226  |    
                            20152 ; 227  |#endif // #ifndef _TYPES_H
                            20153 
                            20155 
                            20156 ; 5    |#include "playlist.h"
                            20157 
                            20159 
                            20160 ; 1    |#ifndef PLAYLIST_H
                            20161 ; 2    |#define PLAYLIST_H
                            20162 ; 3    |
                            20163 ; 4    |#include "types.h"
                            20164 ; 5    |
                            20165 ; 6    |typedef struct {
                            20166 ; 7    |    WORD    m_wTrack;                       
                            20167 ; 8    |    WORD    m_wDeviceID;
                            20168 ; 9    |    WORD    m_wBufferLength;            //this is in BYTES, not WORDS!
                            20169 ; 10   |    _packed BYTE *m_pFilename;
                            20170 ; 11   |} SONGFILEINFO;
                            20171 ; 12   |
                            20172 ; 13   |#define PLAYLIST_SUCCESS                                0
                            20173 ; 14   |#define PLAYLIST_FILE_ERROR                             1
                            20174 ; 15   |#define PLAYLIST_END_OF_LIST                    2
                            20175 ; 16   |#define PLAYLIST_TRACK_NOT_FOUND                3
                            20176 ; 17   |#define PLAYLIST_DIR_NOT_EMPTY          4 
                            20177 ; 18   |#define PLAYLIST_REBUILD                5
                            20178 ; 19   |#define PLAYLIST_LAST_RETCODE                   5               //The value should always be the same as the last RETCODE
                            20179 ; 20   |
                            20180 ; 21   |
                            20181 ; 22   |#ifdef  USE_PLAYLIST1
                            20182 ; 23   |RETCODE ChangeDIRtoFileEntryDir(struct FileEntry *pCurrentEntry, _packed BYTE * buffer);
                            20183 ; 24   |#endif
                            20184 ; 25   |RETCODE _reentrant Playlist_LFNGetFileName(int,int,UCS3*);                      //UCS3 is actually typdef WORD
                            20185 ; 26   |RETCODE _reentrant Playlist_MarkCurrentSongPlayed(int,int,int*);
                            20186 ; 27   |RETCODE _reentrant Playlist_GetCurrentSongFileInfo(int, int, int*);
                            20187 ; 28   |RETCODE _reentrant Playlist_GetNextSongFileInfo(int, int , int*);
                            20188 ; 29   |RETCODE _reentrant Playlist_GetPreviousSongFileInfo(int,int,int*);
                            20189 ; 30   |#ifdef USE_PLAYLIST1
                            20190 ; 31   |_reentrant INT Playlist_LocateEntryFromName(INT,INT,INT*);
                            20191 ; 32   |#endif
                            20192 ; 33   |
                            20193 ; 34   |#endif 
                            20194 
                            20196 
                            20197 ; 6    |
                            20198 ; 7    |#define DECODER_STATE_STOP          0
                            20199 ; 8    |#define DECODER_STATE_PLAY          1
                            20200 ; 9    |#define DECODER_STATE_PAUSE         2
                            20201 ; 10   |#define DECODER_STATE_TOGGLE    4
                            20202 ; 11   |
                            20203 ; 12   |#define PLAYERLIB_SUCCESS       0
                            20204 ; 13   |#define PLAYERLIB_BAD_FILE      1
                            20205 ; 14   |#define PLAYERLIB_ERROR         2
                            20206 ; 15   |#define PLAYERLIB_END_OF_LIST   3
                            20207 ; 16   |
                            20208 ; 17   |//These are in the DecoderSR/DecoderCSR
                            20209 ; 18   |#define DECODER_PAUSED          1<<5
                            20210 ; 19   |#define DECODER_STOPPED         1<<6
                            20211 ; 20   |#define DECODER_SYNCED          1<<10
                            20212 ; 21   |#define DECODER_PLAYING         1<<12
                            20213 ; 22   |#define DECODER_SONG_INFO       1<<15
                            20214 ; 23   |#define DECODER_FILE_IS_OPEN    1<<16
                            20215 ; 24   |#define DECODER_A_SET           1<<18
                            20216 ; 25   |#define DECODER_B_SET           1<<19
                            20217 ; 26   |#define DECODER_BAD_FILE        1<<21
                            20218 ; 27   |#define DECODER_LOOKING_FOR_SYNC 1<<22
                            20219 ; 28   |
                            20220 ; 29   |//PrevSong Message Parameters
                            20221 ; 30   |#define PREVSONG_STOP        0             //PrevSong + Stopped
                            20222 ; 31   |#define PREVSONG_PLAY        1<<0          //PrevSong + Play
                            20223 ; 32   |#define PREVSONG_RWND        1<<1          //PrevSong + Rwnd
                            20224 ; 33   |//NextSong Message Parameters
                            20225 ; 34   |#define NEXTSONG_STOP        0             //NextSong + Stopped
                            20226 ; 35   |#define NEXTSONG_PLAY_EOF    1             //NextSong + Play + EOF reached
                            20227 ; 36   |#define NEXTSONG_PLAY_BUTTON 3             //NextSong + Play + BUTTON pressed
                            20228 ; 37   |#define NEXTSONG_FFWD        4             //NextSong + Ffwd
                            20229 ; 38   |#define NEXTSONG_DELETE_MENU 5             //NextSong via delete menu
                            20230 ; 39   |//CurrentSong Message Parameters
                            20231 ; 40   |#define CURRENTSONG_DELETE_MENU 1          //CurrentSong via delete menu
                            20232 ; 41   |
                            20233 ; 42   |#ifdef USE_PLAYLIST3
                            20234 ; 43   |extern DWORD    g_CurrentSongFastkey;
                            20235 ; 44   |#endif  // USE_PLAYLIST3
                            20236 ; 45   |
                            20237 ; 46   |#ifdef USE_PLAYLIST5
                            20238 ; 47   |extern long g_CurrentFastKey;
                            20239 ; 48   |#endif //USE_PLAYLIST5
                            20240 ; 49   |RETCODE _reentrant PlayerLib_SetState (int iState,int bWait,int*);  
                            20241 ; 50   |RETCODE _reentrant PlayerLib_FastForward (int bPlayDuring,int,int*);
                            20242 ; 51   |RETCODE _reentrant PlayerLib_Rewind(int bPlayDuring,int,int*);
                            20243 ; 52   |RETCODE _reentrant PlayerLib_SetSongName(int bStartPlaying, int, SONGFILEINFO*);
                            20244 
                            20253 
                            20254 ; 53   |RETCODE _reentrant PlayerLib_GetCurrentSong(WORD wMode,int ignored1,int*ignored2);
                            20255 ; 54   |RETCODE _reentrant PlayerLib_SkipToNextSong(WORD,WORD,int*);
                            20256 ; 55   |RETCODE _reentrant PlayerLib_SkipToPreviousSong(WORD,WORD,int*);
                            20257 ; 56   |RETCODE _reentrant PlayerLib_EnablePlaylist(int bTrueFalse,int,int*);  
                            20258 ; 57   |RETCODE _reentrant PlayerLib_GetMetaData(WORD wMode,int ignored1,int*ignored2);
                            20259 ; 58   |DWORD _reentrant PlayerLib_GetSongPosition(void);
                            20260 ; 59   |RETCODE _reentrant PlayerLib_SetSongPosition(DWORD dwSongPos);
                            20261 ; 60   |////////////////////Bookmarking functions///////////////////////////////
                            20262 ; 61   |RETCODE _reentrant PlayerLib_ResetBookmark(int iCurrentPlayset, int ignored, int* pPtr);
                            20263 ; 62   |RETCODE _reentrant PlayerLib_SetBookmark(int iCurrentPlayset, int iTracknum,int* pPtr);
                            20264 ; 63   |RETCODE _reentrant PlayerLib_GotoTrack(int iTracknum, int ignored, int* ptr);
                            20265 ; 64   |RETCODE _reentrant PlayerLib_GetBookmarkSongInfo(int iCurrentPlayset, int ignored2, int* pPtr);
                            20266 ; 65   |#ifdef USE_PLAYLIST3
                            20267 ; 66   |RETCODE _reentrant PlayerLib_GetCurrentSong_ML(WORD wMode,int ignored1,int*ignored2);
                            20268 ; 67   |#endif // #ifdef USE_PLAYLIST3
                            20269 ; 68   |
                            20270 ; 69   |#endif 
                            20271 
                            20273 
                            20274 ; 20   |#endif
                            20275 ; 21   |
                            20276 ; 22   |_X WORD g_wFrameLengthInBytes = 551;    // EOF safety offset bytes, SL
                            20277 
                            20278 
X:0000                      20279         org     x,".xdatavbr",init:
                            20280 Fg_wFrameLengthInBytes:
X:0000 000227               20281         dc      $000227
                            20290 
                            20291 ; 23   |
                            20292 ; 24   |_Y VBR_GLOBAL_HEADER_DATA g_VBRGlobalData;
                            20293 
                            20304 
                            20305 ; 25   |_Y VBR_HEADER_DATA g_VBRHeaderData;                  // struct for VBR Data (Xing or VBRI)
                            20306 ; 26   |
                            20307 ; 27   |extern WORD g_wVBRSignature;   // Xing or VBR ("X"/"V"/"U"(unknown) or 0 for none)
                            20308 ; 28   |
                            20309 ; 29   |
                            20310 ; 30   |DWORD _reentrant ExtractI4(BYTE *buf, INT i);   // stmp 6724  Change type from INT to DWORD to allow 4-byte storage
                            20311 ; 31   |WORD _reentrant ExtractIVar(BYTE *buf, INT i, BYTE iByteCount);
                            20312 ; 32   |
                            20313 ; 33   |INT _reentrant GetXingHeader(VBR_HEADER_DATA * VbrHeader, _packed BYTE *buf, WORD * pOffset);
                            20314 ; 34   |INT _reentrant GetVBRiHeader(VBR_HEADER_DATA * VbrHeader, _packed BYTE *buf, WORD * pOffset);
                            20315 ; 35   |
                            20316 ; 36   |
                            20317 ; 37   |///////////////////////////////////////////////////////////////////////////////
                            20318 ; 38   |//> Name:        RETCODE _reentrant FileReadWithSync (INT BytesToRead, INT iHandle, WORD *ReadBuffer)
                            20319 ; 39   |//
                            20320 ; 40   |//  Type:        Function
                            20321 ; 41   |//
                            20322 ; 42   |//  Description:
                            20323 ; 43   |//
                            20324 ; 44   |//  Inputs:      
                            20325 ; 45   |//  Outputs:
                            20326 ; 46   |//
                            20327 ; 47   |//  Notes:
                            20328 ; 48   |//<
                            20329 ; 49   |/////////////////////////////////////////////////////////////////////////////////
                            20330 ; 50   |RETCODE _reentrant FileReadWithSync (INT BytesToRead, INT iHandle, WORD *ReadBuffer)
                            20331 ; 51   |{
                            20332 
P:0000                      20333         org     p,".ptextvbr":
                            20338 FFileReadWithSync:
P:0000 055F7C         2    220339         movec   ssh,y:(r7)+
P:0001 3F0500         2    420342         move    #5,n7
P:0002 000000         2    620343         nop
P:0003 204F00         2    820344         move    (r7)+n7
                            20356 
                            20357 ; 52   |        int i;
                            20358 ; 53   |        WORD wCount=0;  
                            20359 
P:0004 77F400 FFFFFC  3   1120361         move    #-4,n7
P:0006 000000         2   1320362         nop
P:0007 5D6F00         4   1720363         move    b1,y:(r7+n7)
P:0008 77F400 FFFFFB  3   2020366         move    #-5,n7
P:000A 000000         2   2220367         nop
P:000B 5C6F00         4   2620368         move    a1,y:(r7+n7)
P:000C 240000         2   2820371         move    #0,x0
P:000D 270000         2   3020372         move    #0,y1
P:000E 77F400 FFFFFE  3   3320374         move    #-2,n7
P:0010 000000         2   3520375         nop
P:0011 4F6F00         4   3920376         move    y1,y:(r7+n7)
                            20379 
                            20380 ; 54   |        
                            20381 ; 55   |        while (FSFileRead(150, iHandle, MEM_SPACE_Y, (INT)(-1), ReadBuffer) != ERROR)
                            20382 
P:0012 0AF080 rrrrrr  6   4520384         jmp     L17
                            20385 
                            20386 ; 56   |        {
                            20387 ; 57   |                for (i = 0; i < 150/3; i++)
                            20388 
                            20390 L12:
P:0014 240000         2   4720393         move    #0,x0
P:0015 250000         2   4920394         move    #0,x1
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  80

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0016 045FA0         2   5120396         movec   m0,n7
P:0017 000000         2   5320397         nop
P:0018 4D6F00         4   5720398         move    x1,y:(r7+n7)
P:0019 77F400 FFFFFD  3   6020401         move    #-3,n7
P:001B 000000         2   6220402         nop
P:001C 68EF00         4   6620403         move    y:(r7+n7),r0
P:001D 221600         2   6820404         move    r0,r6
P:001E 383200         2   7020407         move    #50,n0
P:001F 000000         2   7220408         nop
P:0020 044818         4   7620409         lua     (r0)+n0,n0
P:0021 45F400 00FF00  3   7920410         move    #$FF00,x1
P:0023 27FF00         2   8120411         move    #<$FF,y1
                            20412 
                            20413 ; 58   |                {
                            20414 ; 59   |                        if (((ReadBuffer[i]&0xFF)==0xFF)||((ReadBuffer[i]&0xFF00)==0xFF00)||((ReadBuffer[i]&0xFF0000)==0xFF0000))
                            20415 
P:0024 5CE600         2   8320417 L13:    move    y:(r6),a1
P:0025 218F00         2   8520418         move    a1,b
P:0026 46F400 0000FF  3   8820419         move    #>$FF,y0
P:0028 200056         2   9020420         and     y0,a
P:0029 218E00         2   9220421         move    a1,a
P:002A 2A0000         2   9420422         move    #0,a2
P:002B 200055         2   9620423         cmp     y0,a
P:002C 0AF0AA rrrrrr  6  10220424         jeq     L15
P:002E 21AE00         2  10420425         move    b1,a
P:002F 200066         2  10620426         and     x1,a
P:0030 2A0000         2  10820427         move    #0,a2
P:0031 200065         2  11020428         cmp     x1,a
P:0032 0AF0AA rrrrrr  6  11620429         jeq     L15
P:0034 20007E         2  11820430         and     y1,b
P:0035 200071         2  12020431         tfr     y1,a
P:0036 2A0000         2  12220432         move    #0,a2
P:0037 2B0000         2  12420433         move    #0,b2
P:0038 20000D         2  12620434         cmp     a,b
P:0039 0AF0A2 rrrrrr  6  13220435         jne     L16
P:003B 77F400 FFFFFD  3  13520436 L15:    move    #-3,n7
P:003D 000000         2  13720437         nop
P:003E 686F00         4  14120438         move    r0,y:(r7+n7)
                            20441 
                            20442 ; 60   |                        {
                            20443 ; 61   |                                fseek(iHandle,-150+i*3,SEEK_CUR);
                            20444 
P:003F 045FA0         2  14320446         movec   m0,n7
P:0040 000000         2  14520447         nop
P:0041 4DEF00         4  14920448         move    y:(r7+n7),x1
P:0042 46F400 000003  3  15220449         move    #>3,y0
P:0044 2000E0         2  15420450         mpy     x1,y0,a
P:0045 200022         2  15620451         asr     a
P:0046 210E00         2  15820454         move    a0,a
P:0047 47F400 000096  3  16120455         move    #>150,y1
P:0049 200074         2  16320456         sub     y1,a
P:004A 218800         2  16520457         move    a1,a0
P:004B 214C00         2  16720458         move    a2,a1
P:004C 77F400 FFFFFC  3  17020459         move    #-4,n7
P:004E 000000         2  17220460         nop
P:004F 5FEF00         4  17620461         move    y:(r7+n7),b
P:0050 0BF080 rrrrrr  6  18220464         jsr     Ffseek
                            20468 
                            20469 ; 62   |                                return FSFileRead(BytesToRead, iHandle, MEM_SPACE_Y, (INT)(-1), ReadBuffer);
                            20470 
P:0052 77F400 FFFFFD  3  18520472         move    #-3,n7
P:0054 000000         2  18720473         nop
P:0055 68EF00         4  19120474         move    y:(r7+n7),r0
P:0056 77F400 FFFFFC  3  19420475         move    #-4,n7
P:0058 000000         2  19620476         nop
P:0059 5FEF00         4  20020477         move    y:(r7+n7),b
P:005A 77F400 FFFFFB  3  20320478         move    #-5,n7
P:005C 000000         2  20520479         nop
P:005D 5EEF00         4  20920480         move    y:(r7+n7),a
P:005E 244000         2  21120481         move    #<$40,x0
P:005F 46F400 FFFFFF  3  21420482         move    #>-1,y0
P:0061 0BF080 rrrrrr  6  22020483         jsr     FFSFileRead
P:0063 0AF080 rrrrrr  6  22620493         jmp     L19
                            20494 
                            20495 ; 63   |                        }
                            20496 ; 64   |
                            20497 ; 65   |            wCount += 3;
                            20498 
                            20500 L16:
P:0065 77F400 FFFFFE  3  22920505         move    #-2,n7
P:0067 000000         2  23120506         nop
P:0068 5FEF00         4  23520507         move    y:(r7+n7),b
P:0069 56F400 000003  3  23820508         move    #>3,a
P:006B 200018         2  24020509         add     a,b
                            20512 
                            20513 ; 66   |            if (wCount > MP3_SYNC_THRESHOLD)
                            20514 
P:006C 5D6F00         4  24420516         move    b1,y:(r7+n7)
P:006D 46F400 011170  3  24720517         move    #70000,y0
P:006F 2B0000         2  24920518         move    #0,b2
P:0070 20005D         2  25120519         cmp     y0,b
P:0071 0AF0A7 rrrrrr  6  25720522         jgt     L18
P:0073 205E00         2  25920524         move    (r6)+
P:0074 045FA0         2  26120525         movec   m0,n7
P:0075 000000         2  26320526         nop
P:0076 5EEF00         4  26720527         move    y:(r7+n7),a
P:0077 57F400 000001  3  27020528         move    #>1,b
P:0079 200010         2  27220529         add     b,a
P:007A 5C6F00         4  27620532         move    a1,y:(r7+n7)
P:007B 22CF00         2  27820535         move    r6,b
P:007C 230E00         2  28020536         move    n0,a
P:007D 20000D         2  28220537         cmp     a,b
P:007E 0AF0A9 rrrrrr  6  28820538         jlt     L13
P:0080 77F400 FFFFFC  3  29120540 L17:    move    #-4,n7
P:0082 000000         2  29320541         nop
P:0083 5FEF00         4  29720542         move    y:(r7+n7),b
P:0084 77F400 FFFFFD  3  30020545         move    #-3,n7
P:0086 000000         2  30220546         nop
P:0087 686F00         4  30620547         move    r0,y:(r7+n7)
P:0088 46F400 FFFFFF  3  30920552         move    #>-1,y0
P:008A 56F400 000096  3  31220553         move    #>150,a
P:008C 244000         2  31420554         move    #<$40,x0
P:008D 0BF080 rrrrrr  6  32020555         jsr     FFSFileRead
P:008F 44F400 FFFFFF  3  32320560         move    #>-1,x0
P:0091 200045         2  32520561         cmp     x0,a
P:0092 0AF0A2 rrrrrr  6  33120562         jne     L12
                            20563 
                            20564 ; 67   |              return ERROR;
                            20565 ; 68   |                }
                            20566 ; 69   |        }
                            20567 ; 70   |        return ERROR;
                            20568 
P:0094 56F400 FFFFFF  3  33420570 L18:    move    #>-1,a
                            20571 
                            20572 ; 71   |}
                            20573 
P:0096 77F400 FFFFFA  3  33720575 L19:    move    #-6,n7
P:0098 000000         2  33920576         nop
P:0099 05EF7C         4  34320577         movec   y:(r7+n7),ssh
P:009A 204F00         2  34520579         move    (r7)+n7
P:009B 00000C         4  34920581         rts
                            20588 
                            20589 ; 72   |
                            20590 ; 73   |///////////////////////////////////////////////////////////////////////////////
                            20591 ; 74   |//> Name:        RETCODE _reentrant MP3MetaDataReadVBRHeaders(INT iHandle,FILE_META_DATA*pMetaData)
                            20592 ; 75   |//
                            20593 ; 76   |//  Type:        Function
                            20594 ; 77   |//
                            20595 ; 78   |//  Description: Reads in the XING header, and fills in the related parts of the meta data structure.
                            20596 ; 79   |//
                            20597 ; 80   |//  Inputs:      
                            20598 ; 81   |//  Outputs:     0 if Success, -1 if Failure.
                            20599 ; 82   |//
                            20600 ; 83   |//  Notes:       Currently we're checking for VBRi (Fraunhofer) and Xing headers.
                            20601 ; 84   |//<
                            20602 ; 85   |/////////////////////////////////////////////////////////////////////////////////
                            20603 ; 86   |RETCODE _reentrant MP3MetaDataReadVBRHeaders(INT iHandle, FILE_META_DATA *pMetaData)
                            20604 ; 87   |{
                            20605 
                            20612 FMP3MetaDataReadVBRHeaders:
P:009C 055F7C         2  35120613         movec   ssh,y:(r7)+
P:009D 3FA100         2  35320616         move    #161,n7
P:009E 000000         2  35520617         nop
P:009F 204F00         2  35720618         move    (r7)+n7
                            20628 
                            20629 ; 88   |    WORD ReadBuffer[READ_BUFFER_SIZE];              // read file (packed bytes) into this buffer
                            20630 ; 89   |    LONG uPosition = ftell(iHandle);
                            20631 
P:00A0 77F400 FFFFFD  3  36020633         move    #-3,n7
P:00A2 000000         2  36220634         nop
P:00A3 686F00         4  36620635         move    r0,y:(r7+n7)
P:00A4 77F400 FFFFFC  3  36920638         move    #-4,n7
P:00A6 000000         2  37120639         nop
P:00A7 5C6F00         4  37520640         move    a1,y:(r7+n7)
P:00A8 0BF080 rrrrrr  6  38120645         jsr     Fftell
P:00AA 77F400 FFFFFE  3  38420648         move    #-2,n7
P:00AC 205F00         2  38620649         move    (r7)+
P:00AD 5C6F00         4  39020651         move    a1,y:(r7+n7)
P:00AE 205700         2  39220652         move    (r7)-
P:00AF 586F00         4  39620654         move    a0,y:(r7+n7)
                            20657 
                            20658 ; 90   |    WORD wOffset = 0;
                            20659 
P:00B0 20001B         2  39820661         clr     b   
P:00B1 77F400 FFFF5F  3  40120662         move    #-161,n7
P:00B3 000000         2  40320663         nop
P:00B4 5D6F00         4  40720664         move    b1,y:(r7+n7)
                            20667 
                            20668 ; 91   |    INT i;
                            20669 ; 92   |
                            20670 ; 93   |    g_VBRGlobalData.VBRTable = &g_wVBRTOCTable[0];     // Initialize VBR Table pointer (Global)
                            20671 
P:00B5 61F400 rrrrrr  3  41020673         move    #Fg_wVBRTOCTable,r1
P:00B7 697000 rrrrrr  3  41320674         move    r1,y:Fg_VBRGlobalData+3
                            20675 
                            20676 ; 94   |    g_wVBRSignature = 0;                            // Initialize to zero (No VBR).
                            20677 
P:00B9 5D7000 rrrrrr  3  41620679         move    b1,y:Fg_wVBRSignature
                            20681 
                            20682 ; 95   |
                            20683 ; 96   |//    Clear the lookup table.
                            20684 ; 97   |    for (i=0; i<VBR_TOC_SIZE; i++) 
                            20685 
P:00BB 223600         2  41820687         move    r1,r6
P:00BC 06C880 rrrrrr  6  42420689         do      #200,L25
                            20691 
                            20692 ; 98   |    {
                            20693 ; 99   |      g_wVBRTOCTable[i]=0;
                            20694 
P:00BE 5D5E00         2  42620696         move    b1,y:(r6)+
P:00BF 000000         2  42820698         nop
                         (4)20699 L25:
                            20701 
                            20702 ; 100  |    }
                            20703 ; 101  |    g_VBRGlobalData.VBRTotalSeconds = 0;
                            20704 
P:00C0 5D7000 rrrrrr  3  43120706         move    b1,y:Fg_VBRGlobalData+1
                            20707 
                            20708 ; 102  |    g_VBRGlobalData.VBRDurPerBin = 0;
                            20709 
P:00C2 5D7000 rrrrrr  3  43420711         move    b1,y:Fg_VBRGlobalData+2
                            20712 
                            20713 ; 103  |
                            20714 ; 104  |        // Jan 27 05 (in sdk june 2005)- Find SyncByte before checking VBR header. stmp00006282
                            20715 ; 105  |        if (FileReadWithSync(VBR_BYTES_TO_READ, iHandle, ReadBuffer) != ERROR)
                            20716 
P:00C4 77F400 FFFF60  3  43720718         move    #-160,n7
P:00C6 000000         2  43920719         nop
P:00C7 044F15         4  44320720         lua     (r7)+n7,r5
P:00C8 77F400 FFFFFC  3  44620721         move    #-4,n7
P:00CA 000000         2  44820722         nop
P:00CB 5FEF00         4  45220723         move    y:(r7+n7),b
P:00CC 22B000         2  45420726         move    r5,r0
P:00CD 56F400 000190  3  45720727         move    #400,a
P:00CF 0BF080 rrrrrr  6  46320728         jsr     FFileReadWithSync
P:00D1 45F400 FFFFFF  3  46620731         move    #>-1,x1
P:00D3 200065         2  46820732         cmp     x1,a
P:00D4 0AF0AA rrrrrr  6  47420733         jeq     L24
                            20734 
                            20735 ; 106  |    {
                            20736 ; 107  |        // Check if Xing Header exists -- if so, use it
                            20737 ; 108  |        if ((GetXingHeader(&g_VBRHeaderData, (_packed BYTE*)ReadBuffer, &wOffset) == SUCCESS) || 
                            20738 ; 109  |            (GetVBRiHeader(&g_VBRHeaderData, (_packed BYTE *)ReadBuffer, &wOffset) == SUCCESS) )
                            20739 
P:00D6 77F400 FFFF5F  3  47720741         move    #-161,n7
P:00D8 000000         2  47920742         nop
P:00D9 044F1D         4  48320743         lua     (r7)+n7,n5
P:00DA 23B100         2  48520744         move    n5,r1
P:00DB 77F400 FFFF60  3  48820745         move    #-160,n7
P:00DD 000000         2  49020746         nop
P:00DE 044F14         4  49420747         lua     (r7)+n7,r4
P:00DF 60F400 rrrrrr  3  49720748         move    #Fg_VBRHeaderData,r0
P:00E1 0BF080 rrrrrr  6  50320749         jsr     FGetXingHeader
P:00E3 200003         2  50520750         tst     a
P:00E4 0AF0AA rrrrrr  6  51120751         jeq     L22
P:00E6 77F400 FFFF5F  3  51420752         move    #-161,n7
P:00E8 000000         2  51620753         nop
P:00E9 044F11         4  52020754         lua     (r7)+n7,r1
P:00EA 77F400 FFFF60  3  52320755         move    #-160,n7
P:00EC 000000         2  52520756         nop
P:00ED 044F14         4  52920757         lua     (r7)+n7,r4
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  81

M:ADDR CODE           CYCLES LINE SOURCELINE
P:00EE 60F400 rrrrrr  3  53220758         move    #Fg_VBRHeaderData,r0
P:00F0 0BF080 rrrrrr  6  53820759         jsr     FGetVBRiHeader
P:00F2 200003         2  54020760         tst     a
P:00F3 0AF0A2 rrrrrr  6  54620761         jne     L23
                            20762 
                            20763 ; 110  |        { // fill in Xing Meta-Data if Xing header found
                            20764 ; 111  |          // fill in the sampling rate
                            20765 ; 112  |          pMetaData->wSampRate = g_VBRHeaderData.VBRSampleRate;
                            20766 
P:00F5 4EF000 rrrrrr  3  54920768 L22:    move    y:Fg_VBRHeaderData+1,y0
P:00F7 3C0C00         2  55120769         move    #12,n4
P:00F8 77F400 FFFFFD  3  55420770         move    #-3,n7
P:00FA 000000         2  55620771         nop
P:00FB 6CEF00         4  56020772         move    y:(r7+n7),r4
P:00FC 229100         2  56220773         move    r4,r1
P:00FD 044C16         4  56620774         lua     (r4)+n4,r6
P:00FE 000000         2  56820777         nop
P:00FF 4E6600         2  57020778         move    y0,y:(r6)
                            20779 
                            20780 ; 113  |          // fill in the number of frames
                            20781 ; 114  |          pMetaData->dwNumFrames = g_VBRHeaderData.VBRStreamFrames;
                            20782 
P:0100 5FF000 rrrrrr  3  57320784         move    y:Fg_VBRHeaderData+4,b
P:0102 59F000 rrrrrr  3  57620785         move    y:Fg_VBRHeaderData+3,b0
P:0104 391700         2  57820786         move    #23,n1
P:0105 000000         2  58020787         nop
P:0106 044916         4  58420788         lua     (r1)+n1,r6
P:0107 000000         2  58620789         nop
P:0108 595E00         2  58820790         move    b0,y:(r6)+
P:0109 5D5600         2  59020791         move    b1,y:(r6)-
                            20792 
                            20793 ; 115  |          // fill in the number of bytes
                            20794 ; 116  |          pMetaData->dwDataBytes = g_VBRHeaderData.VBRStreamBytes;
                            20795 
P:010A 5FF000 rrrrrr  3  59320797         move    y:Fg_VBRHeaderData+6,b
P:010C 59F000 rrrrrr  3  59620798         move    y:Fg_VBRHeaderData+5,b0
P:010E 391500         2  59820799         move    #21,n1
P:010F 000000         2  60020800         nop
P:0110 044916         4  60420801         lua     (r1)+n1,r6
P:0111 000000         2  60620802         nop
P:0112 595E00         2  60820803         move    b0,y:(r6)+
P:0113 5D5600         2  61020804         move    b1,y:(r6)-
                            20805 
                            20806 ; 117  |          // Fill in the time
                            20807 ; 118  |          pMetaData->iTime = g_VBRGlobalData.VBRTotalSeconds;   
                            20808 
P:0114 4EF000 rrrrrr  3  61320810         move    y:Fg_VBRGlobalData+1,y0
P:0116 270000         2  61520811         move    #0,y1
P:0117 390F00         2  61720812         move    #15,n1
P:0118 000000         2  61920813         nop
P:0119 044916         4  62320814         lua     (r1)+n1,r6
P:011A 000000         2  62520817         nop
P:011B 4E5E00         2  62720818         move    y0,y:(r6)+
P:011C 4F5600         2  62920819         move    y1,y:(r6)-
                            20820 
                            20821 ; 119  |        }
                            20822 ; 120  |        // increment the StartPosition so we're positioned after the Xing or VBR Headers.
                            20823 ; 121  |        pMetaData->dwStartPos += wOffset;
                            20824 
P:011D 3E1100         2  63120826 L23:    move    #17,n6
P:011E 77F400 FFFFFD  3  63420827         move    #-3,n7
P:0120 000000         2  63620828         nop
P:0121 6EEF00         4  64020829         move    y:(r7+n7),r6
P:0122 000000         2  64220830         nop
P:0123 204E00         2  64420831         move    (r6)+n6
P:0124 4CDE00         2  64620835         move    y:(r6)+,x0
P:0125 4DD600         2  64820836         move    y:(r6)-,x1
P:0126 77F400 FFFF5F  3  65120837         move    #-161,n7
P:0128 000000         2  65320838         nop
P:0129 59EF00         4  65720839         move    y:(r7+n7),b0
P:012A 2D0000         2  65920840         move    #0,b1
P:012B 200028         2  66120841         add     x,b
P:012C 595E00         2  66320842         move    b0,y:(r6)+
P:012D 5D5600         2  66520843         move    b1,y:(r6)-
                            20844 
                            20845 ; 122  |        fseek(iHandle,(uPosition+wOffset),SEEK_SET);
                            20846 
P:012E 58EF00         4  66920848         move    y:(r7+n7),a0
P:012F 2C0000         2  67120849         move    #0,a1
P:0130 2A0000         2  67320850         move    #0,a2
P:0131 77F400 FFFFFE  3  67620851         move    #-2,n7
P:0133 205F00         2  67820852         move    (r7)+
P:0134 4FEF00         4  68220854         move    y:(r7+n7),y1
P:0135 205700         2  68420855         move    (r7)-
P:0136 4EEF00         4  68820857         move    y:(r7+n7),y0
P:0137 200030         2  69020858         add     y,a
P:0138 77F400 FFFFFC  3  69320861         move    #-4,n7
P:013A 000000         2  69520862         nop
P:013B 5FEF00         4  69920863         move    y:(r7+n7),b
P:013C 44F400 FFFFFF  3  70220864         move    #>-1,x0
P:013E 0BF080 rrrrrr  6  70820865         jsr     Ffseek
                            20870 
                            20871 ; 123  |    }
                            20872 ; 124  |    return SUCCESS;
                            20873 
P:0140 200013         2  71020875 L24:    clr     a   
P:0141 218E00         2  71220876         move    a1,a
                            20877 
                            20878 ; 125  |}
                            20879 
P:0142 77F400 FFFF5E  3  71520881         move    #-162,n7
P:0144 000000         2  71720882         nop
P:0145 05EF7C         4  72120883         movec   y:(r7+n7),ssh
P:0146 204F00         2  72320885         move    (r7)+n7
P:0147 00000C         4  72720887         rts
                            20889 
                            20890 ; 126  |
                            20891 ; 127  |///////////////////////////////////////////////////////////////////////////////
                            20892 ; 128  |//> Name:        GetXingHeader
                            20893 ; 129  |//
                            20894 ; 130  |//  Type:        Function
                            20895 ; 131  |//
                            20896 ; 132  |//  Description: Used to check for Xing header at beginning of file and extract
                            20897 ; 133  |//               meta-data if found. 
                            20898 ; 134  |//
                            20899 ; 135  |//  Inputs:      XHEADDATA *X  Pointer to Xing header data structure to be filled in
                            20900 ; 136  |//               *buf          Pointer to packed buffer containing file read contents (to search)
                            20901 ; 137  |//               *pOffset      Number of bytes from beginning of file to end of Xing header.
                            20902 ; 138  |//
                            20903 ; 139  |//  Outputs:     Returns SUCCESS if Xing header found, ERROR if not.
                            20904 ; 140  |//
                            20905 ; 141  |//  Notes: Bytes - description.
                            20906 ; 142  |// 4   Xing
                            20907 ; 143  |// 4   flags
                            20908 ; 144  |// 4   frames
                            20909 ; 145  |// 4   bytes
                            20910 ; 146  |// 100 toc
                            20911 ; 147  |// 
                            20912 ; 148  |//<
                            20913 ; 149  |/////////////////////////////////////////////////////////////////////////////////
                            20914 ; 150  |INT _reentrant GetXingHeader(VBR_HEADER_DATA * VbrHeader, _packed BYTE *buf, WORD * pOffset)
                            20915 ; 151  |{
                            20916 
                            20918 
Y:0000                      20919         org     y,".yconstvbr",const:
Y:0000 00AC44 00BB80        20920 L26:    dc      $00ac44,$00bb80,$007d00,$01869f
       007D00 01869F              
                            20921 
P:0148                      20922         org     p,".ptextvbr":
                            20928 FGetXingHeader:
P:0148 055F7C         2  72920929         movec   ssh,y:(r7)+
P:0149 77F400 00019F  3  73220932         move    #415,n7
P:014B 000000         2  73420933         nop
P:014C 204F00         2  73620934         move    (r7)+n7
                            20958 
                            20959 ; 152  |    BYTE btVBRUnpack[VBR_BYTES_TO_READ];  // Careful - not much room on stack.
                            20960 ; 153  |    BYTE i;
                            20961 ; 154  |    INT iXingPtr=0;
                            20962 ; 155  |    INT head_flags;
                            20963 ; 156  |    INT h_id, h_mode, h_sr_index;
                            20964 ; 157  |    WORD sr_table[4] = { 44100, 48000, 32000, 99999 };
                            20965 
P:014D 77F400 FFFFF6  3  73920967         move    #-10,n7
P:014F 000000         2  74120968         nop
P:0150 696F00         4  74520969         move    r1,y:(r7+n7)
P:0151 77F400 FFFFF5  3  74820972         move    #-11,n7
P:0153 000000         2  75020973         nop
P:0154 686F00         4  75420974         move    r0,y:(r7+n7)
P:0155 63F400 rrrrrr  3  75720977         move    #L26,r3
P:0157 77F400 FFFE61  3  76020978         move    #-415,n7
P:0159 000000         2  76220979         nop
P:015A 044F11         4  76620980         lua     (r7)+n7,r1
P:015B 060480 rrrrrr  6  77220981         do      #4,L113
P:015D 59DB00         2  77420983         move    y:(r3)+,b0
P:015E 595900         2  77620984         move    b0,y:(r1)+
                         (4)20985 L113:
                            20990 
                            20991 ; 158  |    DWORD  dwPreviousByteCount=0, dwCurrentByteCount;
                            20992 
P:015F 270000         2  77820994         move    #0,y1
P:0160 260000         2  78020995         move    #0,y0
P:0161 77F400 FFFFF7  3  78320997         move    #-9,n7
P:0163 205F00         2  78520998         move    (r7)+
P:0164 4F6F00         4  78921000         move    y1,y:(r7+n7)
P:0165 205700         2  79121001         move    (r7)-
P:0166 4E6F00         4  79521003         move    y0,y:(r7+n7)
                            21012 
                            21013 ; 159  |    WORD   wLookup256,wTemp;
                            21014 ; 160  |
                            21015 ; 161  |    // unpack first XING_BYTES_TO_READ bytes
                            21016 ; 162  |    unpack_data(buf,btVBRUnpack,XING_BYTES_TO_READ);
                            21017 
P:0167 77F400 FFFE65  3  79821019         move    #-411,n7
P:0169 000000         2  80021020         nop
P:016A 044F1B         4  80421021         lua     (r7)+n7,n3
P:016B 229000         2  80621022         move    r4,r0
P:016C 237400         2  80821023         move    n3,r4
P:016D 56F400 00009C  3  81121024         move    #>156,a
P:016F 0BF080 rrrrrr  6  81721025         jsr     unpack_data
                            21029 
                            21030 ; 163  |
                            21031 ; 164  |    // get selected MPEG header data
                            21032 ; 165  |    h_id       = (btVBRUnpack[1] >> 3) & 3;
                            21033 
P:0171 46F400 000003  3  82021035         move    #>3,y0
P:0173 77F400 FFFE66  3  82321036         move    #-410,n7
P:0175 000000         2  82521037         nop
P:0176 4FEF00         4  82921038         move    y:(r7+n7),y1
P:0177 0103C0         2  83121039         mpy     y1,#3,a
P:0178 200056         2  83321040         and     y0,a
                            21042 
                            21043 ; 166  |    h_sr_index = (btVBRUnpack[2] >> 2) & 3;
                            21044 
P:0179 45F400 000002  3  83621046         move    #>2,x1
P:017B 77F400 FFFE67  3  83921047         move    #-409,n7
P:017D 000000         2  84121048         nop
P:017E 5FEF00         4  84521049         move    y:(r7+n7),b
P:017F 20002B         2  84721050         lsr     b
P:0180 20002B         2  84921051         lsr     b
P:0181 20005E         2  85121052         and     y0,b
P:0182 77F400 FFFFF9  3  85421053         move    #-7,n7
P:0184 000000         2  85621054         nop
P:0185 5D6F00         4  86021055         move    b1,y:(r7+n7)
                            21057 
                            21058 ; 167  |    h_mode     = (btVBRUnpack[3] >> 6) & 3;
                            21059 
P:0186 77F400 FFFE68  3  86321061         move    #-408,n7
P:0188 000000         2  86521062         nop
P:0189 4FEF00         4  86921063         move    y:(r7+n7),y1
P:018A 0106C8         2  87121064         mpy     y1,#6,b
P:018B 20005E         2  87321065         and     y0,b
                            21067 
                            21068 ; 168  |
                            21069 ; 169  |    // determine offset of header
                            21070 ; 170  |    if( h_id == 3)
                            21071 
P:018C 218E00         2  87521073         move    a1,a
P:018D 200055         2  87721074         cmp     y0,a
P:018E 0AF0A2 rrrrrr  6  88321076         jne     L85
                            21077 
                            21078 ; 171  |
                            21079 ; 172  |    {        // mpeg1
                            21080 ; 173  |      if( h_mode != 3 ) 
                            21081 
P:0190 21AF00         2  88521083         move    b1,b
P:0191 20005D         2  88721084         cmp     y0,b
P:0192 0AF0AA rrrrrr  6  89321086         jeq     L86
                            21087 
                            21088 ; 174  |        iXingPtr+=(32+4);
                            21089 
P:0194 47F400 000024  3  89621091         move    #>36,y1
P:0196 0AF080 rrrrrr  6  90221093         jmp     L89
                            21094 
                            21095 ; 175  |      else
                            21096 ; 176  |        iXingPtr+=(17+4);
                            21097 ; 177  |    }
                            21098 ; 178  |    else
                            21099 ; 179  |    {      // mpeg2
                            21100 ; 180  |      if( h_mode != 3 )
                            21101 
P:0198 21AF00         2  90421103 L85:    move    b1,b
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  82

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0199 20005D         2  90621104         cmp     y0,b
P:019A 0AF0AA rrrrrr  6  91221105         jeq     L87
                            21106 
                            21107 ; 181  |        iXingPtr+=(17+4);
                            21108 
P:019C 47F400 000015  3  91521110 L86:    move    #>21,y1
P:019E 0AF080 rrrrrr  6  92121111         jmp     L89
                            21112 
                            21113 ; 182  |      else
                            21114 ; 183  |        iXingPtr+=(9+4);
                            21115 
P:01A0 47F400 00000D  3  92421117 L87:    move    #>13,y1
                            21118 
                            21119 ; 184  |    }
                            21120 ; 185  |
                            21121 ; 186  |    // look for header title "Xing"
                            21122 ; 187  |    if( btVBRUnpack[iXingPtr]   != 'X' ) return ERROR;  // fail
                            21123 
P:01A2 77F400 FFFFFA  3  92721125 L89:    move    #-6,n7
P:01A4 000000         2  92921126         nop
P:01A5 4F6F00         4  93321127         move    y1,y:(r7+n7)
P:01A6 20FC00         2  93521128         move    y1,n4
P:01A7 77F400 FFFE65  3  93821131         move    #-411,n7
P:01A9 000000         2  94021132         nop
P:01AA 044F14         4  94421133         lua     (r7)+n7,r4
P:01AB 229500         2  94621134         move    r4,r5
P:01AC 044C16         4  95021135         lua     (r4)+n4,r6
P:01AD 000000         2  95221136         nop
P:01AE 5FE600         2  95421137         move    y:(r6),b
P:01AF 47F400 000058  3  95721138         move    #>88,y1
P:01B1 20007D         2  95921139         cmp     y1,b
P:01B2 0AF0A2 rrrrrr  6  96521140         jne     L92
                            21141 
                            21142 ; 188  |    if( btVBRUnpack[iXingPtr+1] != 'i' ) return ERROR;  // header not found
                            21143 
P:01B4 77F400 FFFE66  3  96821145         move    #-410,n7
P:01B6 000000         2  97021146         nop
P:01B7 044F1D         4  97421147         lua     (r7)+n7,n5
P:01B8 23B400         2  97621148         move    n5,r4
P:01B9 000000         2  97821149         nop
P:01BA 044C16         4  98221150         lua     (r4)+n4,r6
P:01BB 000000         2  98421151         nop
P:01BC 5FE600         2  98621152         move    y:(r6),b
P:01BD 44F400 000069  3  98921153         move    #>105,x0
P:01BF 20004D         2  99121154         cmp     x0,b
P:01C0 0AF0A2 rrrrrr  6  99721155         jne     L92
                            21156 
                            21157 ; 189  |    if( btVBRUnpack[iXingPtr+2] != 'n' ) return ERROR;
                            21158 
P:01C2 77F400 FFFE67  3 100021160         move    #-409,n7
P:01C4 000000         2 100221161         nop
P:01C5 044F16         4 100621162         lua     (r7)+n7,r6
P:01C6 239E00         2 100821163         move    n4,n6
P:01C7 000000         2 101021164         nop
P:01C8 204E00         2 101221165         move    (r6)+n6
P:01C9 5FE600         2 101421166         move    y:(r6),b
P:01CA 44F400 00006E  3 101721167         move    #>110,x0
P:01CC 20004D         2 101921168         cmp     x0,b
P:01CD 0AF0A2 rrrrrr  6 102521169         jne     L92
                            21170 
                            21171 ; 190  |    if( btVBRUnpack[iXingPtr+3] != 'g' ) return ERROR;
                            21172 
P:01CF 77F400 FFFE68  3 102821174         move    #-408,n7
P:01D1 000000         2 103021175         nop
P:01D2 044F14         4 103421176         lua     (r7)+n7,r4
P:01D3 000000         2 103621177         nop
P:01D4 044C16         4 104021178         lua     (r4)+n4,r6
P:01D5 000000         2 104221179         nop
P:01D6 5FE600         2 104421180         move    y:(r6),b
P:01D7 44F400 000067  3 104721181         move    #>103,x0
P:01D9 20004D         2 104921182         cmp     x0,b
P:01DA 0AF0AA rrrrrr  6 105521183         jeq     L93
P:01DC 56F400 FFFFFF  3 105821184 L92:    move    #>-1,a
P:01DE 0AF080 rrrrrr  6 106421185         jmp     L109
                            21186 
                            21187 ; 191  |
                            21188 ; 192  |    // if we get this far, we have a Xing header
                            21189 ; 193  |    // extract the info from it
                            21190 ; 194  |    //  buf+=iXingPtr/3;
                            21191 ; 195  |
                            21192 ; 196  |    VbrHeader->VBRSampleRate = sr_table[h_sr_index];
                            21193 
                            21195 L93:
P:01E0 77F400 FFFE61  3 106721197         move    #-415,n7
P:01E2 000000         2 106921198         nop
P:01E3 044F16         4 107321199         lua     (r7)+n7,r6
P:01E4 77F400 FFFFF9  3 107621200         move    #-7,n7
P:01E6 000000         2 107821201         nop
P:01E7 4CEF00         4 108221202         move    y:(r7+n7),x0
P:01E8 209E00         2 108421203         move    x0,n6
P:01E9 000000         2 108621204         nop
P:01EA 204E00         2 108821205         move    (r6)+n6
P:01EB 5FE600         2 109021206         move    y:(r6),b
P:01EC 77F400 FFFFF5  3 109321207         move    #-11,n7
P:01EE 000000         2 109521208         nop
P:01EF 6CEF00         4 109921209         move    y:(r7+n7),r4
P:01F0 000000         2 110121210         nop
P:01F1 045C16         4 110521211         lua     (r4)+,r6
P:01F2 000000         2 110721214         nop
P:01F3 5D6600         2 110921215         move    b1,y:(r6)
                            21216 
                            21217 ; 197  |    if( h_id == 0 ) VbrHeader->VBRSampleRate >>= 2;
                            21218 
P:01F4 200003         2 111121220         tst     a
P:01F5 0AF0A2 rrrrrr  6 111721221         jne     L94
P:01F7 20002B         2 111921222         lsr     b
P:01F8 20002B         2 112121223         lsr     b
P:01F9 5D6600         2 112321224         move    b1,y:(r6)
P:01FA 0AF080 rrrrrr  6 112921225         jmp     L96
                            21226 
                            21227 ; 198  |    else if( h_id == 2 ) VbrHeader->VBRSampleRate >>= 1;
                            21228 
P:01FC 200065         2 113121230 L94:    cmp     x1,a
P:01FD 0AF0A2 rrrrrr  6 113721231         jne     L96
P:01FF 5FE600         2 113921232         move    y:(r6),b
P:0200 20002B         2 114121233         lsr     b
P:0201 5D6600         2 114321234         move    b1,y:(r6)
                            21235 
                            21236 ; 199  |    // unpack next 12 bytes (4 flags bytes, 4 frames bytes (if exist), 4 bytes bytes (if exist))
                            21237 ; 200  |    //  unpack_data(buf,btXingUnpack,12);
                            21238 ; 201  |
                            21239 ; 202  |    iXingPtr+=4;
                            21240 
P:0202 77F400 FFFFFB  3 114621242 L96:    move    #-5,n7
P:0204 000000         2 114821243         nop
P:0205 6E6F00         4 115221244         move    r6,y:(r7+n7)
P:0206 77F400 FFFFF5  3 115521245         move    #-11,n7
P:0208 000000         2 115721246         nop
P:0209 6C6F00         4 116121247         move    r4,y:(r7+n7)
P:020A 77F400 FFFFFA  3 116421250         move    #-6,n7
P:020C 000000         2 116621251         nop
P:020D 5FEF00         4 117021252         move    y:(r7+n7),b
P:020E 56F400 000004  3 117321253         move    #>4,a
P:0210 200018         2 117521254         add     a,b
P:0211 21AE00         2 117721257         move    b1,a
                            21260 
                            21261 ; 203  |    head_flags = ExtractI4(btVBRUnpack,iXingPtr); // get flags
                            21262 
P:0212 77F400 FFFFFC  3 118021264         move    #-4,n7
P:0214 000000         2 118221265         nop
P:0215 5C6F00         4 118621266         move    a1,y:(r7+n7)
P:0216 22B000         2 118821271         move    r5,r0
P:0217 0BF080 rrrrrr  6 119421272         jsr     FExtractI4
                            21276 
                            21277 ; 204  |    iXingPtr+=4;
                            21278 
P:0219 77F400 FFFFFC  3 119721280         move    #-4,n7
P:021B 000000         2 119921281         nop
P:021C 5FEF00         4 120321282         move    y:(r7+n7),b
P:021D 44F400 000004  3 120621283         move    #>4,x0
P:021F 200048         2 120821284         add     x0,b
P:0220 77F400 FFFFFE  3 121121287         move    #-2,n7
P:0222 000000         2 121321288         nop
P:0223 5D6F00         4 121721289         move    b1,y:(r7+n7)
                            21292 
                            21293 ; 205  |
                            21294 ; 206  |    if( head_flags & FRAMES_FLAG ) 
                            21295 
P:0224 210E00         2 121921297         move    a0,a
P:0225 77F400 FFFFFD  3 122221298         move    #-3,n7
P:0227 000000         2 122421299         nop
P:0228 5E6F00         4 122821300         move    a,y:(r7+n7)
P:0229 44F400 000001  3 123121301         move    #>1,x0
P:022B 200046         2 123321302         and     x0,a
P:022C 0AF0AA rrrrrr  6 123921305         jeq     L97
                            21306 
                            21307 ; 207  |    {
                            21308 ; 208  |      VbrHeader->VBRStreamFrames = ExtractI4(btVBRUnpack,iXingPtr);
                            21309 
P:022E 77F400 FFFFFE  3 124221311         move    #-2,n7
P:0230 000000         2 124421312         nop
P:0231 5EEF00         4 124821313         move    y:(r7+n7),a
P:0232 77F400 FFFE65  3 125121316         move    #-411,n7
P:0234 000000         2 125321317         nop
P:0235 044F10         4 125721318         lua     (r7)+n7,r0
P:0236 0BF080 rrrrrr  6 126321319         jsr     FExtractI4
P:0238 3D0300         2 126521322         move    #3,n5
P:0239 77F400 FFFFF5  3 126821323         move    #-11,n7
P:023B 000000         2 127021324         nop
P:023C 6DEF00         4 127421325         move    y:(r7+n7),r5
P:023D 000000         2 127621326         nop
P:023E 044D16         4 128021327         lua     (r5)+n5,r6
P:023F 000000         2 128221330         nop
P:0240 585E00         2 128421331         move    a0,y:(r6)+
P:0241 5C5600         2 128621332         move    a1,y:(r6)-
                            21333 
                            21334 ; 209  |      iXingPtr+=4;
                            21335 
P:0242 77F400 FFFFFE  3 128921337         move    #-2,n7
P:0244 000000         2 129121338         nop
P:0245 5FEF00         4 129521339         move    y:(r7+n7),b
P:0246 56F400 000004  3 129821340         move    #>4,a
P:0248 200018         2 130021341         add     a,b
P:0249 5D6F00         4 130421344         move    b1,y:(r7+n7)
                            21347 
                            21348 ; 210  |    }
                            21349 
P:024A 0AF080 rrrrrr  6 131021351         jmp     L98
                            21352 
                            21353 ; 211  |    else
                            21354 ; 212  |      VbrHeader->VBRStreamFrames = 0;
                            21355 
                            21357 L97:
P:024C 3C0300         2 131221360         move    #3,n4
P:024D 77F400 FFFFF5  3 131521361         move    #-11,n7
P:024F 000000         2 131721362         nop
P:0250 6CEF00         4 132121363         move    y:(r7+n7),r4
P:0251 229500         2 132321364         move    r4,r5
P:0252 044C16         4 132721365         lua     (r4)+n4,r6
P:0253 20001B         2 132921368         clr     b   
P:0254 595E00         2 133121369         move    b0,y:(r6)+
P:0255 5D5600         2 133321370         move    b1,y:(r6)-
P:0256 77F400 FFFFF5  3 133621371 L98:    move    #-11,n7
P:0258 000000         2 133821372         nop
P:0259 6D6F00         4 134221373         move    r5,y:(r7+n7)
                            21376 
                            21377 ; 213  |
                            21378 ; 214  |    if( head_flags & BYTES_FLAG )  
                            21379 
P:025A 45F400 000002  3 134521381         move    #>2,x1
P:025C 77F400 FFFFFD  3 134821382         move    #-3,n7
P:025E 000000         2 135021383         nop
P:025F 5FEF00         4 135421384         move    y:(r7+n7),b
P:0260 20006E         2 135621385         and     x1,b
P:0261 0AF0AA rrrrrr  6 136221386         jeq     L99
                            21387 
                            21388 ; 215  |    {
                            21389 ; 216  |      VbrHeader->VBRStreamBytes = ExtractI4(btVBRUnpack,iXingPtr); 
                            21390 
P:0263 77F400 FFFFFE  3 136521392         move    #-2,n7
P:0265 000000         2 136721393         nop
P:0266 5EEF00         4 137121394         move    y:(r7+n7),a
P:0267 77F400 FFFE65  3 137421397         move    #-411,n7
P:0269 000000         2 137621398         nop
P:026A 044F10         4 138021399         lua     (r7)+n7,r0
P:026B 0BF080 rrrrrr  6 138621400         jsr     FExtractI4
P:026D 3E0500         2 138821403         move    #5,n6
P:026E 77F400 FFFFF5  3 139121404         move    #-11,n7
P:0270 000000         2 139321405         nop
P:0271 6EEF00         4 139721406         move    y:(r7+n7),r6
P:0272 000000         2 139921407         nop
P:0273 204E00         2 140121408         move    (r6)+n6
P:0274 585E00         2 140321409         move    a0,y:(r6)+
P:0275 5C5600         2 140521410         move    a1,y:(r6)-
                            21411 
                            21412 ; 217  |      iXingPtr+=4;
                            21413 
P:0276 77F400 FFFFFE  3 140821415         move    #-2,n7
P:0278 000000         2 141021416         nop
P:0279 5FEF00         4 141421417         move    y:(r7+n7),b
P:027A 46F400 000004  3 141721418         move    #>4,y0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  83

M:ADDR CODE           CYCLES LINE SOURCELINE
P:027C 200058         2 141921419         add     y0,b
P:027D 5D6F00         4 142321422         move    b1,y:(r7+n7)
                            21425 
                            21426 ; 218  |    }
                            21427 ; 219  |
                            21428 ; 220  |    g_VBRGlobalData.VBRTableSize = XING_TOC_SIZE;
                            21429 
P:027E 296400         2 142521431 L99:    move    #100,b0
P:027F 597000 rrrrrr  3 142821432         move    b0,y:Fg_VBRGlobalData
                            21433 
                            21434 ; 221  |    
                            21435 ; 222  |    // Calculate the total seconds
                            21436 ; 223  |    wTemp = VbrHeader->VBRSampleRate >= 32000 ? MP3L2_3FRAME_SIZE : MP3VBR_LOW_FRAME_SIZE;
                            21437 
P:0281 77F400 FFFFFB  3 143121439         move    #-5,n7
P:0283 000000         2 143321440         nop
P:0284 6EEF00         4 143721441         move    y:(r7+n7),r6
P:0285 000000         2 143921442         nop
P:0286 5FE600         2 144121443         move    y:(r6),b
P:0287 46F400 007D00  3 144421444         move    #$7D00,y0
P:0289 045FA0         2 144621445         movec   m0,n7
P:028A 000000         2 144821446         nop
P:028B 5D6F00         4 145221447         move    b1,y:(r7+n7)
P:028C 2B0000         2 145421448         move    #0,b2
P:028D 20005D         2 145621449         cmp     y0,b
P:028E 44F400 000480  3 145921450         move    #1152,x0
P:0290 0AF0A1 rrrrrr  6 146521451         jge     L111
P:0292 44F400 000240  3 146821452         move    #576,x0
P:0294 208600         2 147021453 L111:   move    x0,y0
                            21455 
                            21456 ; 224  |    g_VBRGlobalData.VBRTotalSeconds = (WORD)(((DWORD)VbrHeader->VBRStreamFrames * 
                            21457 ; 225  |                                           wTemp) / VbrHeader->VBRSampleRate);
                            21458 
P:0295 3D0300         2 147221460         move    #3,n5
P:0296 77F400 FFFFF5  3 147521461         move    #-11,n7
P:0298 000000         2 147721462         nop
P:0299 6DEF00         4 148121463         move    y:(r7+n7),r5
P:029A 000000         2 148321464         nop
P:029B 044D16         4 148721465         lua     (r5)+n5,r6
P:029C 000000         2 148921468         nop
P:029D 4CDE00         2 149121469         move    y:(r6)+,x0
P:029E 4DD600         2 149321470         move    y:(r6)-,x1
P:029F 270000         2 149521471         move    #0,y1
P:02A0 0040F8         2 149721473         ori     #$40,mr
P:02A1 000000         2 149921474         nop
P:02A2 2000D8         2 150121475         mpy     y0,x0,b
P:02A3 2128EA         2 150321476         mac     x1,y0,b b0,a0
P:02A4 2000CA         2 150521477         mac     x0,y1,b
P:02A5 00BFB8         2 150721478         andi    #$BF,mr
P:02A6 212C00         2 150921479         move    b0,a1
P:02A7 21AA00         2 151121480         move    b1,a2
P:02A8 200022         2 151321481         asr     a
P:02A9 045FA0         2 151521482         movec   m0,n7
P:02AA 000000         2 151721483         nop
P:02AB 4EEF00         4 152121484         move    y:(r7+n7),y0
P:02AC 0BF080 rrrrrr  6 152721485         jsr     Rdiv_ululul
P:02AE 210500         2 152921486         move    a0,x1
P:02AF 4D7000 rrrrrr  3 153221487         move    x1,y:Fg_VBRGlobalData+1
                            21488 
                            21489 ; 226  |    
                            21490 ; 227  |    // Note - multiply by 128 so we can preserve two digits of accuracy.
                            21491 ; 228  |    g_VBRGlobalData.VBRDurPerBin = ((g_VBRGlobalData.VBRTotalSeconds * 128)/
                            21492 ; 229  |                                 (g_VBRGlobalData.VBRTableSize + 1));
                            21493 
P:02B1 0111F0         2 153421495         mpy     x1,#17,a
P:02B2 46F400 000001  3 153721496         move    #>1,y0
P:02B4 57F400 000064  3 154021497         move    #>100,b
P:02B6 200058         2 154221498         add     y0,b
P:02B7 210E00         2 154421499         move    a0,a
P:02B8 0BF080 rrrrrr  6 155021500         jsr     Rdiv_uiuiui
P:02BA 587000 rrrrrr  3 155321501         move    a0,y:Fg_VBRGlobalData+2
                            21502 
                            21503 ; 230  |    
                            21504 ; 231  |    // If we made it down here, we're probably OK - but need to validate table (see below).
                            21505 ; 232  |    if( head_flags & TOC_FLAG )  
                            21506 
P:02BC 77F400 FFFFFD  3 155621508         move    #-3,n7
P:02BE 000000         2 155821509         nop
P:02BF 5FEF00         4 156221510         move    y:(r7+n7),b
P:02C0 45F400 000004  3 156521511         move    #>4,x1
P:02C2 20006E         2 156721512         and     x1,b
P:02C3 0AF0AA rrrrrr  6 157321516         jeq     L107
                            21517 
                            21518 ; 233  |    {
                            21519 ; 234  |          g_wVBRSignature = 'X';
                            21520 
P:02C5 46F400 000058  3 157621522         move    #>88,y0
P:02C7 045FA0         2 157821523         movec   m0,n7
P:02C8 000000         2 158021524         nop
P:02C9 4E6F00         4 158421525         move    y0,y:(r7+n7)
                            21526 
                            21527 ; 235  |      for (i=0; i<XING_TOC_SIZE; i++) 
                            21528 
P:02CA 3E0000         2 158621530         move    #0,n6
P:02CB 66F400 rrrrrr  3 158921532         move    #Fg_wVBRTOCTable,r6
P:02CD 77F400 FFFE66  3 159221533         move    #-410,n7
P:02CF 000000         2 159421534         nop
P:02D0 044F14         4 159821535         lua     (r7)+n7,r4
P:02D1 066480 rrrrrr  6 160421536         do      #100,L112
                            21538 
                            21539 ; 236  |      {
                            21540 ; 237  |        if (i == (XING_TOC_SIZE-1)) 
                            21541 
P:02D3 23CE00         2 160621543         move    n6,a
P:02D4 57F400 000063  3 160921544         move    #>99,b
P:02D6 200005         2 161121545         cmp     b,a
P:02D7 0AF0A2 rrrrrr  6 161721546         jne     L101
                            21547 
                            21548 ; 238  |          wLookup256 = 256;
                            21549 
P:02D9 57F400 000100  3 162021551         move    #$100,b
P:02DB 0AF080 rrrrrr  6 162621553         jmp     L102
                            21554 
                            21555 ; 239  |        else
                            21556 ; 240  |          wLookup256 = btVBRUnpack[iXingPtr+i+1];
                            21557 
P:02DD 77F400 FFFFFE  3 162921559 L101:   move    #-2,n7
P:02DF 000000         2 163121560         nop
P:02E0 4EEF00         4 163521561         move    y:(r7+n7),y0
P:02E1 23CF00         2 163721562         move    n6,b
P:02E2 200058         2 163921563         add     y0,b
P:02E3 21BC00         2 164121565         move    b1,n4
P:02E4 000000         2 164321566         nop
P:02E5 044C12         4 164721567         lua     (r4)+n4,r2
P:02E6 000000         2 164921568         nop
P:02E7 5FE200         2 165121569         move    y:(r2),b
                            21571 
                            21572 ; 241  |        // 4/7/04 - Change integrity check of table.  Instead of marking a
                            21573 ; 242  |        // VBR file as invalid if the last entry is zero, mark as invalid if
                            21574 ; 243  |        // a zero is found in the first 90.  Zeros in the last 10 entries will
                            21575 ; 244  |        // will be filled with 0xFF.  We'll try to use as much of the table as
                            21576 ; 245  |        // possible.
                            21577 ; 246  |        if ((wLookup256 == 0) && (i>0))  // Check integrity of table.
                            21578 
P:02E8 2B0000         2 165321580 L102:   move    #0,b2
P:02E9 20000B         2 165521581         tst     b
P:02EA 0AF0A2 rrrrrr  6 166121582         jne     L106
P:02EC 200003         2 166321583         tst     a
P:02ED 0AF0AF rrrrrr  6 166921584         jle     L106
                            21585 
                            21586 ; 247  |        {
                            21587 ; 248  |          if (i < 90)
                            21588 
P:02EF 46F400 00005A  3 167221590         move    #>90,y0
P:02F1 200055         2 167421591         cmp     y0,a
P:02F2 0AF0A1 rrrrrr  6 168021592         jge     L103
                            21593 
                            21594 ; 249  |          {
                            21595 ; 250  |             g_wVBRSignature = 'U';      // Error in table (invalid) - Don't use Xing header
                            21596 
P:02F4 47F400 000055  3 168321598         move    #>85,y1
P:02F6 045FA0         2 168521599         movec   m0,n7
P:02F7 000000         2 168721600         nop
P:02F8 4F6F00         4 169121601         move    y1,y:(r7+n7)
                            21602 
                            21603 ; 251  |          } else
                            21604 
P:02F9 0AF080 rrrrrr  6 169721606         jmp     L106
                            21607 
                            21608 ; 252  |          {
                            21609 ; 253  |             // We'll just fill the array with 255 if a zero is found.
                            21610 ; 254  |             wLookup256 = 255;
                            21611 
P:02FB 57F400 0000FF  3 170021613 L103:   move    #>$FF,b
                            21614 
                            21615 ; 255  |          }
                            21616 ; 256  |        }
                            21617 ; 257  | 
                            21618 ; 258  |        // In order to emulate the VBRi template, we only need to store the difference
                            21619 ; 259  |        // between samples.
                            21620 ; 260  |        dwCurrentByteCount = ((( (DWORD)VbrHeader->VBRStreamBytes * (WORD)wLookup256)+128) / 256);
                            21621 
P:02FD 3D0500         2 170221623 L106:   move    #5,n5
P:02FE 000000         2 170421624         nop
P:02FF 044D13         4 170821625         lua     (r5)+n5,r3
P:0300 000000         2 171021626         nop
P:0301 4CDB00         2 171221627         move    y:(r3)+,x0
P:0302 4DD300         2 171421628         move    y:(r3)-,x1
P:0303 21A900         2 171621629         move    b1,b0
P:0304 212600         2 171821630         move    b0,y0
P:0305 270000         2 172021631         move    #0,y1
P:0306 0040F8         2 172221633         ori     #$40,mr
P:0307 000000         2 172421634         nop
P:0308 2000D0         2 172621635         mpy     y0,x0,a
P:0309 2109E2         2 172821636         mac     x1,y0,a a0,b0
P:030A 2000C2         2 173021637         mac     x0,y1,a
P:030B 00BFB8         2 173221638         andi    #$BF,mr
P:030C 210D00         2 173421639         move    a0,b1
P:030D 218B00         2 173621640         move    a1,b2
P:030E 20002A         2 173821641         asr     b
P:030F 200013         2 174021642         clr     a   
P:0310 288000         2 174221643         move    #$80,a0
P:0311 200018         2 174421644         add     a,b
P:0312 2B0000         2 174621645         move    #0,b2
P:0313 060880 rrrrrr  6 175221646         do      #8,L114
P:0315 20002A         2 175421648         asr     b
P:0316 000000         2 175621649         nop
                         (4)21650 L114:
                            21653 
                            21654 ; 261  |        g_wVBRTOCTable[i] = (WORD)((DWORD)dwCurrentByteCount - (DWORD)dwPreviousByteCount);
                            21655 
P:0317 200001         2 175821657         tfr     b,a
P:0318 77F400 FFFFF7  3 176121658         move    #-9,n7
P:031A 205F00         2 176321659         move    (r7)+
P:031B 4FEF00         4 176721661         move    y:(r7+n7),y1
P:031C 205700         2 176921662         move    (r7)-
P:031D 4EEF00         4 177321664         move    y:(r7+n7),y0
P:031E 200034         2 177521665         sub     y,a
P:031F 585E00         2 177721668         move    a0,y:(r6)+
                            21669 
                            21670 ; 262  |        dwPreviousByteCount = dwCurrentByteCount;
                            21671 
P:0320 205F00         2 177921673         move    (r7)+
P:0321 5D6F00         4 178321675         move    b1,y:(r7+n7)
P:0322 205700         2 178521676         move    (r7)-
P:0323 596F00         4 178921678         move    b0,y:(r7+n7)
P:0324 23CE00         2 179121682         move    n6,a
P:0325 57F400 000001  3 179421683         move    #>1,b
P:0327 200010         2 179621684         add     b,a
P:0328 219E00         2 179821688         move    a1,n6
                       (194)21690 L112:
                            21692 
                            21693 ; 263  |
                            21694 ; 264  |      }
                            21695 ; 265  |      iXingPtr+=XING_TOC_SIZE;
                            21696 
P:0329 77F400 FFFFFE  3 180121698         move    #-2,n7
P:032B 000000         2 180321699         nop
P:032C 5EEF00         4 180721700         move    y:(r7+n7),a
P:032D 57F400 000064  3 181021701         move    #>100,b
P:032F 200018         2 181221702         add     a,b
P:0330 5D6F00         4 181621708         move    b1,y:(r7+n7)
P:0331 045FA0         2 181821711         movec   m0,n7
P:0332 000000         2 182021712         nop
P:0333 5CEF00         4 182421713         move    y:(r7+n7),a1
P:0334 5C7000 rrrrrr  3 182721714         move    a1,y:Fg_wVBRSignature
                            21715 
                            21716 ; 266  |    }
                            21717 
P:0336 0AF080 rrrrrr  6 183321719         jmp     L108
                            21720 
                            21721 ; 267  |        else
                            21722 ; 268  |        g_wVBRSignature = 'U';
                            21723 
P:0338 47F400 000055  3 183621725 L107:   move    #>85,y1
P:033A 4F7000 rrrrrr  3 183921726         move    y1,y:Fg_wVBRSignature
                            21727 
                            21728 ; 269  |
                            21729 ; 270  |    *pOffset = iXingPtr;
                            21730 
P:033C 77F400 FFFFFE  3 184221732 L108:   move    #-2,n7
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  84

M:ADDR CODE           CYCLES LINE SOURCELINE
P:033E 000000         2 184421733         nop
P:033F 4EEF00         4 184821734         move    y:(r7+n7),y0
P:0340 77F400 FFFFF6  3 185121735         move    #-10,n7
P:0342 000000         2 185321736         nop
P:0343 6EEF00         4 185721737         move    y:(r7+n7),r6
P:0344 000000         2 185921738         nop
P:0345 4E6600         2 186121739         move    y0,y:(r6)
                            21744 
                            21745 ; 271  |
                            21746 ; 272  |    return SUCCESS;
                            21747 
P:0346 200013         2 186321749         clr     a   
                            21750 
                            21751 ; 273  |}
                            21752 
P:0347 77F400 FFFE60  3 186621754 L109:   move    #-416,n7
P:0349 000000         2 186821755         nop
P:034A 05EF7C         4 187221756         movec   y:(r7+n7),ssh
P:034B 204F00         2 187421758         move    (r7)+n7
P:034C 00000C         4 187821760         rts
                            21767 
                            21768 ; 274  |
                            21769 ; 275  |///////////////////////////////////////////////////////////////////////////////
                            21770 ; 276  |//> Name:        GetVBRiHeader
                            21771 ; 277  |//
                            21772 ; 278  |//  Type:        Function
                            21773 ; 279  |//
                            21774 ; 280  |//  Description: Used to check for VBRi header at beginning of file and extract
                            21775 ; 281  |//               meta-data if found. 
                            21776 ; 282  |//
                            21777 ; 283  |//  Inputs:      VBR_HEADER_DATA *V   Pointer to Xing header data structure to be filled in
                            21778 ; 284  |//               *buf                 Pointer to packed buffer containing file read contents 
                            21779 ; 285  |//                                    (to search)
                            21780 ; 286  |//
                            21781 ; 287  |//  Outputs:     Returns SUCCESS if VBR header found, ERROR if not.
                            21782 ; 288  |//
                            21783 ; 289  |//  Notes: 
                            21784 ; 290  |// 4    VBRI          // Recognition string.
                            21785 ; 291  |// 2    Version       // MPEG Version.
                            21786 ; 292  |// 2    Delay         // Not filled in - I'm not sure what it's purpose is.
                            21787 ; 293  |// 2    Quality       // Not filled in
                            21788 ; 294  |// 4    Stream Bytes  // Number of bytes in media stream.
                            21789 ; 295  |// 4    Stream Frames // Number of frames in media stream.
                            21790 ; 296  |// 2    Table Size    // Size of Table
                            21791 ; 297  |// 2    Table Scale   // ???
                            21792 ; 298  |// 2    Entry Bytes   // # bytes in each entry of table
                            21793 ; 299  |// 2    Entry Frames  // ???
                            21794 ; 300  |// 200  Table         // Table correlating linear space (consumed bytes) to non-linear
                            21795 ; 301  |//                    // space (Time) since this is variable bit rate.
                            21796 ; 302  |/////////////////////////////////////////////////////////////////////////////////
                            21797 ; 303  |INT _reentrant GetVBRiHeader(VBR_HEADER_DATA * VbrHeader, _packed BYTE *buf, WORD * pOffset)
                            21798 ; 304  |{
                            21799 
                            21801 
Y:0004                      21802         org     y,".yconstvbr",const:
Y:0004 00AC44 00BB80        21803 L115:   dc      $00ac44,$00bb80,$007d00,$01869f
       007D00 01869F              
                            21804 
P:034D                      21805         org     p,".ptextvbr":
                            21809 FGetVBRiHeader:
P:034D 055F7C         2 188021810         movec   ssh,y:(r7)+
P:034E 77F400 0001A0  3 188321813         move    #416,n7
P:0350 000000         2 188521814         nop
P:0351 204F00         2 188721815         move    (r7)+n7
                            21839 
                            21840 ; 305  |    BYTE btVBRUnpack[VBR_BYTES_TO_READ];  // Careful - not much room on stack.
                            21841 ; 306  |    BYTE i;
                            21842 ; 307  |    INT iVBRiPtr=0;
                            21843 ; 308  |    INT head_flags;
                            21844 ; 309  |    INT h_id, h_mode, h_sr_index;
                            21845 ; 310  |    WORD sr_table[4] = { 44100, 48000, 32000, 99999 };
                            21846 
P:0352 77F400 FFFFF5  3 189021848         move    #-11,n7
P:0354 000000         2 189221849         nop
P:0355 696F00         4 189621850         move    r1,y:(r7+n7)
P:0356 77F400 FFFFF4  3 189921853         move    #-12,n7
P:0358 000000         2 190121854         nop
P:0359 686F00         4 190521855         move    r0,y:(r7+n7)
P:035A 63F400 rrrrrr  3 190821858         move    #L115,r3
P:035C 77F400 FFFE60  3 191121859         move    #-416,n7
P:035E 000000         2 191321860         nop
P:035F 044F11         4 191721861         lua     (r7)+n7,r1
P:0360 060480 rrrrrr  6 192321862         do      #4,L171
P:0362 59DB00         2 192521864         move    y:(r3)+,b0
P:0363 595900         2 192721865         move    b0,y:(r1)+
                         (4)21866 L171:
                            21873 
                            21874 ; 311  |    WORD wTemp1, wTemp2;
                            21875 ; 312  |
                            21876 ; 313  |    // unpack bytes
                            21877 ; 314  |    unpack_data(buf, btVBRUnpack, VBR_BYTES_TO_READ);
                            21878 
P:0364 77F400 FFFE64  3 193021880         move    #-412,n7
P:0366 000000         2 193221881         nop
P:0367 044F13         4 193621882         lua     (r7)+n7,r3
P:0368 229000         2 193821883         move    r4,r0
P:0369 227400         2 194021884         move    r3,r4
P:036A 56F400 000190  3 194321885         move    #400,a
P:036C 0BF080 rrrrrr  6 194921886         jsr     unpack_data
                            21890 
                            21891 ; 315  |
                            21892 ; 316  |    // get selected MPEG header data
                            21893 ; 317  |    h_id       = (btVBRUnpack[1] >> 3) & 3;
                            21894 
P:036E 46F400 000003  3 195221896         move    #>3,y0
P:0370 77F400 FFFE65  3 195521897         move    #-411,n7
P:0372 000000         2 195721898         nop
P:0373 4FEF00         4 196121899         move    y:(r7+n7),y1
P:0374 0103C0         2 196321900         mpy     y1,#3,a
P:0375 200056         2 196521901         and     y0,a
                            21903 
                            21904 ; 318  |    h_sr_index = (btVBRUnpack[2] >> 2) & 3;
                            21905 
P:0376 47F400 000002  3 196821907         move    #>2,y1
P:0378 77F400 FFFE66  3 197121908         move    #-410,n7
P:037A 000000         2 197321909         nop
P:037B 5FEF00         4 197721910         move    y:(r7+n7),b
P:037C 20002B         2 197921911         lsr     b
P:037D 20002B         2 198121912         lsr     b
P:037E 20005E         2 198321913         and     y0,b
P:037F 77F400 FFFFF6  3 198621914         move    #-10,n7
P:0381 000000         2 198821915         nop
P:0382 5D6F00         4 199221916         move    b1,y:(r7+n7)
                            21918 
                            21919 ; 319  |    h_mode     = (btVBRUnpack[3] >> 6) & 3;
                            21920 
P:0383 77F400 FFFE67  3 199521922         move    #-409,n7
P:0385 000000         2 199721923         nop
P:0386 4DEF00         4 200121924         move    y:(r7+n7),x1
P:0387 0106F8         2 200321925         mpy     x1,#6,b
P:0388 20005E         2 200521926         and     y0,b
                            21928 
                            21929 ; 320  |
                            21930 ; 321  |    // determine offset of header
                            21931 ; 322  |    if( h_id == 3) 
                            21932 
P:0389 218E00         2 200721934         move    a1,a
P:038A 200055         2 200921935         cmp     y0,a
P:038B 0AF0A2 rrrrrr  6 201521937         jne     L152
                            21938 
                            21939 ; 323  |    {        // mpeg1
                            21940 ; 324  |      if( h_mode != 3 ) 
                            21941 
P:038D 21AF00         2 201721943         move    b1,b
P:038E 20005D         2 201921944         cmp     y0,b
P:038F 0AF0AA rrrrrr  6 202521946         jeq     L153
                            21947 
                            21948 ; 325  |        iVBRiPtr+=(32+4);
                            21949 
P:0391 44F400 000024  3 202821951         move    #>36,x0
P:0393 0AF080 rrrrrr  6 203421953         jmp     L156
                            21954 
                            21955 ; 326  |      else
                            21956 ; 327  |        iVBRiPtr+=(17+4);
                            21957 ; 328  |    }
                            21958 ; 329  |    else
                            21959 ; 330  |    {      // mpeg2
                            21960 ; 331  |      if( h_mode != 3 )
                            21961 
P:0395 21AF00         2 203621963 L152:   move    b1,b
P:0396 20005D         2 203821964         cmp     y0,b
P:0397 0AF0AA rrrrrr  6 204421965         jeq     L154
                            21966 
                            21967 ; 332  |        iVBRiPtr+=(17+4);
                            21968 
P:0399 44F400 000015  3 204721970 L153:   move    #>21,x0
P:039B 0AF080 rrrrrr  6 205321971         jmp     L156
                            21972 
                            21973 ; 333  |      else
                            21974 ; 334  |        iVBRiPtr+=(9+4);
                            21975 
P:039D 44F400 00000D  3 205621977 L154:   move    #>13,x0
                            21978 
                            21979 ; 335  |    }
                            21980 ; 336  |
                            21981 ; 337  |    // look for header title "VBRI"
                            21982 ; 338  |    if( btVBRUnpack[iVBRiPtr]   != 'V' ) return ERROR;  // fail
                            21983 
P:039F 77F400 FFFFF7  3 205921985 L156:   move    #-9,n7
P:03A1 000000         2 206121986         nop
P:03A2 4C6F00         4 206521987         move    x0,y:(r7+n7)
P:03A3 209C00         2 206721988         move    x0,n4
P:03A4 77F400 FFFE64  3 207021991         move    #-412,n7
P:03A6 000000         2 207221992         nop
P:03A7 044F14         4 207621993         lua     (r7)+n7,r4
P:03A8 229500         2 207821994         move    r4,r5
P:03A9 044C16         4 208221995         lua     (r4)+n4,r6
P:03AA 000000         2 208421996         nop
P:03AB 5FE600         2 208621997         move    y:(r6),b
P:03AC 44F400 000056  3 208921998         move    #>86,x0
P:03AE 20004D         2 209121999         cmp     x0,b
P:03AF 0AF0A2 rrrrrr  6 209722000         jne     L159
                            22001 
                            22002 ; 339  |    if( btVBRUnpack[iVBRiPtr+1] != 'B' ) return ERROR;  // header not found
                            22003 
P:03B1 77F400 FFFE65  3 210022005         move    #-411,n7
P:03B3 000000         2 210222006         nop
P:03B4 044F16         4 210622007         lua     (r7)+n7,r6
P:03B5 239E00         2 210822008         move    n4,n6
P:03B6 000000         2 211022009         nop
P:03B7 204E00         2 211222010         move    (r6)+n6
P:03B8 5FE600         2 211422011         move    y:(r6),b
P:03B9 45F400 000042  3 211722012         move    #>66,x1
P:03BB 20006D         2 211922013         cmp     x1,b
P:03BC 0AF0A2 rrrrrr  6 212522014         jne     L159
                            22015 
                            22016 ; 340  |    if( btVBRUnpack[iVBRiPtr+2] != 'R' ) return ERROR;
                            22017 
P:03BE 77F400 FFFE66  3 212822019         move    #-410,n7
P:03C0 000000         2 213022020         nop
P:03C1 044F16         4 213422021         lua     (r7)+n7,r6
P:03C2 000000         2 213622022         nop
P:03C3 204E00         2 213822023         move    (r6)+n6
P:03C4 5FE600         2 214022024         move    y:(r6),b
P:03C5 45F400 000052  3 214322025         move    #>82,x1
P:03C7 20006D         2 214522026         cmp     x1,b
P:03C8 0AF0A2 rrrrrr  6 215122027         jne     L159
                            22028 
                            22029 ; 341  |    if( btVBRUnpack[iVBRiPtr+3] != 'I' ) return ERROR;
                            22030 
P:03CA 77F400 FFFE67  3 215422032         move    #-409,n7
P:03CC 000000         2 215622033         nop
P:03CD 044F14         4 216022034         lua     (r7)+n7,r4
P:03CE 000000         2 216222035         nop
P:03CF 044C16         4 216622036         lua     (r4)+n4,r6
P:03D0 000000         2 216822037         nop
P:03D1 5FE600         2 217022038         move    y:(r6),b
P:03D2 45F400 000049  3 217322039         move    #>73,x1
P:03D4 20006D         2 217522040         cmp     x1,b
P:03D5 0AF0AA rrrrrr  6 218122041         jeq     L160
P:03D7 56F400 FFFFFF  3 218422042 L159:   move    #>-1,a
P:03D9 0AF080 rrrrrr  6 219022043         jmp     L165
                            22044 
                            22045 ; 342  |
                            22046 ; 343  |    // if we get this far, we have a VBR header
                            22047 ; 344  |    // extract the info from it
                            22048 ; 345  |
                            22049 ; 346  |    VbrHeader->VBRVersion = h_id;
                            22050 
                            22052 L160:
P:03DB 77F400 FFFFF4  3 219322054         move    #-12,n7
P:03DD 000000         2 219522055         nop
P:03DE 6CEF00         4 219922056         move    y:(r7+n7),r4
P:03DF 000000         2 220122057         nop
P:03E0 5C6400         2 220322058         move    a1,y:(r4)
                            22061 
                            22062 ; 347  |    VbrHeader->VBRSampleRate = sr_table[h_sr_index];
                            22063 
P:03E1 77F400 FFFE60  3 220622065         move    #-416,n7
P:03E3 000000         2 220822066         nop
P:03E4 044F16         4 221222067         lua     (r7)+n7,r6
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  85

M:ADDR CODE           CYCLES LINE SOURCELINE
P:03E5 77F400 FFFFF6  3 221522068         move    #-10,n7
P:03E7 000000         2 221722069         nop
P:03E8 4DEF00         4 222122070         move    y:(r7+n7),x1
P:03E9 20BE00         2 222322071         move    x1,n6
P:03EA 000000         2 222522072         nop
P:03EB 204E00         2 222722073         move    (r6)+n6
P:03EC 5FE600         2 222922074         move    y:(r6),b
P:03ED 045C16         4 223322075         lua     (r4)+,r6
P:03EE 000000         2 223522076         nop
P:03EF 5D6600         2 223722077         move    b1,y:(r6)
                            22078 
                            22079 ; 348  |    if     ( h_id == 0 ) VbrHeader->VBRSampleRate >>= 2; //divide by 4 if MPEG2.5
                            22080 
P:03F0 200003         2 223922082         tst     a
P:03F1 0AF0A2 rrrrrr  6 224522083         jne     L161
P:03F3 20002B         2 224722084         lsr     b
P:03F4 20002B         2 224922085         lsr     b
P:03F5 5D6600         2 225122086         move    b1,y:(r6)
P:03F6 0AF080 rrrrrr  6 225722087         jmp     L163
                            22088 
                            22089 ; 349  |    //else if( h_id == 1 ) ;                             //reserved
                            22090 ; 350  |    else if( h_id == 2 ) VbrHeader->VBRSampleRate >>= 1; //divide by 2 if MPEG2
                            22091 
P:03F8 200075         2 225922093 L161:   cmp     y1,a
P:03F9 0AF0A2 rrrrrr  6 226522094         jne     L163
P:03FB 5FE600         2 226722095         move    y:(r6),b
P:03FC 20002B         2 226922096         lsr     b
P:03FD 5D6600         2 227122097         move    b1,y:(r6)
                            22098 
                            22099 ; 351  |    //else if( h_id == 3 ) ;                             //divide by 1 if MPEG1, i.e. keep what was read
                            22100 ; 352  |
                            22101 ; 353  |    
                            22102 ; 354  |    // Now extract the tag information.
                            22103 ; 355  |    iVBRiPtr+=4;
                            22104 
P:03FE 77F400 FFFFF8  3 227422106 L163:   move    #-8,n7
P:0400 000000         2 227622107         nop
P:0401 6E6F00         4 228022108         move    r6,y:(r7+n7)
P:0402 77F400 FFFFF4  3 228322109         move    #-12,n7
P:0404 000000         2 228522110         nop
P:0405 6C6F00         4 228922111         move    r4,y:(r7+n7)
P:0406 77F400 FFFFF7  3 229222114         move    #-9,n7
P:0408 000000         2 229422115         nop
P:0409 5EEF00         4 229822116         move    y:(r7+n7),a
P:040A 57F400 000004  3 230122117         move    #>4,b
P:040C 200018         2 230322118         add     a,b
P:040D 21AE00         2 230522123         move    b1,a
                            22126 
                            22127 ; 356  |    VbrHeader->VBRVersion = ExtractIVar(btVBRUnpack,iVBRiPtr,2); // get Version
                            22128 
P:040E 22B000         2 230722130         move    r5,r0
P:040F 57F400 000002  3 231022131         move    #>2,b
P:0411 77F400 FFFFF9  3 231322132         move    #-7,n7
P:0413 000000         2 231522133         nop
P:0414 5C6F00         4 231922134         move    a1,y:(r7+n7)
P:0415 0BF080 rrrrrr  6 232522139         jsr     FExtractIVar
P:0417 77F400 FFFFF4  3 232822142         move    #-12,n7
P:0419 000000         2 233022143         nop
P:041A 6EEF00         4 233422144         move    y:(r7+n7),r6
P:041B 000000         2 233622145         nop
P:041C 5C6600         2 233822146         move    a1,y:(r6)
                            22147 
                            22148 ; 357  |    iVBRiPtr+=6;     // Skip Delay & Quality.
                            22149 
P:041D 45F400 000006  3 234122151         move    #>6,x1
P:041F 77F400 FFFFF9  3 234422152         move    #-7,n7
P:0421 000000         2 234622153         nop
P:0422 5FEF00         4 235022154         move    y:(r7+n7),b
P:0423 200068         2 235222155         add     x1,b
P:0424 21AE00         2 235422158         move    b1,a
                            22161 
                            22162 ; 358  |    VbrHeader->VBRStreamBytes = ExtractIVar(btVBRUnpack,iVBRiPtr,3); // get Hi 3 Bytes - Stream Bytes
                            22163 
P:0425 57F400 000003  3 235722165         move    #>3,b
P:0427 77F400 FFFE64  3 236022166         move    #-412,n7
P:0429 000000         2 236222167         nop
P:042A 044F10         4 236622168         lua     (r7)+n7,r0
P:042B 77F400 FFFFF9  3 236922169         move    #-7,n7
P:042D 000000         2 237122170         nop
P:042E 5C6F00         4 237522171         move    a1,y:(r7+n7)
P:042F 0BF080 rrrrrr  6 238122176         jsr     FExtractIVar
P:0431 218800         2 238322179         move    a1,a0
P:0432 2C0000         2 238522180         move    #0,a1
P:0433 3E0500         2 238722181         move    #5,n6
P:0434 77F400 FFFFF4  3 239022182         move    #-12,n7
P:0436 000000         2 239222183         nop
P:0437 6EEF00         4 239622184         move    y:(r7+n7),r6
P:0438 000000         2 239822185         nop
P:0439 204E00         2 240022186         move    (r6)+n6
P:043A 585E00         2 240222187         move    a0,y:(r6)+
P:043B 5C5600         2 240422188         move    a1,y:(r6)-
                            22189 
                            22190 ; 359  |    VbrHeader->VBRStreamBytes <<= 8;
                            22191 
P:043C 060880 rrrrrr  6 241022193         do      #8,L172
P:043E 200032         2 241222195         asl     a
P:043F 000000         2 241422196         nop
                         (4)22197 L172:
P:0440 77F400 FFFFFA  3 241722199         move    #-6,n7
P:0442 000000         2 241922200         nop
P:0443 6E6F00         4 242322201         move    r6,y:(r7+n7)
P:0444 77F400 FFFFFB  3 242622202         move    #-5,n7
P:0446 205F00         2 242822203         move    (r7)+
P:0447 5C6F00         4 243222205         move    a1,y:(r7+n7)
P:0448 205700         2 243422206         move    (r7)-
P:0449 586F00         4 243822208         move    a0,y:(r7+n7)
P:044A 585E00         2 244022209         move    a0,y:(r6)+
P:044B 5C5600         2 244222210         move    a1,y:(r6)-
                            22211 
                            22212 ; 360  |    iVBRiPtr+=3;     // Point to Low word.
                            22213 
P:044C 46F400 000003  3 244522215         move    #>3,y0
P:044E 77F400 FFFFF9  3 244822216         move    #-7,n7
P:0450 000000         2 245022217         nop
P:0451 5FEF00         4 245422218         move    y:(r7+n7),b
P:0452 200058         2 245622219         add     y0,b
P:0453 21AE00         2 245822222         move    b1,a
                            22225 
                            22226 ; 361  |    VbrHeader->VBRStreamBytes |= ExtractIVar(btVBRUnpack,iVBRiPtr,1); // get Low Byte - Stream bytes
                            22227 
P:0454 77F400 FFFE64  3 246122229         move    #-412,n7
P:0456 000000         2 246322230         nop
P:0457 044F10         4 246722231         lua     (r7)+n7,r0
P:0458 77F400 FFFFFD  3 247022232         move    #-3,n7
P:045A 000000         2 247222233         nop
P:045B 5C6F00         4 247622234         move    a1,y:(r7+n7)
P:045C 57F400 000001  3 247922239         move    #>1,b
P:045E 0BF080 rrrrrr  6 248522240         jsr     FExtractIVar
P:0460 218600         2 248722243         move    a1,y0
P:0461 270000         2 248922244         move    #0,y1
P:0462 77F400 FFFFFB  3 249222245         move    #-5,n7
P:0464 205F00         2 249422246         move    (r7)+
P:0465 5FEF00         4 249822248         move    y:(r7+n7),b
P:0466 205700         2 250022249         move    (r7)-
P:0467 59EF00         4 250422251         move    y:(r7+n7),b0
P:0468 21A400         2 250622252         move    b1,x0
P:0469 212D00         2 250822253         move    b0,b1
P:046A 20005A         2 251022254         or      y0,b
P:046B 21A900         2 251222255         move    b1,b0
P:046C 208D00         2 251422256         move    x0,b1
P:046D 20007A         2 251622257         or      y1,b
P:046E 77F400 FFFFFA  3 251922258         move    #-6,n7
P:0470 000000         2 252122259         nop
P:0471 6EEF00         4 252522260         move    y:(r7+n7),r6
P:0472 000000         2 252722261         nop
P:0473 595E00         2 252922262         move    b0,y:(r6)+
P:0474 5D5600         2 253122263         move    b1,y:(r6)-
                            22264 
                            22265 ; 362  |    iVBRiPtr+=1;     // Point to Stream Frames.
                            22266 
P:0475 77F400 FFFFFD  3 253422268         move    #-3,n7
P:0477 000000         2 253622269         nop
P:0478 5FEF00         4 254022270         move    y:(r7+n7),b
P:0479 44F400 000001  3 254322271         move    #>1,x0
P:047B 200048         2 254522272         add     x0,b
P:047C 21AE00         2 254722275         move    b1,a
                            22278 
                            22279 ; 363  |    VbrHeader->VBRStreamFrames = ExtractIVar(btVBRUnpack,iVBRiPtr,3); // get Hi Word - Stream Frames
                            22280 
P:047D 57F400 000003  3 255022282         move    #>3,b
P:047F 77F400 FFFE64  3 255322283         move    #-412,n7
P:0481 000000         2 255522284         nop
P:0482 044F10         4 255922285         lua     (r7)+n7,r0
P:0483 77F400 FFFFF9  3 256222286         move    #-7,n7
P:0485 000000         2 256422287         nop
P:0486 5C6F00         4 256822288         move    a1,y:(r7+n7)
P:0487 0BF080 rrrrrr  6 257422293         jsr     FExtractIVar
P:0489 218800         2 257622296         move    a1,a0
P:048A 2C0000         2 257822297         move    #0,a1
P:048B 44F400 000003  3 258122298         move    #>3,x0
P:048D 3E0300         2 258322299         move    #3,n6
P:048E 77F400 FFFFF4  3 258622300         move    #-12,n7
P:0490 000000         2 258822301         nop
P:0491 6EEF00         4 259222302         move    y:(r7+n7),r6
P:0492 000000         2 259422303         nop
P:0493 204E00         2 259622304         move    (r6)+n6
P:0494 585E00         2 259822305         move    a0,y:(r6)+
P:0495 5C5600         2 260022306         move    a1,y:(r6)-
                            22307 
                            22308 ; 364  |    VbrHeader->VBRStreamFrames <<= 8;
                            22309 
P:0496 060880 rrrrrr  6 260622311         do      #8,L173
P:0498 200032         2 260822313         asl     a
P:0499 000000         2 261022314         nop
                         (4)22315 L173:
P:049A 77F400 FFFFFA  3 261322317         move    #-6,n7
P:049C 000000         2 261522318         nop
P:049D 6E6F00         4 261922319         move    r6,y:(r7+n7)
P:049E 77F400 FFFFFB  3 262222320         move    #-5,n7
P:04A0 205F00         2 262422321         move    (r7)+
P:04A1 5C6F00         4 262822323         move    a1,y:(r7+n7)
P:04A2 205700         2 263022324         move    (r7)-
P:04A3 586F00         4 263422326         move    a0,y:(r7+n7)
P:04A4 585E00         2 263622327         move    a0,y:(r6)+
P:04A5 5C5600         2 263822328         move    a1,y:(r6)-
                            22329 
                            22330 ; 365  |    iVBRiPtr+=3;     // Point to Low word.
                            22331 
P:04A6 77F400 FFFFF9  3 264122333         move    #-7,n7
P:04A8 000000         2 264322334         nop
P:04A9 5FEF00         4 264722335         move    y:(r7+n7),b
P:04AA 200048         2 264922336         add     x0,b
P:04AB 21AE00         2 265122339         move    b1,a
                            22342 
                            22343 ; 366  |    VbrHeader->VBRStreamFrames |= ExtractIVar(btVBRUnpack,iVBRiPtr,1); // get Low Word - Stream Frames
                            22344 
P:04AC 77F400 FFFE64  3 265422346         move    #-412,n7
P:04AE 000000         2 265622347         nop
P:04AF 044F10         4 266022348         lua     (r7)+n7,r0
P:04B0 77F400 FFFFFD  3 266322349         move    #-3,n7
P:04B2 000000         2 266522350         nop
P:04B3 5C6F00         4 266922351         move    a1,y:(r7+n7)
P:04B4 57F400 000001  3 267222356         move    #>1,b
P:04B6 0BF080 rrrrrr  6 267822357         jsr     FExtractIVar
P:04B8 218600         2 268022360         move    a1,y0
P:04B9 270000         2 268222361         move    #0,y1
P:04BA 77F400 FFFFFB  3 268522362         move    #-5,n7
P:04BC 205F00         2 268722363         move    (r7)+
P:04BD 5FEF00         4 269122365         move    y:(r7+n7),b
P:04BE 205700         2 269322366         move    (r7)-
P:04BF 59EF00         4 269722368         move    y:(r7+n7),b0
P:04C0 21A400         2 269922369         move    b1,x0
P:04C1 212D00         2 270122370         move    b0,b1
P:04C2 20005A         2 270322371         or      y0,b
P:04C3 21A900         2 270522372         move    b1,b0
P:04C4 208D00         2 270722373         move    x0,b1
P:04C5 20007A         2 270922374         or      y1,b
P:04C6 77F400 FFFFFA  3 271222375         move    #-6,n7
P:04C8 000000         2 271422376         nop
P:04C9 6EEF00         4 271822377         move    y:(r7+n7),r6
P:04CA 000000         2 272022378         nop
P:04CB 595E00         2 272222379         move    b0,y:(r6)+
P:04CC 5D5600         2 272422380         move    b1,y:(r6)-
                            22381 
                            22382 ; 367  |    iVBRiPtr+=1;     // Point to Table Size.
                            22383 
P:04CD 77F400 FFFFFD  3 272722385         move    #-3,n7
P:04CF 000000         2 272922386         nop
P:04D0 5FEF00         4 273322387         move    y:(r7+n7),b
P:04D1 56F400 000001  3 273622388         move    #>1,a
P:04D3 200018         2 273822389         add     a,b
P:04D4 21AE00         2 274022392         move    b1,a
                            22395 
                            22396 ; 368  |    g_VBRGlobalData.VBRTableSize = ExtractIVar(btVBRUnpack,iVBRiPtr,2); // get Table Size
                            22397 
P:04D5 77F400 FFFE64  3 274322399         move    #-412,n7
P:04D7 000000         2 274522400         nop
P:04D8 044F10         4 274922401         lua     (r7)+n7,r0
P:04D9 57F400 000002  3 275222402         move    #>2,b
P:04DB 77F400 FFFFFB  3 275522403         move    #-5,n7
P:04DD 000000         2 275722404         nop
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  86

M:ADDR CODE           CYCLES LINE SOURCELINE
P:04DE 5C6F00         4 276122405         move    a1,y:(r7+n7)
P:04DF 0BF080 rrrrrr  6 276722410         jsr     FExtractIVar
P:04E1 5C7000 rrrrrr  3 277022413         move    a1,y:Fg_VBRGlobalData
                            22414 
                            22415 ; 369  |    iVBRiPtr+=2;     // Point to Table Scale.
                            22416 
P:04E3 44F400 000002  3 277322418         move    #>2,x0
P:04E5 77F400 FFFFFB  3 277622419         move    #-5,n7
P:04E7 000000         2 277822420         nop
P:04E8 5FEF00         4 278222421         move    y:(r7+n7),b
P:04E9 200048         2 278422422         add     x0,b
P:04EA 21AE00         2 278622425         move    b1,a
                            22428 
                            22429 ; 370  |    VbrHeader->VBRTableScale = ExtractIVar(btVBRUnpack,iVBRiPtr,2); // get Table Scale
                            22430 
P:04EB 77F400 FFFE64  3 278922432         move    #-412,n7
P:04ED 000000         2 279122433         nop
P:04EE 044F10         4 279522434         lua     (r7)+n7,r0
P:04EF 200049         2 279722435         tfr     x0,b
P:04F0 77F400 FFFFFB  3 280022436         move    #-5,n7
P:04F2 000000         2 280222437         nop
P:04F3 5C6F00         4 280622438         move    a1,y:(r7+n7)
P:04F4 0BF080 rrrrrr  6 281222443         jsr     FExtractIVar
P:04F6 3E0700         2 281422446         move    #7,n6
P:04F7 77F400 FFFFF4  3 281722447         move    #-12,n7
P:04F9 000000         2 281922448         nop
P:04FA 6EEF00         4 282322449         move    y:(r7+n7),r6
P:04FB 000000         2 282522450         nop
P:04FC 204E00         2 282722451         move    (r6)+n6
P:04FD 5C6600         2 282922452         move    a1,y:(r6)
                            22453 
                            22454 ; 371  |    iVBRiPtr+=2;     // Point to Entry Bytes.
                            22455 
P:04FE 45F400 000002  3 283222457         move    #>2,x1
P:0500 77F400 FFFFFB  3 283522458         move    #-5,n7
P:0502 000000         2 283722459         nop
P:0503 5FEF00         4 284122460         move    y:(r7+n7),b
P:0504 200068         2 284322461         add     x1,b
P:0505 21AE00         2 284522464         move    b1,a
                            22467 
                            22468 ; 372  |    VbrHeader->VBREntryBytes = ExtractIVar(btVBRUnpack,iVBRiPtr,2); // get Entry Bytes
                            22469 
P:0506 77F400 FFFE64  3 284822471         move    #-412,n7
P:0508 000000         2 285022472         nop
P:0509 044F10         4 285422473         lua     (r7)+n7,r0
P:050A 200069         2 285622474         tfr     x1,b
P:050B 77F400 FFFFFB  3 285922475         move    #-5,n7
P:050D 000000         2 286122476         nop
P:050E 5C6F00         4 286522477         move    a1,y:(r7+n7)
P:050F 0BF080 rrrrrr  6 287122482         jsr     FExtractIVar
P:0511 3E0800         2 287322485         move    #8,n6
P:0512 77F400 FFFFF4  3 287622486         move    #-12,n7
P:0514 000000         2 287822487         nop
P:0515 6EEF00         4 288222488         move    y:(r7+n7),r6
P:0516 000000         2 288422489         nop
P:0517 204E00         2 288622490         move    (r6)+n6
P:0518 77F400 FFFFFC  3 288922491         move    #-4,n7
P:051A 000000         2 289122492         nop
P:051B 6E6F00         4 289522493         move    r6,y:(r7+n7)
P:051C 5C6600         2 289722494         move    a1,y:(r6)
                            22495 
                            22496 ; 373  |    iVBRiPtr+=2;     // Point to Entry Frames.
                            22497 
P:051D 56F400 000002  3 290022499         move    #>2,a
P:051F 77F400 FFFFFB  3 290322500         move    #-5,n7
P:0521 000000         2 290522501         nop
P:0522 5FEF00         4 290922502         move    y:(r7+n7),b
P:0523 200018         2 291122503         add     a,b
P:0524 21A600         2 291322506         move    b1,y0
                            22509 
                            22510 ; 374  |    VbrHeader->VBREntryFrames = ExtractIVar(btVBRUnpack,iVBRiPtr,2); // get Entry Frames
                            22511 
P:0525 77F400 FFFE64  3 291622513         move    #-412,n7
P:0527 000000         2 291822514         nop
P:0528 044F10         4 292222515         lua     (r7)+n7,r0
P:0529 200009         2 292422516         tfr     a,b
P:052A 77F400 FFFFFD  3 292722517         move    #-3,n7
P:052C 000000         2 292922518         nop
P:052D 4E6F00         4 293322519         move    y0,y:(r7+n7)
P:052E 200051         2 293522520         tfr     y0,a
P:052F 0BF080 rrrrrr  6 294122525         jsr     FExtractIVar
P:0531 3E0900         2 294322528         move    #9,n6
P:0532 77F400 FFFFF4  3 294622529         move    #-12,n7
P:0534 000000         2 294822530         nop
P:0535 6EEF00         4 295222531         move    y:(r7+n7),r6
P:0536 000000         2 295422532         nop
P:0537 204E00         2 295622533         move    (r6)+n6
P:0538 5C6600         2 295822537         move    a1,y:(r6)
                            22538 
                            22539 ; 375  |    iVBRiPtr+=2;     // Point to Entry Bytes.
                            22540 
P:0539 46F400 000002  3 296122542         move    #>2,y0
P:053B 77F400 FFFFFD  3 296422543         move    #-3,n7
P:053D 000000         2 296622544         nop
P:053E 5FEF00         4 297022545         move    y:(r7+n7),b
P:053F 200058         2 297222546         add     y0,b
P:0540 5D6F00         4 297622549         move    b1,y:(r7+n7)
                            22552 
                            22553 ; 376  |    
                            22554 ; 377  |    
                            22555 ; 378  |    g_VBRGlobalData.VBRTableSize = (g_VBRGlobalData.VBRTableSize < VBR_TOC_SIZE) ? 
                            22556 ; 379  |                                    g_VBRGlobalData.VBRTableSize : VBR_TOC_SIZE;
                            22557 
P:0541 5FF000 rrrrrr  3 297922559         move    y:Fg_VBRGlobalData,b
P:0543 46F400 0000C8  3 298222560         move    #>200,y0
P:0545 2B0000         2 298422561         move    #0,b2
P:0546 20005D         2 298622562         cmp     y0,b
P:0547 0AF0A1 rrrrrr  6 299222563         jge     L167
P:0549 77F400 FFFFFE  3 299522564         move    #-2,n7
P:054B 000000         2 299722565         nop
P:054C 5D6F00         4 300122566         move    b1,y:(r7+n7)
P:054D 0AF080 rrrrrr  6 300722567         jmp     L168
P:054F 77F400 FFFFFE  3 301022568 L167:   move    #-2,n7
P:0551 000000         2 301222569         nop
P:0552 4E6F00         4 301622570         move    y0,y:(r7+n7)
P:0553 77F400 FFFFFE  3 301922571 L168:   move    #-2,n7
P:0555 000000         2 302122572         nop
P:0556 58EF00         4 302522573         move    y:(r7+n7),a0
P:0557 587000 rrrrrr  3 302822574         move    a0,y:Fg_VBRGlobalData
                            22575 
                            22576 ; 380  |
                            22577 ; 381  |    // Calculate the total seconds
                            22578 ; 382  |    wTemp1 = VbrHeader->VBRSampleRate >= 32000 ? MP3L2_3FRAME_SIZE : MP3VBR_LOW_FRAME_SIZE;
                            22579 
P:0559 77F400 FFFFF8  3 303122581         move    #-8,n7
P:055B 000000         2 303322582         nop
P:055C 6EEF00         4 303722583         move    y:(r7+n7),r6
P:055D 000000         2 303922584         nop
P:055E 5FE600         2 304122585         move    y:(r6),b
P:055F 46F400 007D00  3 304422586         move    #$7D00,y0
P:0561 045FA0         2 304622587         movec   m0,n7
P:0562 000000         2 304822588         nop
P:0563 5D6F00         4 305222589         move    b1,y:(r7+n7)
P:0564 2B0000         2 305422590         move    #0,b2
P:0565 20005D         2 305622591         cmp     y0,b
P:0566 54F400 000480  3 305922592         move    #1152,a1
P:0568 0AF0A1 rrrrrr  6 306522593         jge     L170
P:056A 54F400 000240  3 306822594         move    #576,a1
P:056C 218600         2 307022595 L170:   move    a1,y0
                            22597 
                            22598 ; 383  |    g_VBRGlobalData.VBRTotalSeconds = (WORD)(((DWORD)VbrHeader->VBRStreamFrames * 
                            22599 ; 384  |                                           wTemp1) / VbrHeader->VBRSampleRate);
                            22600 
P:056D 77F400 FFFFFA  3 307322602         move    #-6,n7
P:056F 000000         2 307522603         nop
P:0570 6EEF00         4 307922604         move    y:(r7+n7),r6
P:0571 000000         2 308122605         nop
P:0572 4CDE00         2 308322606         move    y:(r6)+,x0
P:0573 4DD600         2 308522607         move    y:(r6)-,x1
P:0574 270000         2 308722608         move    #0,y1
P:0575 0040F8         2 308922610         ori     #$40,mr
P:0576 000000         2 309122611         nop
P:0577 2000D8         2 309322612         mpy     y0,x0,b
P:0578 2128EA         2 309522613         mac     x1,y0,b b0,a0
P:0579 2000CA         2 309722614         mac     x0,y1,b
P:057A 00BFB8         2 309922615         andi    #$BF,mr
P:057B 212C00         2 310122616         move    b0,a1
P:057C 21AA00         2 310322617         move    b1,a2
P:057D 200022         2 310522618         asr     a
P:057E 045FA0         2 310722619         movec   m0,n7
P:057F 000000         2 310922620         nop
P:0580 4EEF00         4 311322621         move    y:(r7+n7),y0
P:0581 0BF080 rrrrrr  6 311922622         jsr     Rdiv_ululul
P:0583 587000 rrrrrr  3 312222623         move    a0,y:Fg_VBRGlobalData+1
                            22624 
                            22625 ; 385  |
                            22626 ; 386  |    g_VBRGlobalData.VBRDurPerBin = ((g_VBRGlobalData.VBRTotalSeconds * 128)/
                            22627 ; 387  |                                 (g_VBRGlobalData.VBRTableSize + 1));
                            22628 
P:0585 210600         2 312422630         move    a0,y0
P:0586 0111E8         2 312622631         mpy     y0,#17,b
P:0587 212600         2 312822632         move    b0,y0
P:0588 77F400 FFFFFE  3 313122633         move    #-2,n7
P:058A 000000         2 313322634         nop
P:058B 5EEF00         4 313722635         move    y:(r7+n7),a
P:058C 57F400 000001  3 314022636         move    #>1,b
P:058E 200010         2 314222637         add     b,a
P:058F 218F00         2 314422638         move    a1,b
P:0590 200051         2 314622639         tfr     y0,a
P:0591 0BF080 rrrrrr  6 315222640         jsr     Rdiv_uiuiui
P:0593 587000 rrrrrr  3 315522641         move    a0,y:Fg_VBRGlobalData+2
                            22642 
                            22643 ; 388  |
                            22644 ; 389  |    // Retrieve the table values from the files.
                            22645 ; 390  |    for (i=0; i<g_VBRGlobalData.VBRTableSize, i<VBR_TOC_SIZE; i++) 
                            22646 
P:0595 57F400 rrrrrr  3 315822648         move    #Fg_wVBRTOCTable,b
P:0597 66F400 rrrrrr  3 316122649         move    #Fg_wVBRTOCTable+200,r6
P:0599 045FA0         2 316322650         movec   m0,n7
P:059A 000000         2 316522651         nop
P:059B 6E6F00         4 316922652         move    r6,y:(r7+n7)
P:059C 77F400 FFFFFC  3 317222653         move    #-4,n7
P:059E 000000         2 317422654         nop
P:059F 6DEF00         4 317822655         move    y:(r7+n7),r5
P:05A0 77F400 FFFFFE  3 318122656 L164:   move    #-2,n7
P:05A2 000000         2 318322657         nop
P:05A3 5D6F00         4 318722658         move    b1,y:(r7+n7)
                            22659 
                            22660 ; 391  |    {
                            22661 ; 392  |      // TBD - we should set some parameters that will alert us if the table is corrupt.
                            22662 ; 393  |      //       I have seen zero entries in a VBRI table, so that is not invalid.
                            22663 ; 394  |      g_wVBRTOCTable[i] = ExtractIVar(btVBRUnpack,iVBRiPtr,VbrHeader->VBREntryBytes); // get Data Frames.
                            22664 
P:05A4 77F400 FFFFFC  3 319022666         move    #-4,n7
P:05A6 000000         2 319222667         nop
P:05A7 6D6F00         4 319622668         move    r5,y:(r7+n7)
P:05A8 5FE500         2 319822669         move    y:(r5),b
P:05A9 77F400 FFFE64  3 320122670         move    #-412,n7
P:05AB 000000         2 320322671         nop
P:05AC 044F10         4 320722672         lua     (r7)+n7,r0
P:05AD 77F400 FFFFFD  3 321022673         move    #-3,n7
P:05AF 000000         2 321222674         nop
P:05B0 5EEF00         4 321622675         move    y:(r7+n7),a
P:05B1 0BF080 rrrrrr  6 322222678         jsr     FExtractIVar
P:05B3 77F400 FFFFFE  3 322522681         move    #-2,n7
P:05B5 000000         2 322722682         nop
P:05B6 6EEF00         4 323122683         move    y:(r7+n7),r6
P:05B7 000000         2 323322684         nop
P:05B8 5C5E00         2 323522685         move    a1,y:(r6)+
                            22686 
                            22687 ; 395  |      iVBRiPtr+=VbrHeader->VBREntryBytes;     // Increment Pointer.
                            22688 
P:05B9 77F400 FFFFFC  3 323822690         move    #-4,n7
P:05BB 000000         2 324022691         nop
P:05BC 6DEF00         4 324422692         move    y:(r7+n7),r5
P:05BD 000000         2 324622693         nop
P:05BE 4EE500         2 324822694         move    y:(r5),y0
P:05BF 77F400 FFFFFD  3 325122695         move    #-3,n7
P:05C1 000000         2 325322696         nop
P:05C2 5FEF00         4 325722697         move    y:(r7+n7),b
P:05C3 200058         2 325922698         add     y0,b
P:05C4 5D6F00         4 326322701         move    b1,y:(r7+n7)
P:05C5 22CF00         2 326522705         move    r6,b
P:05C6 045FA0         2 326722706         movec   m0,n7
P:05C7 000000         2 326922707         nop
P:05C8 5EEF00         4 327322708         move    y:(r7+n7),a
P:05C9 2A0000         2 327522709         move    #0,a2
P:05CA 20000D         2 327722710         cmp     a,b
P:05CB 0AF0A9 rrrrrr  6 328322711         jlt     L164
                            22712 
                            22713 ; 396  |    }
                            22714 ; 397  |
                            22715 ; 398  |    g_wVBRSignature = 'V';
                            22716 
P:05CD 57F400 000056  3 328622718         move    #>86,b
P:05CF 5D7000 rrrrrr  3 328922719         move    b1,y:Fg_wVBRSignature
                            22720 
                            22721 ; 399  |    *pOffset = iVBRiPtr;
                            22722 
P:05D1 77F400 FFFFFD  3 329222724         move    #-3,n7
P:05D3 000000         2 329422725         nop
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  87

M:ADDR CODE           CYCLES LINE SOURCELINE
P:05D4 4EEF00         4 329822726         move    y:(r7+n7),y0
P:05D5 77F400 FFFFF5  3 330122727         move    #-11,n7
P:05D7 000000         2 330322728         nop
P:05D8 6EEF00         4 330722729         move    y:(r7+n7),r6
P:05D9 000000         2 330922730         nop
P:05DA 4E6600         2 331122731         move    y0,y:(r6)
                            22736 
                            22737 ; 400  |    return SUCCESS;
                            22738 
P:05DB 200013         2 331322740         clr     a   
                            22741 
                            22742 ; 401  |}
                            22743 
P:05DC 77F400 FFFE5F  3 331622745 L165:   move    #-417,n7
P:05DE 000000         2 331822746         nop
P:05DF 05EF7C         4 332222747         movec   y:(r7+n7),ssh
P:05E0 204F00         2 332422749         move    (r7)+n7
P:05E1 00000C         4 332822751         rts
                            22755 
                            22756 ; 402  |
                            22757 ; 403  |////////////////////////////////////////////////////////////////////////////////
                            22758 ; 404  |//
                            22759 ; 405  |//>  Name:          ExtractI4
                            22760 ; 406  |//
                            22761 ; 407  |//   Type:          Function
                            22762 ; 408  |//
                            22763 ; 409  |//   Description:   Big endian extract for Xing finder.
                            22764 ; 410  |//
                            22765 ; 411  |//   Inputs:        Ptr to buffer containing unpacked header, offset in buffer
                            22766 ; 412  |//
                            22767 ; 413  |//   Outputs:       RETCODE dword value
                            22768 ; 414  |//
                            22769 ; 415  |//   Notes:         none
                            22770 ; 416  |//<
                            22771 ; 417  |////////////////////////////////////////////////////////////////////////////////
                            22772 ; 418  |DWORD _reentrant ExtractI4(BYTE *buf, INT i)            // stmp 6724  Change type from INT to DWORD to allow 4-byte storage
                            22773 ; 419  |{
                            22774 
                            22779 
                            22780 ; 420  |        DWORD x;                                                                        // stmp 6724  Change type from INT to DWORD to allow 4-byte storage
                            22781 ; 421  |    // big endian extract
                            22782 ; 422  |    x = buf[i];
                            22783 
                            22785 FExtractI4:
P:05E2 219800         2 333022786         move    a1,n0
P:05E3 219B00         2 333222787         move    a1,n3
P:05E4 044816         4 333622794         lua     (r0)+n0,r6
P:05E5 000000         2 333822795         nop
P:05E6 59E600         2 334022796         move    y:(r6),b0
P:05E7 2D0000         2 334222797         move    #0,b1
                            22799 
                            22800 ; 423  |    x <<= 8;
                            22801 
P:05E8 060880 rrrrrr  6 334822803         do      #8,L174
P:05EA 20003A         2 335022805         asl     b
P:05EB 000000         2 335222806         nop
                         (4)22807 L174:
                            22809 
                            22810 ; 424  |    x |= buf[i+1];
                            22811 
P:05EC 045813         4 335622813         lua     (r0)+,r3
P:05ED 000000         2 335822814         nop
P:05EE 044B16         4 336222815         lua     (r3)+n3,r6
P:05EF 000000         2 336422816         nop
P:05F0 4EE600         2 336622817         move    y:(r6),y0
P:05F1 270000         2 336822818         move    #0,y1
P:05F2 21A400         2 337022819         move    b1,x0
P:05F3 212D00         2 337222820         move    b0,b1
P:05F4 20005A         2 337422821         or      y0,b
P:05F5 21A900         2 337622822         move    b1,b0
P:05F6 208D00         2 337822823         move    x0,b1
P:05F7 20007A         2 338022824         or      y1,b
                            22825 
                            22826 ; 425  |    x <<= 8;
                            22827 
P:05F8 060880 rrrrrr  6 338622829         do      #8,L175
P:05FA 20003A         2 338822831         asl     b
P:05FB 000000         2 339022832         nop
                         (4)22833 L175:
                            22835 
                            22836 ; 426  |    x |= buf[i+2];
                            22837 
P:05FC 380200         2 339222839         move    #2,n0
P:05FD 000000         2 339422840         nop
P:05FE 044813         4 339822841         lua     (r0)+n0,r3
P:05FF 000000         2 340022842         nop
P:0600 044B16         4 340422843         lua     (r3)+n3,r6
P:0601 000000         2 340622844         nop
P:0602 4EE600         2 340822845         move    y:(r6),y0
P:0603 270000         2 341022846         move    #0,y1
P:0604 21A400         2 341222847         move    b1,x0
P:0605 212D00         2 341422848         move    b0,b1
P:0606 20005A         2 341622849         or      y0,b
P:0607 21A900         2 341822850         move    b1,b0
P:0608 208D00         2 342022851         move    x0,b1
P:0609 20007A         2 342222852         or      y1,b
                            22853 
                            22854 ; 427  |    x <<= 8;
                            22855 
P:060A 060880 rrrrrr  6 342822857         do      #8,L176
P:060C 20003A         2 343022859         asl     b
P:060D 000000         2 343222860         nop
                         (4)22861 L176:
                            22863 
                            22864 ; 428  |    x |= buf[i+3];
                            22865 
P:060E 380300         2 343422867         move    #3,n0
P:060F 000000         2 343622868         nop
P:0610 044813         4 344022869         lua     (r0)+n0,r3
P:0611 000000         2 344222870         nop
P:0612 044B16         4 344622871         lua     (r3)+n3,r6
P:0613 000000         2 344822872         nop
P:0614 4EE600         2 345022873         move    y:(r6),y0
P:0615 270000         2 345222874         move    #0,y1
P:0616 21A500         2 345422875         move    b1,x1
P:0617 212D00         2 345622876         move    b0,b1
P:0618 20005A         2 345822877         or      y0,b
P:0619 21A900         2 346022878         move    b1,b0
P:061A 20AD00         2 346222879         move    x1,b1
P:061B 20007A         2 346422880         or      y1,b
P:061C 200001         2 346622881         tfr     b,a
                            22885 
                            22886 ; 429  |
                            22887 ; 430  |    return x;
                            22888 
P:061D 2A0000         2 346822890         move    #0,a2
                            22891 
                            22892 ; 431  |}
                            22893 
P:061E 00000C         4 347222895         rts
                            22899 
                            22900 ; 432  |
                            22901 ; 433  |////////////////////////////////////////////////////////////////////////////////
                            22902 ; 434  |//
                            22903 ; 435  |//>  Name:          ExtractIVar
                            22904 ; 436  |//
                            22905 ; 437  |//   Type:          Function
                            22906 ; 438  |//
                            22907 ; 439  |//   Description:   Big endian extract for Buffer Grab.
                            22908 ; 440  |//
                            22909 ; 441  |//   Inputs:        Ptr to buffer containing unpacked header, offset in buffer,
                            22910 ; 442  |//                  Number of Bytes.
                            22911 ; 443  |//
                            22912 ; 444  |//   Outputs:       WORD value - Result of fetch.
                            22913 ; 445  |//
                            22914 ; 446  |//   Notes:         none
                            22915 ; 447  |//<
                            22916 ; 448  |////////////////////////////////////////////////////////////////////////////////
                            22917 ; 449  |WORD _reentrant ExtractIVar(BYTE *buf, INT i, BYTE iByteCount)
                            22918 ; 450  |{
                            22919 
                            22924 FExtractIVar:
                            22933 
                            22934 ; 451  |    WORD x = 0;
                            22935 
P:061F 21B600         2 347422937         move    b1,r6
P:0620 260000         2 347622940         move    #0,y0
                            22944 
                            22945 ; 452  |    BYTE iCount;
                            22946 ; 453  |
                            22947 ; 454  |    if (iByteCount > 3)
                            22948 
P:0621 22CF00         2 347822950         move    r6,b
P:0622 45F400 000003  3 348122951         move    #>3,x1
P:0624 20006D         2 348322952         cmp     x1,b
P:0625 0AF0AF rrrrrr  6 348922953         jle     L177
                            22954 
                            22955 ; 455  |    {
                            22956 ; 456  |      SystemHalt();     // Can't return more than 3 bytes.
                            22957 
                            22959 
                            22960 ; Start __asm() call number 1
                            22962  error
P:0627 000200         4 349322962     debug
                            22963 ; End   __asm() call number 1
                            22964 
                            22965 ; 457  |    }
                            22966 ; 458  |
                            22967 ; 459  |    // big endian extract
                            22968 ; 460  |    for (iCount=0; iCount<iByteCount; iCount++) 
                            22969 
P:0628 240000         2 349522971 L177:   move    #0,x0
P:0629 47F400 000001  3 349822973         move    #>1,y1
P:062B 22CF00         2 350022974         move    r6,b
P:062C 20000B         2 350222975         tst     b
P:062D 0AF0AA rrrrrr  6 350822976         jeq     L181
P:062F 06CD00 rrrrrr  6 351422977         do      b1,L181
                            22981 
                            22982 ; 461  |    {
                            22983 ; 462  |      x <<= 8;
                            22984 
P:0631 0110E8         2 351622986         mpy     y0,#16,b
P:0632 212500         2 351822990         move    b0,x1
                            22993 
                            22994 ; 463  |      x |= buf[i+iCount];
                            22995 
P:0633 218F00         2 352022997         move    a1,b
P:0634 200048         2 352222998         add     x0,b
P:0635 21B800         2 352422999         move    b1,n0
P:0636 000000         2 352623000         nop
P:0637 044816         4 353023001         lua     (r0)+n0,r6
P:0638 000000         2 353223002         nop
P:0639 4EE600         2 353423003         move    y:(r6),y0
P:063A 20AD00         2 353623004         move    x1,b1
P:063B 20005A         2 353823005         or      y0,b
P:063C 21A600         2 354023008         move    b1,y0
P:063D 200049         2 354223012         tfr     x0,b
P:063E 200078         2 354423013         add     y1,b
P:063F 21A400         2 354623017         move    b1,x0
                        (32)23019 L181:
                            23021 
                            23022 ; 464  |    }
                            23023 ; 465  |
                            23024 ; 466  |    return x;
                            23025 
P:0640 200051         2 354823027         tfr     y0,a
                            23031 
                            23032 ; 467  |}
                            23033 
P:0641 00000C         4 355223035         rts
                            23040 
                            23041 ; 468  |///////////////////////////////////////////////////////////////////////////////
                            23042 ; 469  |//> Name:        CalculateCurrentTimeVBR
                            23043 ; 470  |//
                            23044 ; 471  |//  Type:        Function
                            23045 ; 472  |//
                            23046 ; 473  |//  Description: Given a consumed byte count, interpolate where we are in
                            23047 ; 474  |//               time using the VBR lookup table - for use when playing VBR files. 
                            23048 ; 475  |//
                            23049 ; 476  |//  Inputs:      NONE
                            23050 ; 477  |//
                            23051 ; 478  |//  Outputs:     NONE
                            23052 ; 479  |//
                            23053 ; 480  |//  Notes: 
                            23054 ; 481  |//              1)  We can have up to 200 entries.
                            23055 ; 482  |//              2)  Although not used here, compiling here then copying to
                            23056 ; 483  |//                  decoder_overlay.asm eases changes.
                            23057 ; 484  |/////////////////////////////////////////////////////////////////////////////////
                            23058 ; 485  |#if (0)
                            23059 ; 486  |void _reentrant CalculateCurrentTimeVBR(void)
                            23060 ; 487  |{
                            23061 ; 488  |  BYTE  i=0;
                            23062 ; 489  |  WORD  wRoundError;
                            23063 ; 490  |  WORD  wCurrentSecondsx128=0;
                            23064 ; 491  |  WORD  wTemp;
                            23065 ; 492  |  DWORD  dwCurrentBytePointer = ((DWORD)g_wSongByteTotalConsumedHigh<<24) + 
                            23066 ; 493  |                                g_wSongByteTotalConsumedLow;
                            23067 ; 494  |  DWORD  dwAccumulatedBytes=0;
                            23068 ; 495  |  WORD  Subtraction;
                            23069 ; 496  |  
                            23070 ; 497  |  // loop while accumulating bytes until we exceed CurrentPosition in file or at end of table.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  88

M:ADDR CODE           CYCLES LINE SOURCELINE
                            23071 ; 498  |  while (((DWORD)dwCurrentBytePointer >= (DWORD)dwAccumulatedBytes) && (i<g_VBRGlobalData.VBRTableSize))
                            23072 ; 499  |  {
                            23073 ; 500  |    dwAccumulatedBytes += g_wVBRTOCTable[i++];
                            23074 ; 501  |    wCurrentSecondsx128 += g_VBRGlobalData.VBRDurPerBin;
                            23075 ; 502  |  }
                            23076 ; 503  |
                            23077 ; 504  |  // Get the previous bin's value which is differential bytes between bin[i-1] and bin[i];
                            23078 ; 505  |  wTemp = g_wVBRTOCTable[i-1];
                            23079 ; 506  |
                            23080 ; 507  |  // Calculate the time to subtract off by interpolating between bins.  Multiply by duration per
                            23081 ; 508  |  // bin to estimate where we are.
                            23082 ; 509  |  wRoundError = (wTemp >> 1);
                            23083 ; 510  |  Subtraction = (WORD)(dwAccumulatedBytes - dwCurrentBytePointer);
                            23084 ; 511  |  Subtraction = ((g_VBRGlobalData.VBRDurPerBin * Subtraction)
                            23085 ; 512  |                     + wRoundError) / wTemp;
                            23086 ; 513  |
                            23087 ; 514  |  // Subtract off the interpolated difference.
                            23088 ; 515  |  wCurrentSecondsx128 -= Subtraction;
                            23089 ; 516  |
                            23090 ; 517  |  g_wAccumulatedSecs = wCurrentSecondsx128/128;
                            23091 ; 518  | 
                            23092 ; 519  |}
                            23093 ; 520  |#endif
                            23094 ; 521  |
                            23095 ; 522  |
                            23096 ; 523  |///////////////////////////////////////////////////////////////////////////////
                            23097 ; 524  |//> Name:        GetMp3FrameInfo
                            23098 ; 525  |//
                            23099 ; 526  |//  Type:        Function
                            23100 ; 527  |//
                            23101 ; 528  |//  Description: Used to find the Mp3 frame (searches for sync bytes -- 11 bits set to 1)
                            23102 ; 529  |//               Also looks through consecutive frames for changing bitrates and sets VBR to be true
                            23103 ; 530  |//               bitrates are indeed changing.
                            23104 ; 531  |//
                            23105 ; 532  |//  Inputs:      File handle, MetaData struct
                            23106 ; 533  |//  Outputs:     0 if Success, Error Code if Failure
                            23107 ; 534  |//
                            23108 ; 535  |//  Notes:       If frame is found, fills in the following in the meta-data struct:
                            23109 ; 536  |//                 wSampRate, wBitRate, iTime (if no Xing header), bVBR
                            23110 ; 537  |//               Currently: A frame is considered to have been found if the following criteria
                            23111 ; 538  |//               are met:
                            23112 ; 539  |//                   1. The 11 sync bits are found (11 ones in a row)  -- (ExtractMp3Frame does this)
                            23113 ; 540  |//                             ****AND****
                            23114 ; 541  |//                   2. The bitrate is NOT equal to 4 ones in a row (not allowed)  -- (ExtractMp3Frame does this)
                            23115 ; 542  |//                             ****AND****
                            23116 ; 543  |//                   3. Two frames in a row are found and critical values match between them
                            23117 ; 544  |//<
                            23118 ; 545  |/////////////////////////////////////////////////////////////////////////////////
                            23119 ; 546  |RETCODE _reentrant GetMp3FrameInfo(FILE_META_DATA * MetaData, INT iHandle)
                            23120 ; 547  |{
                            23121 
                            23126 FGetMp3FrameInfo:
P:0642 055F7C         2 355423127         movec   ssh,y:(r7)+
P:0643 3F2200         2 355623130         move    #34,n7
P:0644 000000         2 355823131         nop
P:0645 204F00         2 356023132         move    (r7)+n7
                            23150 
                            23151 ; 548  |    WORD wFrameBufferPacked[FRAME_HEADER_PACKED];
                            23152 ; 549  |    BYTE btFrameUnpack[FRAME_HEADER_SIZE];
                            23153 ; 550  |    INT  iExtract=NOERROR,i;
                            23154 ; 551  |    BOOL bFrameFound=FALSE, bVBR=0, bFirstFrameFound=FALSE;
                            23155 
P:0646 77F400 FFFFF7  3 356323157         move    #-9,n7
P:0648 000000         2 356523158         nop
P:0649 5C6F00         4 356923159         move    a1,y:(r7+n7)
P:064A 77F400 FFFFF6  3 357223162         move    #-10,n7
P:064C 000000         2 357423163         nop
P:064D 686F00         4 357823164         move    r0,y:(r7+n7)
P:064E 260000         2 358023167         move    #0,y0
P:064F 270000         2 358223168         move    #0,y1
P:0650 77F400 FFFFF8  3 358523170         move    #-8,n7
P:0652 000000         2 358723171         nop
P:0653 4F6F00         4 359123172         move    y1,y:(r7+n7)
P:0654 77F400 FFFFF9  3 359423177         move    #-7,n7
P:0656 000000         2 359623178         nop
P:0657 4E6F00         4 360023179         move    y0,y:(r7+n7)
                            23182 
                            23183 ; 552  |    WORD  wBitRate=0, wSampRate=0;
                            23184 
P:0658 77F400 FFFFE6  3 360323186         move    #-26,n7
P:065A 000000         2 360523187         nop
P:065B 4E6F00         4 360923188         move    y0,y:(r7+n7)
P:065C 77F400 FFFFE5  3 361223190         move    #-27,n7
P:065E 000000         2 361423191         nop
P:065F 4E6F00         4 361823192         move    y0,y:(r7+n7)
                            23194 
                            23195 ; 553  |    WORD  wBitRateTemp=0, wSampRateTemp=0;
                            23196 
P:0660 77F400 FFFFE4  3 362123198         move    #-28,n7
P:0662 000000         2 362323199         nop
P:0663 4E6F00         4 362723200         move    y0,y:(r7+n7)
P:0664 77F400 FFFFE3  3 363023202         move    #-29,n7
P:0666 000000         2 363223203         nop
P:0667 4E6F00         4 363623204         move    y0,y:(r7+n7)
                            23213 
                            23214 ; 554  |    WORD  wFrameLengthInBytes;
                            23215 ; 555  |    BYTE  btBitRateTemp,btPaddingBitTemp;
                            23216 ; 556  |    DWORD dwStartPosOffset=0;
                            23217 
P:0668 20001B         2 363823219         clr     b   
                            23223 
                            23224 ; 557  |    WORD  wByteCountWithoutSync=0;
                            23225 
P:0669 77F400 FFFFFC  3 364123227         move    #-4,n7
P:066B 000000         2 364323228         nop
P:066C 4E6F00         4 364723229         move    y0,y:(r7+n7)
                            23236 
                            23237 ; 558  |    volatile BYTE  btMPEGVer,btBitRate,btSampRate,btPaddingBit;
                            23238 ; 559  |    volatile INT   iLayer=0;
                            23239 
P:066D 77F400 FFFFDE  3 365023241         move    #-34,n7
P:066F 000000         2 365223242         nop
P:0670 4E6F00         4 365623243         move    y0,y:(r7+n7)
                            23244 
                            23245 ; 560  |
                            23246 ; 561  |    // Search through file until sync is found
                            23247 ; 562  |    while (!bFrameFound)
                            23248 ; 563  |    {
                            23249 ; 564  |      while (!bFirstFrameFound)
                            23250 
P:0671 0AF080 rrrrrr  6 366223252 L317:   jmp     L322
                            23253 
                            23254 ; 565  |      {
                            23255 ; 566  |        // Reset to beginning of file or start position offset by the current offset
                            23256 ; 567  |        if ((fseek(iHandle,MetaData->dwStartPos+dwStartPosOffset,SEEK_SET)) == ERROR)    // FileSeek to start position
                            23257 
P:0673 3B1100         2 366423259 L318:   move    #17,n3
P:0674 77F400 FFFFF6  3 366723260         move    #-10,n7
P:0676 000000         2 366923261         nop
P:0677 6BEF00         4 367323262         move    y:(r7+n7),r3
P:0678 000000         2 367523263         nop
P:0679 044B16         4 367923264         lua     (r3)+n3,r6
P:067A 77F400 FFFFFD  3 368223265         move    #-3,n7
P:067C 000000         2 368423266         nop
P:067D 6E6F00         4 368823267         move    r6,y:(r7+n7)
P:067E 205E00         2 369023268         move    (r6)+
P:067F 5ED600         2 369223269         move    y:(r6)-,a
P:0680 58E600         2 369423270         move    y:(r6),a0
P:0681 77F400 FFFFFA  3 369723271         move    #-6,n7
P:0683 205F00         2 369923272         move    (r7)+
P:0684 5D6F00         4 370323274         move    b1,y:(r7+n7)
P:0685 205700         2 370523275         move    (r7)-
P:0686 596F00         4 370923277         move    b0,y:(r7+n7)
P:0687 200010         2 371123278         add     b,a
P:0688 77F400 FFFFF7  3 371423281         move    #-9,n7
P:068A 000000         2 371623282         nop
P:068B 5FEF00         4 372023283         move    y:(r7+n7),b
P:068C 44F400 FFFFFF  3 372323286         move    #>-1,x0
P:068E 2A0000         2 372523287         move    #0,a2
P:068F 0ACC17 rrrrrr  6 373123288         jclr    #23,a1,L348
P:0691 208A00         2 373323289         move    x0,a2
P:0692 0BF080 rrrrrr  6 373923290 L348:   jsr     Ffseek
P:0694 57F400 FFFFFF  3 374223293         move    #>-1,b
P:0696 200005         2 374423294         cmp     b,a
P:0697 0AF0AA rrrrrr  6 375023295         jeq     L334
                            23296 
                            23297 ; 568  |          return(META_DATA_FILESEEK_ERROR);
                            23298 ; 569  |
                            23299 ; 570  |        // Extract frame header from file
                            23300 ; 571  |        iExtract = ExtractMp3Frame(iHandle,wFrameBufferPacked,btFrameUnpack);
                            23301 
P:0699 77F400 FFFFEB  3 375323303         move    #-21,n7
P:069B 000000         2 375523304         nop
P:069C 044F10         4 375923305         lua     (r7)+n7,r0
P:069D 77F400 FFFFE7  3 376223306         move    #-25,n7
P:069F 000000         2 376423307         nop
P:06A0 044F14         4 376823308         lua     (r7)+n7,r4
P:06A1 77F400 FFFFF7  3 377123309         move    #-9,n7
P:06A3 000000         2 377323310         nop
P:06A4 5EEF00         4 377723311         move    y:(r7+n7),a
P:06A5 0BF080 rrrrrr  6 378323314         jsr     FExtractMp3Frame
                            23318 
                            23319 ; 572  |
                            23320 ; 573  |        if(iExtract==ERROR)            // ERROR reading file
                            23321 
P:06A7 44F400 FFFFFF  3 378623323         move    #>-1,x0
P:06A9 200045         2 378823324         cmp     x0,a
P:06AA 0AF0A2 rrrrrr  6 379423325         jne     L319
                            23326 
                            23327 ; 574  |          return(META_DATA_FILEREAD_ERROR);
                            23328 
P:06AC 56F400 000201  3 379723330         move    #$201,a
P:06AE 0AF080 rrrrrr  6 380323332         jmp     L347
                            23333 
                            23334 ; 575  |
                            23335 ; 576  |        if(iExtract==SUCCESS)          // SYNC bits found (11 ones)
                            23336 
P:06B0 200003         2 380523338 L319:   tst     a
P:06B1 0AF0AA rrrrrr  6 381123339         jeq     L320
                            23340 
                            23341 ; 577  |        {
                            23342 ; 578  |          bFirstFrameFound = TRUE;
                            23343 ; 579  |          // Update start position
                            23344 ; 580  |          MetaData->dwStartPos = MetaData->dwStartPos + dwStartPosOffset;
                            23345 ; 581  |        }
                            23346 ; 582  |        else
                            23347 ; 583  |        {
                            23348 ; 584  |          // else (iExtract == seek increment value)
                            23349 ; 585  |          // Update Counters
                            23350 ; 586  |          dwStartPosOffset+= (DWORD)iExtract;
                            23351 
P:06B3 214F00         2 381323353         move    a2,b
P:06B4 218900         2 381523354         move    a1,b0
P:06B5 77F400 FFFFFA  3 381823355         move    #-6,n7
P:06B7 205F00         2 382023356         move    (r7)+
P:06B8 4DEF00         4 382423358         move    y:(r7+n7),x1
P:06B9 205700         2 382623359         move    (r7)-
P:06BA 4CEF00         4 383023361         move    y:(r7+n7),x0
P:06BB 200028         2 383223362         add     x,b
                            23367 
                            23368 ; 587  |          wByteCountWithoutSync+= (WORD)iExtract;
                            23369 
P:06BC 77F400 FFFFFC  3 383523371         move    #-4,n7
P:06BE 000000         2 383723372         nop
P:06BF 4EEF00         4 384123373         move    y:(r7+n7),y0
P:06C0 200050         2 384323374         add     y0,a
                            23379 
                            23380 ; 588  |
                            23381 ; 589  |          // Return error if Sync not found within MP3_SYNC_THRESHOLD (project.inc) bytes
                            23382 ; 590  |          // This is to prevent searching a large file that is perhaps bad.
                            23383 ; 591  |          if(wByteCountWithoutSync > MP3_SYNC_THRESHOLD)
                            23384 
P:06C1 5C6F00         4 384723386         move    a1,y:(r7+n7)
P:06C2 47F400 011170  3 385023387         move    #70000,y1
P:06C4 2A0000         2 385223388         move    #0,a2
P:06C5 200075         2 385423389         cmp     y1,a
P:06C6 0AF0AF rrrrrr  6 386023392         jle     L322
                            23393 
                            23394 ; 592  |            return(META_DATA_NOT_FOUND);
                            23395 
P:06C8 0AF080 rrrrrr  6 386623397         jmp     L343
                            23399 L320:
P:06CA 46F400 000001  3 386923402         move    #>1,y0
P:06CC 77F400 FFFFF9  3 387223405         move    #-7,n7
P:06CE 000000         2 387423406         nop
P:06CF 4E6F00         4 387823407         move    y0,y:(r7+n7)
P:06D0 77F400 FFFFFD  3 388123411         move    #-3,n7
P:06D2 000000         2 388323412         nop
P:06D3 6EEF00         4 388723413         move    y:(r7+n7),r6
P:06D4 000000         2 388923414         nop
P:06D5 205E00         2 389123415         move    (r6)+
P:06D6 5ED600         2 389323416         move    y:(r6)-,a
P:06D7 58E600         2 389523417         move    y:(r6),a0
P:06D8 77F400 FFFFFA  3 389823418         move    #-6,n7
P:06DA 205F00         2 390023419         move    (r7)+
P:06DB 5FEF00         4 390423421         move    y:(r7+n7),b
P:06DC 205700         2 390623422         move    (r7)-
P:06DD 59EF00         4 391023424         move    y:(r7+n7),b0
P:06DE 200010         2 391223425         add     b,a
P:06DF 585E00         2 391423428         move    a0,y:(r6)+
P:06E0 5C5600         2 391623429         move    a1,y:(r6)-
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  89

M:ADDR CODE           CYCLES LINE SOURCELINE
P:06E1 77F400 FFFFF9  3 391923431 L322:   move    #-7,n7
P:06E3 000000         2 392123432         nop
P:06E4 5EEF00         4 392523433         move    y:(r7+n7),a
P:06E5 2A0000         2 392723434         move    #0,a2
P:06E6 200003         2 392923435         tst     a
P:06E7 0AF0AA rrrrrr  6 393523436         jeq     L318
                            23437 
                            23438 ; 593  |        }
                            23439 ; 594  |      }
                            23440 ; 595  |
                            23441 ; 596  |      // At this point, we have found what looks like the first frame
                            23442 ; 597  |      // We are pointing to the first byte of the frame header. (Sync byte).
                            23443 ; 598  |      dwStartPosOffset = 0;                   // reset the offset
                            23444 ; 599  |
                            23445 ; 600  |      // We have found the first frame header, extract the data from it
                            23446 ; 601  |      btMPEGVer=(((btFrameUnpack[1])>>3)&(0x03));
                            23447 
P:06E9 77F400 FFFFE8  3 393823449         move    #-24,n7
P:06EB 000000         2 394023450         nop
P:06EC 5FEF00         4 394423451         move    y:(r7+n7),b
P:06ED 21AE00         2 394623452         move    b1,a
P:06EE 47F400 000003  3 394923453         move    #>3,y1
P:06F0 060380 rrrrrr  6 395523454         do      #3,L349
P:06F2 20002B         2 395723456         lsr     b
P:06F3 000000         2 395923457         nop
                         (4)23458 L349:
P:06F4 20007E         2 396123461         and     y1,b
P:06F5 77F400 FFFFE2  3 396423462         move    #-30,n7
P:06F7 000000         2 396623463         nop
P:06F8 5D6F00         4 397023464         move    b1,y:(r7+n7)
                            23465 
                            23466 ; 602  |      iLayer=(((btFrameUnpack[1])>>1)&(0x03));
                            23467 
P:06F9 45F400 000001  3 397323469         move    #>1,x1
P:06FB 200023         2 397523470         lsr     a
P:06FC 200076         2 397723471         and     y1,a
P:06FD 77F400 FFFFDE  3 398023472         move    #-34,n7
P:06FF 000000         2 398223473         nop
P:0700 5C6F00         4 398623474         move    a1,y:(r7+n7)
                            23475 
                            23476 ; 603  |      btBitRate=((btFrameUnpack[2])>>4);
                            23477 
P:0701 77F400 FFFFE9  3 398923479         move    #-23,n7
P:0703 000000         2 399123480         nop
P:0704 5EEF00         4 399523481         move    y:(r7+n7),a
P:0705 218F00         2 399723482         move    a1,b
P:0706 060480 rrrrrr  6 400323483         do      #4,L350
P:0708 200023         2 400523485         lsr     a
P:0709 000000         2 400723486         nop
                         (4)23487 L350:
P:070A 77F400 FFFFE1  3 401023489         move    #-31,n7
P:070C 000000         2 401223490         nop
P:070D 5C6F00         4 401623491         move    a1,y:(r7+n7)
                            23492 
                            23493 ; 604  |      btSampRate=(((btFrameUnpack[2])>>2)&(0x03));
                            23494 
P:070E 20002B         2 401823496         lsr     b
P:070F 20002B         2 402023497         lsr     b
P:0710 20007E         2 402223498         and     y1,b
P:0711 77F400 FFFFE0  3 402523499         move    #-32,n7
P:0713 000000         2 402723500         nop
P:0714 5D6F00         4 403123501         move    b1,y:(r7+n7)
                            23502 
                            23503 ; 605  |      btPaddingBit=((btFrameUnpack[2]>>1)&(0x01));
                            23504 
P:0715 77F400 FFFFE9  3 403423506         move    #-23,n7
P:0717 000000         2 403623507         nop
P:0718 5FEF00         4 404023508         move    y:(r7+n7),b
P:0719 20002B         2 404223509         lsr     b
P:071A 20006E         2 404423510         and     x1,b
P:071B 77F400 FFFFDF  3 404723511         move    #-33,n7
P:071D 000000         2 404923512         nop
P:071E 5D6F00         4 405323513         move    b1,y:(r7+n7)
                            23514 
                            23515 ; 606  |
                            23516 ; 607  |      if((btMPEGVer!=1)&(btSampRate != 3)& (btBitRate != 0)&(iLayer!=0))
                            23517 
P:071F 77F400 FFFFE2  3 405623519         move    #-30,n7
P:0721 000000         2 405823520         nop
P:0722 5FEF00         4 406223521         move    y:(r7+n7),b
P:0723 20006D         2 406423522         cmp     x1,b
P:0724 2C0000         2 406623523         move    #0,a1
P:0725 0AF0AA rrrrrr  6 407223524         jeq     L351
P:0727 2C0100         2 407423525         move    #1,a1
P:0728 77F400 FFFFE0  3 407723526 L351:   move    #-32,n7
P:072A 000000         2 407923527         nop
P:072B 5FEF00         4 408323528         move    y:(r7+n7),b
P:072C 20007D         2 408523529         cmp     y1,b
P:072D 260000         2 408723530         move    #0,y0
P:072E 0AF0AA rrrrrr  6 409323531         jeq     L352
P:0730 0AC660         4 409723532         bset    #0,y0
P:0731 200056         2 409923533 L352:   and     y0,a
P:0732 77F400 FFFFE1  3 410223534         move    #-31,n7
P:0734 000000         2 410423535         nop
P:0735 5FEF00         4 410823536         move    y:(r7+n7),b
P:0736 2B0000         2 411023537         move    #0,b2
P:0737 20000B         2 411223538         tst     b
P:0738 270000         2 411423539         move    #0,y1
P:0739 0AF0AA rrrrrr  6 412023540         jeq     L353
P:073B 0AC760         4 412423541         bset    #0,y1
P:073C 200076         2 412623542 L353:   and     y1,a
P:073D 77F400 FFFFDE  3 412923543         move    #-34,n7
P:073F 000000         2 413123544         nop
P:0740 5FEF00         4 413523545         move    y:(r7+n7),b
P:0741 20000B         2 413723546         tst     b
P:0742 240000         2 413923547         move    #0,x0
P:0743 0AF0AA rrrrrr  6 414523548         jeq     L354
P:0745 0AC460         4 414923549         bset    #0,x0
P:0746 200046         2 415123550 L354:   and     x0,a
P:0747 0AF0AA rrrrrr  6 415723551         jeq     L325
                            23552 
                            23553 ; 608  |       {
                            23554 ; 609  |      // get the sampling rate and bitrate
                            23555 ; 610  |      GetMp3Rates(btMPEGVer,btSampRate,btBitRate,iLayer,&wSampRate,&wBitRate);
                            23556 
P:0749 77F400 FFFFE5  3 416023558         move    #-27,n7
P:074B 000000         2 416223559         nop
P:074C 044F10         4 416623560         lua     (r7)+n7,r0
P:074D 77F400 FFFFE6  3 416923561         move    #-26,n7
P:074F 000000         2 417123562         nop
P:0750 044F14         4 417523563         lua     (r7)+n7,r4
P:0751 77F400 FFFFE2  3 417823564         move    #-30,n7
P:0753 000000         2 418023565         nop
P:0754 5EEF00         4 418423566         move    y:(r7+n7),a
P:0755 77F400 FFFFE1  3 418723567         move    #-31,n7
P:0757 000000         2 418923568         nop
P:0758 4CEF00         4 419323569         move    y:(r7+n7),x0
P:0759 77F400 FFFFE0  3 419623570         move    #-32,n7
P:075B 000000         2 419823571         nop
P:075C 5FEF00         4 420223572         move    y:(r7+n7),b
P:075D 77F400 FFFFDE  3 420523573         move    #-34,n7
P:075F 000000         2 420723574         nop
P:0760 4EEF00         4 421123575         move    y:(r7+n7),y0
P:0761 0BF080 rrrrrr  6 421723576         jsr     FGetMp3Rates
                            23577 
                            23578 ; 611  |      // calculate frame length
                            23579 ; 612  |      wFrameLengthInBytes = GetFrameLength(btMPEGVer,wBitRate,wSampRate,btPaddingBit,iLayer);
                            23580 
P:0763 77F400 FFFFE6  3 422023582         move    #-26,n7
P:0765 000000         2 422223583         nop
P:0766 5FEF00         4 422623584         move    y:(r7+n7),b
P:0767 77F400 FFFFE5  3 422923585         move    #-27,n7
P:0769 000000         2 423123586         nop
P:076A 4CEF00         4 423523587         move    y:(r7+n7),x0
P:076B 77F400 FFFFE2  3 423823588         move    #-30,n7
P:076D 000000         2 424023589         nop
P:076E 5EEF00         4 424423590         move    y:(r7+n7),a
P:076F 77F400 FFFFDF  3 424723591         move    #-33,n7
P:0771 000000         2 424923592         nop
P:0772 4EEF00         4 425323593         move    y:(r7+n7),y0
P:0773 77F400 FFFFDE  3 425623594         move    #-34,n7
P:0775 000000         2 425823595         nop
P:0776 4DEF00         4 426223596         move    y:(r7+n7),x1
P:0777 0BF080 rrrrrr  6 426823597         jsr     FGetFrameLength
                            23599 
                            23600 ; 613  |      // Update frame size, SL
                            23601 ; 614  |      g_wFrameLengthInBytes = wFrameLengthInBytes + 1;
                            23602 
P:0779 218F00         2 427023604         move    a1,b
P:077A 47F400 000001  3 427323605         move    #>1,y1
P:077C 200078         2 427523606         add     y1,b
P:077D 557000 rrrrrr  3 427823607         move    b1,x:Fg_wFrameLengthInBytes
                            23608 
                            23609 ; 615  |
                            23610 ; 616  |      // Move forward to next frame and read it.
                            23611 ; 617  |      if ((fseek(iHandle,(MetaData->dwStartPos+(DWORD)wFrameLengthInBytes),SEEK_SET))==ERROR)
                            23612 
P:077F 391100         2 428023614         move    #17,n1
P:0780 77F400 FFFFF6  3 428323615         move    #-10,n7
P:0782 000000         2 428523616         nop
P:0783 69EF00         4 428923617         move    y:(r7+n7),r1
P:0784 000000         2 429123618         nop
P:0785 044916         4 429523619         lua     (r1)+n1,r6
P:0786 000000         2 429723620         nop
P:0787 4CDE00         2 429923621         move    y:(r6)+,x0
P:0788 4DD600         2 430123622         move    y:(r6)-,x1
P:0789 218800         2 430323623         move    a1,a0
P:078A 2C0000         2 430523624         move    #0,a1
P:078B 200020         2 430723626         add     x,a
P:078C 77F400 FFFFF7  3 431023627         move    #-9,n7
P:078E 000000         2 431223628         nop
P:078F 5FEF00         4 431623629         move    y:(r7+n7),b
P:0790 44F400 FFFFFF  3 431923632         move    #>-1,x0
P:0792 2A0000         2 432123633         move    #0,a2
P:0793 0ACC17 rrrrrr  6 432723634         jclr    #23,a1,L355
P:0795 208A00         2 432923635         move    x0,a2
P:0796 0BF080 rrrrrr  6 433523636 L355:   jsr     Ffseek
P:0798 45F400 FFFFFF  3 433823639         move    #>-1,x1
P:079A 200065         2 434023640         cmp     x1,a
P:079B 77F400 FFFFF7  3 434323641         move    #-9,n7
P:079D 000000         2 434523642         nop
P:079E 5EEF00         4 434923643         move    y:(r7+n7),a
P:079F 0AF0AA rrrrrr  6 435523646         jeq     L334
                            23647 
                            23648 ; 618  |        return META_DATA_FILESEEK_ERROR;
                            23649 ; 619  |
                            23650 ; 620  |      // Extract frame header from file
                            23651 ; 621  |      iExtract = ExtractMp3Frame(iHandle,wFrameBufferPacked,btFrameUnpack);
                            23652 
P:07A1 77F400 FFFFEB  3 435823654         move    #-21,n7
P:07A3 000000         2 436023655         nop
P:07A4 044F10         4 436423656         lua     (r7)+n7,r0
P:07A5 77F400 FFFFE7  3 436723657         move    #-25,n7
P:07A7 000000         2 436923658         nop
P:07A8 044F14         4 437323659         lua     (r7)+n7,r4
P:07A9 0BF080 rrrrrr  6 437923664         jsr     FExtractMp3Frame
P:07AB 77F400 FFFFFD  3 438223667         move    #-3,n7
P:07AD 000000         2 438423668         nop
P:07AE 5E6F00         4 438823669         move    a,y:(r7+n7)
                            23671 
                            23672 ; 622  |
                            23673 ; 623  |      if (iExtract==SUCCESS)
                            23674 
P:07AF 200003         2 439023676         tst     a
P:07B0 0AF0A2 rrrrrr  6 439623677         jne     L325
                            23678 
                            23679 ; 624  |      {
                            23680 ; 625  |        // Check that sampling rate and MPEG version and layer match
                            23681 ; 626  |        if (((((btFrameUnpack[1])>>3)&(0x03))==(btMPEGVer)) &(((btFrameUnpack[2])>>4)!=0)&(((btFrameUnpack[2])>>4)!=15)&
                            23682 ; 627  |            ((((btFrameUnpack[1])>>1)&(0x03))==iLayer) &
                            23683 ; 628  |            ((((btFrameUnpack[2])>>2)&(0x03))==btSampRate))
                            23684 
P:07B2 77F400 FFFFE8  3 439923686         move    #-24,n7
P:07B4 000000         2 440123687         nop
P:07B5 4DEF00         4 440523688         move    y:(r7+n7),x1
P:07B6 47F400 000003  3 440823689         move    #>3,y1
P:07B8 0103F8         2 441023690         mpy     x1,#3,b
P:07B9 20007E         2 441223691         and     y1,b
P:07BA 77F400 FFFFE2  3 441523692         move    #-30,n7
P:07BC 000000         2 441723693         nop
P:07BD 4EEF00         4 442123694         move    y:(r7+n7),y0
P:07BE 21AF00         2 442323695         move    b1,b
P:07BF 20005D         2 442523696         cmp     y0,b
P:07C0 250000         2 442723697         move    #0,x1
P:07C1 0AF0A2 rrrrrr  6 443323698         jne     L356
P:07C3 0AC560         4 443723699         bset    #0,x1
P:07C4 77F400 FFFFE9  3 444023700 L356:   move    #-23,n7
P:07C6 000000         2 444223701         nop
P:07C7 5EEF00         4 444623702         move    y:(r7+n7),a
P:07C8 060480 rrrrrr  6 445223703         do      #4,L357
P:07CA 200023         2 445423705         lsr     a
P:07CB 000000         2 445623706         nop
                         (4)23707 L357:
P:07CC 218E00         2 445823709         move    a1,a
P:07CD 21C400         2 446023710         move    a,x0
P:07CE 200003         2 446223711         tst     a
P:07CF 260000         2 446423712         move    #0,y0
P:07D0 0AF0AA rrrrrr  6 447023713         jeq     L358
P:07D2 0AC660         4 447423714         bset    #0,y0
P:07D3 20AD00         2 447623715 L358:   move    x1,b1
P:07D4 20005E         2 447823716         and     y0,b
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  90

M:ADDR CODE           CYCLES LINE SOURCELINE
P:07D5 200041         2 448023717         tfr     x0,a
P:07D6 46F400 00000F  3 448323718         move    #>15,y0
P:07D8 200055         2 448523719         cmp     y0,a
P:07D9 250000         2 448723720         move    #0,x1
P:07DA 0AF0AA rrrrrr  6 449323721         jeq     L359
P:07DC 0AC560         4 449723722         bset    #0,x1
P:07DD 20006E         2 449923723 L359:   and     x1,b
P:07DE 21AE00         2 450123724         move    b1,a
P:07DF 77F400 FFFFE8  3 450423725         move    #-24,n7
P:07E1 000000         2 450623726         nop
P:07E2 5FEF00         4 451023727         move    y:(r7+n7),b
P:07E3 20002B         2 451223728         lsr     b
P:07E4 20007E         2 451423729         and     y1,b
P:07E5 77F400 FFFFDE  3 451723730         move    #-34,n7
P:07E7 000000         2 451923731         nop
P:07E8 4EEF00         4 452323732         move    y:(r7+n7),y0
P:07E9 21AF00         2 452523733         move    b1,b
P:07EA 20005D         2 452723734         cmp     y0,b
P:07EB 260000         2 452923735         move    #0,y0
P:07EC 0AF0A2 rrrrrr  6 453523736         jne     L360
P:07EE 0AC660         4 453923737         bset    #0,y0
P:07EF 200056         2 454123738 L360:   and     y0,a
P:07F0 218500         2 454323739         move    a1,x1
P:07F1 77F400 FFFFE9  3 454623740         move    #-23,n7
P:07F3 000000         2 454823741         nop
P:07F4 5FEF00         4 455223742         move    y:(r7+n7),b
P:07F5 20002B         2 455423743         lsr     b
P:07F6 20002B         2 455623744         lsr     b
P:07F7 20007E         2 455823745         and     y1,b
P:07F8 77F400 FFFFE0  3 456123746         move    #-32,n7
P:07FA 000000         2 456323747         nop
P:07FB 4FEF00         4 456723748         move    y:(r7+n7),y1
P:07FC 21AF00         2 456923749         move    b1,b
P:07FD 20007D         2 457123750         cmp     y1,b
P:07FE 260000         2 457323751         move    #0,y0
P:07FF 0AF0A2 rrrrrr  6 457923752         jne     L361
P:0801 0AC660         4 458323753         bset    #0,y0
P:0802 218F00         2 458523754 L361:   move    a1,b
P:0803 20005E         2 458723755         and     y0,b
P:0804 0AF0AA rrrrrr  6 459323756         jeq     L325
                            23757 
                            23758 ; 629  |        {
                            23759 ; 630  |            // Fill in rates
                            23760 ; 631  |            MetaData->wSampRate = wSampRate;
                            23761 
P:0806 3C0C00         2 459523763         move    #12,n4
P:0807 77F400 FFFFF6  3 459823764         move    #-10,n7
P:0809 000000         2 460023765         nop
P:080A 6CEF00         4 460423766         move    y:(r7+n7),r4
P:080B 229600         2 460623767         move    r4,r6
P:080C 044C15         4 461023768         lua     (r4)+n4,r5
P:080D 77F400 FFFFE5  3 461323771         move    #-27,n7
P:080F 000000         2 461523772         nop
P:0810 4EEF00         4 461923773         move    y:(r7+n7),y0
P:0811 4E6500         2 462123774         move    y0,y:(r5)
                            23775 
                            23776 ; 632  |            MetaData->wBitRate = wBitRate;
                            23777 
P:0812 3E0E00         2 462323779         move    #14,n6
P:0813 000000         2 462523780         nop
P:0814 204E00         2 462723781         move    (r6)+n6
P:0815 77F400 FFFFE6  3 463023784         move    #-26,n7
P:0817 000000         2 463223785         nop
P:0818 4EEF00         4 463623786         move    y:(r7+n7),y0
P:0819 77F400 FFFFFE  3 463923787         move    #-2,n7
P:081B 000000         2 464123788         nop
P:081C 6E6F00         4 464523789         move    r6,y:(r7+n7)
P:081D 4E6600         2 464723790         move    y0,y:(r6)
                            23792 
                            23793 ; 633  |            btBitRateTemp=((btFrameUnpack[2])>>4);
                            23794 ; 634  |            btPaddingBitTemp=((btFrameUnpack[2]>>1)&(0x01));
                            23795 
P:081E 77F400 FFFFE9  3 465023797         move    #-23,n7
P:0820 000000         2 465223798         nop
P:0821 5FEF00         4 465623799         move    y:(r7+n7),b
P:0822 46F400 000001  3 465923800         move    #>1,y0
P:0824 20002B         2 466123801         lsr     b
P:0825 21AF00         2 466323802         move    b1,b
P:0826 20005E         2 466523803         and     y0,b
P:0827 045FA0         2 466723804         movec   m0,n7
P:0828 000000         2 466923805         nop
P:0829 5D6F00         4 467323806         move    b1,y:(r7+n7)
                            23808 
                            23809 ; 635  |            // get the sampling rate and bitrate
                            23810 ; 636  |            GetMp3Rates(btMPEGVer,btSampRate,btBitRateTemp,iLayer,&wSampRateTemp,&wBitRateTemp);
                            23811 
P:082A 77F400 FFFFE3  3 467623813         move    #-29,n7
P:082C 000000         2 467823814         nop
P:082D 044F10         4 468223815         lua     (r7)+n7,r0
P:082E 77F400 FFFFE4  3 468523816         move    #-28,n7
P:0830 000000         2 468723817         nop
P:0831 044F14         4 469123818         lua     (r7)+n7,r4
P:0832 77F400 FFFFE2  3 469423819         move    #-30,n7
P:0834 000000         2 469623820         nop
P:0835 5EEF00         4 470023821         move    y:(r7+n7),a
P:0836 77F400 FFFFE0  3 470323822         move    #-32,n7
P:0838 000000         2 470523823         nop
P:0839 5FEF00         4 470923824         move    y:(r7+n7),b
P:083A 77F400 FFFFDE  3 471223825         move    #-34,n7
P:083C 000000         2 471423826         nop
P:083D 4EEF00         4 471823827         move    y:(r7+n7),y0
P:083E 0BF080 rrrrrr  6 472423828         jsr     FGetMp3Rates
P:0840 045FA0         2 472623830         movec   m0,n7
P:0841 000000         2 472823831         nop
P:0842 4EEF00         4 473223832         move    y:(r7+n7),y0
                            23835 
                            23836 ; 637  |            // calculate frame length
                            23837 ; 638  |            wFrameLengthInBytes = GetFrameLength(btMPEGVer,wBitRateTemp,wSampRateTemp,btPaddingBitTemp,iLayer);
                            23838 
P:0843 77F400 FFFFE4  3 473523840         move    #-28,n7
P:0845 000000         2 473723841         nop
P:0846 5FEF00         4 474123842         move    y:(r7+n7),b
P:0847 77F400 FFFFE3  3 474423843         move    #-29,n7
P:0849 000000         2 474623844         nop
P:084A 4CEF00         4 475023845         move    y:(r7+n7),x0
P:084B 77F400 FFFFE2  3 475323846         move    #-30,n7
P:084D 000000         2 475523847         nop
P:084E 5EEF00         4 475923848         move    y:(r7+n7),a
P:084F 77F400 FFFFDE  3 476223849         move    #-34,n7
P:0851 000000         2 476423850         nop
P:0852 4DEF00         4 476823851         move    y:(r7+n7),x1
P:0853 0BF080 rrrrrr  6 477423852         jsr     FGetFrameLength
                            23855 
                            23856 ; 639  |            // Move forward to next frame and read it.
                            23857 ; 640  |            if ((fseek(iHandle,(wFrameLengthInBytes - (WORD)MP3_FRAME_HEADER_BYTES_TO_READ),SEEK_CUR)) == ERROR)
                            23858 
P:0855 57F400 000004  3 477723860         move    #>4,b
P:0857 200014         2 477923861         sub     b,a
P:0858 218800         2 478123863         move    a1,a0
P:0859 2C0000         2 478323864         move    #0,a1
P:085A 2A0000         2 478523865         move    #0,a2
P:085B 77F400 FFFFF7  3 478823866         move    #-9,n7
P:085D 000000         2 479023867         nop
P:085E 5FEF00         4 479423868         move    y:(r7+n7),b
P:085F 240000         2 479623871         move    #0,x0
P:0860 0BF080 rrrrrr  6 480223872         jsr     Ffseek
P:0862 46F400 FFFFFF  3 480523875         move    #>-1,y0
P:0864 200055         2 480723876         cmp     y0,a
P:0865 77F400 FFFFFE  3 481023877         move    #-2,n7
P:0867 000000         2 481223878         nop
P:0868 6DEF00         4 481623879         move    y:(r7+n7),r5
P:0869 0AF0AA rrrrrr  6 482223880         jeq     L334
                            23881 
                            23882 ; 641  |              return META_DATA_FILESEEK_ERROR;
                            23883 ; 642  |
                            23884 ; 643  |            if ((wBitRate != wBitRateTemp) || (g_wVBRSignature == 'X') || (g_wVBRSignature == 'V'))
                            23885 
P:086B 77F400 FFFFE6  3 482523887         move    #-26,n7
P:086D 000000         2 482723888         nop
P:086E 5FEF00         4 483123889         move    y:(r7+n7),b
P:086F 77F400 FFFFE4  3 483423890         move    #-28,n7
P:0871 000000         2 483623891         nop
P:0872 5EEF00         4 484023892         move    y:(r7+n7),a
P:0873 2A0000         2 484223893         move    #0,a2
P:0874 2B0000         2 484423894         move    #0,b2
P:0875 20000D         2 484623895         cmp     a,b
P:0876 0AF0A2 rrrrrr  6 485223896         jne     L328
P:0878 5FF000 rrrrrr  3 485523897         move    y:Fg_wVBRSignature,b
P:087A 46F400 000058  3 485823898         move    #>88,y0
P:087C 2B0000         2 486023899         move    #0,b2
P:087D 20005D         2 486223900         cmp     y0,b
P:087E 0AF0AA rrrrrr  6 486823901         jeq     L328
P:0880 47F400 000056  3 487123902         move    #>86,y1
P:0882 20007D         2 487323903         cmp     y1,b
P:0883 0AF0A2 rrrrrr  6 487923904         jne     L330
                            23905 
                            23906 ; 644  |            {
                            23907 ; 645  |                if (MetaData->iTime)
                            23908 ; 646  |                        MetaData->wBitRate = (MetaData->dwNumBytes / MetaData->iTime*8) / 1000; // for stmp6282 vbr w/o TOC uses avg time
                            23909 ; 647  |                bVBR = TRUE;
                            23910 ; 648  |                MetaData->bVBR = VBR_TRUE;
                            23911 ; 649  |            }
                            23912 ; 650  |            bFrameFound = TRUE;      // second frame matches first, so take it to be right
                            23913 ; 651  |            break;
                            23914 
P:0885 0AF080 rrrrrr  6 488523916         jmp     L328
                            23917 
                            23918 ; 652  |        }
                            23919 ; 653  |      }
                            23920 ; 654  |       }
                            23921 ; 655  |      // ELSE -- the frame did not match, so start over
                            23922 ; 656  |      dwStartPosOffset++;            // increment start position to prevent looping on bad data
                            23923 
P:0887 20001B         2 488723925 L325:   clr     b   
P:0888 000009         2 488923926         inc     b
                            23928 
                            23929 ; 657  |      bFirstFrameFound = FALSE;      // begin looking for first frame again
                            23930 
P:0889 280000         2 489123932         move    #0,a0
P:088A 77F400 FFFFF9  3 489423935         move    #-7,n7
P:088C 000000         2 489623936         nop
P:088D 586F00         4 490023937         move    a0,y:(r7+n7)
P:088E 0AF080 rrrrrr  6 490623941         jmp     L317
P:0890 390F00         2 490823943 L328:   move    #15,n1
P:0891 77F400 FFFFF6  3 491123944         move    #-10,n7
P:0893 000000         2 491323945         nop
P:0894 69EF00         4 491723946         move    y:(r7+n7),r1
P:0895 223200         2 491923947         move    r1,r2
P:0896 044916         4 492323948         lua     (r1)+n1,r6
P:0897 000000         2 492523951         nop
P:0898 205E00         2 492723952         move    (r6)+
P:0899 5FD600         2 492923953         move    y:(r6)-,b
P:089A 59E600         2 493123954         move    y:(r6),b0
P:089B 20000B         2 493323956         tst     b
P:089C 0AF0AA rrrrrr  6 493923957         jeq     L329
P:089E 3A1300         2 494123959         move    #19,n2
P:089F 000000         2 494323960         nop
P:08A0 044A16         4 494723961         lua     (r2)+n2,r6
P:08A1 000000         2 494923962         nop
P:08A2 205E00         2 495123963         move    (r6)+
P:08A3 5ED600         2 495323964         move    y:(r6)-,a
P:08A4 58E600         2 495523965         move    y:(r6),a0
P:08A5 212600         2 495723966         move    b0,y0
P:08A6 21A700         2 495923967         move    b1,y1
P:08A7 0BF080 rrrrrr  6 496523968         jsr     Rdiv_ululul
P:08A9 060380 rrrrrr  6 497123969         do      #3,L362
P:08AB 200032         2 497323971         asl     a
P:08AC 000000         2 497523972         nop
                         (4)23973 L362:
P:08AD 270000         2 497723975         move    #0,y1
P:08AE 46F400 0003E8  3 498023976         move    #1000,y0
P:08B0 0BF080 rrrrrr  6 498623977         jsr     Rdiv_ululul
P:08B2 586500         2 498823978         move    a0,y:(r5)
P:08B3 280100         2 499023980 L329:   move    #1,a0
P:08B4 77F400 FFFFF8  3 499323983         move    #-8,n7
P:08B6 000000         2 499523984         nop
P:08B7 586F00         4 499923985         move    a0,y:(r7+n7)
P:08B8 3A1900         2 500123989         move    #25,n2
P:08B9 77F400 FFFFF6  3 500423990         move    #-10,n7
P:08BB 000000         2 500623991         nop
P:08BC 6A6F00         4 501023992         move    r2,y:(r7+n7)
P:08BD 044A16         4 501423993         lua     (r2)+n2,r6
P:08BE 290100         2 501623996         move    #1,b0
P:08BF 596600         2 501823997         move    b0,y:(r6)
                            23998 
                            23999 ; 658  |    }    // while (!bFrameFound)
                            24000 ; 659  |
                            24001 ; 660  |    if (!bVBR)
                            24002 
P:08C0 77F400 FFFFF8  3 502124004 L330:   move    #-8,n7
P:08C2 000000         2 502324005         nop
P:08C3 5FEF00         4 502724006         move    y:(r7+n7),b
P:08C4 2B0000         2 502924007         move    #0,b2
P:08C5 20000B         2 503124008         tst     b
P:08C6 0AF0A2 rrrrrr  6 503724009         jne     L341
                            24010 
                            24011 ; 661  |    {
                            24012 ; 662  |      // check for variable bit rates -- this is not 100% right since need to search entire file
                            24013 ; 663  |      for (i=0; i<(MP3_FRAMES_TO_CHECK_VBR-2); i++)
                            24014 
P:08C8 20001B         2 503924016         clr     b   
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  91

M:ADDR CODE           CYCLES LINE SOURCELINE
P:08C9 77F400 FFFFFE  3 504224018 L331:   move    #-2,n7
P:08CB 000000         2 504424019         nop
P:08CC 5D6F00         4 504824020         move    b1,y:(r7+n7)
                            24023 
                            24024 ; 664  |      {
                            24025 ; 665  |        iExtract = ExtractMp3Frame(iHandle,wFrameBufferPacked,btFrameUnpack);
                            24026 
P:08CD 77F400 FFFFEB  3 505124028         move    #-21,n7
P:08CF 000000         2 505324029         nop
P:08D0 044F10         4 505724030         lua     (r7)+n7,r0
P:08D1 77F400 FFFFE7  3 506024031         move    #-25,n7
P:08D3 000000         2 506224032         nop
P:08D4 044F14         4 506624033         lua     (r7)+n7,r4
P:08D5 77F400 FFFFF7  3 506924034         move    #-9,n7
P:08D7 000000         2 507124035         nop
P:08D8 5EEF00         4 507524036         move    y:(r7+n7),a
P:08D9 0BF080 rrrrrr  6 508124039         jsr     FExtractMp3Frame
P:08DB 77F400 FFFFFD  3 508424042         move    #-3,n7
P:08DD 000000         2 508624043         nop
P:08DE 5E6F00         4 509024044         move    a,y:(r7+n7)
                            24045 
                            24046 ; 666  |        btBitRateTemp=((btFrameUnpack[2])>>4);
                            24047 
P:08DF 77F400 FFFFE9  3 509324049         move    #-23,n7
P:08E1 000000         2 509524050         nop
P:08E2 4CEF00         4 509924051         move    y:(r7+n7),x0
P:08E3 0104D8         2 510124052         mpy     x0,#4,b
P:08E4 21A400         2 510324053         move    b1,x0
                            24055 
                            24056 ; 667  |        btPaddingBitTemp=((btFrameUnpack[2]>>1)&(0x01));
                            24057 
P:08E5 5FEF00         4 510724059         move    y:(r7+n7),b
P:08E6 46F400 000001  3 511024060         move    #>1,y0
P:08E8 20002B         2 511224061         lsr     b
P:08E9 20005E         2 511424062         and     y0,b
P:08EA 21B500         2 511624063         move    b1,r5
                            24065 
                            24066 ; 668  |                if (iExtract != SUCCESS)
                            24067 
P:08EB 200003         2 511824069         tst     a
P:08EC 0AF0A2 rrrrrr  6 512424070         jne     L341
P:08EE 045FA0         2 512624071         movec   m0,n7
P:08EF 000000         2 512824072         nop
P:08F0 6D6F00         4 513224073         move    r5,y:(r7+n7)
                            24076 
                            24077 ; 669  |                        break;
                            24078 ; 670  |        // get the sampling rate and bitrate
                            24079 ; 671  |        if(GetMp3Rates(btMPEGVer,btSampRate,btBitRateTemp,iLayer,&wSampRateTemp,&wBitRateTemp)==ERROR)
                            24080 
P:08F1 77F400 FFFFE3  3 513524082         move    #-29,n7
P:08F3 000000         2 513724083         nop
P:08F4 044F10         4 514124084         lua     (r7)+n7,r0
P:08F5 77F400 FFFFE4  3 514424085         move    #-28,n7
P:08F7 000000         2 514624086         nop
P:08F8 044F14         4 515024087         lua     (r7)+n7,r4
P:08F9 77F400 FFFFE2  3 515324088         move    #-30,n7
P:08FB 000000         2 515524089         nop
P:08FC 5EEF00         4 515924090         move    y:(r7+n7),a
P:08FD 77F400 FFFFE0  3 516224091         move    #-32,n7
P:08FF 000000         2 516424092         nop
P:0900 5FEF00         4 516824093         move    y:(r7+n7),b
P:0901 77F400 FFFFDE  3 517124094         move    #-34,n7
P:0903 000000         2 517324095         nop
P:0904 4EEF00         4 517724096         move    y:(r7+n7),y0
P:0905 0BF080 rrrrrr  6 518324097         jsr     FGetMp3Rates
P:0907 045FA0         2 518524099         movec   m0,n7
P:0908 000000         2 518724100         nop
P:0909 4EEF00         4 519124101         move    y:(r7+n7),y0
P:090A 47F400 FFFFFF  3 519424104         move    #>-1,y1
P:090C 200075         2 519624105         cmp     y1,a
P:090D 0AF0AA rrrrrr  6 520224106         jeq     L341
                            24107 
                            24108 ; 672  |            break;
                            24109 ; 673  |        // calculate frame length
                            24110 ; 674  |        wFrameLengthInBytes = GetFrameLength(btMPEGVer,wBitRateTemp,wSampRateTemp,btPaddingBitTemp,iLayer);
                            24111 
P:090F 77F400 FFFFE4  3 520524113         move    #-28,n7
P:0911 000000         2 520724114         nop
P:0912 5FEF00         4 521124115         move    y:(r7+n7),b
P:0913 77F400 FFFFE3  3 521424116         move    #-29,n7
P:0915 000000         2 521624117         nop
P:0916 4CEF00         4 522024118         move    y:(r7+n7),x0
P:0917 77F400 FFFFE2  3 522324119         move    #-30,n7
P:0919 000000         2 522524120         nop
P:091A 5EEF00         4 522924121         move    y:(r7+n7),a
P:091B 77F400 FFFFDE  3 523224122         move    #-34,n7
P:091D 000000         2 523424123         nop
P:091E 4DEF00         4 523824124         move    y:(r7+n7),x1
P:091F 0BF080 rrrrrr  6 524424125         jsr     FGetFrameLength
                            24128 
                            24129 ; 675  |        // Move forward to next frame and read it.
                            24130 ; 676  |        if ((fseek(iHandle,(wFrameLengthInBytes - (WORD)MP3_FRAME_HEADER_BYTES_TO_READ),SEEK_CUR)) == ERROR)
                            24131 
P:0921 44F400 000004  3 524724133         move    #>4,x0
P:0923 200044         2 524924134         sub     x0,a
P:0924 218800         2 525124136         move    a1,a0
P:0925 2C0000         2 525324137         move    #0,a1
P:0926 2A0000         2 525524138         move    #0,a2
P:0927 77F400 FFFFF7  3 525824139         move    #-9,n7
P:0929 000000         2 526024140         nop
P:092A 5FEF00         4 526424141         move    y:(r7+n7),b
P:092B 240000         2 526624144         move    #0,x0
P:092C 0BF080 rrrrrr  6 527224145         jsr     Ffseek
P:092E 45F400 FFFFFF  3 527524148         move    #>-1,x1
P:0930 200065         2 527724149         cmp     x1,a
P:0931 0AF0A2 rrrrrr  6 528324150         jne     L335
                            24151 
                            24152 ; 677  |          return META_DATA_FILESEEK_ERROR;
                            24153 
P:0933 56F400 000203  3 528624155 L334:   move    #515,a
P:0935 0AF080 rrrrrr  6 529224156         jmp     L347
                            24157 
                            24158 ; 678  |
                            24159 ; 679  |        if (wBitRate != wBitRateTemp)
                            24160 
P:0937 77F400 FFFFE6  3 529524162 L335:   move    #-26,n7
P:0939 000000         2 529724163         nop
P:093A 5EEF00         4 530124164         move    y:(r7+n7),a
P:093B 77F400 FFFFE4  3 530424165         move    #-28,n7
P:093D 000000         2 530624166         nop
P:093E 5FEF00         4 531024167         move    y:(r7+n7),b
P:093F 2B0000         2 531224168         move    #0,b2
P:0940 2A0000         2 531424169         move    #0,a2
P:0941 200005         2 531624170         cmp     b,a
P:0942 0AF0AA rrrrrr  6 532224171         jeq     L336
                            24172 
                            24173 ; 680  |        {
                            24174 ; 681  |          bVBR = TRUE;
                            24175 
P:0944 56F400 000001  3 532524177         move    #>1,a
P:0946 77F400 FFFFF8  3 532824180         move    #-8,n7
P:0948 000000         2 533024181         nop
P:0949 5C6F00         4 533424182         move    a1,y:(r7+n7)
                            24185 
                            24186 ; 682  |          MetaData->bVBR = VBR_TRUE;
                            24187 
P:094A 3C1900         2 533624189         move    #25,n4
P:094B 77F400 FFFFF6  3 533924190         move    #-10,n7
P:094D 000000         2 534124191         nop
P:094E 6CEF00         4 534524192         move    y:(r7+n7),r4
P:094F 000000         2 534724193         nop
P:0950 044C16         4 535124194         lua     (r4)+n4,r6
P:0951 290100         2 535324195         move    #1,b0
P:0952 596600         2 535524196         move    b0,y:(r6)
                            24197 
                            24198 ; 683  |          if (g_wVBRSignature == 0)
                            24199 
P:0953 5FF000 rrrrrr  3 535824201         move    y:Fg_wVBRSignature,b
P:0955 2B0000         2 536024202         move    #0,b2
P:0956 20000B         2 536224203         tst     b
P:0957 0AF0A2 rrrrrr  6 536824204         jne     L341
                            24205 
                            24206 ; 684  |          {
                            24207 ; 685  |            g_wVBRSignature = 'U';      // This is probably a VBR file, but not enough information.
                            24208 
P:0959 47F400 000055  3 537124210         move    #>85,y1
P:095B 4F7000 rrrrrr  3 537424211         move    y1,y:Fg_wVBRSignature
                            24212 
                            24213 ; 686  |          }
                            24214 ; 687  |          break;
                            24215 
P:095D 0AF080 rrrrrr  6 538024217         jmp     L341
                            24218 
                            24219 ; 688  |        }
                            24220 
                            24222 L336:
P:095F 77F400 FFFFFE  3 538324224         move    #-2,n7
P:0961 000000         2 538524225         nop
P:0962 4EEF00         4 538924226         move    y:(r7+n7),y0
P:0963 57F400 000001  3 539224227         move    #>1,b
P:0965 200058         2 539424228         add     y0,b
P:0966 46F400 000062  3 539724233         move    #>98,y0
P:0968 20005D         2 539924234         cmp     y0,b
P:0969 0AF0A9 rrrrrr  6 540524235         jlt     L331
                            24236 
                            24237 ; 689  |
                            24238 ; 690  |      }
                            24239 ; 691  |    }
                            24240 ; 692  |
                            24241 ; 693  |    if (!bVBR)
                            24242 
P:096B 77F400 FFFFF8  3 540824244 L341:   move    #-8,n7
P:096D 000000         2 541024245         nop
P:096E 5EEF00         4 541424246         move    y:(r7+n7),a
P:096F 2A0000         2 541624247         move    #0,a2
P:0970 200003         2 541824248         tst     a
P:0971 0AF0A2 rrrrrr  6 542424251         jne     L342
                            24252 
                            24253 ; 694  |      MetaData->bVBR = VBR_NOT_DETERMINED;
                            24254 
P:0973 3C1900         2 542624256         move    #25,n4
P:0974 77F400 FFFFF6  3 542924257         move    #-10,n7
P:0976 000000         2 543124258         nop
P:0977 6CEF00         4 543524259         move    y:(r7+n7),r4
P:0978 000000         2 543724260         nop
P:0979 044C16         4 544124261         lua     (r4)+n4,r6
P:097A 20001B         2 544324264         clr     b   
P:097B 5D6600         2 544524265         move    b1,y:(r6)
                            24267 
                            24268 ; 695  |
                            24269 ; 696  |    if(iExtract==ERROR)
                            24270 
P:097C 77F400 FFFFFD  3 544824272 L342:   move    #-3,n7
P:097E 000000         2 545024273         nop
P:097F 5FEF00         4 545424274         move    y:(r7+n7),b
P:0980 45F400 FFFFFF  3 545724275         move    #>-1,x1
P:0982 20006D         2 545924276         cmp     x1,b
P:0983 0AF0A2 rrrrrr  6 546524279         jne     L344
                            24280 
                            24281 ; 697  |      return(META_DATA_NOT_FOUND);
                            24282 
P:0985 56F400 000100  3 546824284 L343:   move    #$100,a
P:0987 0AF080 rrrrrr  6 547424286         jmp     L347
                            24287 
                            24288 ; 698  |
                            24289 ; 699  |    return(META_DATA_FOUND);
                            24290 
P:0989 200013         2 547624292 L344:   clr     a   
                            24293 
                            24294 ; 700  |}
                            24295 
P:098A 77F400 FFFFDD  3 547924297 L347:   move    #-35,n7
P:098C 000000         2 548124298         nop
P:098D 05EF7C         4 548524299         movec   y:(r7+n7),ssh
P:098E 204F00         2 548724301         move    (r7)+n7
P:098F 00000C         4 549124303         rts
                            24310 
                            24311 ; 701  |
                            24312 ; 702  |///////////////////////////////////////////////////////////////////////////////
                            24313 ; 703  |//> Name:        ExtractMp3Frame
                            24314 ; 704  |//
                            24315 ; 705  |//  Type:        Function
                            24316 ; 706  |//
                            24317 ; 707  |//  Description: Searches for mp3 frame headers.
                            24318 ; 708  |//
                            24319 ; 709  |//  Inputs:      File handle, ptr to packed buffer to read into, ptr to unpacked buffer to extract to
                            24320 ; 710  |//
                            24321 ; 711  |//  Outputs:     0 if Success, -1 if Failure, otherwise 1, 2, 3, or 4.
                            24322 ; 712  |//                    A '1' is returned if byte number 1 (count starts with byte 0) is FF.
                            24323 ; 713  |//                    A '2' is returned if byte number 2 is FF.
                            24324 ; 714  |//                    A '3' is returned if byte number 3 is FF.
                            24325 ; 715  |//                    A '4' is returned if none are FF.
                            24326 ; 716  |//                    This allows calling routine to FileSeek forward this many bytes and call again.
                            24327 ; 717  |//
                            24328 ; 718  |//               Currently: A frame is considered to have been found if the following criteria
                            24329 ; 719  |//               are met:
                            24330 ; 720  |//                   1. The 11 sync bits are found (11 ones in a row)  -- (ExtractMp3Frame does this)
                            24331 ; 721  |//                             ****AND****
                            24332 ; 722  |//                   2. The bitrate is NOT equal to 4 ones in a row (not allowed)  -- (ExtractMp3Frame does this)
                            24333 ; 723  |//                             ****AND****
                            24334 ; 724  |//                   3. Two frames in a row are found and critical values match between them -- (GetMp3FrameInfo does this)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  92

M:ADDR CODE           CYCLES LINE SOURCELINE
                            24335 ; 725  |//<
                            24336 ; 726  |/////////////////////////////////////////////////////////////////////////////////
                            24337 ; 727  |INT _reentrant ExtractMp3Frame(INT iHandle, WORD * wFrameBufferPacked, BYTE * btFrameUnpack)
                            24338 ; 728  |{
                            24339 
                            24344 FExtractMp3Frame:
P:0990 055F7C         2 549324345         movec   ssh,y:(r7)+
P:0991 3F0300         2 549524348         move    #3,n7
P:0992 000000         2 549724349         nop
P:0993 204F00         2 549924350         move    (r7)+n7
                            24360 
                            24361 ; 729  |    INT  i;
                            24362 
P:0994 045FA0         2 550124364         movec   m0,n7
P:0995 000000         2 550324365         nop
P:0996 6C6F00         4 550724366         move    r4,y:(r7+n7)
                            24369 
                            24370 ; 730  |
                            24371 ; 731  |    // Read from File
                            24372 ; 732  |    if (FSFileRead(MP3_FRAME_HEADER_BYTES_TO_READ, iHandle, MEM_SPACE_Y, (INT)(-1), wFrameBufferPacked) != MP3_FRAME_HEADER_BYTES_TO_READ)
                            24373 
P:0997 77F400 FFFFFE  3 551024375         move    #-2,n7
P:0999 000000         2 551224376         nop
P:099A 686F00         4 551624377         move    r0,y:(r7+n7)
P:099B 46F400 FFFFFF  3 551924382         move    #>-1,y0
P:099D 2D0400         2 552124383         move    #4,b1
P:099E 77F400 FFFFFD  3 552424384         move    #-3,n7
P:09A0 000000         2 552624385         nop
P:09A1 5C6F00         4 553024386         move    a1,y:(r7+n7)
P:09A2 21AE00         2 553224389         move    b1,a
P:09A3 5FEF00         4 553624390         move    y:(r7+n7),b
P:09A4 244000         2 553824391         move    #<$40,x0
P:09A5 0BF080 rrrrrr  6 554424392         jsr     FFSFileRead
P:09A7 46F400 000004  3 554724398         move    #>4,y0
P:09A9 200055         2 554924399         cmp     y0,a
P:09AA 0AF0AA rrrrrr  6 555524400         jeq     L363
                            24401 
                            24402 ; 733  |      return(ERROR);
                            24403 
P:09AC 56F400 FFFFFF  3 555824405         move    #>-1,a
P:09AE 0AF080 rrrrrr  6 556424406         jmp     L370
P:09B0 045FA0         2 556624407 L363:   movec   m0,n7
P:09B1 000000         2 556824408         nop
P:09B2 6CEF00         4 557224409         move    y:(r7+n7),r4
P:09B3 200051         2 557424412         tfr     y0,a
                            24413 
                            24414 ; 734  |
                            24415 ; 735  |    // unpack bytes read
                            24416 ; 736  |    unpack_data((_packed BYTE *)wFrameBufferPacked,btFrameUnpack,FRAME_HEADER_SIZE);
                            24417 
P:09B4 77F400 FFFFFE  3 557724419         move    #-2,n7
P:09B6 000000         2 557924420         nop
P:09B7 68EF00         4 558324421         move    y:(r7+n7),r0
P:09B8 0BF080 rrrrrr  6 558924422         jsr     unpack_data
                            24428 
                            24429 ; 737  |
                            24430 ; 738  |    if ((btFrameUnpack[0]==0xFF)&((btFrameUnpack[1]>>5)==0x07))
                            24431 
P:09BA 045FA0         2 559124433         movec   m0,n7
P:09BB 000000         2 559324434         nop
P:09BC 6DEF00         4 559724435         move    y:(r7+n7),r5
P:09BD 000000         2 559924436         nop
P:09BE 5FE500         2 560124437         move    y:(r5),b
P:09BF 47F400 0000FF  3 560424440         move    #>$FF,y1
P:09C1 20007D         2 560624441         cmp     y1,b
P:09C2 2C0000         2 560824442         move    #0,a1
P:09C3 0AF0A2 rrrrrr  6 561424443         jne     L372
P:09C5 2C0100         2 561624444         move    #1,a1
P:09C6 45F400 000001  3 561924445 L372:   move    #>1,x1
P:09C8 045D16         4 562324446         lua     (r5)+,r6
P:09C9 000000         2 562524447         nop
P:09CA 4EE600         2 562724448         move    y:(r6),y0
P:09CB 0105E8         2 562924449         mpy     y0,#5,b
P:09CC 21AF00         2 563124450         move    b1,b
P:09CD 46F400 000007  3 563424451         move    #>7,y0
P:09CF 20005D         2 563624452         cmp     y0,b
P:09D0 240000         2 563824453         move    #0,x0
P:09D1 0AF0A2 rrrrrr  6 564424454         jne     L373
P:09D3 0AC460         4 564824455         bset    #0,x0
P:09D4 200046         2 565024456 L373:   and     x0,a
P:09D5 0AF0AA rrrrrr  6 565624457         jeq     L365
                            24458 
                            24459 ; 739  |    // IF sync bits are all set (11 of them)
                            24460 ; 740  |    {
                            24461 ; 741  |      // If the bitrate index == 0x0F, then this is not a valid frame
                            24462 ; 742  |      if (((btFrameUnpack[2]>>4)!=0x0F))
                            24463 
P:09D7 3D0200         2 565824465         move    #2,n5
P:09D8 000000         2 566024466         nop
P:09D9 204D00         2 566224467         move    (r5)+n5
P:09DA 4EE500         2 566424469         move    y:(r5),y0
P:09DB 0104E8         2 566624470         mpy     y0,#4,b
P:09DC 21AF00         2 566824471         move    b1,b
P:09DD 56F400 00000F  3 567124472         move    #>15,a
P:09DF 20000D         2 567324473         cmp     a,b
P:09E0 0AF0AA rrrrrr  6 567924474         jeq     L365
                            24475 
                            24476 ; 743  |        return SUCCESS;
                            24477 
P:09E2 200013         2 568124479         clr     a   
P:09E3 0AF080 rrrrrr  6 568724480         jmp     L370
                            24481 
                            24482 ; 744  |    }
                            24483 ; 745  |
                            24484 ; 746  |    for (i=1;i<=3;i++)
                            24485 
P:09E5 200061         2 568924487 L365:   tfr     x1,a
P:09E6 060380 rrrrrr  6 569524489         do      #3,L371
                            24491 
                            24492 ; 747  |      if (btFrameUnpack[i]==0xFF)
                            24493 
P:09E8 5FE600         2 569724495         move    y:(r6),b
P:09E9 20007D         2 569924496         cmp     y1,b
P:09EA 0AF0A2 rrrrrr  6 570524497         jne     L367
                            24498 
                            24499 ; 748  |        return i;
                            24500 
P:09EC 00008C         2 570724502         enddo
P:09ED 0AF080 rrrrrr  6 571324504         jmp     L370
                            24505 L367:
P:09EF 205E00         2 571524507         move    (r6)+
P:09F0 200060         2 571724508         add     x1,a
                        (22)24509 L371:
                            24511 
                            24512 ; 749  |
                            24513 ; 750  |    // IF none of the 4 bytes are FF, return a '4' to seek forward to 5th byte
                            24514 ; 751  |    return 4;
                            24515 
P:09F1 56F400 000004  3 572024517         move    #>4,a
                            24519 
                            24520 ; 752  |}
                            24521 
P:09F3 77F400 FFFFFC  3 572324523 L370:   move    #-4,n7
P:09F5 000000         2 572524524         nop
P:09F6 05EF7C         4 572924525         movec   y:(r7+n7),ssh
P:09F7 204F00         2 573124527         move    (r7)+n7
P:09F8 00000C         4 573524529         rts
                            24531 
                            24532 ; 753  |
                            24533 ; 754  |
                            24534 ; 755  |///////////////////////////////////////////////////////////////////////////////
                            24535 ; 756  |//> Name:        ScanForFF
                            24536 ; 757  |//
                            24537 ; 758  |//  Type:        Function
                            24538 ; 759  |//
                            24539 ; 760  |//  Description: Quickly scans through file looking for the first instance of "FF"
                            24540 ; 761  |//
                            24541 ; 762  |//  Inputs:      File handle, threshold to stop looking if reached.
                            24542 ; 763  |//  Outputs:     0 if SUCCESS & points to byte number of first FF.
                            24543 ; 764  |//               ERROR CODE if not success.
                            24544 ; 765  |//
                            24545 ; 766  |//<
                            24546 ; 767  |/////////////////////////////////////////////////////////////////////////////////
                            24547 ; 768  |RETCODE _reentrant ScanForFF(INT iHandle, WORD wThresholdMax,  FILE_META_DATA*pMetaData)
                            24548 ; 769  |{
                            24549 
                            24554 FScanForFF:
P:09F9 055F7C         2 573724555         movec   ssh,y:(r7)+
P:09FA 3F3800         2 573924558         move    #56,n7
P:09FB 000000         2 574124559         nop
P:09FC 204F00         2 574324560         move    (r7)+n7
                            24570 
                            24571 ; 770  |    RETCODE rtn = META_DATA_NOT_FOUND;
                            24572 
P:09FD 77F400 FFFFFA  3 574624574         move    #-6,n7
P:09FF 000000         2 574824575         nop
P:0A00 5C6F00         4 575224576         move    a1,y:(r7+n7)
P:0A01 77F400 FFFFFC  3 575524579         move    #-4,n7
P:0A03 000000         2 575724580         nop
P:0A04 686F00         4 576124581         move    r0,y:(r7+n7)
P:0A05 77F400 FFFFFB  3 576424584         move    #-5,n7
P:0A07 000000         2 576624585         nop
P:0A08 5D6F00         4 577024586         move    b1,y:(r7+n7)
P:0A09 46F400 000100  3 577324589         move    #$100,y0
P:0A0B 77F400 FFFFFD  3 577624591         move    #-3,n7
P:0A0D 000000         2 577824592         nop
P:0A0E 4E6F00         4 578224593         move    y0,y:(r7+n7)
                            24602 
                            24603 ; 771  |    INT  i;
                            24604 ; 772  |    WORD wTempBuffer[50];
                            24605 ; 773  |    WORD wCount=0;
                            24606 
P:0A0F 270000         2 578424608         move    #0,y1
P:0A10 77F400 FFFFFE  3 578724610         move    #-2,n7
P:0A12 000000         2 578924611         nop
P:0A13 4F6F00         4 579324612         move    y1,y:(r7+n7)
                            24617 
                            24618 ; 774  |    BOOL bLoopDone=FALSE;
                            24619 
P:0A14 240000         2 579524621         move    #0,x0
P:0A15 045FA0         2 579724623         movec   m0,n7
P:0A16 000000         2 579924624         nop
P:0A17 4C6F00         4 580324625         move    x0,y:(r7+n7)
                            24628 
                            24629 ; 775  |
                            24630 ; 776  |    while(!bLoopDone)
                            24631 
P:0A18 0AF080 rrrrrr  6 580924633         jmp     L394
                            24634 
                            24635 ; 777  |    {
                            24636 ; 778  |      // Read from File
                            24637 ; 779  |      if (FSFileRead(150, iHandle, MEM_SPACE_Y, (INT)(-1), wTempBuffer) != ERROR)
                            24638 
P:0A1A 77F400 FFFFFA  3 581224640 L385:   move    #-6,n7
P:0A1C 000000         2 581424641         nop
P:0A1D 5FEF00         4 581824642         move    y:(r7+n7),b
P:0A1E 46F400 FFFFFF  3 582124645         move    #>-1,y0
P:0A20 77F400 FFFFC8  3 582424646         move    #-56,n7
P:0A22 000000         2 582624647         nop
P:0A23 044F10         4 583024648         lua     (r7)+n7,r0
P:0A24 56F400 000096  3 583324649         move    #>150,a
P:0A26 244000         2 583524650         move    #<$40,x0
P:0A27 0BF080 rrrrrr  6 584124651         jsr     FFSFileRead
P:0A29 45F400 FFFFFF  3 584424654         move    #>-1,x1
P:0A2B 200065         2 584624655         cmp     x1,a
P:0A2C 0AF0AA rrrrrr  6 585224656         jeq     L391
                            24657 
                            24658 ; 780  |      {
                            24659 ; 781  |          // Scan buffer for "FF" in any of the words.
                            24660 ; 782  |          for (i=0;i<50;i++)
                            24661 
P:0A2E 270000         2 585424663         move    #0,y1
                            24665 
                            24666 ; 783  |          {
                            24667 ; 784  |            if (((wTempBuffer[i]&0xFF)==0xFF)||((wTempBuffer[i]&0xFF00)==0xFF00)||((wTempBuffer[i]&0xFF0000)==0xFF0000))
                            24668 
P:0A2F 77F400 FFFFC8  3 585724670 L386:   move    #-56,n7
P:0A31 000000         2 585924671         nop
P:0A32 044F13         4 586324672         lua     (r7)+n7,r3
P:0A33 20FB00         2 586524673         move    y1,n3
P:0A34 000000         2 586724674         nop
P:0A35 044B16         4 587124675         lua     (r3)+n3,r6
P:0A36 000000         2 587324676         nop
P:0A37 5FE600         2 587524677         move    y:(r6),b
P:0A38 21AE00         2 587724678         move    b1,a
P:0A39 45F400 0000FF  3 588024679         move    #>$FF,x1
P:0A3B 200066         2 588224680         and     x1,a
P:0A3C 2A0000         2 588424681         move    #0,a2
P:0A3D 200065         2 588624682         cmp     x1,a
P:0A3E 0AF0AA rrrrrr  6 589224683         jeq     L388
P:0A40 21AE00         2 589424684         move    b1,a
P:0A41 46F400 00FF00  3 589724685         move    #$FF00,y0
P:0A43 200056         2 589924686         and     y0,a
P:0A44 2A0000         2 590124687         move    #0,a2
P:0A45 200055         2 590324688         cmp     y0,a
P:0A46 0AF0AA rrrrrr  6 590924689         jeq     L388
P:0A48 26FF00         2 591124690         move    #<$FF,y0
P:0A49 20005E         2 591324691         and     y0,b
P:0A4A 200051         2 591524692         tfr     y0,a
P:0A4B 2A0000         2 591724693         move    #0,a2
P:0A4C 2B0000         2 591924694         move    #0,b2
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  93

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0A4D 20000D         2 592124695         cmp     a,b
P:0A4E 0AF0A2 rrrrrr  6 592724696         jne     L389
                            24697 
                            24698 ; 785  |            {
                            24699 ; 786  |              rtn = SUCCESS;
                            24700 
P:0A50 250000         2 592924702 L388:   move    #0,x1
P:0A51 77F400 FFFFFD  3 593224705         move    #-3,n7
P:0A53 000000         2 593424706         nop
P:0A54 4D6F00         4 593824707         move    x1,y:(r7+n7)
                            24710 
                            24711 ; 787  |              //update the start position of the MP3 data
                            24712 ; 788  |              pMetaData->dwStartPos+=(DWORD)wCount;
                            24713 
P:0A55 3E1100         2 594024715         move    #17,n6
P:0A56 77F400 FFFFFC  3 594324716         move    #-4,n7
P:0A58 000000         2 594524717         nop
P:0A59 6EEF00         4 594924718         move    y:(r7+n7),r6
P:0A5A 000000         2 595124719         nop
P:0A5B 204E00         2 595324720         move    (r6)+n6
P:0A5C 4EDE00         2 595524721         move    y:(r6)+,y0
P:0A5D 4FD600         2 595724722         move    y:(r6)-,y1
P:0A5E 77F400 FFFFFE  3 596024724         move    #-2,n7
P:0A60 000000         2 596224725         nop
P:0A61 58EF00         4 596624726         move    y:(r7+n7),a0
P:0A62 2C0000         2 596824727         move    #0,a1
P:0A63 200030         2 597024728         add     y,a
P:0A64 585E00         2 597224729         move    a0,y:(r6)+
P:0A65 5C5600         2 597424730         move    a1,y:(r6)-
                            24731 
                            24732 ; 789  |              fseek(iHandle,pMetaData->dwStartPos,SEEK_SET);
                            24733 
P:0A66 77F400 FFFFFA  3 597724735         move    #-6,n7
P:0A68 000000         2 597924736         nop
P:0A69 5FEF00         4 598324737         move    y:(r7+n7),b
P:0A6A 44F400 FFFFFF  3 598624740         move    #>-1,x0
P:0A6C 2A0000         2 598824741         move    #0,a2
P:0A6D 0ACC17 rrrrrr  6 599424742         jclr    #23,a1,L396
P:0A6F 208A00         2 599624743         move    x0,a2
P:0A70 0BF080 rrrrrr  6 600224744 L396:   jsr     Ffseek
                            24747 
                            24748 ; 790  |              bLoopDone=TRUE;
                            24749 
P:0A72 0AF080 rrrrrr  6 600824751         jmp     L390
                            24752 
                            24753 ; 791  |              break;
                            24754 ; 792  |            }
                            24755 ; 793  |            wCount += 3;
                            24756 
                            24758 L389:
P:0A74 77F400 FFFFFE  3 601124760         move    #-2,n7
P:0A76 000000         2 601324761         nop
P:0A77 5FEF00         4 601724762         move    y:(r7+n7),b
P:0A78 46F400 000003  3 602024763         move    #>3,y0
P:0A7A 200058         2 602224764         add     y0,b
                            24767 
                            24768 ; 794  |            if (wCount > wThresholdMax)
                            24769 
P:0A7B 77F400 FFFFFB  3 602524771         move    #-5,n7
P:0A7D 000000         2 602724772         nop
P:0A7E 5EEF00         4 603124773         move    y:(r7+n7),a
P:0A7F 77F400 FFFFFE  3 603424774         move    #-2,n7
P:0A81 000000         2 603624775         nop
P:0A82 5D6F00         4 604024776         move    b1,y:(r7+n7)
P:0A83 2A0000         2 604224777         move    #0,a2
P:0A84 2B0000         2 604424778         move    #0,b2
P:0A85 20000D         2 604624779         cmp     a,b
P:0A86 0AF0AF rrrrrr  6 605224782         jle     L392
                            24783 
                            24784 ; 795  |            {
                            24785 ; 796  |              bLoopDone=TRUE;
                            24786 
P:0A88 290100         2 605424788 L390:   move    #1,b0
P:0A89 045FA0         2 605624791         movec   m0,n7
P:0A8A 000000         2 605824792         nop
P:0A8B 596F00         4 606224793         move    b0,y:(r7+n7)
                            24796 
                            24797 ; 797  |              break;
                            24798 
P:0A8C 0AF080 rrrrrr  6 606824800         jmp     L394
                            24801 
                            24802 ; 798  |            }
                            24803 ; 799  |          }
                            24804 ; 800  |      }
                            24805 ; 801  |      else
                            24806 ; 802  |      {
                            24807 ; 803  |        rtn = META_DATA_FILEREAD_ERROR;
                            24808 
P:0A8E 55F400 000201  3 607124810 L391:   move    #$201,b1
P:0A90 77F400 FFFFFD  3 607424813         move    #-3,n7
P:0A92 000000         2 607624814         nop
P:0A93 5D6F00         4 608024815         move    b1,y:(r7+n7)
                            24818 
                            24819 ; 804  |        break;
                            24820 
P:0A94 0AF080 rrrrrr  6 608624822         jmp     L395
                            24824 L392:
P:0A96 57F400 000001  3 608924826         move    #>1,b
P:0A98 200078         2 609124827         add     y1,b
P:0A99 21A700         2 609324830         move    b1,y1
P:0A9A 200079         2 609524833         tfr     y1,b
P:0A9B 56F400 000032  3 609824834         move    #>50,a
P:0A9D 20000D         2 610024835         cmp     a,b
P:0A9E 0AF0A9 rrrrrr  6 610624836         jlt     L386
P:0AA0 045FA0         2 610824838 L394:   movec   m0,n7
P:0AA1 000000         2 611024839         nop
P:0AA2 5FEF00         4 611424840         move    y:(r7+n7),b
P:0AA3 2B0000         2 611624841         move    #0,b2
P:0AA4 20000B         2 611824842         tst     b
P:0AA5 0AF0AA rrrrrr  6 612424843         jeq     L385
                            24844 
                            24845 ; 805  |      }
                            24846 ; 806  |    } // while(1)
                            24847 ; 807  |    return rtn;
                            24848 
P:0AA7 77F400 FFFFFD  3 612724850 L395:   move    #-3,n7
P:0AA9 000000         2 612924851         nop
P:0AAA 5EEF00         4 613324852         move    y:(r7+n7),a
                            24855 
                            24856 ; 808  |}
                            24857 
P:0AAB 77F400 FFFFC7  3 613624859         move    #-57,n7
P:0AAD 000000         2 613824860         nop
P:0AAE 05EF7C         4 614224861         movec   y:(r7+n7),ssh
P:0AAF 204F00         2 614424863         move    (r7)+n7
P:0AB0 00000C         4 614824865         rts
                            24874 
                            24875 ; 809  |
                            24876 ; 810  |///////////////////////////////////////////////////////////////////////////////
                            24877 ; 811  |//> Name:        GetFrameLength
                            24878 ; 812  |//
                            24879 ; 813  |//  Type:        Function
                            24880 ; 814  |//
                            24881 ; 815  |//  Description: Computes the frame length for mp3 file.
                            24882 ; 816  |//
                            24883 ; 817  |//  Inputs:      MPEG Version, Bitrate, sampling rate, padding bit (0 or 1), and MPEG layer (I, II, or III)
                            24884 ; 818  |//  Outputs:     the compressed frame length for current frame, in Bytes
                            24885 ; 819  |//
                            24886 ; 820  |//<
                            24887 ; 821  |/////////////////////////////////////////////////////////////////////////////////
                            24888 ; 822  |WORD _reentrant GetFrameLength(BYTE btMPEGVer, WORD wBitRate, WORD wSampRate, BYTE btPaddingBit, INT iLayer)
                            24889 ; 823  |{
                            24890 
                            24895 FGetFrameLength:
P:0AB1 205F00         2 615024896         move    (r7)+
P:0AB2 205F00         2 615224897         move    (r7)+
                            24911 
                            24912 ; 824  |    WORD  wFrameLengthInBytes=0;
                            24913 
P:0AB3 21A700         2 615424915         move    b1,y1
P:0AB4 045FA0         2 615624918         movec   m0,n7
P:0AB5 000000         2 615824919         nop
P:0AB6 4E6F00         4 616224920         move    y0,y:(r7+n7)
P:0AB7 77F400 FFFFFE  3 616524923         move    #-2,n7
P:0AB9 000000         2 616724924         nop
P:0ABA 4C6F00         4 617124925         move    x0,y:(r7+n7)
                            24928 
                            24929 ; 825  |
                            24930 ; 826  |    //For Layer I files us this formula:
                            24931 ; 827  |    //FrameLengthInBytes = (12 * BitRate / SampleRate + Padding) * 4
                            24932 ; 828  |    if (iLayer == LayerI)
                            24933 
P:0ABB 200069         2 617324935         tfr     x1,b
P:0ABC 46F400 000003  3 617624936         move    #>3,y0
P:0ABE 20005D         2 617824937         cmp     y0,b
P:0ABF 0AF0A2 rrrrrr  6 618424938         jne     L402
                            24939 
                            24940 ; 829  |      wFrameLengthInBytes = ((((WORD)12000*wBitRate / wSampRate)+ (WORD)btPaddingBit)*(WORD)4);
                            24941 
P:0AC1 46F400 002EE0  3 618724943         move    #12000,y0
P:0AC3 2000B0         2 618924944         mpy     y1,y0,a
P:0AC4 200022         2 619124945         asr     a
P:0AC5 200049         2 619324947         tfr     x0,b
P:0AC6 210E00         2 619524948         move    a0,a
P:0AC7 0BF080 rrrrrr  6 620124949         jsr     Rdiv_uiuiui
P:0AC9 045FA0         2 620324952         movec   m0,n7
P:0ACA 000000         2 620524953         nop
P:0ACB 4DEF00         4 620924954         move    y:(r7+n7),x1
P:0ACC 210E00         2 621124955         move    a0,a
P:0ACD 200060         2 621324956         add     x1,a
P:0ACE 200033         2 621524959         lsl     a
P:0ACF 200033         2 621724960         lsl     a
P:0AD0 0AF080 rrrrrr  6 622324962         jmp     L406
                            24963 
                            24964 ; 830  |
                            24965 ; 831  |    //For Layer II & III files use this formula:
                            24966 ; 832  |    //FrameLengthInBytes = (FrameSizeInBits/8) * BitRate / SampleRate + Padding
                            24967 ; 833  |    // This works out to:
                            24968 ; 834  |    //    MPEG Version 1 :         FrameLengthInBytes = 144 * Bitrate / SampleRate + Padding
                            24969 ; 835  |    //    MPEG Version 2 and 2.5 : FrameLengthInBytes = 72 * Bitrate / SampleRate + Padding
                            24970 ; 836  |    else
                            24971 ; 837  |    {
                            24972 ; 838  |        // Layer II uses the same formula irrespective of MPEG versions.
                            24973 ; 839  |        if ((btMPEGVer == MPEGv1)||(iLayer == LayerII))
                            24974 
                            24976 L402:
P:0AD2 218F00         2 622524983         move    a1,b
P:0AD3 20005D         2 622724984         cmp     y0,b
P:0AD4 0AF0AA rrrrrr  6 623324985         jeq     L403
P:0AD6 200069         2 623524986         tfr     x1,b
P:0AD7 46F400 000002  3 623824987         move    #>2,y0
P:0AD9 20005D         2 624024988         cmp     y0,b
P:0ADA 0AF0A2 rrrrrr  6 624624991         jne     L404
                            24992 
                            24993 ; 840  |           wFrameLengthInBytes = (((((LONG)wBitRate * (LONG)1000 * (LONG)144)/(LONG)wSampRate))+ (LONG)btPaddingBit);
                            24994 
P:0ADC 20E400         2 624824996 L403:   move    y1,x0
P:0ADD 250000         2 625024997         move    #0,x1
P:0ADE 270000         2 625225001         move    #0,y1
P:0ADF 46F400 023280  3 625525002         move    #144000,y0
P:0AE1 0040F8         2 625725003         ori     #$40,mr
P:0AE2 000000         2 625925004         nop
P:0AE3 2000D8         2 626125005         mpy     y0,x0,b
P:0AE4 2128EA         2 626325006         mac     x1,y0,b b0,a0
P:0AE5 2000CA         2 626525007         mac     x0,y1,b
P:0AE6 212CFA         2 626725008         mac     y1,x1,b b0,a1
P:0AE7 00BFB8         2 626925009         andi    #$BF,mr
P:0AE8 212A00         2 627125010         move    b0,a2
P:0AE9 200022         2 627325011         asr     a
P:0AEA 77F400 FFFFFE  3 627625013         move    #-2,n7
P:0AEC 000000         2 627825014         nop
P:0AED 59EF00         4 628225015         move    y:(r7+n7),b0
P:0AEE 2D0000         2 628425016         move    #0,b1
P:0AEF 2B0000         2 628625017         move    #0,b2
P:0AF0 0BF080 rrrrrr  6 629225022         jsr     Rdiv_lll
P:0AF2 045FA0         2 629425023         movec   m0,n7
P:0AF3 000000         2 629625024         nop
P:0AF4 59EF00         4 630025025         move    y:(r7+n7),b0
P:0AF5 2D0000         2 630225026         move    #0,b1
P:0AF6 2B0000         2 630425027         move    #0,b2
P:0AF7 200010         2 630625031         add     b,a
P:0AF8 210E00         2 630825032         move    a0,a
P:0AF9 0AF080 rrrrrr  6 631425034         jmp     L406
                            25035 
                            25036 ; 841  |        else
                            25037 ; 842  |            wFrameLengthInBytes = (((((LONG)wBitRate * (LONG)1000 * (LONG)72)/(LONG)wSampRate))+ (LONG)btPaddingBit);
                            25038 
                            25040 L404:
P:0AFB 20E400         2 631625044         move    y1,x0
P:0AFC 250000         2 631825045         move    #0,x1
P:0AFD 270000         2 632025049         move    #0,y1
P:0AFE 46F400 011940  3 632325050         move    #72000,y0
P:0B00 0040F8         2 632525051         ori     #$40,mr
P:0B01 000000         2 632725052         nop
P:0B02 2000D8         2 632925053         mpy     y0,x0,b
P:0B03 2128EA         2 633125054         mac     x1,y0,b b0,a0
P:0B04 2000CA         2 633325055         mac     x0,y1,b
P:0B05 212CFA         2 633525056         mac     y1,x1,b b0,a1
P:0B06 00BFB8         2 633725057         andi    #$BF,mr
P:0B07 212A00         2 633925058         move    b0,a2
P:0B08 200022         2 634125059         asr     a
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  94

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0B09 59EF00         4 634525061         move    y:(r7+n7),b0
P:0B0A 2D0000         2 634725062         move    #0,b1
P:0B0B 2B0000         2 634925063         move    #0,b2
P:0B0C 0BF080 rrrrrr  6 635525067         jsr     Rdiv_lll
P:0B0E 045FA0         2 635725068         movec   m0,n7
P:0B0F 000000         2 635925069         nop
P:0B10 4EEF00         4 636325070         move    y:(r7+n7),y0
P:0B11 270000         2 636525071         move    #0,y1
P:0B12 200030         2 636725075         add     y,a
P:0B13 210E00         2 636925076         move    a0,a
                            25078 
                            25079 ; 843  |    }
                            25080 
                            25082 L406:
                            25083 
                            25084 ; 844  |    return(wFrameLengthInBytes);
                            25085 ; 845  |}
                            25086 
P:0B14 205700         2 637125088         move    (r7)-
P:0B15 205700         2 637325089         move    (r7)-
P:0B16 00000C         4 637725091         rts
                            25094 
                            25095 ; 846  |
                            25096 ; 847  |
                            25097 ; 848  |///////////////////////////////////////////////////////////////////////////////
                            25098 ; 849  |//> Name:        GetMp3Rates
                            25099 ; 850  |//
                            25100 ; 851  |//  Type:        Function
                            25101 ; 852  |//
                            25102 ; 853  |//  Description: Finds the sampling rate and bitrate for the current frame.
                            25103 ; 854  |//
                            25104 ; 855  |//  Inputs:      Mpeg version, sampling rate bits, bit rate bits, MPEG layer, ptr to Sampling rate, ptr to Bitrate
                            25105 ; 856  |//  Outputs:     Success or failure.
                            25106 ; 857  |//
                            25107 ; 858  |//<
                            25108 ; 859  |/////////////////////////////////////////////////////////////////////////////////
                            25109 ; 860  |// leave 0     caused hang when 1
                            25110 ; 861  |#define LAYER3_ONLY 0
                            25111 ; 862  |#if LAYER3_ONLY
                            25112 ; 863  |WORD _P wBitRateIndex3[16] = { 0, 32, 40, 48, 56,  64,  80,  96,  112, 128, 160, 192, 224, 256, 320, 999};
                            25113 ; 864  |WORD _P wMPEG1SampRate[4] = {44100, 48000, 32000, 999};
                            25114 ; 865  |#else
                            25115 ; 866  |WORD _P wBitRateIndex1[16] = { 0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 999};
                            25116 
                            25117 
P:0000                      25118         org     p,".pdatavbr",init:
                            25119 FwBitRateIndex1:
P:0000 000000 000020        25120         dc      $000000,$000020,$000040,$000060,$000080,$0000a0,$0000c0,$0000e0
       000040 000060              
       000080 0000A0              
       0000C0 0000E0              
P:0008 000100 000120        25121         dc      $000100,$000120,$000140,$000160,$000180,$0001a0,$0001c0,$0003e7
       000140 000160              
       000180 0001A0              
       0001C0 0003E7              
                            25125 
                            25126 ; 867  |WORD _P wBitRateIndex2[16] = { 0, 32, 48, 56, 64,  80,  96,  112, 128, 160, 192, 224, 256, 320, 384, 999};
                            25127 
                            25128 FwBitRateIndex2:
P:0010 000000 000020        25129         dc      $000000,$000020,$000030,$000038,$000040,$000050,$000060,$000070
       000030 000038              
       000040 000050              
       000060 000070              
P:0018 000080 0000A0        25130         dc      $000080,$0000a0,$0000c0,$0000e0,$000100,$000140,$000180,$0003e7
       0000C0 0000E0              
       000100 000140              
       000180 0003E7              
                            25133 
                            25134 ; 868  |WORD _P wBitRateIndex3[16] = { 0, 32, 40, 48, 56,  64,  80,  96,  112, 128, 160, 192, 224, 256, 320, 999};
                            25135 
                            25136 FwBitRateIndex3:
P:0020 000000 000020        25137         dc      $000000,$000020,$000028,$000030,$000038,$000040,$000050,$000060
       000028 000030              
       000038 000040              
       000050 000060              
P:0028 000070 000080        25138         dc      $000070,$000080,$0000a0,$0000c0,$0000e0,$000100,$000140,$0003e7
       0000A0 0000C0              
       0000E0 000100              
       000140 0003E7              
                            25141 
                            25142 ; 869  |WORD _P wBitRateIndex4[16] = { 0, 32, 48, 56, 64,  80,  96,  112, 128, 144, 160, 176, 192, 224, 256, 999};
                            25143 
                            25144 FwBitRateIndex4:
P:0030 000000 000020        25145         dc      $000000,$000020,$000030,$000038,$000040,$000050,$000060,$000070
       000030 000038              
       000040 000050              
       000060 000070              
P:0038 000080 000090        25146         dc      $000080,$000090,$0000a0,$0000b0,$0000c0,$0000e0,$000100,$0003e7
       0000A0 0000B0              
       0000C0 0000E0              
       000100 0003E7              
                            25149 
                            25150 ; 870  |WORD _P wBitRateIndex5[16] = { 0, 8,  16, 24, 32,  40,  48,  56,  64,  80,  96,  112, 128, 144, 160, 999};
                            25151 
                            25152 FwBitRateIndex5:
P:0040 000000 000008        25153         dc      $000000,$000008,$000010,$000018,$000020,$000028,$000030,$000038
       000010 000018              
       000020 000028              
       000030 000038              
P:0048 000040 000050        25154         dc      $000040,$000050,$000060,$000070,$000080,$000090,$0000a0,$0003e7
       000060 000070              
       000080 000090              
       0000A0 0003E7              
                            25157 
                            25158 ; 871  |WORD _P wMPEG1SampRate[4] = {44100, 48000, 32000, 999};
                            25159 
                            25160 FwMPEG1SampRate:
P:0050 00AC44 00BB80        25161         dc      $00ac44,$00bb80,$007d00,$0003e7
       007D00 0003E7              
                            25164 
                            25165 ; 872  |WORD _P wMPEG2SampRate[4] = {22050, 24000, 16000, 999};
                            25166 
                            25167 FwMPEG2SampRate:
P:0054 005622 005DC0        25168         dc      $005622,$005dc0,$003e80,$0003e7
       003E80 0003E7              
                            25171 
                            25172 ; 873  |WORD _P wMPEG2pt5SampRate[4] = {11025, 12000, 8000, 999};
                            25173 
                            25174 FwMPEG2pt5SampRate:
P:0058 002B11 002EE0        25175         dc      $002b11,$002ee0,$001f40,$0003e7
       001F40 0003E7              
                            25178 
                            25179 ; 874  |#endif
                            25180 ; 875  |INT _reentrant GetMp3Rates(BYTE btMPEGVer,BYTE btSampRate,BYTE btBitRate,INT iLayer, WORD *wSampRate,WORD *wBitRate)
                            25181 ; 876  |{
                            25182 
P:0B17                      25183         org     p,".ptextvbr":
                            25188 FGetMp3Rates:
P:0B17 219B00         2 637925201         move    a1,n3
                            25204 
                            25205 ; 877  |#if LAYER3_ONLY
                            25206 ; 878  |    // When sdk2.600.025 is merged to sdk3.0.152, the locator tries and fails to locate these in yconst rather than on the y stack.
                            25207 ; 879  |    // y const space allocation reduction acquired by dropping support for layer 1 and 2 here (temporary) TOVERIFY: TODO: change back & stop const cause.
                            25208 ; 880  |    *wSampRate = wMPEG1SampRate[btSampRate];
                            25209 ; 881  |    *wBitRate = wBitRateIndex3[btBitRate];  // assume layer 3 (mp3 means mpeg1 layer3). This is 99% of mp3 files.
                            25210 ; 882  |#else
                            25211 ; 883  |    // Find BitRate & Sampling Rate
                            25212 ; 884  |    if (btMPEGVer == MPEGv1)
                            25213 
P:0B18 236E00         2 638125215         move    n3,a
P:0B19 47F400 000003  3 638425216         move    #>3,y1
P:0B1B 200075         2 638625217         cmp     y1,a
P:0B1C 0AF0A2 rrrrrr  6 639225218         jne     L409
                            25219 
                            25220 ; 885  |    {
                            25221 ; 886  |      *wSampRate = wMPEG1SampRate[btSampRate];
                            25222 
P:0B1E 21BE00         2 639425224         move    b1,n6
P:0B1F 66F400 rrrrrr  3 639725225         move    #FwMPEG1SampRate,r6
P:0B21 000000         2 639925226         nop
P:0B22 044E12         4 640325227         lua     (r6)+n6,r2
P:0B23 000000         2 640525230         nop
P:0B24 07E28C         6 641125231         movem   p:(r2),a1
P:0B25 5C6000         2 641325232         move    a1,y:(r0)
                            25233 
                            25234 ; 887  |      if (iLayer == LayerI)
                            25235 
P:0B26 200059         2 641525237         tfr     y0,b
P:0B27 20007D         2 641725238         cmp     y1,b
P:0B28 0AF0A2 rrrrrr  6 642325239         jne     L407
                            25240 
                            25241 ; 888  |        *wBitRate = wBitRateIndex1[btBitRate];
                            25242 
P:0B2A 209E00         2 642525244         move    x0,n6
P:0B2B 66F400 rrrrrr  3 642825245         move    #FwBitRateIndex1,r6
P:0B2D 000000         2 643025246         nop
P:0B2E 204E00         2 643225247         move    (r6)+n6
P:0B2F 07E68F         6 643825251         movem   p:(r6),b
P:0B30 5D6400         2 644025252         move    b1,y:(r4)
P:0B31 0AF080 rrrrrr  6 644625253         jmp     L416
                            25254 
                            25255 ; 889  |      else if (iLayer == LayerII)
                            25256 
                            25258 L407:
P:0B33 200051         2 644825261         tfr     y0,a
P:0B34 46F400 000002  3 645125262         move    #>2,y0
P:0B36 200055         2 645325263         cmp     y0,a
P:0B37 0AF0A2 rrrrrr  6 645925266         jne     L408
                            25267 
                            25268 ; 890  |        *wBitRate = wBitRateIndex2[btBitRate];
                            25269 
P:0B39 209B00         2 646125271         move    x0,n3
P:0B3A 63F400 rrrrrr  3 646425272         move    #FwBitRateIndex2,r3
P:0B3C 000000         2 646625273         nop
P:0B3D 204B00         2 646825274         move    (r3)+n3
P:0B3E 07E388         6 647425278         movem   p:(r3),a0
P:0B3F 586400         2 647625280         move    a0,y:(r4)
P:0B40 0AF080 rrrrrr  6 648225281         jmp     L416
                            25282 
                            25283 ; 891  |      else
                            25284 ; 892  |        *wBitRate = wBitRateIndex3[btBitRate];
                            25285 
                            25287 L408:
P:0B42 209A00         2 648425290         move    x0,n2
P:0B43 62F400 rrrrrr  3 648725291         move    #FwBitRateIndex3,r2
P:0B45 000000         2 648925292         nop
P:0B46 044A11         4 649325293         lua     (r2)+n2,r1
P:0B47 000000         2 649525296         nop
P:0B48 07E18C         6 650125297         movem   p:(r1),a1
P:0B49 5C6400         2 650325298         move    a1,y:(r4)
                            25299 
                            25300 ; 893  |    }
                            25301 
P:0B4A 0AF080 rrrrrr  6 650925303         jmp     L416
                            25304 
                            25305 ; 894  |    else
                            25306 ; 895  |    {
                            25307 ; 896  |      if (btMPEGVer == MPEGv2)
                            25308 
                            25310 L409:
P:0B4C 45F400 000002  3 651225316         move    #>2,x1
P:0B4E 200065         2 651425317         cmp     x1,a
P:0B4F 0AF0A2 rrrrrr  6 652025318         jne     L410
                            25319 
                            25320 ; 897  |        *wSampRate = wMPEG2SampRate[btSampRate];
                            25321 
P:0B51 21BE00         2 652225323         move    b1,n6
P:0B52 66F400 rrrrrr  3 652525324         move    #FwMPEG2SampRate,r6
P:0B54 000000         2 652725325         nop
P:0B55 044E12         4 653125326         lua     (r6)+n6,r2
P:0B56 000000         2 653325327         nop
P:0B57 07E285         6 653925328         movem   p:(r2),x1
P:0B58 4D6000         2 654125329         move    x1,y:(r0)
                            25330 
                            25331 ; 898  |      if (btMPEGVer == MPEGv2pt5)
                            25332 
P:0B59 236E00         2 654325334 L410:   move    n3,a
P:0B5A 2A0000         2 654525335         move    #0,a2
P:0B5B 200003         2 654725336         tst     a
P:0B5C 0AF0A2 rrrrrr  6 655325339         jne     L411
                            25340 
                            25341 ; 899  |        *wSampRate = wMPEG2pt5SampRate[btSampRate];
                            25342 
P:0B5E 21BE00         2 655525344         move    b1,n6
P:0B5F 66F400 rrrrrr  3 655825345         move    #FwMPEG2pt5SampRate,r6
P:0B61 000000         2 656025346         nop
P:0B62 204E00         2 656225347         move    (r6)+n6
P:0B63 07E689         6 656825350         movem   p:(r6),b0
P:0B64 596000         2 657025351         move    b0,y:(r0)
                            25352 
                            25353 ; 900  |      if (iLayer == LayerI)
                            25354 
P:0B65 200051         2 657225356 L411:   tfr     y0,a
P:0B66 200075         2 657425357         cmp     y1,a
P:0B67 0AF0A2 rrrrrr  6 658025361         jne     L412
                            25362 
                            25363 ; 901  |        *wBitRate = wBitRateIndex4[btBitRate];
                            25364 
P:0B69 209B00         2 658225366         move    x0,n3
P:0B6A 63F400 rrrrrr  3 658525367         move    #FwBitRateIndex4,r3
P:0B6C 000000         2 658725368         nop
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  95

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0B6D 044B15         4 659125369         lua     (r3)+n3,r5
P:0B6E 000000         2 659325372         nop
P:0B6F 07E584         6 659925373         movem   p:(r5),x0
P:0B70 4C6400         2 660125374         move    x0,y:(r4)
P:0B71 0AF080 rrrrrr  6 660725375         jmp     L416
                            25376 
                            25377 ; 902  |      else
                            25378 ; 903  |        *wBitRate = wBitRateIndex5[btBitRate];
                            25379 
                            25381 L412:
P:0B73 209A00         2 660925384         move    x0,n2
P:0B74 62F400 rrrrrr  3 661225385         move    #FwBitRateIndex5,r2
P:0B76 000000         2 661425386         nop
P:0B77 204A00         2 661625387         move    (r2)+n2
P:0B78 07E285         6 662225390         movem   p:(r2),x1
P:0B79 4D6400         2 662425391         move    x1,y:(r4)
                            25392 
                            25393 ; 904  |    }
                            25394 ; 905  |#endif
                            25395 ; 906  |    return(SUCCESS);
                            25396 
P:0B7A 200013         2 662625398 L416:   clr     a   
                            25400 
                            25401 ; 907  |}
                            25402 
P:0B7B 00000C         4 663025404         rts
                            25410 
                            25411 ; 908  |
                            25412 ; 909  |///////////////////////////////////////////////////////////////////////////////
                            25413 ; 910  |//> Name:        MP3MetaDataReadNonID3Info
                            25414 ; 911  |//
                            25415 ; 912  |//  Type:        Function
                            25416 ; 913  |//
                            25417 ; 914  |//  Description: Read VBR header and Frame header
                            25418 ; 915  |//
                            25419 ; 916  |//  Inputs:      NONE
                            25420 ; 917  |//
                            25421 ; 918  |//  Outputs:     NONE
                            25422 ; 919  |//
                            25423 ; 920  |//  Notes: 
                            25424 ; 921  |/////////////////////////////////////////////////////////////////////////////////
                            25425 ; 922  |RETCODE _reentrant MP3MetaDataReadNonID3Info(INT iHandle, FILE_META_DATA *pMetaData)
                            25426 ; 923  |{
                            25427 
                            25432 FMP3MetaDataReadNonID3Info:
P:0B7C 055F7C         2 663225433         movec   ssh,y:(r7)+
P:0B7D 3F0300         2 663425436         move    #3,n7
P:0B7E 000000         2 663625437         nop
P:0B7F 204F00         2 663825438         move    (r7)+n7
                            25446 
                            25447 ; 924  |    RETCODE rtn = META_DATA_NOT_FOUND;
                            25448 
P:0B80 77F400 FFFFFD  3 664125450         move    #-3,n7
P:0B82 000000         2 664325451         nop
P:0B83 5C6F00         4 664725452         move    a1,y:(r7+n7)
P:0B84 77F400 FFFFFE  3 665025457         move    #-2,n7
P:0B86 000000         2 665225458         nop
P:0B87 686F00         4 665625459         move    r0,y:(r7+n7)
                            25464 
                            25465 ; 925  |
                            25466 ; 926  |        // The XING header should be just right after ID3V2 tag
                            25467 ; 927  |        //this will leave the file position at where the function entered if no XING header, or just after the XING header
                            25468 ; 928  |        MP3MetaDataReadVBRHeaders(iHandle,pMetaData);
                            25469 
P:0B88 0BF080 rrrrrr  6 666225471         jsr     FMP3MetaDataReadVBRHeaders
                            25476 
                            25477 ; 929  |
                            25478 ; 930  |        // Do a fast scan, looking for "FF" in the file.
                            25479 ; 931  |        // ScanForFF returns at the first FF byte, or with an Error Code
                            25480 ; 932  |        rtn = ScanForFF(iHandle, (WORD)MP3_SYNC_THRESHOLD, pMetaData);
                            25481 
P:0B8A 77F400 FFFFFD  3 666525483         move    #-3,n7
P:0B8C 000000         2 666725484         nop
P:0B8D 5EEF00         4 667125485         move    y:(r7+n7),a
P:0B8E 77F400 FFFFFE  3 667425488         move    #-2,n7
P:0B90 000000         2 667625489         nop
P:0B91 68EF00         4 668025490         move    y:(r7+n7),r0
P:0B92 57F400 011170  3 668325493         move    #70000,b
P:0B94 0BF080 rrrrrr  6 668925494         jsr     FScanForFF
P:0B96 045FA0         2 669125499         movec   m0,n7
P:0B97 000000         2 669325500         nop
P:0B98 5E6F00         4 669725501         move    a,y:(r7+n7)
                            25503 
                            25504 ; 933  |
                            25505 ; 934  |        if (rtn == SUCCESS)
                            25506 
P:0B99 200003         2 669925508         tst     a
P:0B9A 0AF0A2 rrrrrr  6 670525509         jne     L431
P:0B9C 77F400 FFFFFD  3 670825510         move    #-3,n7
P:0B9E 000000         2 671025511         nop
P:0B9F 5EEF00         4 671425512         move    y:(r7+n7),a
P:0BA0 77F400 FFFFFE  3 671725515         move    #-2,n7
P:0BA2 000000         2 671925516         nop
P:0BA3 68EF00         4 672325517         move    y:(r7+n7),r0
                            25520 
                            25521 ; 935  |        {
                            25522 ; 936  |                // search for frame header to get sample rate and bitrate
                            25523 ; 937  |                rtn = GetMp3FrameInfo(pMetaData, iHandle);
                            25524 
P:0BA4 0BF080 rrrrrr  6 672925526         jsr     FGetMp3FrameInfo
P:0BA6 045FA0         2 673125531         movec   m0,n7
P:0BA7 000000         2 673325532         nop
P:0BA8 5E6F00         4 673725533         move    a,y:(r7+n7)
                            25534 
                            25535 ; 938  |
                            25536 ; 939  |                if (rtn != META_DATA_FOUND)
                            25537 
P:0BA9 200003         2 673925539         tst     a
P:0BAA 0AF0AA rrrrrr  6 674525540         jeq     L427
                            25541 
                            25542 ; 940  |                {
                            25543 ; 941  |                        FSFileClose(iHandle);
                            25544 
P:0BAC 77F400 FFFFFD  3 674825546         move    #-3,n7
P:0BAE 000000         2 675025547         nop
P:0BAF 5EEF00         4 675425548         move    y:(r7+n7),a
P:0BB0 0BF080 rrrrrr  6 676025549         jsr     FFSFileClose
                            25553 
                            25554 ; 942  |
                            25555 ; 943  |                        return rtn;
                            25556 
P:0BB2 0AF080 rrrrrr  6 676625558         jmp     L431
                            25559 
                            25560 ; 944  |                }
                            25561 ; 945  |
                            25562 ; 946  |                // calculate time for files with no Xing header
                            25563 ; 947  |                if ((pMetaData->dwNumFrames == 0) || (pMetaData->iTime == 0))
                            25564 
P:0BB4 3D1700         2 676825566 L427:   move    #23,n5
P:0BB5 77F400 FFFFFE  3 677125567         move    #-2,n7
P:0BB7 000000         2 677325568         nop
P:0BB8 6DEF00         4 677725569         move    y:(r7+n7),r5
P:0BB9 000000         2 677925570         nop
P:0BBA 044D16         4 678325571         lua     (r5)+n5,r6
P:0BBB 000000         2 678525574         nop
P:0BBC 205E00         2 678725575         move    (r6)+
P:0BBD 5FD600         2 678925576         move    y:(r6)-,b
P:0BBE 59E600         2 679125577         move    y:(r6),b0
P:0BBF 2B0000         2 679325578         move    #0,b2
P:0BC0 20000B         2 679525579         tst     b
P:0BC1 0AF0AA rrrrrr  6 680125580         jeq     L428
P:0BC3 3D0F00         2 680325581         move    #15,n5
P:0BC4 000000         2 680525582         nop
P:0BC5 044D16         4 680925583         lua     (r5)+n5,r6
P:0BC6 000000         2 681125584         nop
P:0BC7 205E00         2 681325585         move    (r6)+
P:0BC8 5ED600         2 681525586         move    y:(r6)-,a
P:0BC9 58E600         2 681725587         move    y:(r6),a0
P:0BCA 200003         2 681925588         tst     a
P:0BCB 0AF0A2 rrrrrr  6 682525589         jne     L429
                            25590 
                            25591 ; 948  |                        pMetaData->iTime = (INT) (pMetaData->dwNumBytes * (DWORD)8 / (pMetaData->wBitRate * (WORD) 1000));
                            25592 
P:0BCD 3D1300         2 682725594 L428:   move    #19,n5
P:0BCE 000000         2 682925595         nop
P:0BCF 044D16         4 683325596         lua     (r5)+n5,r6
P:0BD0 000000         2 683525597         nop
P:0BD1 205E00         2 683725598         move    (r6)+
P:0BD2 5ED600         2 683925599         move    y:(r6)-,a
P:0BD3 58E600         2 684125600         move    y:(r6),a0
P:0BD4 060380 rrrrrr  6 684725601         do      #3,L432
P:0BD6 200032         2 684925603         asl     a
P:0BD7 000000         2 685125604         nop
                         (4)25605 L432:
P:0BD8 3D0E00         2 685325607         move    #14,n5
P:0BD9 000000         2 685525608         nop
P:0BDA 044D16         4 685925609         lua     (r5)+n5,r6
P:0BDB 000000         2 686125610         nop
P:0BDC 4EE600         2 686325611         move    y:(r6),y0
P:0BDD 47F400 0003E8  3 686625612         move    #1000,y1
P:0BDF 2000B8         2 686825613         mpy     y0,y1,b
P:0BE0 20002A         2 687025614         asr     b
P:0BE1 212600         2 687225615         move    b0,y0
P:0BE2 270000         2 687425616         move    #0,y1
P:0BE3 0BF080 rrrrrr  6 688025617         jsr     Rdiv_ululul
P:0BE5 210E00         2 688225618         move    a0,a
P:0BE6 218800         2 688425619         move    a1,a0
P:0BE7 214C00         2 688625620         move    a2,a1
P:0BE8 3D0F00         2 688825621         move    #15,n5
P:0BE9 000000         2 689025622         nop
P:0BEA 044D16         4 689425623         lua     (r5)+n5,r6
P:0BEB 000000         2 689625624         nop
P:0BEC 585E00         2 689825625         move    a0,y:(r6)+
P:0BED 5C5600         2 690025626         move    a1,y:(r6)-
                            25627 
                            25628 ; 949  |
                            25629 ; 950  |                Mp3DecoderStartFrameFilePosition = pMetaData->dwStartPos;
                            25630 
P:0BEE 3D1100         2 690225632 L429:   move    #17,n5
P:0BEF 000000         2 690425633         nop
P:0BF0 044D16         4 690825634         lua     (r5)+n5,r6
P:0BF1 000000         2 691025635         nop
P:0BF2 205E00         2 691225636         move    (r6)+
P:0BF3 5ED600         2 691425637         move    y:(r6)-,a
P:0BF4 58E600         2 691625638         move    y:(r6),a0
P:0BF5 5C7000 rrrrrr  3 691925639         move    a1,y:FMp3DecoderStartFrameFilePosition+1
P:0BF7 587000 rrrrrr  3 692225640         move    a0,y:FMp3DecoderStartFrameFilePosition
                            25641 
                            25642 ; 951  |
                            25643 ; 952  |        }
                            25644 ; 953  |        return rtn;
                            25645 
P:0BF9 045FA0         2 692425647 L431:   movec   m0,n7
P:0BFA 000000         2 692625648         nop
P:0BFB 5EEF00         4 693025649         move    y:(r7+n7),a
                            25652 
                            25653 ; 954  |}
                            25654 
P:0BFC 77F400 FFFFFC  3 693325656         move    #-4,n7
P:0BFE 000000         2 693525657         nop
P:0BFF 05EF7C         4 693925658         movec   y:(r7+n7),ssh
P:0C00 204F00         2 694125660         move    (r7)+n7
P:0C01 00000C         4 694525662         rts
                            25670 
                            25673 
Y:0000                      25674         org     y,".ybssvbr",bss:
                            25675 Fg_VBRHeaderData:
Y:0000                      25676         ds      10
   |   RESERVED                   
Y:0009
                            25686 Fg_VBRGlobalData:
Y:000A                      25687         ds      4
   |   RESERVED                   
Y:000D
                            25690 
                            25691         extern  Rdiv_lll, Rdiv_uiuiui, Rdiv_ululul, unpack_data
                            25692         extern  FFSFileClose, FFSFileRead
                            25693         extern  y:FMp3DecoderStartFrameFilePosition, Ffseek, Fftell
                            25694         extern  y:Fg_wVBRSignature, y:Fg_wVBRTOCTable
                            25695 
                            25696         global  FExtractI4, FExtractIVar, FExtractMp3Frame
                            25697         global  FFileReadWithSync, FGetFrameLength, FGetMp3FrameInfo
                            25698         global  FGetMp3Rates, FGetVBRiHeader, FGetXingHeader
                            25699         global  FMP3MetaDataReadNonID3Info, FMP3MetaDataReadVBRHeaders
                            25700         global  FScanForFF, Fg_VBRGlobalData, Fg_VBRHeaderData
                            25701         global  Fg_wFrameLengthInBytes, FwBitRateIndex1, FwBitRateIndex2
                            25702         global  FwBitRateIndex3, FwBitRateIndex4, FwBitRateIndex5
                            25703         global  FwMPEG1SampRate, FwMPEG2SampRate, FwMPEG2pt5SampRate
                            25704 
                            25705         local   L12, L13, L15, L16, L17, L18, L19, L22, L23, L24, L25, L26
                            25706         local   L85, L86, L87, L89, L92, L93, L94, L96, L97, L98, L99, L101
                            25707         local   L102, L103, L106, L107, L108, L109, L111, L112, L113, L114
                            25708         local   L115, L152, L153, L154, L156, L159, L160, L161, L163, L164
                            25709         local   L165, L167, L168, L170, L171, L172, L173, L174, L175, L176
                            25710         local   L177, L181, L317, L318, L319, L320, L322, L325, L328, L329
                            25711         local   L330, L331, L334, L335, L336, L341, L342, L343, L344, L347
                            25712         local   L348, L349, L350, L351, L352, L353, L354, L355, L356, L357
                            25713         local   L358, L359, L360, L361, L362, L363, L365, L367, L370, L371
                            25714         local   L372, L373, L385, L386, L388, L389, L390, L391, L392, L394
                            25715         local   L395, L396, L402, L403, L404, L406, L407, L408, L409, L410
                            25716         local   L411, L412, L416, L427, L428, L429, L431, L432
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  96

M:ADDR CODE           CYCLES LINE SOURCELINE
                            25717 
                            25718         calls   "ExtractMp3Frame", "FSFileRead", "unpack_data"
                            25719         calls   "FileReadWithSync", "FSFileRead", "fseek"
                            25720         calls   "GetFrameLength", "Rdiv_lll", "Rdiv_uiuiui"
                            25721         calls   "GetMp3FrameInfo", "ExtractMp3Frame", "GetFrameLength"
                            25722         calls   "GetMp3FrameInfo", "GetMp3Rates", "Rdiv_ululul", "fseek"
                            25723         calls   "GetVBRiHeader", "ExtractIVar", "Rdiv_uiuiui"
                            25724         calls   "GetVBRiHeader", "Rdiv_ululul", "unpack_data"
                            25725         calls   "GetXingHeader", "ExtractI4", "Rdiv_uiuiui", "Rdiv_ululul"
                            25726         calls   "GetXingHeader", "unpack_data"
                            25727         calls   "MP3MetaDataReadNonID3Info", "FSFileClose"
                            25728         calls   "MP3MetaDataReadNonID3Info", "GetMp3FrameInfo"
                            25729         calls   "MP3MetaDataReadNonID3Info", "MP3MetaDataReadVBRHeaders"
                            25730         calls   "MP3MetaDataReadNonID3Info", "Rdiv_ululul", "ScanForFF"
                            25731         calls   "MP3MetaDataReadVBRHeaders", "FileReadWithSync"
                            25732         calls   "MP3MetaDataReadVBRHeaders", "GetVBRiHeader"
                            25733         calls   "MP3MetaDataReadVBRHeaders", "GetXingHeader", "fseek"
                            25734         calls   "MP3MetaDataReadVBRHeaders", "ftell"
                            25735         calls   "ScanForFF", "FSFileRead", "fseek"
                            25736 
