TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   1
C:\STMP3XXX_SDK_FIRMWARE_320_finalfix\Projects\SDK\lcdexample\usbmsc\Make\cc871f2b.src
M:ADDR CODE           CYCLES LINE SOURCELINE
                                1 ; TASKING DSP2410 C compiler v1.5r1 Build 208 SN 00100122
                                2 ; options: -OG -si -w68 -w66 -I..\output_3500\include
                                3 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\usbmsc -I -I..\..
                                4 ;          -I..\..\..\..\..\inc -I..\..\..\..\..\System\Common
                                5 ;          -I..\..\..\..\..\System\Common\symbols -I
                                6 ;          -I..\..\..\..\..\Algorithms\DRM\janus\src\h
                                7 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                                8 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                                9 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               10 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               11 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               12 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\Media
                               13 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\HAL\include
                               14 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               15 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive\include
                               16 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               17 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               18 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive
                               19 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               20 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive\include
                               21 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               22 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               23 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive
                               24 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               25 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media\include
                               26 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               27 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               28 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media
                               29 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               30 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               31 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               32 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               33 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive\include
                               34 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               35 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               36 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive
                               37 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include -I
                               38 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               39 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               40 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               41 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               42 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               43 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               44 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               45 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               46 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common
                               47 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               48 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive\include
                               49 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               50 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               51 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive
                               52 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               53 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media\include
                               54 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               55 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               56 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media
                               57 ;          -I..\..\..\..\..\devicedriver\media\include
                               58 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               59 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               60 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               61 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               62 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   2

M:ADDR CODE           CYCLES LINE SOURCELINE
                               63 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               64 ;          -I..\..\..\..\..\DeviceDriver\Media\include
                               65 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash\include
                               66 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash
                               67 ;          -I..\..\..\..\..\system\common\resourcemanager -I..\..\..\..\..\inc
                               68 ;          -I..\..\..\..\..\DeviceDriver\Media\usb\Ch9
                               69 ;          -I..\..\..\..\..\DeviceDriver\Media\scsi
                               70 ;          -I..\..\..\..\..\DeviceDriver\Media\usbmsc
                               71 ;          -I..\..\..\..\..\DeviceDriver\Media\mtp
                               72 ;          -I..\..\..\..\..\System\Common\updater
                               73 ;          -I..\..\..\..\..\libsource\sysserialnumber -DALL -DD3500 -DMMC
                               74 ;          -DLIION -DTUNER_STFM1000 -DSTFM1000_LCD=TRUE -DDCDC_POWER_TRANSFER
                               75 ;          -DBACKLIGHT -DWMAAPI_NO_DRM -DREVB_ENGR_BD -DSED15XX_LCD -DFAT16
                               76 ;          -DDEVICE_3500 -DENGR_BD -DUSBMSC_BUILD -DBATTERY_TYPE_LI_ION
                               77 ;          -DBATTERY_CHARGE -DUSE_PLAYLIST3_HOST -DASCII_ONLY -DRETAIL
                               78 ;          -DDEVICE_3500 -DMMC -Dk_opt_performance_enhancement
                               79 ;          -I..\..\..\..\..\devicedriver\display
                               80 ;          -I..\..\..\..\..\System\MsgModules\Hardware\Display -g -O2 -R -Cs
                               81 ;          -MmyL
                               82 
                               90 
                               91 ;descriptors_350:
                               92 ; 1    |////////////////////////////////////////////////////////////////////////////////
                               93 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2004
                               94 ; 3    |//
                               95 ; 4    |// File : Descriptors.c
                               96 ; 5    |// Description : This file only supports
                               97 ; 6    |//                  1. 1 Language (English)
                               98 ; 7    |//                  2. Descriptor up to 255 bytes in size 
                               99 ; 8    |////////////////////////////////////////////////////////////////////////////////
                              100 ; 9    |#include "usb_api.h"
                              101 
                              103 
                              104 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              105 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                              106 ; 3    |//
                              107 ; 4    |// File : USB_API.H
                              108 ; 5    |// Description : USB_API.H defines and structures definition for USB device
                              109 ; 6    |//               driver API.
                              110 ; 7    |//               This 
                              111 ; 8    |////////////////////////////////////////////////////////////////////////////////
                              112 ; 9    |
                              113 ; 10   |#ifndef __usb_api_h__
                              114 ; 11   |#define __usb_api_h__ 1
                              115 ; 12   |
                              116 ; 13   |#include "types.h"
                              117 
                              119 
                              120 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              121 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              122 ; 3    |//
                              123 ; 4    |// Filename: types.h
                              124 ; 5    |// Description: Standard data types
                              125 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              126 ; 7    |
                              127 ; 8    |#ifndef _TYPES_H
                              128 ; 9    |#define _TYPES_H
                              129 ; 10   |
                              130 ; 11   |// TODO:  move this outta here!
                              131 ; 12   |#if !defined(NOERROR)
                              132 ; 13   |#define NOERROR 0
                              133 ; 14   |#define SUCCESS 0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   3

M:ADDR CODE           CYCLES LINE SOURCELINE
                              134 ; 15   |#endif 
                              135 ; 16   |#if !defined(SUCCESS)
                              136 ; 17   |#define SUCCESS  0
                              137 ; 18   |#endif
                              138 ; 19   |#if !defined(ERROR)
                              139 ; 20   |#define ERROR   -1
                              140 ; 21   |#endif
                              141 ; 22   |#if !defined(FALSE)
                              142 ; 23   |#define FALSE 0
                              143 ; 24   |#endif
                              144 ; 25   |#if !defined(TRUE)
                              145 ; 26   |#define TRUE  1
                              146 ; 27   |#endif
                              147 ; 28   |
                              148 ; 29   |#if !defined(NULL)
                              149 ; 30   |#define NULL 0
                              150 ; 31   |#endif
                              151 ; 32   |
                              152 ; 33   |#define MAX_INT     0x7FFFFF
                              153 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              154 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              155 ; 36   |#define MAX_ULONG   (-1) 
                              156 ; 37   |
                              157 ; 38   |#define WORD_SIZE   24              // word size in bits
                              158 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              159 ; 40   |
                              160 ; 41   |
                              161 ; 42   |#define BYTE    unsigned char       // btVarName
                              162 ; 43   |#define CHAR    signed char         // cVarName
                              163 ; 44   |#define USHORT  unsigned short      // usVarName
                              164 ; 45   |#define SHORT   unsigned short      // sVarName
                              165 ; 46   |#define WORD    unsigned int        // wVarName
                              166 ; 47   |#define INT     signed int          // iVarName
                              167 ; 48   |#define DWORD   unsigned long       // dwVarName
                              168 ; 49   |#define LONG    signed long         // lVarName
                              169 ; 50   |#define BOOL    unsigned int        // bVarName
                              170 ; 51   |#define FRACT   _fract              // frVarName
                              171 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              172 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              173 ; 54   |#define FLOAT   float               // fVarName
                              174 ; 55   |#define DBL     double              // dVarName
                              175 ; 56   |#define ENUM    enum                // eVarName
                              176 ; 57   |#define CMX     _complex            // cmxVarName
                              177 ; 58   |typedef WORD UCS3;                   // 
                              178 ; 59   |
                              179 ; 60   |#define UINT16  unsigned short
                              180 ; 61   |#define UINT8   unsigned char   
                              181 ; 62   |#define UINT32  unsigned long
                              182 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                              183 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                              184 ; 65   |#define WCHAR   UINT16
                              185 ; 66   |
                              186 ; 67   |//UINT128 is 16 bytes or 6 words
                              187 ; 68   |typedef struct UINT128_3500 {   
                              188 ; 69   |    int val[6];     
                              189 ; 70   |} UINT128_3500;
                              190 ; 71   |
                              191 ; 72   |#define UINT128   UINT128_3500
                              192 ; 73   |
                              193 ; 74   |// Little endian word packed byte strings:   
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   4

M:ADDR CODE           CYCLES LINE SOURCELINE
                              194 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              195 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              196 ; 77   |// Little endian word packed byte strings:   
                              197 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              198 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              199 ; 80   |
                              200 ; 81   |// Declare Memory Spaces To Use When Coding
                              201 ; 82   |// A. Sector Buffers
                              202 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              203 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              204 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              205 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              206 
                              208 
                              209 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              210 ; 88   |// B. Media DDI Memory
                              211 ; 89   |#define MEDIA_DDI_MEM _Y
                              212 ; 90   |
                              213 ; 91   |
                              214 ; 92   |
                              215 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              216 ; 94   |// Examples of circular pointers:
                              217 ; 95   |//    INT CIRC cpiVarName
                              218 ; 96   |//    DWORD CIRC cpdwVarName
                              219 ; 97   |
                              220 ; 98   |#define RETCODE INT                 // rcVarName
                              221 ; 99   |
                              222 ; 100  |// generic bitfield structure
                              223 ; 101  |struct Bitfield {
                              224 ; 102  |    unsigned int B0  :1;
                              225 ; 103  |    unsigned int B1  :1;
                              226 ; 104  |    unsigned int B2  :1;
                              227 ; 105  |    unsigned int B3  :1;
                              228 ; 106  |    unsigned int B4  :1;
                              229 ; 107  |    unsigned int B5  :1;
                              230 ; 108  |    unsigned int B6  :1;
                              231 ; 109  |    unsigned int B7  :1;
                              232 ; 110  |    unsigned int B8  :1;
                              233 ; 111  |    unsigned int B9  :1;
                              234 ; 112  |    unsigned int B10 :1;
                              235 ; 113  |    unsigned int B11 :1;
                              236 ; 114  |    unsigned int B12 :1;
                              237 ; 115  |    unsigned int B13 :1;
                              238 ; 116  |    unsigned int B14 :1;
                              239 ; 117  |    unsigned int B15 :1;
                              240 ; 118  |    unsigned int B16 :1;
                              241 ; 119  |    unsigned int B17 :1;
                              242 ; 120  |    unsigned int B18 :1;
                              243 ; 121  |    unsigned int B19 :1;
                              244 ; 122  |    unsigned int B20 :1;
                              245 ; 123  |    unsigned int B21 :1;
                              246 ; 124  |    unsigned int B22 :1;
                              247 ; 125  |    unsigned int B23 :1;
                              248 ; 126  |};
                              249 ; 127  |
                              250 ; 128  |union BitInt {
                              251 ; 129  |        struct Bitfield B;
                              252 ; 130  |        int        I;
                              253 ; 131  |};
                              254 ; 132  |
                              255 ; 133  |#define MAX_MSG_LENGTH 10
                              256 ; 134  |struct CMessage
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   5

M:ADDR CODE           CYCLES LINE SOURCELINE
                              257 ; 135  |{
                              258 ; 136  |        unsigned int m_uLength;
                              259 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              260 ; 138  |};
                              261 ; 139  |
                              262 ; 140  |typedef struct {
                              263 ; 141  |    WORD m_wLength;
                              264 ; 142  |    WORD m_wMessage;
                              265 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              266 ; 144  |} Message;
                              267 ; 145  |
                              268 ; 146  |struct MessageQueueDescriptor
                              269 ; 147  |{
                              270 ; 148  |        int *m_pBase;
                              271 ; 149  |        int m_iModulo;
                              272 ; 150  |        int m_iSize;
                              273 ; 151  |        int *m_pHead;
                              274 ; 152  |        int *m_pTail;
                              275 ; 153  |};
                              276 ; 154  |
                              277 ; 155  |struct ModuleEntry
                              278 ; 156  |{
                              279 ; 157  |    int m_iSignaledEventMask;
                              280 ; 158  |    int m_iWaitEventMask;
                              281 ; 159  |    int m_iResourceOfCode;
                              282 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              283 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                              284 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              285 ; 163  |    int m_uTimeOutHigh;
                              286 ; 164  |    int m_uTimeOutLow;
                              287 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              288 ; 166  |};
                              289 ; 167  |
                              290 ; 168  |union WaitMask{
                              291 ; 169  |    struct B{
                              292 ; 170  |        unsigned int m_bNone     :1;
                              293 ; 171  |        unsigned int m_bMessage  :1;
                              294 ; 172  |        unsigned int m_bTimer    :1;
                              295 ; 173  |        unsigned int m_bButton   :1;
                              296 ; 174  |    } B;
                              297 ; 175  |    int I;
                              298 ; 176  |} ;
                              299 ; 177  |
                              300 ; 178  |
                              301 ; 179  |struct Button {
                              302 ; 180  |        WORD wButtonEvent;
                              303 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              304 ; 182  |};
                              305 ; 183  |
                              306 ; 184  |struct Message {
                              307 ; 185  |        WORD wMsgLength;
                              308 ; 186  |        WORD wMsgCommand;
                              309 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              310 ; 188  |};
                              311 ; 189  |
                              312 ; 190  |union EventTypes {
                              313 ; 191  |        struct CMessage msg;
                              314 ; 192  |        struct Button Button ;
                              315 ; 193  |        struct Message Message;
                              316 ; 194  |};
                              317 ; 195  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   6

M:ADDR CODE           CYCLES LINE SOURCELINE
                              318 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              319 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              320 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              321 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              322 ; 200  |
                              323 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              324 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              325 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              326 ; 204  |
                              327 ; 205  |#if DEBUG
                              328 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              329 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              330 ; 208  |#else 
                              331 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                              332 ; 210  |#define DebugBuildAssert(x)    
                              333 ; 211  |#endif
                              334 ; 212  |
                              335 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              336 ; 214  |//  #pragma asm
                              337 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              338 ; 216  |//  #pragma endasm
                              339 ; 217  |
                              340 ; 218  |
                              341 ; 219  |#ifdef COLOR_262K
                              342 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                              343 ; 221  |#elif defined(COLOR_65K)
                              344 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                              345 ; 223  |#else
                              346 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                              347 ; 225  |#endif
                              348 ; 226  |    
                              349 ; 227  |#endif // #ifndef _TYPES_H
                              350 
                              352 
                              353 ; 14   |#include "project.h"
                              354 
                              356 
                              357 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                              358 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                              359 ; 3    |//  Filename: project.inc
                              360 ; 4    |//  Description: 
                              361 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                              362 ; 6    |
                              363 ; 7    |#if (!defined(_PROJECT_INC))
                              364 ; 8    |#define _PROJECT_INC 1
                              365 ; 9    |
                              366 ; 10   |#if defined(STMP_BUILD_PLAYER)
                              367 ; 11   |#include "hwequ.h"
                              368 ; 12   |#else 
                              369 ; 13   |//include "regscodec.inc"
                              370 ; 14   |#endif
                              371 ; 15   |
                              372 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                              373 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults
                                   ON) & 
                              374 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm
                                  . STMP00012148
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   7

M:ADDR CODE           CYCLES LINE SOURCELINE
                              375 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal
                                  ). 
                              376 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's spe
                                  cs can 
                              377 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player m
                                  ode.  
                              378 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                              379 ; 23   |
                              380 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                              381 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                              382 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                              383 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define bel
                                  ow by defining
                              384 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                              385 ; 29   |#define ATTEMPT_FAST_BOOT 1
                              386 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                              387 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot 
                                  config above- 
                              388 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down thresh
                                  holds by maybe 50mV.
                              389 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed
                                  .
                              390 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                              391 ; 35   |
                              392 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                              393 ; 37   |// MEDIA DEFINITIONS
                              394 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                              395 ; 39   |
                              396 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                              397 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                              398 ; 42   |#if defined(NAND1)
                              399 ; 43   |#define SM_INTERNAL_CHIPS 1
                              400 ; 44   |#else 
                              401 ; 45   |#if defined(NAND2)
                              402 ; 46   |#define SM_INTERNAL_CHIPS 2
                              403 ; 47   |#else 
                              404 ; 48   |#if defined(NAND3)
                              405 ; 49   |#define SM_INTERNAL_CHIPS 3
                              406 ; 50   |#else 
                              407 ; 51   |#if defined(NAND4)
                              408 ; 52   |#define SM_INTERNAL_CHIPS 4
                              409 ; 53   |#else 
                              410 ; 54   |#define SM_INTERNAL_CHIPS 1
                              411 ; 55   |#endif
                              412 ; 56   |#endif
                              413 ; 57   |#endif
                              414 ; 58   |#endif
                              415 ; 59   |
                              416 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                              417 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                              418 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it rea
                                  ds 0.  
                              419 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                              420 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it rea
                                  ds 1.
                              421 ; 65   |//*** comment out if active high ****
                              422 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                              423 ; 67   |
                              424 ; 68   |#if defined(SMEDIA)
                              425 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                              426 ; 70   |#define NUM_SM_EXTERNAL 1
                              427 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   8

M:ADDR CODE           CYCLES LINE SOURCELINE
                              428 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                              429 ; 73   |#else 
                              430 ; 74   |#if defined(MMC)
                              431 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                              432 ; 76   |#define NUM_SM_EXTERNAL 0
                              433 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                              434 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                              435 ; 79   |#else 
                              436 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                              437 ; 81   |#define NUM_SM_EXTERNAL 0
                              438 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                              439 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                              440 ; 84   |#endif
                              441 ; 85   |#endif
                              442 ; 86   |
                              443 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                              444 ; 88   |// Mass Storage Class definitions
                              445 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                              446 ; 90   |// Set to 0 if Composite Device build is desired.    
                              447 ; 91   |#define MULTI_LUN_BUILD 1   
                              448 ; 92   |
                              449 ; 93   |////////////////////////////////////////////////////////////////////////////////
                              450 ; 94   |//  SCSI
                              451 ; 95   |#if (MULTI_LUN_BUILD==0)
                              452 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                              453 ; 97   |    #define SCSI_NUM_TARGETS                        2
                              454 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              455 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                              456 ; 100  |  #else
                              457 ; 101  |    #define SCSI_NUM_TARGETS                        1
                              458 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              459 ; 103  |  #endif
                              460 ; 104  |#else
                              461 ; 105  |    #define SCSI_NUM_TARGETS                        1
                              462 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                              463 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                              464 ; 108  |  #else
                              465 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                              466 ; 110  |  #endif
                              467 ; 111  |#endif
                              468 ; 112  |
                              469 ; 113  |
                              470 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                              471 ; 115  |
                              472 ; 116  |
                              473 ; 117  |////////////////////////////////////////////////////////////////////////////////
                              474 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                              475 ; 119  |////////////////////////////////////////////////////////////////////////////////
                              476 ; 120  |#ifdef MMC
                              477 ; 121  |#ifdef MTP_BUILD
                              478 ; 122  |// --------------------
                              479 ; 123  |// MTP and MMC
                              480 ; 124  |// --------------------
                              481 ; 125  |#define NUM_LOGICAL_MEDIA       2
                              482 ; 126  |#define NUM_LOGICAL_DRIVES      8
                              483 ; 127  |#else  // ifndef MTP_BUILD
                              484 ; 128  |#ifdef STMP_BUILD_PLAYER
                              485 ; 129  |// --------------------
                              486 ; 130  |// Player and MMC
                              487 ; 131  |// --------------------
                              488 ; 132  |#else
                              489 ; 133  |// --------------------
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   9

M:ADDR CODE           CYCLES LINE SOURCELINE
                              490 ; 134  |// USBMSC and MMC
                              491 ; 135  |// --------------------
                              492 ; 136  |#define NUM_LOGICAL_MEDIA       3
                              493 ; 137  |#define NUM_LOGICAL_DRIVES      8
                              494 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                              495 ; 139  |#endif // ifdef MTP_BUILD
                              496 ; 140  |#else  // ifndef MMC
                              497 ; 141  |#ifdef MTP_BUILD
                              498 ; 142  |// --------------------
                              499 ; 143  |// MTP and NAND only
                              500 ; 144  |// --------------------
                              501 ; 145  |#define NUM_LOGICAL_MEDIA       1
                              502 ; 146  |#define NUM_LOGICAL_DRIVES      7
                              503 ; 147  |#else  // ifndef MTP_BUILD
                              504 ; 148  |#ifdef STMP_BUILD_PLAYER
                              505 ; 149  |// --------------------
                              506 ; 150  |// Player and NAND only
                              507 ; 151  |// --------------------
                              508 ; 152  |#else
                              509 ; 153  |// --------------------
                              510 ; 154  |// USBMSC and NAND only
                              511 ; 155  |// --------------------
                              512 ; 156  |#define NUM_LOGICAL_MEDIA       2
                              513 ; 157  |#define NUM_LOGICAL_DRIVES      7
                              514 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                              515 ; 159  |#endif // ifdef MTP_BUILD
                              516 ; 160  |#endif // ifdef MMC 
                              517 ; 161  |
                              518 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                              519 ; 163  |#if (defined(MTP_BUILD))
                              520 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                              521 ; 165  |
                              522 ; 166  |////!
                              523 ; 167  |////! This varible holds the watchdog count for the store flush.
                              524 ; 168  |////!
                              525 ; 169  |///
                              526 ; 170  |#include <types.h>
                              527 ; 171  |extern volatile INT g_StoreWatchDogCount;
                              528 ; 172  |extern const INT g_StoreWatchDogTimeout;
                              529 ; 173  |#endif
                              530 ; 174  |
                              531 ; 175  |////////////////////////////////////////////////////////////////////////////////
                              532 ; 176  |// These are needed here for Mass Storage Class
                              533 ; 177  |// Needs to be cleaned up
                              534 ; 178  |////////////////////////////////////////////////////////////////////////////////
                              535 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                              536 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                              537 ; 181  |#define SCRATCH_USER_X_SIZE 512
                              538 ; 182  |
                              539 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                              540 ; 184  |
                              541 ; 185  |#endif
                              542 ; 186  |
                              543 ; 187  |
                              544 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                              545 ; 189  |// SmartMedia/NAND defs
                              546 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                              547 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                              548 ; 192  |
                              549 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                              550 ; 194  |// Sysloadresources defs
                              551 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  10

M:ADDR CODE           CYCLES LINE SOURCELINE
                              552 ; 196  |
                              553 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                              554 ; 198  |// MMC defs
                              555 ; 199  |#define MMC_MAX_PARTITIONS 1
                              556 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                              557 ; 201  |
                              558 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                              559 ; 203  |// SPI defs
                              560 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                              561 ; 205  |
                              562 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                              563 ; 207  |// Global media defs
                              564 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                              565 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                              566 ; 210  |
                              567 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                              568 ; 212  |// DO NOT CHANGE THESE!!!
                              569 ; 213  |#define SM_MAX_PARTITIONS 4
                              570 ; 214  |#define MAX_HANDLES 2
                              571 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                              572 ; 216  |
                              573 ; 217  |
                              574 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                              575 ; 219  |// Battery LRADC Values 
                              576 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                              577 ; 221  |// brownout trip point in mV (moved by RS)
                              578 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                              579 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                              580 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                              581 ; 225  |//     audio recording to media.
                              582 ; 226  |#define BATT_SAFETY_MARGIN 10
                              583 ; 227  |
                              584 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                                  
                              585 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline vol
                                  tage to do a refresh.
                              586 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                              587 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                              588 ; 232  |
                              589 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc 
                                  presence.
                              590 ; 234  |
                              591 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                              592 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat che
                                  ck.
                              593 ; 237  |#if (!defined(CLCD))
                              594 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                              595 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                              596 ; 240  |#else 
                              597 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                              598 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                              599 ; 243  |#endif
                              600 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                              601 ; 245  |
                              602 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                              603 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIo
                                  n.
                              604 ; 248  |// See mp3 encoder overlay.
                              605 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                              606 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                              607 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                              608 ; 252  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  11

M:ADDR CODE           CYCLES LINE SOURCELINE
                              609 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                              610 ; 254  |// Voice recording filenames
                              611 ; 255  |// number of digits in filename Vxxx.wav
                              612 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                              613 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                              614 ; 258  |
                              615 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                              616 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                              617 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                              618 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                              619 ; 263  |#if defined(DEVICE_3500)
                              620 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                              621 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                              622 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                              623 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, 
                                  & demo player)
                              624 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                              625 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                              626 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                              627 ; 271  |
                              628 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn whe
                                  n bias not yet ready.
                              629 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                              630 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevent
                                  ion if you use rec button from outside voice menu.
                              631 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latenc
                                  y in the record-from-music-menu use-case.
                              632 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                              633 ; 277  |
                              634 ; 278  |#else 
                              635 ; 279  |// STMP3410
                              636 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                              637 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                              638 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                              639 ; 283  |#endif
                              640 ; 284  |
                              641 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                              642 ; 286  |// Number of available soft timers
                              643 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                              644 ; 288  |#if defined(SYNC_LYRICS)
                              645 ; 289  |#define SOFT_TIMERS 10
                              646 ; 290  |#else 
                              647 ; 291  |#if defined(JPEG_DECODER)
                              648 ; 292  |#define SOFT_TIMERS 10
                              649 ; 293  |#else 
                              650 ; 294  |#define SOFT_TIMERS 9
                              651 ; 295  |#endif
                              652 ; 296  |#endif
                              653 ; 297  |
                              654 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                              655 ; 299  |//  sizes
                              656 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                              657 ; 301  |#if defined(MMC)
                              658 ; 302  |#if defined(USE_PLAYLIST5)
                              659 ; 303  |#define MENU_STACK_SIZE 1500
                              660 ; 304  |#else 
                              661 ; 305  |#define MENU_STACK_SIZE 1250
                              662 ; 306  |#endif //if @def('USE_PLAYLIST5')
                              663 ; 307  |#else 
                              664 ; 308  |#if defined(USE_PLAYLIST5)
                              665 ; 309  |#define MENU_STACK_SIZE 1500
                              666 ; 310  |#else 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  12

M:ADDR CODE           CYCLES LINE SOURCELINE
                              667 ; 311  |#define MENU_STACK_SIZE 1250
                              668 ; 312  |#endif //if @def('USE_PLAYLIST5')
                              669 ; 313  |#endif //if @def('MMC')
                              670 ; 314  |
                              671 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 75
                                  0 else 550 for other builds? TOVERIFY. MYALLOC
                              672 ; 316  |// 
                              673 ; 317  |#define STACK_L1_SIZE 750
                              674 ; 318  |#define STACK_L2_SIZE 100
                              675 ; 319  |#define STACK_L3_SIZE 160
                              676 ; 320  |
                              677 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                              678 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                              679 ; 323  |// is ok with switching code.
                              680 ; 324  |#if defined(MTP_BUILD)
                              681 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                              682 ; 326  |#endif
                              683 ; 327  |
                              684 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                              685 ; 329  |// maximum number of nested funclets 
                              686 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                              687 ; 331  |#define MAX_NESTED_FUNCLET 6 
                              688 ; 332  |
                              689 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                              690 ; 334  |//    LCD DEFINITIONS
                              691 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                              692 ; 336  |
                              693 ; 337  |#define SPACE_CHAR 0x000020          
                              694 ; 338  |#define ZERO_CHAR 0x000030
                              695 ; 339  |#define COLON_CHAR 0x00003A
                              696 ; 340  |#define PERIOD_CHAR 0x00002E
                              697 ; 341  |
                              698 ; 342  |#if (defined(S6B33B0A_LCD))
                              699 ; 343  |#define LCD_X_SIZE 128
                              700 ; 344  |#define LCD_Y_SIZE 159
                              701 ; 345  |#endif
                              702 ; 346  |
                              703 ; 347  |#if (defined(SED15XX_LCD))
                              704 ; 348  |#define LCD_X_SIZE 128
                              705 ; 349  |#define LCD_Y_SIZE 64
                              706 ; 350  |#endif
                              707 ; 351  |
                              708 ; 352  |
                              709 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                              710 ; 354  |//   Details on Customizing Contrast
                              711 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                              712 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                              713 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                              714 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                              715 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                              716 ; 360  |//   unless the ezact sequence is remembered.
                              717 ; 361  |//   To find out what range your player supports: 
                              718 ; 362  |//   change these equs to full range or comment out (full range is default)
                              719 ; 363  |//;;;;;;
                              720 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                              721 ; 365  |// recommended calibration using player -- uncomment 
                              722 ; 366  |//;;;;;;
                              723 ; 367  |//CONTRAST_CALIBRATION    equ  1
                              724 ; 368  |////////////////////////////
                              725 ; 369  |#if (defined(DEMO_HW))
                              726 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi 
                                  LCD (June6'05)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  13

M:ADDR CODE           CYCLES LINE SOURCELINE
                              727 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                              728 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                              729 ; 373  |#else 
                              730 ; 374  |
                              731 ; 375  |#if (defined(S6B33B0A_LCD))
                              732 ; 376  |#define LCD_MAX_CONTRAST 210
                              733 ; 377  |#define LCD_MIN_CONTRAST 160    
                              734 ; 378  |#endif
                              735 ; 379  |
                              736 ; 380  |#if (defined(SED15XX_LCD))
                              737 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                              738 ; 382  |// Engineering board regs support range [17-37].
                              739 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                              740 ; 384  |//   One default contrast range [24-42] works for both.
                              741 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                              742 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                              743 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                              744 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                              745 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                              746 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                              747 ; 391  |
                              748 ; 392  |#if (defined(NEWSHINGYIH))
                              749 ; 393  |#define LCD_MAX_CONTRAST 250
                              750 ; 394  |#define LCD_MIN_CONTRAST 0
                              751 ; 395  |#else 
                              752 ; 396  |//-----
                              753 ; 397  |// Near optimal for OLD LCD with NEW file. 
                              754 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for bo
                                  th LCDs.
                              755 ; 399  |#define LCD_MAX_CONTRAST 250
                              756 ; 400  |#define LCD_MIN_CONTRAST 0
                              757 ; 401  |
                              758 ; 402  |//=====
                              759 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                              760 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this hi
                                  storic ver.
                              761 ; 405  |//LCD_MAX_CONTRAST equ 42
                              762 ; 406  |//LCD_MIN_CONTRAST equ 24 
                              763 ; 407  |
                              764 ; 408  |#endif
                              765 ; 409  |#endif
                              766 ; 410  |
                              767 ; 411  |#endif
                              768 ; 412  |
                              769 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                              770 ; 414  |// The default value of the lcd contrast in % of range
                              771 ; 415  |//   the default value is used when no settings.dat is available
                              772 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                              773 ; 417  |
                              774 ; 418  |#if (defined(S6B33B0A_LCD))
                              775 ; 419  |// 60% of range is default value
                              776 ; 420  |#define DEFAULT_CONTRAST 50 
                              777 ; 421  |#endif
                              778 ; 422  |
                              779 ; 423  |#if (defined(SED15XX_LCD))
                              780 ; 424  |// % of range is default value (was 60%)
                              781 ; 425  |#define DEFAULT_CONTRAST 50 
                              782 ; 426  |#endif
                              783 ; 427  |
                              784 ; 428  |
                              785 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                              786 ; 430  |// make lower when doing calibration
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  14

M:ADDR CODE           CYCLES LINE SOURCELINE
                              787 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                              788 ; 432  |
                              789 ; 433  |
                              790 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                              791 ; 435  |// For FFWD and RWND
                              792 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                              793 ; 437  |#define SECONDS_TO_SKIP 1
                              794 ; 438  |#define SECONDS_TO_SKIP1 3
                              795 ; 439  |#define SECONDS_TO_SKIP2 6
                              796 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                              797 ; 441  |#define PREV_SONG_THRESHOLD 5  
                              798 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              799 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                              800 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              801 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                              802 ; 446  |
                              803 ; 447  |// For audible FFW/RWD
                              804 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                              805 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                              806 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                              807 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                              808 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              809 ; 453  |#define LEVEL1_BOUNDARY 17 
                              810 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              811 ; 455  |#define LEVEL2_BOUNDARY 33 
                              812 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              813 ; 457  |#define LEVEL3_BOUNDARY 50 
                              814 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                              815 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                              816 ; 460  |// Short Song Time, songs too short to play.
                              817 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                              818 ; 462  |
                              819 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                              820 ; 464  |// MP3 Sync Values
                              821 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                              822 ; 466  |// # bytes to look for sync before marking it bad
                              823 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                              824 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                              825 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                              826 ; 470  |// once we have sync'd, the isr should be called this frequently
                              827 ; 471  |#define MP3_DECODERISR_FAST 7500  
                              828 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                              829 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                              830 ; 474  |
                              831 ; 475  |
                              832 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                              833 ; 477  |//// Multi-Stage Volume Control Definitions
                              834 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                              835 ; 479  |//// Use Multi-Stage Volume
                              836 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                              837 ; 481  |
                              838 ; 482  |//// Master Volume definitions
                              839 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                              840 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                              841 ; 485  |
                              842 ; 486  |//// DAC-Mode definitions
                              843 ; 487  |//// Adjusts 0dB point
                              844 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                              845 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                              846 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines 
                                  above.
                              847 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  15

M:ADDR CODE           CYCLES LINE SOURCELINE
                              848 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provid
                                  es 1.5 dB gain on Stmp34x0; 
                              849 ; 493  |//                                               Max gain possible: 8 step diff would prov
                                  ide +12dB gain.   
                              850 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                              851 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                              852 ; 496  |
                              853 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                              854 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                              855 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                                  
                              856 ; 500  |
                              857 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not t
                                  he default
                              858 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoin
                                  t.
                              859 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                              860 ; 504  |
                              861 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the def
                                  ault
                              862 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                              863 ; 507  |
                              864 ; 508  |
                              865 ; 509  |//// Line In definitions (used for Line-In 1)
                              866 ; 510  |//// 0dB point of the Line In
                              867 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                              868 ; 512  |//// Minimum volume of Line In
                              869 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                              870 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                              871 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                              872 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                              873 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                              874 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS
                                  +1)
                              875 ; 519  |
                              876 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                              877 ; 521  |//// 0dB point of the Line In
                              878 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                              879 ; 523  |//// Minimum volume of Line In
                              880 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                              881 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                              882 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                              883 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                              884 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                              885 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                              886 ; 530  |
                              887 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                              888 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid dea
                                  dlock states & recovers. 
                              889 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                              890 ; 534  |#define FM_WATCHDOG_ENABLE 1
                              891 ; 535  |
                              892 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                              893 ; 537  |////
                              894 ; 538  |////! This varible holds the lcd display state for the mtp project.
                              895 ; 539  |////
                              896 ; 540  |///
                              897 ; 541  |#include <types.h>
                              898 
                              900 
                              901 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              902 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  16

M:ADDR CODE           CYCLES LINE SOURCELINE
                              903 ; 3    |//
                              904 ; 4    |// Filename: types.h
                              905 ; 5    |// Description: Standard data types
                              906 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              907 ; 7    |
                              908 ; 8    |#ifndef _TYPES_H
                              909 ; 9    |#define _TYPES_H
                              910 ; 10   |
                              911 ; 11   |// TODO:  move this outta here!
                              912 ; 12   |#if !defined(NOERROR)
                              913 ; 13   |#define NOERROR 0
                              914 ; 14   |#define SUCCESS 0
                              915 ; 15   |#endif 
                              916 ; 16   |#if !defined(SUCCESS)
                              917 ; 17   |#define SUCCESS  0
                              918 ; 18   |#endif
                              919 ; 19   |#if !defined(ERROR)
                              920 ; 20   |#define ERROR   -1
                              921 ; 21   |#endif
                              922 ; 22   |#if !defined(FALSE)
                              923 ; 23   |#define FALSE 0
                              924 ; 24   |#endif
                              925 ; 25   |#if !defined(TRUE)
                              926 ; 26   |#define TRUE  1
                              927 ; 27   |#endif
                              928 ; 28   |
                              929 ; 29   |#if !defined(NULL)
                              930 ; 30   |#define NULL 0
                              931 ; 31   |#endif
                              932 ; 32   |
                              933 ; 33   |#define MAX_INT     0x7FFFFF
                              934 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              935 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              936 ; 36   |#define MAX_ULONG   (-1) 
                              937 ; 37   |
                              938 ; 38   |#define WORD_SIZE   24              // word size in bits
                              939 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              940 ; 40   |
                              941 ; 41   |
                              942 ; 42   |#define BYTE    unsigned char       // btVarName
                              943 ; 43   |#define CHAR    signed char         // cVarName
                              944 ; 44   |#define USHORT  unsigned short      // usVarName
                              945 ; 45   |#define SHORT   unsigned short      // sVarName
                              946 ; 46   |#define WORD    unsigned int        // wVarName
                              947 ; 47   |#define INT     signed int          // iVarName
                              948 ; 48   |#define DWORD   unsigned long       // dwVarName
                              949 ; 49   |#define LONG    signed long         // lVarName
                              950 ; 50   |#define BOOL    unsigned int        // bVarName
                              951 ; 51   |#define FRACT   _fract              // frVarName
                              952 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              953 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              954 ; 54   |#define FLOAT   float               // fVarName
                              955 ; 55   |#define DBL     double              // dVarName
                              956 ; 56   |#define ENUM    enum                // eVarName
                              957 ; 57   |#define CMX     _complex            // cmxVarName
                              958 ; 58   |typedef WORD UCS3;                   // 
                              959 ; 59   |
                              960 ; 60   |#define UINT16  unsigned short
                              961 ; 61   |#define UINT8   unsigned char   
                              962 ; 62   |#define UINT32  unsigned long
                              963 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  17

M:ADDR CODE           CYCLES LINE SOURCELINE
                              964 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                              965 ; 65   |#define WCHAR   UINT16
                              966 ; 66   |
                              967 ; 67   |//UINT128 is 16 bytes or 6 words
                              968 ; 68   |typedef struct UINT128_3500 {   
                              969 ; 69   |    int val[6];     
                              970 ; 70   |} UINT128_3500;
                              971 ; 71   |
                              972 ; 72   |#define UINT128   UINT128_3500
                              973 ; 73   |
                              974 ; 74   |// Little endian word packed byte strings:   
                              975 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              976 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              977 ; 77   |// Little endian word packed byte strings:   
                              978 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              979 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              980 ; 80   |
                              981 ; 81   |// Declare Memory Spaces To Use When Coding
                              982 ; 82   |// A. Sector Buffers
                              983 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              984 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              985 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              986 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              987 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              988 ; 88   |// B. Media DDI Memory
                              989 ; 89   |#define MEDIA_DDI_MEM _Y
                              990 ; 90   |
                              991 ; 91   |
                              992 ; 92   |
                              993 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              994 ; 94   |// Examples of circular pointers:
                              995 ; 95   |//    INT CIRC cpiVarName
                              996 ; 96   |//    DWORD CIRC cpdwVarName
                              997 ; 97   |
                              998 ; 98   |#define RETCODE INT                 // rcVarName
                              999 ; 99   |
                             1000 ; 100  |// generic bitfield structure
                             1001 ; 101  |struct Bitfield {
                             1002 ; 102  |    unsigned int B0  :1;
                             1003 ; 103  |    unsigned int B1  :1;
                             1004 ; 104  |    unsigned int B2  :1;
                             1005 ; 105  |    unsigned int B3  :1;
                             1006 ; 106  |    unsigned int B4  :1;
                             1007 ; 107  |    unsigned int B5  :1;
                             1008 ; 108  |    unsigned int B6  :1;
                             1009 ; 109  |    unsigned int B7  :1;
                             1010 ; 110  |    unsigned int B8  :1;
                             1011 ; 111  |    unsigned int B9  :1;
                             1012 ; 112  |    unsigned int B10 :1;
                             1013 ; 113  |    unsigned int B11 :1;
                             1014 ; 114  |    unsigned int B12 :1;
                             1015 ; 115  |    unsigned int B13 :1;
                             1016 ; 116  |    unsigned int B14 :1;
                             1017 ; 117  |    unsigned int B15 :1;
                             1018 ; 118  |    unsigned int B16 :1;
                             1019 ; 119  |    unsigned int B17 :1;
                             1020 ; 120  |    unsigned int B18 :1;
                             1021 ; 121  |    unsigned int B19 :1;
                             1022 ; 122  |    unsigned int B20 :1;
                             1023 ; 123  |    unsigned int B21 :1;
                             1024 ; 124  |    unsigned int B22 :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  18

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1025 ; 125  |    unsigned int B23 :1;
                             1026 ; 126  |};
                             1027 ; 127  |
                             1028 ; 128  |union BitInt {
                             1029 ; 129  |        struct Bitfield B;
                             1030 ; 130  |        int        I;
                             1031 ; 131  |};
                             1032 ; 132  |
                             1033 ; 133  |#define MAX_MSG_LENGTH 10
                             1034 ; 134  |struct CMessage
                             1035 ; 135  |{
                             1036 ; 136  |        unsigned int m_uLength;
                             1037 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1038 ; 138  |};
                             1039 ; 139  |
                             1040 ; 140  |typedef struct {
                             1041 ; 141  |    WORD m_wLength;
                             1042 ; 142  |    WORD m_wMessage;
                             1043 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1044 ; 144  |} Message;
                             1045 ; 145  |
                             1046 ; 146  |struct MessageQueueDescriptor
                             1047 ; 147  |{
                             1048 ; 148  |        int *m_pBase;
                             1049 ; 149  |        int m_iModulo;
                             1050 ; 150  |        int m_iSize;
                             1051 ; 151  |        int *m_pHead;
                             1052 ; 152  |        int *m_pTail;
                             1053 ; 153  |};
                             1054 ; 154  |
                             1055 ; 155  |struct ModuleEntry
                             1056 ; 156  |{
                             1057 ; 157  |    int m_iSignaledEventMask;
                             1058 ; 158  |    int m_iWaitEventMask;
                             1059 ; 159  |    int m_iResourceOfCode;
                             1060 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1061 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                             1062 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1063 ; 163  |    int m_uTimeOutHigh;
                             1064 ; 164  |    int m_uTimeOutLow;
                             1065 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1066 ; 166  |};
                             1067 ; 167  |
                             1068 ; 168  |union WaitMask{
                             1069 ; 169  |    struct B{
                             1070 ; 170  |        unsigned int m_bNone     :1;
                             1071 ; 171  |        unsigned int m_bMessage  :1;
                             1072 ; 172  |        unsigned int m_bTimer    :1;
                             1073 ; 173  |        unsigned int m_bButton   :1;
                             1074 ; 174  |    } B;
                             1075 ; 175  |    int I;
                             1076 ; 176  |} ;
                             1077 ; 177  |
                             1078 ; 178  |
                             1079 ; 179  |struct Button {
                             1080 ; 180  |        WORD wButtonEvent;
                             1081 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1082 ; 182  |};
                             1083 ; 183  |
                             1084 ; 184  |struct Message {
                             1085 ; 185  |        WORD wMsgLength;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  19

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1086 ; 186  |        WORD wMsgCommand;
                             1087 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1088 ; 188  |};
                             1089 ; 189  |
                             1090 ; 190  |union EventTypes {
                             1091 ; 191  |        struct CMessage msg;
                             1092 ; 192  |        struct Button Button ;
                             1093 ; 193  |        struct Message Message;
                             1094 ; 194  |};
                             1095 ; 195  |
                             1096 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1097 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1098 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1099 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1100 ; 200  |
                             1101 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1102 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1103 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1104 ; 204  |
                             1105 ; 205  |#if DEBUG
                             1106 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1107 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1108 ; 208  |#else 
                             1109 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                             1110 ; 210  |#define DebugBuildAssert(x)    
                             1111 ; 211  |#endif
                             1112 ; 212  |
                             1113 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1114 ; 214  |//  #pragma asm
                             1115 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1116 ; 216  |//  #pragma endasm
                             1117 ; 217  |
                             1118 ; 218  |
                             1119 ; 219  |#ifdef COLOR_262K
                             1120 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                             1121 ; 221  |#elif defined(COLOR_65K)
                             1122 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                             1123 ; 223  |#else
                             1124 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                             1125 ; 225  |#endif
                             1126 ; 226  |    
                             1127 ; 227  |#endif // #ifndef _TYPES_H
                             1128 
                             1130 
                             1131 ; 542  |extern volatile WORD g_wActivityState;
                             1132 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             1133 ; 544  |
                             1134 ; 545  |void _reentrant Init5VSense(void);
                             1135 ; 546  |void _reentrant ServiceDCDC(void);
                             1136 ; 547  |
                             1137 ; 548  |////////////////////////////////////////////////////////////////////////////
                             1138 ; 549  |//// JPEG Thumbnail Mode Setting
                             1139 ; 550  |//// number of column in thumbnail mode
                             1140 ; 551  |#define THUMBNAIL_X 2           
                             1141 ; 552  |//// number of row in  thumbnail mode
                             1142 ; 553  |#define THUMBNAIL_Y 2           
                             1143 ; 554  |//// thumbnail boundary offset x
                             1144 ; 555  |#define THUMBNAIL_X_OFFSET 4            
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  20

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1145 ; 556  |//// thumbnail boundary offset y
                             1146 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             1147 ; 558  |
                             1148 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             1149 ; 560  |
                             1150 
                             1152 
                             1153 ; 15   |
                             1154 ; 16   |#ifndef _USB_MEM
                             1155 ; 17   |//if not overwridden, default to the compiler default memory space
                             1156 ; 18   |#define _USB_MEM
                             1157 ; 19   |#endif
                             1158 ; 20   |
                             1159 ; 21   |#define USB_LANGUAGE_ENGLISH 0x0409
                             1160 ; 22   |#define USB_LANGUAGE_CHINESE_PRC 0x0804
                             1161 ; 23   |#define USB_LANGUAGE_CHINESE_TAIWAN 0x0404
                             1162 ; 24   |#define USB_LANGUAGE_JAPANESE 0x0411
                             1163 ; 25   |
                             1164 ; 26   |#define MAX_STRING 30
                             1165 ; 27   |
                             1166 ; 28   |#define  USB_SPEED_FULL                      (0)
                             1167 ; 29   |#define  USB_SPEED_LOW                       (1)
                             1168 ; 30   |#define  USB_SPEED_HIGH                      (2)
                             1169 ; 31   |
                             1170 ; 32   |#define EP_FS_MAX_PACKET_SIZE               (64)    
                             1171 ; 33   |
                             1172 ; 34   |#define EP_HS_MAX_PACKET_SIZE               (512)   
                             1173 ; 35   |
                             1174 ; 36   |// Data transferred to devices based on Sigmatel 3500 chip may sometimes be 
                             1175 ; 37   |// corrupted. The corruption occurs when device is connected in USB High Speed 
                             1176 ; 38   |// mode, and size of the transfer in bytes is divisible by 128, but not 
                             1177 ; 39   |// divisible by the packet size. The workaround is implemented in Microsoft MTP 
                             1178 ; 40   |// driver to allow support for those devices.
                             1179 ; 41   |
                             1180 ; 42   |// the bug can corrupt the end of data buffer. It occurs when host sends out a 
                             1181 ; 43   |// short packet that is multiple of 128 bytes. During this scenario the USB core
                             1182 ; 44   |// does writes that are voided (byte enable == all zero), which was an undefined 
                             1183 ; 45   |// capability and thus the gasket did not apply a proper response. This should 
                             1184 ; 46   |// not affect Mass Storage applications because data transfers are 512 bytes and 
                             1185 ; 47   |// scsi commands are < 16 bytes. Other applications with their own driver will
                             1186 ; 48   |// need to pad the packets if they fall into the error case. "What this basically 
                             1187 ; 49   |// boils down to is that any time the host sends a short packet of 128, 256 or
                             1188 ; 50   |// 384 bytes to a high-speed connected player a number of bytes will be corrupted.
                             1189 ; 51   |// This is easiest to reproduce in SendObject commands but can strike any of the 
                             1190 ; 52   |// commands that take an arbitrary amount of data.
                             1191 ; 53   |#define ARC_HS_128_MODULO_BUG               (128)
                             1192 ; 54   |
                             1193 ; 55   |
                             1194 ; 56   |/* Error codes */
                             1195 ; 57   |#define USB_OK                              (0x00)
                             1196 ; 58   |#define USBERR_REGISTER_SERVICE             (0x01)  // Failed to register a service
                             1197 ; 59   |#define USBERR_NO_SERVICE                   (0x02)  // No registered service found 
                             1198 ; 60   |#define USBERR_TX_FAILED                    (0x03)  // Fail to prepare XD descriptor
                             1199 ; 61   |#define USBERR_SIZE_TOO_LARGE               (0x04)  // Number of bytes to transfer is too 
                                  large
                             1200 ; 62   |#define USBERR_EP_INIT_FAILED               (0x05)  // Endpoint init fail
                             1201 ; 63   |#define USBERR_CONFIG_FAILED                (0x06)  // Error reported by the application
                             1202 ; 64   |                                                    // if the new config failed or not sup
                                  ported
                             1203 ; 65   |#define USBERR_DEVICE_NOT_CONFIGURED        (0x07)  // Error reported by the transfer func
                                  tion
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  21

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1204 ; 66   |                                                    // if attempting to transfer while the
                                   device
                             1205 ; 67   |                                                    // is not configured
                             1206 ; 68   |#define USBERR_INIT_FAILED                  (0x08)  // Fail to initialize the USB API
                             1207 ; 69   |
                             1208 ; 70   |
                             1209 ; 71   |/* Endpoint types */
                             1210 ; 72   |#define  USB_CONTROL_ENDPOINT             (0)
                             1211 ; 73   |#define  USB_ISOCHRONOUS_ENDPOINT         (1)
                             1212 ; 74   |#define  USB_BULK_ENDPOINT                (2)
                             1213 ; 75   |#define  USB_INTERRUPT_ENDPOINT           (3)
                             1214 ; 76   |
                             1215 ; 77   |/* End point direction */
                             1216 ; 78   |#define  USB_OUT                         (0)
                             1217 ; 79   |#define  USB_IN                          (1)
                             1218 ; 80   |
                             1219 ; 81   |/* End point packed size */
                             1220 ; 82   |#define  USB_FS_MAX_PACKET_SIZE           (64)
                             1221 ; 83   |#define  USB_HS_BULK_OUT_MAX_PACKET_SIZE  (256)
                             1222 ; 84   |#define  USB_HS_BULK_IN_MAX_PACKET_SIZE   (128)
                             1223 ; 85   |
                             1224 ; 86   |
                             1225 ; 87   |#define  USB_TEST_MODE_TEST_J             (0x01)
                             1226 ; 88   |#define  USB_TEST_MODE_TEST_K             (0x02)
                             1227 ; 89   |#define  USB_TEST_MODE_TEST_SE0_NAK       (0x03)
                             1228 ; 90   |#define  USB_TEST_MODE_TEST_PACKET        (0x04)
                             1229 ; 91   |
                             1230 ; 92   |/* Available service types */
                             1231 ; 93   |/* Services 0 through 15 are reserved for endpoints */
                             1232 ; 94   |#define  USB_SERVICE_EP0                  (0x00)
                             1233 ; 95   |#define  USB_SERVICE_EP1                  (0x01)
                             1234 ; 96   |#define  USB_SERVICE_EP2                  (0x02)
                             1235 ; 97   |#define  USB_SERVICE_EP3                  (0x03)
                             1236 ; 98   |#define  USB_SERVICE_EP4                  (0x04)
                             1237 ; 99   |#define  USB_SERVICE_EP5                  (0x05)
                             1238 ; 100  |#define  USB_SERVICE_EP6                  (0x06)
                             1239 ; 101  |#define  USB_SERVICE_EP7                  (0x07)
                             1240 ; 102  |#define  USB_SERVICE_EP8                  (0x08)
                             1241 ; 103  |#define  USB_SERVICE_EP9                  (0x09)
                             1242 ; 104  |#define  USB_SERVICE_EP10                 (0x0a)
                             1243 ; 105  |#define  USB_SERVICE_EP11                 (0x0b)
                             1244 ; 106  |#define  USB_SERVICE_EP12                 (0x0c)
                             1245 ; 107  |#define  USB_SERVICE_EP13                 (0x0d)
                             1246 ; 108  |#define  USB_SERVICE_EP14                 (0x0e)
                             1247 ; 109  |#define  USB_SERVICE_EP15                 (0x0f)
                             1248 ; 110  |#define  USB_SERVICE_BUS_RESET            (0x10)
                             1249 ; 111  |#define  USB_SERVICE_SUSPEND              (0x11)
                             1250 ; 112  |#define  USB_SERVICE_SOF                  (0x12)
                             1251 ; 113  |#define  USB_SERVICE_RESUME               (0x13)
                             1252 ; 114  |#define  USB_SERVICE_SLEEP                (0x14)
                             1253 ; 115  |#define  USB_SERVICE_SPEED_DETECTION      (0x15)
                             1254 ; 116  |#define  USB_SERVICE_TEST                 (0x16)
                             1255 ; 117  |#define  USB_SERVICE_CHANGE_CONFIG        (0x17)
                             1256 ; 118  |#define  USB_SERVICE_CHANGE_IFACE         (0x18)   
                             1257 ; 119  |#define  NON_EP_SERVICES                  (USB_SERVICE_SPEED_DETECTION - USB_SERVICE_EP15)
                                  
                             1258 ; 120  |
                             1259 ; 121  |// This is the maximum service structures allocated 
                             1260 ; 122  |// One for each End point + the common services (non endpoint services) 
                             1261 ; 123  |#define MAX_NUMBER_SERVICES               (MAX_NUM_EP + NON_EP_SERVICES)  
                             1262 ; 124  |
                             1263 ; 125  |#define NUMBER_BYTES_IN_SETUP               (8)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  22

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1264 ; 126  |
                             1265 ; 127  |// possible values of btStatus on the xd_struct
                             1266 ; 128  |#define  USB_STATUS_TRANSFER_IDLE           (0)
                             1267 ; 129  |#define  USB_STATUS_TRANSFER_SUCCESS        (1)            
                             1268 ; 130  |#define  USB_STATUS_TRANSFER_ACCEPTED       (2)
                             1269 ; 131  |#define  USB_STATUS_TRANSFER_IN_PROGRESS    (3)
                             1270 ; 132  |#define  USB_STATUS_TRANSFER_ERROR          (4)
                             1271 ; 133  |
                             1272 ; 134  |// types of status set/returned by set_status() and get_status()
                             1273 ; 135  |#define  USB_STATUS_DEVICE_STATE          (0x01)
                             1274 ; 136  |#define  USB_STATUS_INTERFACE             (0x02)
                             1275 ; 137  |#define  USB_STATUS_ADDRESS               (0x03)
                             1276 ; 138  |#define  USB_STATUS_CURRENT_CONFIG        (0x04)
                             1277 ; 139  |#define  USB_STATUS_SOF_COUNT             (0x05)
                             1278 ; 140  |#define  USB_STATUS                       (0x06)
                             1279 ; 141  |#define  USB_STATUS_TEST_MODE             (0x07)
                             1280 ; 142  |#define  USB_STATUS_DEVICE_SPEED          (0x08)  
                             1281 ; 143  |#define  USB_STATUS_DEVICE_TEST           (0x09)  
                             1282 ; 144  |#define  USB_STATUS_CURRENT_IFACE         (0x0a)
                             1283 ; 145  |#define  USB_STATUS_CONNECTION            (0x0b)  
                             1284 ; 146  |// For status endpoint, the endpoint number is coded in the less significant nibble
                             1285 ; 147  |#define  USB_STATUS_ENDPOINT              (0x10)
                             1286 ; 148  |#define  USB_STATUS_ENDPOINT_NUMBER_MASK  (0x0F)
                             1287 ; 149  |
                             1288 ; 150  |#define USB_MAX_SIZE_PER_TRANSFER       (0x4000)    // This is the maximum size that
                             1289 ; 151  |                                                    // we allow per transfer
                             1290 ; 152  |
                             1291 ; 153  |//Possible states the device can be in
                             1292 ; 154  |#define  USB_STATE_UNKNOWN                   (0xff)
                             1293 ; 155  |#define  USB_STATE_UNPLUGGED                 (0x05) // USB Cable unplugged
                             1294 ; 156  |#define  USB_STATE_PLUGGED                   (0x04) // USB Cable inserted
                             1295 ; 157  |#define  USB_STATE_POWERED                   (0x03)
                             1296 ; 158  |#define  USB_STATE_DEFAULT                   (0x02)
                             1297 ; 159  |#define  USB_STATE_ADDRESSED                 (0x01)
                             1298 ; 160  |#define  USB_STATE_CONFIGURED                (0x00)
                             1299 ; 161  |#define  USB_STATE_SUSPENDED                 (0x80)
                             1300 ; 162  |
                             1301 ; 163  |// Possible states the connection can be in
                             1302 ; 164  |//#define USB_STATE_UNKNOWN                 (0xff)
                             1303 ; 165  |#define USB_CONNECTED                       (0x00)
                             1304 ; 166  |#define USB_DISCONNECTED                    (0x01)
                             1305 ; 167  |
                             1306 ; 168  |
                             1307 ; 169  |
                             1308 ; 170  |typedef union
                             1309 ; 171  |{
                             1310 ; 172  |    struct
                             1311 ; 173  |    {
                             1312 ; 174  |        int Recipient               : 5;
                             1313 ; 175  |        int Type                    : 2;
                             1314 ; 176  |        int DataTransferDirection   : 1;
                             1315 ; 177  |        int Request                 : 8;
                             1316 ; 178  |        int                         : 8;
                             1317 ; 179  |    } B;
                             1318 ; 180  |    
                             1319 ; 181  |    int I;
                             1320 ; 182  |} USBRequestType ;
                             1321 
                             1335 
                             1336 ; 183  |
                             1337 ; 184  |typedef struct {
                             1338 ; 185  |   BYTE     bValid;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  23

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1339 ; 186  |   USBRequestType RequestType;
                             1340 ; 187  |   BYTE     btRequest;
                             1341 ; 188  |   WORD     wValue;
                             1342 ; 189  |   WORD     wIndex;
                             1343 ; 190  |   WORD     wLength;
                             1344 ; 191  |    } USB_SetupData;
                             1345 ; 192  |
                             1346 ; 193  |// Descriptor sizes in bytes
                             1347 ; 194  |#define SIZE_DEVICE_DESCRIPTOR_IN_BYTES     (18)
                             1348 ; 195  |#define SIZE_DEVICE_DESCRIPTOR_IN_WORDS     (6)
                             1349 ; 196  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES   (10)
                             1350 ; 197  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_WORDS   (4)
                             1351 ; 198  |#define SIZE_CONFIG_DESCRIPTOR_IN_BYTES     (9)
                             1352 ; 199  |#define SIZE_CONFIG_DESCRIPTOR_IN_WORDS     (3)
                             1353 ; 200  |#define SIZE_INTERFACE_DESCRIPTOR_IN_BYTES  (9)
                             1354 ; 201  |#define SIZE_INTERFACE_DESCRIPTOR_IN_WORDS  (3)
                             1355 ; 202  |#define SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES   (7)
                             1356 ; 203  |
                             1357 ; 204  |
                             1358 ; 205  |// Descriptor types
                             1359 ; 206  |#define DESCRIPTOR_TYPE_DEVICE              (0x01)
                             1360 ; 207  |#define DESCRIPTOR_TYPE_CONFIG              (0x02)
                             1361 ; 208  |#define DESCRIPTOR_TYPE_STRING              (0x03)
                             1362 ; 209  |#define DESCRIPTOR_TYPE_INTERFACE           (0x04)
                             1363 ; 210  |#define DESCRIPTOR_TYPE_ENDPOINT            (0x05)
                             1364 ; 211  |#define DESCRIPTOR_TYPE_DEVICE_QUALIFIER    (0x06)
                             1365 ; 212  |#define DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG  (0x07)
                             1366 ; 213  |#define DESCRIPTOR_TYPE_INTERFACE_POWER     (0x08)
                             1367 ; 214  |
                             1368 ; 215  |
                             1369 ; 216  |#define USB_REQUEST_DIRECTION_HOST_TO_DEVICE    ((WORD)0x000000)
                             1370 ; 217  |#define USB_REQUEST_DIRECTION_DEVICE_TO_HOST    ((WORD)0x000001)
                             1371 ; 218  |
                             1372 ; 219  |#define USB_REQUEST_TYPE_STANDARD               ((WORD)0x000000)
                             1373 ; 220  |#define USB_REQUEST_TYPE_CLASS                  ((WORD)0x000001)
                             1374 ; 221  |#define USB_REQUEST_TYPE_VENDOR                 ((WORD)0x000002)
                             1375 ; 222  |#define USB_REQUEST_TYPE_RESERVED               ((WORD)0x000003)
                             1376 ; 223  |
                             1377 ; 224  |#define USB_REQUEST_RECIPIENT_DEVICE            ((WORD)0x000000)
                             1378 ; 225  |#define USB_REQUEST_RECIPIENT_INTERFACE         ((WORD)0x000001)
                             1379 ; 226  |#define USB_REQUEST_RECIPIENT_ENDPOINT          ((WORD)0x000002)
                             1380 ; 227  |#define USB_REQUEST_RECIPIENT_OTHER             ((WORD)0x000003)
                             1381 ; 228  |
                             1382 ; 229  |#define USB_REQUEST_STANDARD_GET_STATUS         ((WORD)0x000000)
                             1383 ; 230  |#define USB_REQUEST_STANDARD_CLEAR_FEATURE      ((WORD)0x000001)
                             1384 ; 231  |#define USB_REQUEST_STANDARD_RESERVED_1         ((WORD)0x000002)
                             1385 ; 232  |#define USB_REQUEST_STANDARD_SET_FEATURE        ((WORD)0x000003)
                             1386 ; 233  |#define USB_REQUEST_STANDARD_RESERVED_2         ((WORD)0x000004)
                             1387 ; 234  |#define USB_REQUEST_STANDARD_SET_ADDRESS        ((WORD)0x000005)
                             1388 ; 235  |#define USB_REQUEST_STANDARD_GET_DESCRIPTOR     ((WORD)0x000006)
                             1389 ; 236  |#define USB_REQUEST_STANDARD_SET_DESCRIPTOR     ((WORD)0x000007)
                             1390 ; 237  |#define USB_REQUEST_STANDARD_GET_CONFIGURATION  ((WORD)0x000008)
                             1391 ; 238  |#define USB_REQUEST_STANDARD_SET_CONFIGURATION  ((WORD)0x000009)
                             1392 ; 239  |#define USB_REQUEST_STANDARD_GET_INTERFACE      ((WORD)0x00000A)
                             1393 ; 240  |#define USB_REQUEST_STANDARD_SET_INTERFACE      ((WORD)0x00000B)
                             1394 ; 241  |#define USB_REQUEST_STANDARD_SYNCH_FRAME        ((WORD)0x00000C)
                             1395 ; 242  |
                             1396 ; 243  |#define USB_CLEAR_FEATURE_ENDPOINT_HALT         (0)
                             1397 ; 244  |#define USB_CLEAR_FEATURE_REMOTE_WAKEUP         (1)
                             1398 ; 245  |
                             1399 ; 246  |
                             1400 ; 247  |// Struct Device Descriptor
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  24

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1401 ; 248  |typedef struct {
                             1402 ; 249  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (18)
                             1403 ; 250  |    BYTE    btDescriptorType;       // (1) Device descriptor type (1)
                             1404 ; 251  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             1405 ; 252  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             1406 ; 253  |    BYTE    btDeviceClass;          // (4) Class code
                             1407 ; 254  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             1408 ; 255  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             1409 ; 256  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 (8, 16, 32 o
                                  r 64)
                             1410 ; 257  |    BYTE    btIdVendorLsb;          // (8) Vendor Id
                             1411 ; 258  |    BYTE    btIdVendorMsb;          // (9)
                             1412 ; 259  |    BYTE    btIdProductLsb;         // (10) Product Id
                             1413 ; 260  |    BYTE    btIdProductMsb;         // (11)
                             1414 ; 261  |    BYTE    btBcdReleaseLsb;        // (12) Device release number in BCD
                             1415 ; 262  |    BYTE    btBcdReleaseMsb;        // (13)
                             1416 ; 263  |    BYTE    btIndexManufacturer;    // (14) Index of string descriptor describing Manufact
                                  urer
                             1417 ; 264  |    BYTE    btIndexProduct;         // (15) Index of string descriptor describing Product
                             1418 ; 265  |    BYTE    btIndexSerialNumber;    // (16) Index of string descriptor describing Device S
                                  erial Number
                             1419 ; 266  |    BYTE    btNumConfigurations;    // (17) Number of possible configurations
                             1420 ; 267  |} Struct_Standard_Dev_Desc;
                             1421 ; 268  |
                             1422 ; 269  |// Struct Device Qualifier Descriptor
                             1423 ; 270  |typedef struct {
                             1424 ; 271  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (10)
                             1425 ; 272  |    BYTE    btDescriptorType;       // (1) Device descriptor type (6)
                             1426 ; 273  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             1427 ; 274  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             1428 ; 275  |    BYTE    btDeviceClass;          // (4) Class code
                             1429 ; 276  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             1430 ; 277  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             1431 ; 278  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 other speed 
                                  (8, 16, 32 or 64)
                             1432 ; 279  |    BYTE    btNumConfigurations;    // (8) Number of other-speed possible configurations
                             1433 ; 280  |    BYTE    btReserved;             // (9) Reserved for future use, must be 0
                             1434 ; 281  |} Struct_Dev_Qualifier_Desc;
                             1435 ; 282  |
                             1436 ; 283  |// Struct Configuration Descriptor
                             1437 ; 284  |typedef struct {
                             1438 ; 285  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             1439 ; 286  |    BYTE    btDescriptorType;       // (1) Device descriptor type (2 or 7)
                             1440 ; 287  |    BYTE    btTotalLengthLsb;       // (2) Total length of data returned for this config.
                             1441 ; 288  |    BYTE    btTotalLengthMsb;       // (3)                                  
                             1442 ; 289  |    BYTE    btNumInterfaces;        // (4) Number of Interfaces supported by this configur
                                  ation
                             1443 ; 290  |    BYTE    btConfigurationValue;   // (5) Value to use as an argument to the SetConfigura
                                  tion() request
                             1444 ; 291  |    BYTE    btIndexConfiguration;   // (6) Index of string descriptor describing this conf
                                  iguration
                             1445 ; 292  |    BYTE    btBitMapAttributes;     // (7) Configuration Characteristics
                             1446 ; 293  |                                    //     D7:      Reserved (set to one)
                             1447 ; 294  |                                    //     D6:      Self-powered
                             1448 ; 295  |                                    //     D5:      Remote Wakeup
                             1449 ; 296  |                                    //     D4..0:   Reserved (reset to zero)        
                             1450 ; 297  |    BYTE    btMaxPower;             // (8) Maximum power consumption expressed in 2mA unit
                                  s.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  25

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1451 ; 298  |} Struct_Standard_Config_Desc, Struct_Other_Speed_Config_Desc;
                             1452 ; 299  |
                             1453 ; 300  |// Struct Interface Descriptor
                             1454 ; 301  |typedef struct {
                             1455 ; 302  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             1456 ; 303  |    BYTE    btDescriptorType;       // (1) Device descriptor type (4)
                             1457 ; 304  |    BYTE    btInterfaceNum;         // (2) Number of this interface. Zero-based value.
                             1458 ; 305  |    BYTE    btAlternateSetting;     // (3)                                  
                             1459 ; 306  |    BYTE    btNumEndpoints;         // (4) Number of endpointsused by this interface (excl
                                  uding endpoint 0).
                             1460 ; 307  |    BYTE    btInterfaceClass;       // (5) Class code
                             1461 ; 308  |    BYTE    btInterfaceSubClass;    // (6) Sub Class code
                             1462 ; 309  |    BYTE    btInterfaceProtocol;    // (7) Protocol Code
                             1463 ; 310  |    BYTE    btIndexInterface;       // (8) Index of string descriptor describing this inte
                                  rface
                             1464 ; 311  |} Struct_Standard_Interface_Desc;
                             1465 ; 312  |
                             1466 ; 313  |// Struct Endpoint Descriptor
                             1467 ; 314  |typedef struct {
                             1468 ; 315  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (7)
                             1469 ; 316  |    BYTE    btDescriptorType;       // (1) Device descriptor type (5)
                             1470 ; 317  |    BYTE    btEndpointAddress;      // (2) Address of the endpoint on the USB device descr
                                  ibed by this descriptor
                             1471 ; 318  |                                    //      Bit 3..0: Endpoint number
                             1472 ; 319  |                                    //      Bit 6..4: Reserved, reset to zero
                             1473 ; 320  |                                    //      Bit 7:    Direction. Ignored for control endpo
                                  ints (0 OUT, 1 IN)
                             1474 ; 321  |    BYTE    btBitMapAttributes;     // (3) Endpoint attributes
                             1475 ; 322  |                                    //      bits 1..0: Transfer Type (00 Control, 01 Iso, 
                                  10 Bulk, 11 Int)
                             1476 ; 323  |                                    //      bits 5..2: If not an iso endpoints, they are r
                                  eserved and must be reset to zero.
                             1477 ; 324  |                                    //      bits 7..6: Reserved bits, must be reset to zer
                                  o.                                    
                             1478 ; 325  |    BYTE    btMaxPacketSizeLsb;     // (4) Maximum packet size. Refer to standard for bits
                                   specification
                             1479 ; 326  |    BYTE    btMaxPacketSizeMsb;     // (5)
                             1480 ; 327  |    BYTE    btInterval;             // (6) Interval for polling endpoint for data transfer
                                  s (refer to standard)
                             1481 ; 328  |} Struct_Standard_Endpoint_Desc;
                             1482 ; 329  |
                             1483 ; 330  |typedef struct {
                             1484 ; 331  |    BYTE    btLength;                   // (0) Size of this descriptor in bytes (2*MAX_USB
                                  _LANG + 2)
                             1485 ; 332  |    BYTE    btDescriptorType;           // (1) String descriptor type (3)
                             1486 ; 333  |    BYTE    btString[MAX_STRING*2];       
                             1487 ; 334  |} Struct_String_Desc;
                             1488 ; 335  |
                             1489 ; 336  |//
                             1490 ; 337  |// Externals
                             1491 ; 338  |//
                             1492 ; 339  |extern void _reentrant usb_dci_chip_enable (void);
                             1493 ; 340  |extern void _reentrant usb_dci_shutdown(void);
                             1494 ; 341  |
                             1495 ; 342  |BYTE _reentrant usb_device_init(void);
                             1496 ; 343  |void _inline usb_device_shutdown(void)
                             1497 ; 344  |{
                             1498 ; 345  |    usb_dci_shutdown();
                             1499 ; 346  |}
                             1500 ; 347  |
                             1501 ; 348  |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYT
                                  E btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData)); 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  26

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1502 ; 349  |//Remove unused function usb_device_get_service() to reclain _P memroy.
                             1503 ; 350  |//BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE b
                                  tDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength)); 
                             1504 ; 351  |
                             1505 ; 352  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btD
                                  irection, BYTE btType, BOOL bFlag);
                             1506 ; 353  |
                             1507 ; 354  |extern USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             1508 
                             1517 
                             1518 ; 355  |#define usb_device_read_setup_data(btEndpoint) usb_dci_get_setup_data(btEndpoint)
                             1519 ; 356  |
                             1520 ; 357  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus);
                             1521 ; 358  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus);
                             1522 ; 359  |BYTE _reentrant usb_device_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             1523 ; 360  |
                             1524 ; 361  |extern void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             1525 ; 362  |#define usb_device_stall_endpoint(btEndpoint, btDirection) usb_dci_stall_endpoint((btEndpo
                                  int), (btDirection))
                             1526 ; 363  |
                             1527 ; 364  |extern void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             1528 ; 365  |#define usb_device_unstall_endpoint(btEndpoint, btDirection) usb_dci_unstall_endpoint((btE
                                  ndpoint), (btDirection))
                             1529 ; 366  |
                             1530 ; 367  |extern void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             1531 ; 368  |#define usb_device_finish_transaction(btEndpoint) usb_dci_finish_transaction(btEndpoint);
                             1532 ; 369  |
                             1533 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             1534 ; 371  |//
                             1535 ; 372  |//>  Name:          usb_device_enable
                             1536 ; 373  |//
                             1537 ; 374  |//   Type:          Function
                             1538 ; 375  |//
                             1539 ; 376  |//   Description:   Enables the USB device for transfers
                             1540 ; 377  |//
                             1541 ; 378  |//   Inputs:        none
                             1542 ; 379  |//
                             1543 ; 380  |//   Outputs:       USB_OK or error code
                             1544 ; 381  |//
                             1545 ; 382  |//   Notes:         none
                             1546 ; 383  |//<
                             1547 ; 384  |////////////////////////////////////////////////////////////////////////////////
                             1548 ; 385  |void _inline usb_device_enable(void)
                             1549 ; 386  |{
                             1550 ; 387  |    usb_dci_chip_enable();
                             1551 ; 388  |}
                             1552 ; 389  |
                             1553 ; 390  |void _reentrant usb_device_release(void);
                             1554 ; 391  |void _reentrant usb_device_hold(void);
                             1555 ; 392  |BYTE _reentrant usb_device_is_hold(void);
                             1556 ; 393  |void _reentrant usb_device_data_phase_required(void);
                             1557 ; 394  |
                             1558 ; 395  |BOOL _reentrant usb_device_is_first_init(void);
                             1559 ; 396  |void _reentrant usb_device_set_first_init(void);
                             1560 ; 397  |void _reentrant usb_device_clear_first_init(void);
                             1561 ; 398  |
                             1562 ; 399  |WORD _reentrant usb_get_current_limit(void);
                             1563 ; 400  |RETCODE _reentrant usb_set_current_limit(WORD);
                             1564 ; 401  |
                             1565 ; 402  |////////////////////////////////////////////////////////////////////
                             1566 ; 403  |extern BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  27

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1567 ; 404  |#define usb_device_get_endpoint_status(btEndpoint) usb_dci_get_endpoint_status(btEndpoint)
                                  
                             1568 ; 405  |
                             1569 ; 406  |#define USB_ENDPOINT_STATUS_OK                          0
                             1570 ; 407  |#define USB_ENDPOINT_STATUS_STALLED                     1
                             1571 ; 408  |#define USB_ENDPOINT_STATUS_RECIEVED_UNSTALL_REQUEST    2
                             1572 ; 409  |// WHQL
                             1573 ; 410  |#define USB_ENDPOINT_STATUS_HOST_STALLED                3
                             1574 ; 411  |////////////////////////////////////////////////////////////////////
                             1575 ; 412  |
                             1576 ; 413  |
                             1577 ; 414  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             1578 ; 415  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             1579 ; 416  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLen
                                  gth,WORD wPrivateData);
                             1580 ; 417  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             1581 ; 418  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateDa
                                  ta, 
                             1582 ; 419  |                                         BOOL bIsDataPhase, WORD wDirection);
                             1583 ; 420  |
                             1584 ; 421  |#ifndef CUSTOMIZE_UNICODE
                             1585 ; 422  |extern const BYTE g_Manufacturer[];
                             1586 ; 423  |extern const BYTE g_ProductName[];
                             1587 ; 424  |extern const BYTE g_ConfigString[];
                             1588 ; 425  |extern const BYTE g_Interface0String[];
                             1589 ; 426  |extern const BYTE g_Interface1String[];
                             1590 ; 427  |extern const BYTE g_MSOSDescriptorString[];
                             1591 ; 428  |#else   // CUSTOMIZE_UNICODE
                             1592 ; 429  |extern const WORD g_Manufacturer[];
                             1593 ; 430  |extern const WORD g_ProductName[];
                             1594 ; 431  |extern const WORD g_ConfigString[];
                             1595 ; 432  |extern const WORD g_Interface0String[];
                             1596 ; 433  |extern const WORD g_Interface1String[];
                             1597 ; 434  |extern const WORD g_MSOSDescriptorString[];
                             1598 ; 435  |#endif
                             1599 ; 436  |extern WORD g_LanguageList[];
                             1600 ; 437  |
                             1601 ; 438  |extern const BYTE g_SCSIVendorID[];
                             1602 ; 439  |extern const BYTE g_SCSIProductID[];
                             1603 ; 440  |extern void *g_pStrings[];
                             1604 ; 441  |
                             1605 ; 442  |extern WORD g_wUSBVendorID;
                             1606 ; 443  |extern WORD g_wUSBProductID;
                             1607 ; 444  |extern WORD g_wUSBReleaseID;
                             1608 ; 445  |
                             1609 ; 446  |#endif
                             1610 ; 447  |/* EOF */
                             1611 ; 448  |
                             1612 
                             1614 
                             1615 ; 10   |#include "usbmsc.h"
                             1616 
                             1618 
                             1619 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1620 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             1621 ; 3    |//
                             1622 ; 4    |// Filename: usbmsc.h
                             1623 ; 5    |// Description: 
                             1624 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1625 ; 7    |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  28

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1626 ; 8    |#ifndef _USBMSC_H
                             1627 ; 9    |#define _USBMSC_H
                             1628 ; 10   |
                             1629 ; 11   |////////////////////////////////////////////////////////////////////////////////
                             1630 ; 12   |// Includes
                             1631 ; 13   |////////////////////////////////////////////////////////////////////////////////
                             1632 ; 14   |
                             1633 ; 15   |#include "kernel.h"
                             1634 
                             1636 
                             1637 ; 1    |///////////////////////////////////////////////////////////////////////////////
                             1638 ; 2    |///
                             1639 ; 3    |/// Filename: kernel.h
                             1640 ; 4    |/// Description: 
                             1641 ; 5    |///
                             1642 ; 6    |///
                             1643 ; 7    |/// Copyright (c) SigmaTel, Inc. Unpublished
                             1644 ; 8    |///
                             1645 ; 9    |/// SigmaTel, Inc.
                             1646 ; 10   |/// Proprietary  Confidential
                             1647 ; 11   |///
                             1648 ; 12   |/// This source code and the algorithms implemented therein constitute
                             1649 ; 13   |/// confidential information and may comprise trade secrets of SigmaTel, Inc.
                             1650 ; 14   |/// or its associates, and any use thereof is subject to the terms and
                             1651 ; 15   |/// conditions of the Confidential Disclosure Agreement pursuant to which this
                             1652 ; 16   |/// source code was originally received.
                             1653 ; 17   |///
                             1654 ; 18   |///////////////////////////////////////////////////////////////////////////////
                             1655 ; 19   |#ifndef __KERNEL_H
                             1656 ; 20   |#define __KERNEL_H
                             1657 ; 21   |
                             1658 ; 22   |
                             1659 ; 23   |#include "types.h"
                             1660 
                             1662 
                             1663 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1664 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1665 ; 3    |//
                             1666 ; 4    |// Filename: types.h
                             1667 ; 5    |// Description: Standard data types
                             1668 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1669 ; 7    |
                             1670 ; 8    |#ifndef _TYPES_H
                             1671 ; 9    |#define _TYPES_H
                             1672 ; 10   |
                             1673 ; 11   |// TODO:  move this outta here!
                             1674 ; 12   |#if !defined(NOERROR)
                             1675 ; 13   |#define NOERROR 0
                             1676 ; 14   |#define SUCCESS 0
                             1677 ; 15   |#endif 
                             1678 ; 16   |#if !defined(SUCCESS)
                             1679 ; 17   |#define SUCCESS  0
                             1680 ; 18   |#endif
                             1681 ; 19   |#if !defined(ERROR)
                             1682 ; 20   |#define ERROR   -1
                             1683 ; 21   |#endif
                             1684 ; 22   |#if !defined(FALSE)
                             1685 ; 23   |#define FALSE 0
                             1686 ; 24   |#endif
                             1687 ; 25   |#if !defined(TRUE)
                             1688 ; 26   |#define TRUE  1
                             1689 ; 27   |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  29

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1690 ; 28   |
                             1691 ; 29   |#if !defined(NULL)
                             1692 ; 30   |#define NULL 0
                             1693 ; 31   |#endif
                             1694 ; 32   |
                             1695 ; 33   |#define MAX_INT     0x7FFFFF
                             1696 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             1697 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             1698 ; 36   |#define MAX_ULONG   (-1) 
                             1699 ; 37   |
                             1700 ; 38   |#define WORD_SIZE   24              // word size in bits
                             1701 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             1702 ; 40   |
                             1703 ; 41   |
                             1704 ; 42   |#define BYTE    unsigned char       // btVarName
                             1705 ; 43   |#define CHAR    signed char         // cVarName
                             1706 ; 44   |#define USHORT  unsigned short      // usVarName
                             1707 ; 45   |#define SHORT   unsigned short      // sVarName
                             1708 ; 46   |#define WORD    unsigned int        // wVarName
                             1709 ; 47   |#define INT     signed int          // iVarName
                             1710 ; 48   |#define DWORD   unsigned long       // dwVarName
                             1711 ; 49   |#define LONG    signed long         // lVarName
                             1712 ; 50   |#define BOOL    unsigned int        // bVarName
                             1713 ; 51   |#define FRACT   _fract              // frVarName
                             1714 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             1715 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             1716 ; 54   |#define FLOAT   float               // fVarName
                             1717 ; 55   |#define DBL     double              // dVarName
                             1718 ; 56   |#define ENUM    enum                // eVarName
                             1719 ; 57   |#define CMX     _complex            // cmxVarName
                             1720 ; 58   |typedef WORD UCS3;                   // 
                             1721 ; 59   |
                             1722 ; 60   |#define UINT16  unsigned short
                             1723 ; 61   |#define UINT8   unsigned char   
                             1724 ; 62   |#define UINT32  unsigned long
                             1725 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             1726 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             1727 ; 65   |#define WCHAR   UINT16
                             1728 ; 66   |
                             1729 ; 67   |//UINT128 is 16 bytes or 6 words
                             1730 ; 68   |typedef struct UINT128_3500 {   
                             1731 ; 69   |    int val[6];     
                             1732 ; 70   |} UINT128_3500;
                             1733 ; 71   |
                             1734 ; 72   |#define UINT128   UINT128_3500
                             1735 ; 73   |
                             1736 ; 74   |// Little endian word packed byte strings:   
                             1737 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1738 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1739 ; 77   |// Little endian word packed byte strings:   
                             1740 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1741 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1742 ; 80   |
                             1743 ; 81   |// Declare Memory Spaces To Use When Coding
                             1744 ; 82   |// A. Sector Buffers
                             1745 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             1746 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             1747 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             1748 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             1749 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  30

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1750 ; 88   |// B. Media DDI Memory
                             1751 ; 89   |#define MEDIA_DDI_MEM _Y
                             1752 ; 90   |
                             1753 ; 91   |
                             1754 ; 92   |
                             1755 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             1756 ; 94   |// Examples of circular pointers:
                             1757 ; 95   |//    INT CIRC cpiVarName
                             1758 ; 96   |//    DWORD CIRC cpdwVarName
                             1759 ; 97   |
                             1760 ; 98   |#define RETCODE INT                 // rcVarName
                             1761 ; 99   |
                             1762 ; 100  |// generic bitfield structure
                             1763 ; 101  |struct Bitfield {
                             1764 ; 102  |    unsigned int B0  :1;
                             1765 ; 103  |    unsigned int B1  :1;
                             1766 ; 104  |    unsigned int B2  :1;
                             1767 ; 105  |    unsigned int B3  :1;
                             1768 ; 106  |    unsigned int B4  :1;
                             1769 ; 107  |    unsigned int B5  :1;
                             1770 ; 108  |    unsigned int B6  :1;
                             1771 ; 109  |    unsigned int B7  :1;
                             1772 ; 110  |    unsigned int B8  :1;
                             1773 ; 111  |    unsigned int B9  :1;
                             1774 ; 112  |    unsigned int B10 :1;
                             1775 ; 113  |    unsigned int B11 :1;
                             1776 ; 114  |    unsigned int B12 :1;
                             1777 ; 115  |    unsigned int B13 :1;
                             1778 ; 116  |    unsigned int B14 :1;
                             1779 ; 117  |    unsigned int B15 :1;
                             1780 ; 118  |    unsigned int B16 :1;
                             1781 ; 119  |    unsigned int B17 :1;
                             1782 ; 120  |    unsigned int B18 :1;
                             1783 ; 121  |    unsigned int B19 :1;
                             1784 ; 122  |    unsigned int B20 :1;
                             1785 ; 123  |    unsigned int B21 :1;
                             1786 ; 124  |    unsigned int B22 :1;
                             1787 ; 125  |    unsigned int B23 :1;
                             1788 ; 126  |};
                             1789 ; 127  |
                             1790 ; 128  |union BitInt {
                             1791 ; 129  |        struct Bitfield B;
                             1792 ; 130  |        int        I;
                             1793 ; 131  |};
                             1794 ; 132  |
                             1795 ; 133  |#define MAX_MSG_LENGTH 10
                             1796 ; 134  |struct CMessage
                             1797 ; 135  |{
                             1798 ; 136  |        unsigned int m_uLength;
                             1799 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1800 ; 138  |};
                             1801 ; 139  |
                             1802 ; 140  |typedef struct {
                             1803 ; 141  |    WORD m_wLength;
                             1804 ; 142  |    WORD m_wMessage;
                             1805 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1806 ; 144  |} Message;
                             1807 ; 145  |
                             1808 ; 146  |struct MessageQueueDescriptor
                             1809 ; 147  |{
                             1810 ; 148  |        int *m_pBase;
                             1811 ; 149  |        int m_iModulo;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  31

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1812 ; 150  |        int m_iSize;
                             1813 ; 151  |        int *m_pHead;
                             1814 ; 152  |        int *m_pTail;
                             1815 ; 153  |};
                             1816 ; 154  |
                             1817 ; 155  |struct ModuleEntry
                             1818 ; 156  |{
                             1819 ; 157  |    int m_iSignaledEventMask;
                             1820 ; 158  |    int m_iWaitEventMask;
                             1821 ; 159  |    int m_iResourceOfCode;
                             1822 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1823 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                             1824 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1825 ; 163  |    int m_uTimeOutHigh;
                             1826 ; 164  |    int m_uTimeOutLow;
                             1827 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1828 ; 166  |};
                             1829 ; 167  |
                             1830 ; 168  |union WaitMask{
                             1831 ; 169  |    struct B{
                             1832 ; 170  |        unsigned int m_bNone     :1;
                             1833 ; 171  |        unsigned int m_bMessage  :1;
                             1834 ; 172  |        unsigned int m_bTimer    :1;
                             1835 ; 173  |        unsigned int m_bButton   :1;
                             1836 ; 174  |    } B;
                             1837 ; 175  |    int I;
                             1838 ; 176  |} ;
                             1839 ; 177  |
                             1840 ; 178  |
                             1841 ; 179  |struct Button {
                             1842 ; 180  |        WORD wButtonEvent;
                             1843 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1844 ; 182  |};
                             1845 ; 183  |
                             1846 ; 184  |struct Message {
                             1847 ; 185  |        WORD wMsgLength;
                             1848 ; 186  |        WORD wMsgCommand;
                             1849 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1850 ; 188  |};
                             1851 ; 189  |
                             1852 ; 190  |union EventTypes {
                             1853 ; 191  |        struct CMessage msg;
                             1854 ; 192  |        struct Button Button ;
                             1855 ; 193  |        struct Message Message;
                             1856 ; 194  |};
                             1857 ; 195  |
                             1858 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1859 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1860 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1861 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1862 ; 200  |
                             1863 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1864 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1865 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1866 ; 204  |
                             1867 ; 205  |#if DEBUG
                             1868 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1869 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1870 ; 208  |#else 
                             1871 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  32

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1872 ; 210  |#define DebugBuildAssert(x)    
                             1873 ; 211  |#endif
                             1874 ; 212  |
                             1875 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1876 ; 214  |//  #pragma asm
                             1877 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1878 ; 216  |//  #pragma endasm
                             1879 ; 217  |
                             1880 ; 218  |
                             1881 ; 219  |#ifdef COLOR_262K
                             1882 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                             1883 ; 221  |#elif defined(COLOR_65K)
                             1884 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                             1885 ; 223  |#else
                             1886 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                             1887 ; 225  |#endif
                             1888 ; 226  |    
                             1889 ; 227  |#endif // #ifndef _TYPES_H
                             1890 
                             1892 
                             1893 ; 24   |#include "gettime.h"
                             1894 
                             1896 
                             1897 ; 1    |#ifndef __TIME_H
                             1898 ; 2    |#define __TIME_H
                             1899 ; 3    |
                             1900 ; 4    |_callee_save LONG GetTime(void);
                             1901 ; 5    |
                             1902 ; 6    |#endif
                             1903 
                             1905 
                             1906 ; 25   |#include "sysirq.h"
                             1907 
                             1909 
                             1910 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1911 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             1912 ; 3    |//
                             1913 ; 4    |// Filename: sysirq.h
                             1914 ; 5    |// Description: 
                             1915 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1916 ; 7    |
                             1917 ; 8    |#ifndef _SYSIRQ_H
                             1918 ; 9    |#define _SYSIRQ_H
                             1919 ; 10   |
                             1920 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             1921 ; 12   |// Defs
                             1922 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             1923 ; 14   |
                             1924 ; 15   |#define     INTERRUPTS_UNMASK_ALL   0x000000
                             1925 ; 16   |
                             1926 ; 17   |///////////////////////////////////////////////////////////////////////////////
                             1927 ; 18   |// Structure definitions
                             1928 ; 19   |///////////////////////////////////////////////////////////////////////////////
                             1929 ; 20   |
                             1930 ; 21   |///////////////////////////////////////////////////////////////////////////////
                             1931 ; 22   |// Prototypes
                             1932 ; 23   |///////////////////////////////////////////////////////////////////////////////
                             1933 ; 24   |
                             1934 ; 25   |WORD _reentrant SysMaskAllInterrupts(void);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  33

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1935 ; 26   |void _reentrant SysUnMaskAllInterrupts(WORD wLevel);
                             1936 ; 27   |WORD _reentrant SysGetIrqLevel(void);
                             1937 ; 28   |RETCODE _reentrant SysSetIrqLevel(WORD wIrqLevel);
                             1938 ; 29   |
                             1939 ; 30   |#endif // #ifndef _SYSIRQ_H
                             1940 
                             1942 
                             1943 ; 26   |#include "icoll.h"
                             1944 
                             1946 
                             1947 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1948 ; 2    |// Copyright(C) SigmaTel, Inc. 2002
                             1949 ; 3    |//
                             1950 ; 4    |// Filename: icoll.h
                             1951 ; 5    |// Description: 
                             1952 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1953 ; 7    |
                             1954 ; 8    |#ifndef _ICOLL_H
                             1955 ; 9    |#define _ICOLL_H
                             1956 ; 10   |
                             1957 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             1958 ; 12   |// Defs
                             1959 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             1960 ; 14   |                                                                                          
                                  
                             1961 ; 15   |#define ICOLL_SOURCE_DAC_REFILL                                 (DWORD)0             
                             1962 ; 16   |#define ICOLL_SOURCE_DAC_UNDERFLOW                              (DWORD)1             
                             1963 ; 17   |#define ICOLL_SOURCE_ADC_REFILL                                 (DWORD)2             
                             1964 ; 18   |#define ICOLL_SOURCE_ADC_OVERFLOW                               (DWORD)3             
                             1965 ; 19   |#define ICOLL_SOURCE_FLASH_DONE                                 (DWORD)4              
                             1966 ; 20   |#define ICOLL_SOURCE_COMPACTFLASH_CARD_IRQ                      (DWORD)5              
                             1967 ; 21   |#define ICOLL_SOURCE_SMARTMEDIA_TIMEOUT                         (DWORD)6              
                             1968 ; 22   |#define ICOLL_SOURCE_SMARTMEDIA_INTERFACE_INVALID_PROGRAMMING   (DWORD)7              
                             1969 ; 23   |#define ICOLL_SOURCE_COMPACTFLASH_NO_CARD                       (DWORD)8               
                             1970 ; 24   |#define ICOLL_SOURCE_COMPACTFLASH_STATUS_CHANGE                 (DWORD)9               
                             1971 ; 25   |#define ICOLL_SOURCE_GPIO_0                                     (DWORD)10               
                             1972 ; 26   |#define ICOLL_SOURCE_GPIO_1                                     (DWORD)11               
                             1973 ; 27   |#define ICOLL_SOURCE_GPIO_2                                     (DWORD)12                
                             1974 ; 28   |#define ICOLL_SOURCE_TIMER_0                                    (DWORD)13                
                             1975 ; 29   |#define ICOLL_SOURCE_TIMER_1                                    (DWORD)14                
                             1976 ; 30   |#define ICOLL_SOURCE_TIMER_2                                    (DWORD)15                
                             1977 ; 31   |#define ICOLL_SOURCE_TIMER_3                                    (DWORD)16                 
                                  
                             1978 ; 32   |#define ICOLL_SOURCE_GPIO_3                                     (DWORD)17                 
                                  
                             1979 ; 33   |#define ICOLL_SOURCE_SDRAM                                      (DWORD)18                 
                                  
                             1980 ; 34   |#define ICOLL_SOURCE_CDI                                        (DWORD)19                 
                                  
                             1981 ; 35   |
                             1982 ; 36   |#if (defined(DEVICE_3410) || defined(DEVICE_3310))
                             1983 ; 37   |
                             1984 ; 38   |#define ICOLL_SOURCE_USB_SOF                                    (DWORD)20                 
                                   
                             1985 ; 39   |#define ICOLL_SOURCE_USB_SET_INTERFACE_REQUEST                  (DWORD)21                 
                                   
                             1986 ; 40   |#define ICOLL_SOURCE_USB_HOST_RESET                             (DWORD)22                 
                                   
                             1987 ; 41   |#define ICOLL_SOURCE_USB_ENDPOINT_START                         (DWORD)23
                             1988 ; 42   |#define ICOLL_SOURCE_USB_ENDPOINT_0                             (DWORD)23                 
                                   
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  34

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1989 ; 43   |#define ICOLL_SOURCE_USB_ENDPOINT_1                             (DWORD)24                 
                                   
                             1990 ; 44   |#define ICOLL_SOURCE_USB_ENDPOINT_2                             (DWORD)25                 
                                   
                             1991 ; 45   |#define ICOLL_SOURCE_USB_ENDPOINT_3                             (DWORD)26                 
                                   
                             1992 ; 46   |#define ICOLL_SOURCE_USB_ENDPOINT_4                             (DWORD)27                 
                                   
                             1993 ; 47   |#define ICOLL_SOURCE_USB_ENDPOINT_5                             (DWORD)28                 
                                     
                             1994 ; 48   |#define ICOLL_SOURCE_USB_ENDPOINT_6                             (DWORD)29                 
                                     
                             1995 ; 49   |#define ICOLL_SOURCE_USB_ENDPOINT_7                             (DWORD)30                 
                                     
                             1996 ; 50   |
                             1997 ; 51   |#else
                             1998 ; 52   |
                             1999 ; 53   |#define ICOLL_SOURCE_VDD_5V_CONNECTED                           (DWORD)20                 
                                   
                             2000 ; 54   |#define ICOLL_SOURCE_USB_CONTROLLER                             (DWORD)21                 
                                   
                             2001 ; 55   |#define ICOLL_SOURCE_USB_WAKEUP                                 (DWORD)22                 
                                   
                             2002 ; 56   |#define ICOLL_SOURCE_VDD_5V_DISCONNECTED                        (DWORD)23
                             2003 ; 57   |#define ICOLL_SOURCE_ESPI                                       (DWORD)24                 
                                   
                             2004 ; 58   |#define ICOLL_SOURCE_FILCO                                      (DWORD)25                 
                                   
                             2005 ; 59   |#define ICOLL_SOURCE_LRADC1                                     (DWORD)26                 
                                   
                             2006 ; 60   |#define ICOLL_SOURCE_RTC_ALARM                                  (DWORD)27                 
                                   
                             2007 ; 61   |#define ICOLL_SOURCE_LRADC2                                     (DWORD)28                 
                                   
                             2008 ; 62   |#define ICOLL_SOURCE_FLASH_ECC                                  (DWORD)29                 
                                     
                             2009 ; 63   |
                             2010 ; 64   |#endif
                             2011 ; 65   |
                             2012 ; 66   |#define ICOLL_SOURCE_CDSYNC                                     (DWORD)31                 
                                     
                             2013 ; 67   |#define ICOLL_SOURCE_CDSYNC_EXCEPTION                           (DWORD)32                 
                                      
                             2014 ; 68   |#define ICOLL_SOURCE_REED_SOLOMON                               (DWORD)33
                             2015 ; 69   |#define ICOLL_END_OF_TRUE_SOURCES                                ICOLL_SOURCE_REED_SOLOMON
                                  
                             2016 ; 70   |// The rest of these "sources" are not really ICOLL sources.  They are not
                             2017 ; 71   |//  routed through the ICOLL but are included here to make interrupt abstraction
                             2018 ; 72   |//  as simple as possible.  The ICOLL functions special-case these.
                             2019 ; 73   |#define ICOLL_SOURCE_I2C_RX_READY                               (DWORD)34
                             2020 ; 74   |#define ICOLL_SOURCE_I2C_RX_OVERFLOW                            (DWORD)35
                             2021 ; 75   |#define ICOLL_SOURCE_I2C_TX_EMPTY                               (DWORD)36
                             2022 ; 76   |#define ICOLL_SOURCE_I2C_TX_UNDERFLOW                           (DWORD)37
                             2023 ; 77   |#define ICOLL_SOURCE_SPI_COMPLETE                               (DWORD)38
                             2024 ; 78   |#define ICOLL_SOURCE_I2S_RX_OVERFLOW                            (DWORD)39
                             2025 ; 79   |#define ICOLL_SOURCE_I2S_TX_UNDERFLOW                           (DWORD)40
                             2026 ; 80   |#define ICOLL_SOURCE_I2S_RX_READY                               (DWORD)41
                             2027 ; 81   |#define ICOLL_SOURCE_I2S_TX_EMPTY                               (DWORD)42
                             2028 ; 82   |#define ICOLL_SOURCE_HARDWARE_RESET                             (DWORD)43
                             2029 ; 83   |#define ICOLL_SOURCE_STACK_ERROR                                (DWORD)44
                             2030 ; 84   |#define ICOLL_SOURCE_TRACE                                      (DWORD)45
                             2031 ; 85   |#define ICOLL_SOURCE_SWI                                        (DWORD)46
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  35

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2032 ; 86   |#define ICOLL_SOURCE_IRQA                                       (DWORD)47
                             2033 ; 87   |#define ICOLL_SOURCE_BROWNOUT                                   (DWORD)48
                             2034 ; 88   |#define ICOLL_SOURCE_ILLEGAL_INSTRUCTION                        (DWORD)49
                             2035 ; 89   |#define ICOLL_SOURCE_END                                        ICOLL_SOURCE_ILLEGAL_INSTR
                                  UCTION
                             2036 ; 90   |#define ICOLL_NUM_SOURCES                                       ICOLL_SOURCE_END+1
                             2037 ; 91   |
                             2038 ; 92   |#define ICOLL_ICLENABLE_REG_0_LAST_SRC                          (DWORD)23
                             2039 ; 93   |
                             2040 ; 94   |#define ICOLL_PRIORITY_000              0x000000
                             2041 ; 95   |#define ICOLL_PRIORITY_001              0x000001
                             2042 ; 96   |#define ICOLL_PRIORITY_010              0x000002
                             2043 ; 97   |#define ICOLL_PRIORITY_011              0x000003
                             2044 ; 98   |#define ICOLL_PRIORITY_100              0x000004
                             2045 ; 99   |#define ICOLL_PRIORITY_101              0x000005
                             2046 ; 100  |#define ICOLL_PRIORITY_110              0x000006
                             2047 ; 101  |#define ICOLL_PRIORITY_111              0x000007
                             2048 ; 102  |
                             2049 ; 103  |#define ICOLL_STEERING_IVL1             0x000000
                             2050 ; 104  |#define ICOLL_STEERING_IVL2             0x000001
                             2051 ; 105  |#define ICOLL_STEERING_IVL3             0x000002
                             2052 ; 106  |#define ICOLL_STEERING_IVL6             0x000003
                             2053 ; 107  |
                             2054 ; 108  |///////////////////////////////////////////////////////////////////////////////
                             2055 ; 109  |// ERRORS
                             2056 ; 110  |///////////////////////////////////////////////////////////////////////////////
                             2057 ; 111  |                                                                                          
                                  
                             2058 ; 112  |#define ICOLL_ERROR_INVALID_SOURCE              (RETCODE)0x000001
                             2059 ; 113  |
                             2060 ; 114  |///////////////////////////////////////////////////////////////////////////////
                             2061 ; 115  |// Structure definitions
                             2062 ; 116  |///////////////////////////////////////////////////////////////////////////////
                             2063 ; 117  |
                             2064 ; 118  |typedef void (*ISR_VECTOR)(void);
                             2065 ; 119  |
                             2066 ; 120  |typedef struct
                             2067 ; 121  |{
                             2068 ; 122  |    WORD wSource;
                             2069 ; 123  |    WORD wPriority;
                             2070 ; 124  |    WORD wSteering;
                             2071 ; 125  |} ICOLL_ELEMENT;
                             2072 ; 126  |
                             2073 ; 127  |///////////////////////////////////////////////////////////////////////////////
                             2074 ; 128  |// Prototypes
                             2075 ; 129  |///////////////////////////////////////////////////////////////////////////////
                             2076 ; 130  |
                             2077 ; 131  |void _reentrant IcollShutDown(void);
                             2078 ; 132  |RETCODE _reentrant IcollEnable(DWORD dwSource);
                             2079 ; 133  |RETCODE _reentrant IcollDisable(DWORD dwSource);
                             2080 ; 134  |BOOL _reentrant IcollGetStatus(DWORD dwSource);
                             2081 ; 135  |RETCODE _reentrant IcollSetPriority(DWORD dwSource, WORD wPriority);
                             2082 ; 136  |RETCODE _reentrant IcollSetSteering(DWORD dwSource, WORD wSteering);
                             2083 
                             2088 
                             2089 ; 137  |RETCODE _reentrant IcollInstallIsrVector(ISR_VECTOR pISR, WORD wSource);
                             2090 ; 138  |void _asmfunc IcollResetVectorTable(void);
                             2091 ; 139  |#endif // #ifndef _ICOLL_H
                             2092 
                             2094 
                             2095 ; 27   |
                             2096 ; 28   |#ifndef SYS_MAX_MSG_PARAMS
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  36

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2097 ; 29   |#define SYS_MAX_MSG_PARAMS 10
                             2098 ; 30   |#endif
                             2099 ; 31   |
                             2100 ; 32   |#ifndef MAX_REGIONS
                             2101 ; 33   |#define MAX_REGIONS 5
                             2102 ; 34   |#endif 
                             2103 ; 35   |
                             2104 ; 36   |#define TIMEOUT_IMMEDIATE 0
                             2105 ; 37   |
                             2106 ; 38   |struct TaskEntryStruct;
                             2107 ; 39   |
                             2108 ; 40   |union SyncObjectStruct;
                             2109 ; 41   |
                             2110 ; 42   |
                             2111 ; 43   |// JCP - Already defined in types.h
                             2112 ; 44   |
                             2113 ; 45   |//typedef struct {
                             2114 ; 46   |//    WORD m_wLength;
                             2115 ; 47   |//    WORD m_wMessage;
                             2116 ; 48   |//    WORD m_wParams[SYS_MAX_MSG_PARAMS];
                             2117 ; 49   |//} Message;
                             2118 ; 50   |
                             2119 ; 51   |typedef struct {
                             2120 ; 52   |    _circ WORD    *m_pHead;
                             2121 ; 53   |    _circ WORD    *m_pTail;
                             2122 ; 54   |} CircularBufferDescriptor;
                             2123 ; 55   |
                             2124 ; 56   |typedef struct MemoryRegionStruct {
                             2125 ; 57   |    WORD m_wResourceLoaded;
                             2126 ; 58   |    _P INT *m_StartAddress;
                             2127 ; 59   |    _P INT *m_EndAddress;
                             2128 ; 60   |} MemoryRegion;
                             2129 
                             2136 
                             2137 ; 61   |
                             2138 ; 62   |
                             2139 ; 63   |typedef struct TaskEntryStruct{
                             2140 ; 64   |    CircularBufferDescriptor *m_pMessageQueue;
                             2141 ; 65   |    void   *m_pWaitingOnPtr;                                //points to either an object o
                                  r a queue we're waiting on.
                             2142 ; 66   |    WORD    m_wWaitingOnWord;
                             2143 ; 67   |    WORD    m_wState;                                       //The state is used to indicat
                                  e what the task is waiting on.
                             2144 ; 68   |    WORD   *m_pStackPointer;
                             2145 ; 69   |    WORD    m_wTaskID;                                      //The kernel does not use this
                                   for any purpose.   This is set by the developer
                             2146 ; 70   |                                                            //  and returned by SysGetTask
                                  ID() for use by functions that are required to 
                             2147 ; 71   |                                                            //  be task aware.
                             2148 ; 72   |    long    m_lTimeout;                                     //This is in absolute time (ca
                                  n compare directly to the current system time
                             2149 ; 73   |    WORD    m_wRegionResources[MAX_REGIONS];                //a snapshot of the requiremen
                                  ts of the task in terms of which resources are loaded
                             2150 ; 74   |    WORD    m_wPriority;                                    
                             2151 ; 75   |    WORD   *m_pInitialStackPointer;                         //only used at init time
                             2152 ; 76   |    WORD    m_wStackSize;
                             2153 ; 77   |    _reentrant void   (*m_pEntryPoint)(void);               //only used at init time
                             2154 ; 78   |} TaskEntry;
                             2155 
                             2180 
                             2181 ; 79   |
                             2182 ; 80   |typedef union SyncObjectStruct {
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  37

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2183 ; 81   |    TaskEntry   *m_pOwner;
                             2184 ; 82   |    struct
                             2185 ; 83   |    {
                             2186 ; 84   |    int          m_iOwner :16;
                             2187 ; 85   |    int          m_iCount : 8;
                             2188 ; 86   |    } counter;
                             2189 ; 87   |} SyncObject;
                             2190 ; 88   |
                             2191 ; 89   |typedef WORD SignalGroup;
                             2192 ; 90   |
                             2193 ; 91   |
                             2194 ; 92   |typedef struct {
                             2195 ; 93   |    WORD    m_wMessageType;
                             2196 ; 94   |    CircularBufferDescriptor    *m_pDestination;
                             2197 ; 95   |}  RoutingEntry;
                             2198 
                             2203 
                             2204 ; 96   |
                             2205 ; 97   |extern RoutingEntry g_RoutingTable[];
                             2206 ; 98   |extern TaskEntry *g_TaskList[];
                             2207 
                             2215 
                             2216 ; 99   |extern MemoryRegion *g_RegionTable[];
                             2217 ; 100  |
                             2218 ; 101  |//Time Releated Functions
                             2219 ; 102  |_reentrant WORD SysWait(INT wTimeout);
                             2220 ; 103  |
                             2221 ; 104  |//Task Related Functions
                             2222 ; 105  |_reentrant WORD SysGetTaskID(void);
                             2223 ; 106  |
                             2224 ; 107  |//Message related functions
                             2225 ; 108  |_asmfunc WORD SysWaitOnMessage(INT wTimeout, Message *pMsg);
                             2226 
                             2233 
                             2234 ; 109  |_asmfunc WORD SysPeekMessage(CircularBufferDescriptor *pQueue, Message *pMsg);
                             2235 ; 110  |_reentrant WORD SysPostMessage(WORD wLength, ...);
                             2236 ; 111  |_reentrant WORD SysPostMessageWait(INT wTimeout, WORD wLength, ...);
                             2237 ; 112  |
                             2238 ; 113  |//maybe this is too much functionality?
                             2239 ; 114  |_asmfunc WORD SysWaitOnBoth(WORD wTimeout, SyncObject *pObject, Message *pMsg);
                             2240 
                             2252 
                             2253 ; 115  |
                             2254 ; 116  |//SyncObject Related functions
                             2255 ; 117  |_asmfunc WORD SysWaitOnObject(INT wTimeout, SyncObject *pObject);
                             2256 ; 118  |_asmfunc WORD SysAssignObject(SyncObject *pObject, TaskEntry *pTaskID);
                             2257 ; 119  |_reentrant void SysReleaseObject(SyncObject *pObject);
                             2258 ; 120  |_reentrant void ISRReleaseObject(SyncObject *pObject);
                             2259 ; 121  |
                             2260 ; 122  |//Queue Related Functions
                             2261 ; 123  |_asmfunc WORD SysWaitOnQueue(INT wTimeout,CircularBufferDescriptor *pQueue, INT wSizeToBeF
                                  ree);
                             2262 ; 124  |
                             2263 ; 125  |//Event Related Functions
                             2264 ; 126  |_asmfunc WORD SysWaitOnSignal(INT wTimeout, void * pSignalGroup, int iSignal);
                             2265 
                             2267 
                             2268 ; 127  |_asmfunc void SysSignal(SignalGroup *pSignalGroup, int iSignal);
                             2269 ; 128  |
                             2270 ; 129  |//ISR function
                             2271 ; 130  |
                             2272 ; 131  |//SysCallFunctions
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  38

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2273 ; 132  |int _asmfunc exSysCallFunction_v(void);
                             2274 ; 133  |int _asmfunc exSysCallFunction_i(int);
                             2275 ; 134  |int _asmfunc exSysCallFunction_ii(int, int);
                             2276 ; 135  |int _asmfunc exSysCallFunction_iii(int, int, int);
                             2277 ; 136  |int _asmfunc SysCallFunction(WORD * RESOURCE,int _reentrant (int,int,int*),  int, int, int
                                   *);
                             2278 ; 137  |#define SysCallFunction(rsrc,func,a,b,p) SysCallFunction((void*)rsrc,(func),(a),(b),(p))
                             2279 ; 138  |
                             2280 ; 139  |void _asmfunc v_SysCallFunction_v(WORD * RESOURCE,void _reentrant (void));
                             2281 ; 140  |#define v_SysCallFunction_v(rsrc,func) v_SysCallFunction_v((void*)rsrc,(func))
                             2282 ; 141  |
                             2283 ; 142  |void _asmfunc SysCallFunction_i(WORD * RESOURCE,void _reentrant (int),int);
                             2284 ; 143  |#define SysCallFunction_i(rsrc,func,a,b,p) SysCallFunction_i((void*)rsrc,(func),(a),(b),(p
                                  ))
                             2285 ; 144  |
                             2286 ; 145  |int _asmfunc SysCallFunction_L(void* RESOURCE,int _reentrant (long,long,int*),  long, long
                                  , int *);
                             2287 ; 146  |
                             2288 ; 147  |int _asmfunc i_SysCallFunction_i(WORD * RESOURCE,int _reentrant (int), int);
                             2289 ; 148  |
                             2290 ; 149  |int _asmfunc i_SysCallFunction_iipp(WORD * RESOURCE,int _reentrant (int,int,int*,int*),  i
                                  nt, int, int *, int *);
                             2291 ; 150  |
                             2292 ; 151  |int _asmfunc i_SysCallFunction_iiip(WORD * RESOURCE,int _reentrant (int,int,int,int*),  in
                                  t, int, int, int *);
                             2293 ; 152  |
                             2294 ; 153  |int _asmfunc fSysCallFunction(WORD * RESOURCE,int _reentrant (int,int,int*),  int, int, in
                                  t *);
                             2295 ; 154  |
                             2296 ; 155  |
                             2297 ; 156  |//These values are return values, and also values that are set in the TaskEntry.m_wState t
                                  o indicate what the task
                             2298 ; 157  |//is waiting on.
                             2299 ; 158  |#define EVENT_TIMEOUT   0
                             2300 ; 159  |#define EVENT_MESSAGE   1
                             2301 ; 160  |#define EVENT_OBJECT    2
                             2302 ; 161  |#define EVENT_QUEUE     4
                             2303 ; 162  |#define EVENT_SIGNAL    5
                             2304 ; 163  |#define EVENT_RELEASING_OBJECT2 6
                             2305 ; 164  |#define EVENT_RELEASING_OBJECT1 7
                             2306 ; 165  |
                             2307 ; 166  |
                             2308 ; 167  |//this is the owner that a SyncObject should be assigned to if a task it going to wait on 
                                  a completion of the interrupt. 
                             2309 ; 168  |#define ISR_OWNER  ((TaskEntry*)(0xffff))
                             2310 ; 169  |#define KERNEL_OWNER  ((TaskEntry*)(0))
                             2311 ; 170  |
                             2312 ; 171  |
                             2313 ; 172  |#ifdef INSTRUMENT_ENABLE
                             2314 ; 173  |#include <regsgpio.h>
                             2315 ; 174  |
                             2316 ; 175  |//
                             2317 ; 176  |// Define the bit positions in the GPIO registers used for signalling.
                             2318 ; 177  |//
                             2319 ; 178  |#define GPIO_24     B0
                             2320 ; 179  |#define GPIO_36     B12
                             2321 ; 180  |#define GPIO_37     B13
                             2322 ; 181  |#define GPIO_38     B14
                             2323 ; 182  |#define GPIO_39     B15
                             2324 ; 183  |#define GPIO_42     B18
                             2325 ; 184  |#define GPIO_46     B22
                             2326 ; 185  |#define GPIO_47     B23
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  39

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2327 ; 186  |
                             2328 ; 187  |//=============================================================================
                             2329 ; 188  |// SysSignalEvent
                             2330 ; 189  |//-----------------------------------------------------------------------------
                             2331 ; 190  |//! This macro allows code to set a gpio event that can be measured outside the
                             2332 ; 191  |//! part.
                             2333 ; 192  |//! \param wGPIONumber 
                             2334 ; 193  |//!     This should be one of the Macros defined above, and indicates which 
                             2335 ; 194  |//!     GPIO will be set.
                             2336 ; 195  |//!
                             2337 ; 196  |//! \return
                             2338 ; 197  |//!     None. 
                             2339 ; 198  |//!
                             2340 ; 199  |//=============================================================================
                             2341 ; 200  |#define SysSignalEvent(wGPIONumber)         \ 
                             2342 ; 201  |{                                           \ 
                             2343 ; 202  |    HW_GP1DOR.B.##wGPIONumber = 1;          \ 
                             2344 ; 203  |}
                             2345 ; 204  |
                             2346 ; 205  |//=============================================================================
                             2347 ; 206  |// SysClearEvent
                             2348 ; 207  |//-----------------------------------------------------------------------------
                             2349 ; 208  |//! This macro allows code to clear a gpio event that can be measured outside 
                             2350 ; 209  |//! the part.
                             2351 ; 210  |//! \param wGPIONumber 
                             2352 ; 211  |//!     This should be one of the Macros defined above, and indicates which 
                             2353 ; 212  |//!     GPIO will be set.
                             2354 ; 213  |//!
                             2355 ; 214  |//! \return
                             2356 ; 215  |//!     None. 
                             2357 ; 216  |//!
                             2358 ; 217  |//=============================================================================
                             2359 ; 218  |#define SysClearEvent(wGPIONumber)          \ 
                             2360 ; 219  |{                                           \ 
                             2361 ; 220  |    HW_GP1DOR.B.##wGPIONumber = 0;          \ 
                             2362 ; 221  |}
                             2363 ; 222  |
                             2364 ; 223  |//=============================================================================
                             2365 ; 224  |// SysEnableEvent
                             2366 ; 225  |//-----------------------------------------------------------------------------
                             2367 ; 226  |//! This macro must be called by code before using the SysSetEvent or 
                             2368 ; 227  |//! SysClearEvent so that the GPIOs are set up correctly.
                             2369 ; 228  |//!
                             2370 ; 229  |//! \param wGPIONumber 
                             2371 ; 230  |//!     This should be one of the Macros defined above, and indicates which 
                             2372 ; 231  |//!     GPIO will be set.
                             2373 ; 232  |//!
                             2374 ; 233  |//! \return
                             2375 ; 234  |//!     None. 
                             2376 ; 235  |//!
                             2377 ; 236  |//=============================================================================
                             2378 ; 237  |#define SysEnableEvent(wGPIONumber)         \ 
                             2379 ; 238  |{                                           \ 
                             2380 ; 239  |    HW_GP1DOER.B.##wGPIONumber=1;           \ 
                             2381 ; 240  |    HW_GP1DOR.B.##wGPIONumber=0;            \ 
                             2382 ; 241  |    HW_GP1ENR.B.##wGPIONumber=1;            \ 
                             2383 ; 242  |    HW_GP1PWR.B.##wGPIONumber=1;            \ 
                             2384 ; 243  |}
                             2385 ; 244  |#else // INSTRUMENT_ENABLE
                             2386 ; 245  |#define SysSignalEvent(wGPIONumber)
                             2387 ; 246  |#define SysClearEvent(wGPIONumber)
                             2388 ; 247  |#define SysEnableEvent(wGPIONumber)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  40

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2389 ; 248  |#endif // INSTRUMENT_ENABLE
                             2390 ; 249  |    
                             2391 ; 250  |#endif
                             2392 
                             2394 
                             2395 ; 16   |#include "usb_api.h"
                             2396 
                             2398 
                             2399 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2400 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                             2401 ; 3    |//
                             2402 ; 4    |// File : USB_API.H
                             2403 ; 5    |// Description : USB_API.H defines and structures definition for USB device
                             2404 ; 6    |//               driver API.
                             2405 ; 7    |//               This 
                             2406 ; 8    |////////////////////////////////////////////////////////////////////////////////
                             2407 ; 9    |
                             2408 ; 10   |#ifndef __usb_api_h__
                             2409 ; 11   |#define __usb_api_h__ 1
                             2410 ; 12   |
                             2411 ; 13   |#include "types.h"
                             2412 ; 14   |#include "project.h"
                             2413 ; 15   |
                             2414 ; 16   |#ifndef _USB_MEM
                             2415 ; 17   |//if not overwridden, default to the compiler default memory space
                             2416 ; 18   |#define _USB_MEM
                             2417 ; 19   |#endif
                             2418 ; 20   |
                             2419 ; 21   |#define USB_LANGUAGE_ENGLISH 0x0409
                             2420 ; 22   |#define USB_LANGUAGE_CHINESE_PRC 0x0804
                             2421 ; 23   |#define USB_LANGUAGE_CHINESE_TAIWAN 0x0404
                             2422 ; 24   |#define USB_LANGUAGE_JAPANESE 0x0411
                             2423 ; 25   |
                             2424 ; 26   |#define MAX_STRING 30
                             2425 ; 27   |
                             2426 ; 28   |#define  USB_SPEED_FULL                      (0)
                             2427 ; 29   |#define  USB_SPEED_LOW                       (1)
                             2428 ; 30   |#define  USB_SPEED_HIGH                      (2)
                             2429 ; 31   |
                             2430 ; 32   |#define EP_FS_MAX_PACKET_SIZE               (64)    
                             2431 ; 33   |
                             2432 ; 34   |#define EP_HS_MAX_PACKET_SIZE               (512)   
                             2433 ; 35   |
                             2434 ; 36   |// Data transferred to devices based on Sigmatel 3500 chip may sometimes be 
                             2435 ; 37   |// corrupted. The corruption occurs when device is connected in USB High Speed 
                             2436 ; 38   |// mode, and size of the transfer in bytes is divisible by 128, but not 
                             2437 ; 39   |// divisible by the packet size. The workaround is implemented in Microsoft MTP 
                             2438 ; 40   |// driver to allow support for those devices.
                             2439 ; 41   |
                             2440 ; 42   |// the bug can corrupt the end of data buffer. It occurs when host sends out a 
                             2441 ; 43   |// short packet that is multiple of 128 bytes. During this scenario the USB core
                             2442 ; 44   |// does writes that are voided (byte enable == all zero), which was an undefined 
                             2443 ; 45   |// capability and thus the gasket did not apply a proper response. This should 
                             2444 ; 46   |// not affect Mass Storage applications because data transfers are 512 bytes and 
                             2445 ; 47   |// scsi commands are < 16 bytes. Other applications with their own driver will
                             2446 ; 48   |// need to pad the packets if they fall into the error case. "What this basically 
                             2447 ; 49   |// boils down to is that any time the host sends a short packet of 128, 256 or
                             2448 ; 50   |// 384 bytes to a high-speed connected player a number of bytes will be corrupted.
                             2449 ; 51   |// This is easiest to reproduce in SendObject commands but can strike any of the 
                             2450 ; 52   |// commands that take an arbitrary amount of data.
                             2451 ; 53   |#define ARC_HS_128_MODULO_BUG               (128)
                             2452 ; 54   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  41

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2453 ; 55   |
                             2454 ; 56   |/* Error codes */
                             2455 ; 57   |#define USB_OK                              (0x00)
                             2456 ; 58   |#define USBERR_REGISTER_SERVICE             (0x01)  // Failed to register a service
                             2457 ; 59   |#define USBERR_NO_SERVICE                   (0x02)  // No registered service found 
                             2458 ; 60   |#define USBERR_TX_FAILED                    (0x03)  // Fail to prepare XD descriptor
                             2459 ; 61   |#define USBERR_SIZE_TOO_LARGE               (0x04)  // Number of bytes to transfer is too 
                                  large
                             2460 ; 62   |#define USBERR_EP_INIT_FAILED               (0x05)  // Endpoint init fail
                             2461 ; 63   |#define USBERR_CONFIG_FAILED                (0x06)  // Error reported by the application
                             2462 ; 64   |                                                    // if the new config failed or not sup
                                  ported
                             2463 ; 65   |#define USBERR_DEVICE_NOT_CONFIGURED        (0x07)  // Error reported by the transfer func
                                  tion
                             2464 ; 66   |                                                    // if attempting to transfer while the
                                   device
                             2465 ; 67   |                                                    // is not configured
                             2466 ; 68   |#define USBERR_INIT_FAILED                  (0x08)  // Fail to initialize the USB API
                             2467 ; 69   |
                             2468 ; 70   |
                             2469 ; 71   |/* Endpoint types */
                             2470 ; 72   |#define  USB_CONTROL_ENDPOINT             (0)
                             2471 ; 73   |#define  USB_ISOCHRONOUS_ENDPOINT         (1)
                             2472 ; 74   |#define  USB_BULK_ENDPOINT                (2)
                             2473 ; 75   |#define  USB_INTERRUPT_ENDPOINT           (3)
                             2474 ; 76   |
                             2475 ; 77   |/* End point direction */
                             2476 ; 78   |#define  USB_OUT                         (0)
                             2477 ; 79   |#define  USB_IN                          (1)
                             2478 ; 80   |
                             2479 ; 81   |/* End point packed size */
                             2480 ; 82   |#define  USB_FS_MAX_PACKET_SIZE           (64)
                             2481 ; 83   |#define  USB_HS_BULK_OUT_MAX_PACKET_SIZE  (256)
                             2482 ; 84   |#define  USB_HS_BULK_IN_MAX_PACKET_SIZE   (128)
                             2483 ; 85   |
                             2484 ; 86   |
                             2485 ; 87   |#define  USB_TEST_MODE_TEST_J             (0x01)
                             2486 ; 88   |#define  USB_TEST_MODE_TEST_K             (0x02)
                             2487 ; 89   |#define  USB_TEST_MODE_TEST_SE0_NAK       (0x03)
                             2488 ; 90   |#define  USB_TEST_MODE_TEST_PACKET        (0x04)
                             2489 ; 91   |
                             2490 ; 92   |/* Available service types */
                             2491 ; 93   |/* Services 0 through 15 are reserved for endpoints */
                             2492 ; 94   |#define  USB_SERVICE_EP0                  (0x00)
                             2493 ; 95   |#define  USB_SERVICE_EP1                  (0x01)
                             2494 ; 96   |#define  USB_SERVICE_EP2                  (0x02)
                             2495 ; 97   |#define  USB_SERVICE_EP3                  (0x03)
                             2496 ; 98   |#define  USB_SERVICE_EP4                  (0x04)
                             2497 ; 99   |#define  USB_SERVICE_EP5                  (0x05)
                             2498 ; 100  |#define  USB_SERVICE_EP6                  (0x06)
                             2499 ; 101  |#define  USB_SERVICE_EP7                  (0x07)
                             2500 ; 102  |#define  USB_SERVICE_EP8                  (0x08)
                             2501 ; 103  |#define  USB_SERVICE_EP9                  (0x09)
                             2502 ; 104  |#define  USB_SERVICE_EP10                 (0x0a)
                             2503 ; 105  |#define  USB_SERVICE_EP11                 (0x0b)
                             2504 ; 106  |#define  USB_SERVICE_EP12                 (0x0c)
                             2505 ; 107  |#define  USB_SERVICE_EP13                 (0x0d)
                             2506 ; 108  |#define  USB_SERVICE_EP14                 (0x0e)
                             2507 ; 109  |#define  USB_SERVICE_EP15                 (0x0f)
                             2508 ; 110  |#define  USB_SERVICE_BUS_RESET            (0x10)
                             2509 ; 111  |#define  USB_SERVICE_SUSPEND              (0x11)
                             2510 ; 112  |#define  USB_SERVICE_SOF                  (0x12)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  42

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2511 ; 113  |#define  USB_SERVICE_RESUME               (0x13)
                             2512 ; 114  |#define  USB_SERVICE_SLEEP                (0x14)
                             2513 ; 115  |#define  USB_SERVICE_SPEED_DETECTION      (0x15)
                             2514 ; 116  |#define  USB_SERVICE_TEST                 (0x16)
                             2515 ; 117  |#define  USB_SERVICE_CHANGE_CONFIG        (0x17)
                             2516 ; 118  |#define  USB_SERVICE_CHANGE_IFACE         (0x18)   
                             2517 ; 119  |#define  NON_EP_SERVICES                  (USB_SERVICE_SPEED_DETECTION - USB_SERVICE_EP15)
                                  
                             2518 ; 120  |
                             2519 ; 121  |// This is the maximum service structures allocated 
                             2520 ; 122  |// One for each End point + the common services (non endpoint services) 
                             2521 ; 123  |#define MAX_NUMBER_SERVICES               (MAX_NUM_EP + NON_EP_SERVICES)  
                             2522 ; 124  |
                             2523 ; 125  |#define NUMBER_BYTES_IN_SETUP               (8)
                             2524 ; 126  |
                             2525 ; 127  |// possible values of btStatus on the xd_struct
                             2526 ; 128  |#define  USB_STATUS_TRANSFER_IDLE           (0)
                             2527 ; 129  |#define  USB_STATUS_TRANSFER_SUCCESS        (1)            
                             2528 ; 130  |#define  USB_STATUS_TRANSFER_ACCEPTED       (2)
                             2529 ; 131  |#define  USB_STATUS_TRANSFER_IN_PROGRESS    (3)
                             2530 ; 132  |#define  USB_STATUS_TRANSFER_ERROR          (4)
                             2531 ; 133  |
                             2532 ; 134  |// types of status set/returned by set_status() and get_status()
                             2533 ; 135  |#define  USB_STATUS_DEVICE_STATE          (0x01)
                             2534 ; 136  |#define  USB_STATUS_INTERFACE             (0x02)
                             2535 ; 137  |#define  USB_STATUS_ADDRESS               (0x03)
                             2536 ; 138  |#define  USB_STATUS_CURRENT_CONFIG        (0x04)
                             2537 ; 139  |#define  USB_STATUS_SOF_COUNT             (0x05)
                             2538 ; 140  |#define  USB_STATUS                       (0x06)
                             2539 ; 141  |#define  USB_STATUS_TEST_MODE             (0x07)
                             2540 ; 142  |#define  USB_STATUS_DEVICE_SPEED          (0x08)  
                             2541 ; 143  |#define  USB_STATUS_DEVICE_TEST           (0x09)  
                             2542 ; 144  |#define  USB_STATUS_CURRENT_IFACE         (0x0a)
                             2543 ; 145  |#define  USB_STATUS_CONNECTION            (0x0b)  
                             2544 ; 146  |// For status endpoint, the endpoint number is coded in the less significant nibble
                             2545 ; 147  |#define  USB_STATUS_ENDPOINT              (0x10)
                             2546 ; 148  |#define  USB_STATUS_ENDPOINT_NUMBER_MASK  (0x0F)
                             2547 ; 149  |
                             2548 ; 150  |#define USB_MAX_SIZE_PER_TRANSFER       (0x4000)    // This is the maximum size that
                             2549 ; 151  |                                                    // we allow per transfer
                             2550 ; 152  |
                             2551 ; 153  |//Possible states the device can be in
                             2552 ; 154  |#define  USB_STATE_UNKNOWN                   (0xff)
                             2553 ; 155  |#define  USB_STATE_UNPLUGGED                 (0x05) // USB Cable unplugged
                             2554 ; 156  |#define  USB_STATE_PLUGGED                   (0x04) // USB Cable inserted
                             2555 ; 157  |#define  USB_STATE_POWERED                   (0x03)
                             2556 ; 158  |#define  USB_STATE_DEFAULT                   (0x02)
                             2557 ; 159  |#define  USB_STATE_ADDRESSED                 (0x01)
                             2558 ; 160  |#define  USB_STATE_CONFIGURED                (0x00)
                             2559 ; 161  |#define  USB_STATE_SUSPENDED                 (0x80)
                             2560 ; 162  |
                             2561 ; 163  |// Possible states the connection can be in
                             2562 ; 164  |//#define USB_STATE_UNKNOWN                 (0xff)
                             2563 ; 165  |#define USB_CONNECTED                       (0x00)
                             2564 ; 166  |#define USB_DISCONNECTED                    (0x01)
                             2565 ; 167  |
                             2566 ; 168  |
                             2567 ; 169  |
                             2568 ; 170  |typedef union
                             2569 ; 171  |{
                             2570 ; 172  |    struct
                             2571 ; 173  |    {
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  43

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2572 ; 174  |        int Recipient               : 5;
                             2573 ; 175  |        int Type                    : 2;
                             2574 ; 176  |        int DataTransferDirection   : 1;
                             2575 ; 177  |        int Request                 : 8;
                             2576 ; 178  |        int                         : 8;
                             2577 ; 179  |    } B;
                             2578 ; 180  |    
                             2579 ; 181  |    int I;
                             2580 ; 182  |} USBRequestType ;
                             2581 ; 183  |
                             2582 ; 184  |typedef struct {
                             2583 ; 185  |   BYTE     bValid;
                             2584 ; 186  |   USBRequestType RequestType;
                             2585 ; 187  |   BYTE     btRequest;
                             2586 ; 188  |   WORD     wValue;
                             2587 ; 189  |   WORD     wIndex;
                             2588 ; 190  |   WORD     wLength;
                             2589 ; 191  |    } USB_SetupData;
                             2590 ; 192  |
                             2591 ; 193  |// Descriptor sizes in bytes
                             2592 ; 194  |#define SIZE_DEVICE_DESCRIPTOR_IN_BYTES     (18)
                             2593 ; 195  |#define SIZE_DEVICE_DESCRIPTOR_IN_WORDS     (6)
                             2594 ; 196  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES   (10)
                             2595 ; 197  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_WORDS   (4)
                             2596 ; 198  |#define SIZE_CONFIG_DESCRIPTOR_IN_BYTES     (9)
                             2597 ; 199  |#define SIZE_CONFIG_DESCRIPTOR_IN_WORDS     (3)
                             2598 ; 200  |#define SIZE_INTERFACE_DESCRIPTOR_IN_BYTES  (9)
                             2599 ; 201  |#define SIZE_INTERFACE_DESCRIPTOR_IN_WORDS  (3)
                             2600 ; 202  |#define SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES   (7)
                             2601 ; 203  |
                             2602 ; 204  |
                             2603 ; 205  |// Descriptor types
                             2604 ; 206  |#define DESCRIPTOR_TYPE_DEVICE              (0x01)
                             2605 ; 207  |#define DESCRIPTOR_TYPE_CONFIG              (0x02)
                             2606 ; 208  |#define DESCRIPTOR_TYPE_STRING              (0x03)
                             2607 ; 209  |#define DESCRIPTOR_TYPE_INTERFACE           (0x04)
                             2608 ; 210  |#define DESCRIPTOR_TYPE_ENDPOINT            (0x05)
                             2609 ; 211  |#define DESCRIPTOR_TYPE_DEVICE_QUALIFIER    (0x06)
                             2610 ; 212  |#define DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG  (0x07)
                             2611 ; 213  |#define DESCRIPTOR_TYPE_INTERFACE_POWER     (0x08)
                             2612 ; 214  |
                             2613 ; 215  |
                             2614 ; 216  |#define USB_REQUEST_DIRECTION_HOST_TO_DEVICE    ((WORD)0x000000)
                             2615 ; 217  |#define USB_REQUEST_DIRECTION_DEVICE_TO_HOST    ((WORD)0x000001)
                             2616 ; 218  |
                             2617 ; 219  |#define USB_REQUEST_TYPE_STANDARD               ((WORD)0x000000)
                             2618 ; 220  |#define USB_REQUEST_TYPE_CLASS                  ((WORD)0x000001)
                             2619 ; 221  |#define USB_REQUEST_TYPE_VENDOR                 ((WORD)0x000002)
                             2620 ; 222  |#define USB_REQUEST_TYPE_RESERVED               ((WORD)0x000003)
                             2621 ; 223  |
                             2622 ; 224  |#define USB_REQUEST_RECIPIENT_DEVICE            ((WORD)0x000000)
                             2623 ; 225  |#define USB_REQUEST_RECIPIENT_INTERFACE         ((WORD)0x000001)
                             2624 ; 226  |#define USB_REQUEST_RECIPIENT_ENDPOINT          ((WORD)0x000002)
                             2625 ; 227  |#define USB_REQUEST_RECIPIENT_OTHER             ((WORD)0x000003)
                             2626 ; 228  |
                             2627 ; 229  |#define USB_REQUEST_STANDARD_GET_STATUS         ((WORD)0x000000)
                             2628 ; 230  |#define USB_REQUEST_STANDARD_CLEAR_FEATURE      ((WORD)0x000001)
                             2629 ; 231  |#define USB_REQUEST_STANDARD_RESERVED_1         ((WORD)0x000002)
                             2630 ; 232  |#define USB_REQUEST_STANDARD_SET_FEATURE        ((WORD)0x000003)
                             2631 ; 233  |#define USB_REQUEST_STANDARD_RESERVED_2         ((WORD)0x000004)
                             2632 ; 234  |#define USB_REQUEST_STANDARD_SET_ADDRESS        ((WORD)0x000005)
                             2633 ; 235  |#define USB_REQUEST_STANDARD_GET_DESCRIPTOR     ((WORD)0x000006)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  44

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2634 ; 236  |#define USB_REQUEST_STANDARD_SET_DESCRIPTOR     ((WORD)0x000007)
                             2635 ; 237  |#define USB_REQUEST_STANDARD_GET_CONFIGURATION  ((WORD)0x000008)
                             2636 ; 238  |#define USB_REQUEST_STANDARD_SET_CONFIGURATION  ((WORD)0x000009)
                             2637 ; 239  |#define USB_REQUEST_STANDARD_GET_INTERFACE      ((WORD)0x00000A)
                             2638 ; 240  |#define USB_REQUEST_STANDARD_SET_INTERFACE      ((WORD)0x00000B)
                             2639 ; 241  |#define USB_REQUEST_STANDARD_SYNCH_FRAME        ((WORD)0x00000C)
                             2640 ; 242  |
                             2641 ; 243  |#define USB_CLEAR_FEATURE_ENDPOINT_HALT         (0)
                             2642 ; 244  |#define USB_CLEAR_FEATURE_REMOTE_WAKEUP         (1)
                             2643 ; 245  |
                             2644 ; 246  |
                             2645 ; 247  |// Struct Device Descriptor
                             2646 ; 248  |typedef struct {
                             2647 ; 249  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (18)
                             2648 ; 250  |    BYTE    btDescriptorType;       // (1) Device descriptor type (1)
                             2649 ; 251  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             2650 ; 252  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             2651 ; 253  |    BYTE    btDeviceClass;          // (4) Class code
                             2652 ; 254  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             2653 ; 255  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             2654 ; 256  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 (8, 16, 32 o
                                  r 64)
                             2655 ; 257  |    BYTE    btIdVendorLsb;          // (8) Vendor Id
                             2656 ; 258  |    BYTE    btIdVendorMsb;          // (9)
                             2657 ; 259  |    BYTE    btIdProductLsb;         // (10) Product Id
                             2658 ; 260  |    BYTE    btIdProductMsb;         // (11)
                             2659 ; 261  |    BYTE    btBcdReleaseLsb;        // (12) Device release number in BCD
                             2660 ; 262  |    BYTE    btBcdReleaseMsb;        // (13)
                             2661 ; 263  |    BYTE    btIndexManufacturer;    // (14) Index of string descriptor describing Manufact
                                  urer
                             2662 ; 264  |    BYTE    btIndexProduct;         // (15) Index of string descriptor describing Product
                             2663 ; 265  |    BYTE    btIndexSerialNumber;    // (16) Index of string descriptor describing Device S
                                  erial Number
                             2664 ; 266  |    BYTE    btNumConfigurations;    // (17) Number of possible configurations
                             2665 ; 267  |} Struct_Standard_Dev_Desc;
                             2666 ; 268  |
                             2667 ; 269  |// Struct Device Qualifier Descriptor
                             2668 ; 270  |typedef struct {
                             2669 ; 271  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (10)
                             2670 ; 272  |    BYTE    btDescriptorType;       // (1) Device descriptor type (6)
                             2671 ; 273  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             2672 ; 274  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             2673 ; 275  |    BYTE    btDeviceClass;          // (4) Class code
                             2674 ; 276  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             2675 ; 277  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             2676 ; 278  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 other speed 
                                  (8, 16, 32 or 64)
                             2677 ; 279  |    BYTE    btNumConfigurations;    // (8) Number of other-speed possible configurations
                             2678 ; 280  |    BYTE    btReserved;             // (9) Reserved for future use, must be 0
                             2679 ; 281  |} Struct_Dev_Qualifier_Desc;
                             2680 ; 282  |
                             2681 ; 283  |// Struct Configuration Descriptor
                             2682 ; 284  |typedef struct {
                             2683 ; 285  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             2684 ; 286  |    BYTE    btDescriptorType;       // (1) Device descriptor type (2 or 7)
                             2685 ; 287  |    BYTE    btTotalLengthLsb;       // (2) Total length of data returned for this config.
                             2686 ; 288  |    BYTE    btTotalLengthMsb;       // (3)                                  
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  45

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2687 ; 289  |    BYTE    btNumInterfaces;        // (4) Number of Interfaces supported by this configur
                                  ation
                             2688 ; 290  |    BYTE    btConfigurationValue;   // (5) Value to use as an argument to the SetConfigura
                                  tion() request
                             2689 ; 291  |    BYTE    btIndexConfiguration;   // (6) Index of string descriptor describing this conf
                                  iguration
                             2690 ; 292  |    BYTE    btBitMapAttributes;     // (7) Configuration Characteristics
                             2691 ; 293  |                                    //     D7:      Reserved (set to one)
                             2692 ; 294  |                                    //     D6:      Self-powered
                             2693 ; 295  |                                    //     D5:      Remote Wakeup
                             2694 ; 296  |                                    //     D4..0:   Reserved (reset to zero)        
                             2695 ; 297  |    BYTE    btMaxPower;             // (8) Maximum power consumption expressed in 2mA unit
                                  s.
                             2696 ; 298  |} Struct_Standard_Config_Desc, Struct_Other_Speed_Config_Desc;
                             2697 ; 299  |
                             2698 ; 300  |// Struct Interface Descriptor
                             2699 ; 301  |typedef struct {
                             2700 ; 302  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             2701 ; 303  |    BYTE    btDescriptorType;       // (1) Device descriptor type (4)
                             2702 ; 304  |    BYTE    btInterfaceNum;         // (2) Number of this interface. Zero-based value.
                             2703 ; 305  |    BYTE    btAlternateSetting;     // (3)                                  
                             2704 ; 306  |    BYTE    btNumEndpoints;         // (4) Number of endpointsused by this interface (excl
                                  uding endpoint 0).
                             2705 ; 307  |    BYTE    btInterfaceClass;       // (5) Class code
                             2706 ; 308  |    BYTE    btInterfaceSubClass;    // (6) Sub Class code
                             2707 ; 309  |    BYTE    btInterfaceProtocol;    // (7) Protocol Code
                             2708 ; 310  |    BYTE    btIndexInterface;       // (8) Index of string descriptor describing this inte
                                  rface
                             2709 ; 311  |} Struct_Standard_Interface_Desc;
                             2710 ; 312  |
                             2711 ; 313  |// Struct Endpoint Descriptor
                             2712 ; 314  |typedef struct {
                             2713 ; 315  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (7)
                             2714 ; 316  |    BYTE    btDescriptorType;       // (1) Device descriptor type (5)
                             2715 ; 317  |    BYTE    btEndpointAddress;      // (2) Address of the endpoint on the USB device descr
                                  ibed by this descriptor
                             2716 ; 318  |                                    //      Bit 3..0: Endpoint number
                             2717 ; 319  |                                    //      Bit 6..4: Reserved, reset to zero
                             2718 ; 320  |                                    //      Bit 7:    Direction. Ignored for control endpo
                                  ints (0 OUT, 1 IN)
                             2719 ; 321  |    BYTE    btBitMapAttributes;     // (3) Endpoint attributes
                             2720 ; 322  |                                    //      bits 1..0: Transfer Type (00 Control, 01 Iso, 
                                  10 Bulk, 11 Int)
                             2721 ; 323  |                                    //      bits 5..2: If not an iso endpoints, they are r
                                  eserved and must be reset to zero.
                             2722 ; 324  |                                    //      bits 7..6: Reserved bits, must be reset to zer
                                  o.                                    
                             2723 ; 325  |    BYTE    btMaxPacketSizeLsb;     // (4) Maximum packet size. Refer to standard for bits
                                   specification
                             2724 ; 326  |    BYTE    btMaxPacketSizeMsb;     // (5)
                             2725 ; 327  |    BYTE    btInterval;             // (6) Interval for polling endpoint for data transfer
                                  s (refer to standard)
                             2726 ; 328  |} Struct_Standard_Endpoint_Desc;
                             2727 ; 329  |
                             2728 ; 330  |typedef struct {
                             2729 ; 331  |    BYTE    btLength;                   // (0) Size of this descriptor in bytes (2*MAX_USB
                                  _LANG + 2)
                             2730 ; 332  |    BYTE    btDescriptorType;           // (1) String descriptor type (3)
                             2731 ; 333  |    BYTE    btString[MAX_STRING*2];       
                             2732 ; 334  |} Struct_String_Desc;
                             2733 ; 335  |
                             2734 ; 336  |//
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  46

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2735 ; 337  |// Externals
                             2736 ; 338  |//
                             2737 ; 339  |extern void _reentrant usb_dci_chip_enable (void);
                             2738 ; 340  |extern void _reentrant usb_dci_shutdown(void);
                             2739 ; 341  |
                             2740 ; 342  |BYTE _reentrant usb_device_init(void);
                             2741 ; 343  |void _inline usb_device_shutdown(void)
                             2742 ; 344  |{
                             2743 ; 345  |    usb_dci_shutdown();
                             2744 ; 346  |}
                             2745 ; 347  |
                             2746 ; 348  |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYT
                                  E btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData)); 
                             2747 ; 349  |//Remove unused function usb_device_get_service() to reclain _P memroy.
                             2748 ; 350  |//BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE b
                                  tDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength)); 
                             2749 ; 351  |
                             2750 ; 352  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btD
                                  irection, BYTE btType, BOOL bFlag);
                             2751 ; 353  |
                             2752 ; 354  |extern USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             2753 ; 355  |#define usb_device_read_setup_data(btEndpoint) usb_dci_get_setup_data(btEndpoint)
                             2754 ; 356  |
                             2755 ; 357  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus);
                             2756 ; 358  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus);
                             2757 ; 359  |BYTE _reentrant usb_device_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             2758 ; 360  |
                             2759 ; 361  |extern void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             2760 ; 362  |#define usb_device_stall_endpoint(btEndpoint, btDirection) usb_dci_stall_endpoint((btEndpo
                                  int), (btDirection))
                             2761 ; 363  |
                             2762 ; 364  |extern void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             2763 ; 365  |#define usb_device_unstall_endpoint(btEndpoint, btDirection) usb_dci_unstall_endpoint((btE
                                  ndpoint), (btDirection))
                             2764 ; 366  |
                             2765 ; 367  |extern void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             2766 ; 368  |#define usb_device_finish_transaction(btEndpoint) usb_dci_finish_transaction(btEndpoint);
                             2767 ; 369  |
                             2768 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             2769 ; 371  |//
                             2770 ; 372  |//>  Name:          usb_device_enable
                             2771 ; 373  |//
                             2772 ; 374  |//   Type:          Function
                             2773 ; 375  |//
                             2774 ; 376  |//   Description:   Enables the USB device for transfers
                             2775 ; 377  |//
                             2776 ; 378  |//   Inputs:        none
                             2777 ; 379  |//
                             2778 ; 380  |//   Outputs:       USB_OK or error code
                             2779 ; 381  |//
                             2780 ; 382  |//   Notes:         none
                             2781 ; 383  |//<
                             2782 ; 384  |////////////////////////////////////////////////////////////////////////////////
                             2783 ; 385  |void _inline usb_device_enable(void)
                             2784 ; 386  |{
                             2785 ; 387  |    usb_dci_chip_enable();
                             2786 ; 388  |}
                             2787 ; 389  |
                             2788 ; 390  |void _reentrant usb_device_release(void);
                             2789 ; 391  |void _reentrant usb_device_hold(void);
                             2790 ; 392  |BYTE _reentrant usb_device_is_hold(void);
                             2791 ; 393  |void _reentrant usb_device_data_phase_required(void);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  47

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2792 ; 394  |
                             2793 ; 395  |BOOL _reentrant usb_device_is_first_init(void);
                             2794 ; 396  |void _reentrant usb_device_set_first_init(void);
                             2795 ; 397  |void _reentrant usb_device_clear_first_init(void);
                             2796 ; 398  |
                             2797 ; 399  |WORD _reentrant usb_get_current_limit(void);
                             2798 ; 400  |RETCODE _reentrant usb_set_current_limit(WORD);
                             2799 ; 401  |
                             2800 ; 402  |////////////////////////////////////////////////////////////////////
                             2801 ; 403  |extern BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             2802 ; 404  |#define usb_device_get_endpoint_status(btEndpoint) usb_dci_get_endpoint_status(btEndpoint)
                                  
                             2803 ; 405  |
                             2804 ; 406  |#define USB_ENDPOINT_STATUS_OK                          0
                             2805 ; 407  |#define USB_ENDPOINT_STATUS_STALLED                     1
                             2806 ; 408  |#define USB_ENDPOINT_STATUS_RECIEVED_UNSTALL_REQUEST    2
                             2807 ; 409  |// WHQL
                             2808 ; 410  |#define USB_ENDPOINT_STATUS_HOST_STALLED                3
                             2809 ; 411  |////////////////////////////////////////////////////////////////////
                             2810 ; 412  |
                             2811 ; 413  |
                             2812 ; 414  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             2813 ; 415  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             2814 ; 416  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLen
                                  gth,WORD wPrivateData);
                             2815 ; 417  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             2816 ; 418  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateDa
                                  ta, 
                             2817 ; 419  |                                         BOOL bIsDataPhase, WORD wDirection);
                             2818 ; 420  |
                             2819 ; 421  |#ifndef CUSTOMIZE_UNICODE
                             2820 ; 422  |extern const BYTE g_Manufacturer[];
                             2821 ; 423  |extern const BYTE g_ProductName[];
                             2822 ; 424  |extern const BYTE g_ConfigString[];
                             2823 ; 425  |extern const BYTE g_Interface0String[];
                             2824 ; 426  |extern const BYTE g_Interface1String[];
                             2825 ; 427  |extern const BYTE g_MSOSDescriptorString[];
                             2826 ; 428  |#else   // CUSTOMIZE_UNICODE
                             2827 ; 429  |extern const WORD g_Manufacturer[];
                             2828 ; 430  |extern const WORD g_ProductName[];
                             2829 ; 431  |extern const WORD g_ConfigString[];
                             2830 ; 432  |extern const WORD g_Interface0String[];
                             2831 ; 433  |extern const WORD g_Interface1String[];
                             2832 ; 434  |extern const WORD g_MSOSDescriptorString[];
                             2833 ; 435  |#endif
                             2834 ; 436  |extern WORD g_LanguageList[];
                             2835 ; 437  |
                             2836 ; 438  |extern const BYTE g_SCSIVendorID[];
                             2837 ; 439  |extern const BYTE g_SCSIProductID[];
                             2838 ; 440  |extern void *g_pStrings[];
                             2839 ; 441  |
                             2840 ; 442  |extern WORD g_wUSBVendorID;
                             2841 ; 443  |extern WORD g_wUSBProductID;
                             2842 ; 444  |extern WORD g_wUSBReleaseID;
                             2843 ; 445  |
                             2844 ; 446  |#endif
                             2845 ; 447  |/* EOF */
                             2846 ; 448  |
                             2847 
                             2849 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  48

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2850 ; 17   |#include "scsi.h"
                             2851 
                             2853 
                             2854 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2855 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             2856 ; 3    |//
                             2857 ; 4    |// Filename: scsi.h
                             2858 ; 5    |// Description: 
                             2859 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             2860 ; 7    |
                             2861 ; 8    |#ifndef _SCSI_H
                             2862 ; 9    |#define _SCSI_H
                             2863 ; 10   |
                             2864 ; 11   |#include "types.h"
                             2865 
                             2867 
                             2868 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2869 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             2870 ; 3    |//
                             2871 ; 4    |// Filename: types.h
                             2872 ; 5    |// Description: Standard data types
                             2873 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             2874 ; 7    |
                             2875 ; 8    |#ifndef _TYPES_H
                             2876 ; 9    |#define _TYPES_H
                             2877 ; 10   |
                             2878 ; 11   |// TODO:  move this outta here!
                             2879 ; 12   |#if !defined(NOERROR)
                             2880 ; 13   |#define NOERROR 0
                             2881 ; 14   |#define SUCCESS 0
                             2882 ; 15   |#endif 
                             2883 ; 16   |#if !defined(SUCCESS)
                             2884 ; 17   |#define SUCCESS  0
                             2885 ; 18   |#endif
                             2886 ; 19   |#if !defined(ERROR)
                             2887 ; 20   |#define ERROR   -1
                             2888 ; 21   |#endif
                             2889 ; 22   |#if !defined(FALSE)
                             2890 ; 23   |#define FALSE 0
                             2891 ; 24   |#endif
                             2892 ; 25   |#if !defined(TRUE)
                             2893 ; 26   |#define TRUE  1
                             2894 ; 27   |#endif
                             2895 ; 28   |
                             2896 ; 29   |#if !defined(NULL)
                             2897 ; 30   |#define NULL 0
                             2898 ; 31   |#endif
                             2899 ; 32   |
                             2900 ; 33   |#define MAX_INT     0x7FFFFF
                             2901 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             2902 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             2903 ; 36   |#define MAX_ULONG   (-1) 
                             2904 ; 37   |
                             2905 ; 38   |#define WORD_SIZE   24              // word size in bits
                             2906 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             2907 ; 40   |
                             2908 ; 41   |
                             2909 ; 42   |#define BYTE    unsigned char       // btVarName
                             2910 ; 43   |#define CHAR    signed char         // cVarName
                             2911 ; 44   |#define USHORT  unsigned short      // usVarName
                             2912 ; 45   |#define SHORT   unsigned short      // sVarName
                             2913 ; 46   |#define WORD    unsigned int        // wVarName
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  49

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2914 ; 47   |#define INT     signed int          // iVarName
                             2915 ; 48   |#define DWORD   unsigned long       // dwVarName
                             2916 ; 49   |#define LONG    signed long         // lVarName
                             2917 ; 50   |#define BOOL    unsigned int        // bVarName
                             2918 ; 51   |#define FRACT   _fract              // frVarName
                             2919 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             2920 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             2921 ; 54   |#define FLOAT   float               // fVarName
                             2922 ; 55   |#define DBL     double              // dVarName
                             2923 ; 56   |#define ENUM    enum                // eVarName
                             2924 ; 57   |#define CMX     _complex            // cmxVarName
                             2925 ; 58   |typedef WORD UCS3;                   // 
                             2926 ; 59   |
                             2927 ; 60   |#define UINT16  unsigned short
                             2928 ; 61   |#define UINT8   unsigned char   
                             2929 ; 62   |#define UINT32  unsigned long
                             2930 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             2931 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             2932 ; 65   |#define WCHAR   UINT16
                             2933 ; 66   |
                             2934 ; 67   |//UINT128 is 16 bytes or 6 words
                             2935 ; 68   |typedef struct UINT128_3500 {   
                             2936 ; 69   |    int val[6];     
                             2937 ; 70   |} UINT128_3500;
                             2938 ; 71   |
                             2939 ; 72   |#define UINT128   UINT128_3500
                             2940 ; 73   |
                             2941 ; 74   |// Little endian word packed byte strings:   
                             2942 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2943 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2944 ; 77   |// Little endian word packed byte strings:   
                             2945 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2946 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2947 ; 80   |
                             2948 ; 81   |// Declare Memory Spaces To Use When Coding
                             2949 ; 82   |// A. Sector Buffers
                             2950 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             2951 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             2952 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             2953 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             2954 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             2955 ; 88   |// B. Media DDI Memory
                             2956 ; 89   |#define MEDIA_DDI_MEM _Y
                             2957 ; 90   |
                             2958 ; 91   |
                             2959 ; 92   |
                             2960 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             2961 ; 94   |// Examples of circular pointers:
                             2962 ; 95   |//    INT CIRC cpiVarName
                             2963 ; 96   |//    DWORD CIRC cpdwVarName
                             2964 ; 97   |
                             2965 ; 98   |#define RETCODE INT                 // rcVarName
                             2966 ; 99   |
                             2967 ; 100  |// generic bitfield structure
                             2968 ; 101  |struct Bitfield {
                             2969 ; 102  |    unsigned int B0  :1;
                             2970 ; 103  |    unsigned int B1  :1;
                             2971 ; 104  |    unsigned int B2  :1;
                             2972 ; 105  |    unsigned int B3  :1;
                             2973 ; 106  |    unsigned int B4  :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  50

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2974 ; 107  |    unsigned int B5  :1;
                             2975 ; 108  |    unsigned int B6  :1;
                             2976 ; 109  |    unsigned int B7  :1;
                             2977 ; 110  |    unsigned int B8  :1;
                             2978 ; 111  |    unsigned int B9  :1;
                             2979 ; 112  |    unsigned int B10 :1;
                             2980 ; 113  |    unsigned int B11 :1;
                             2981 ; 114  |    unsigned int B12 :1;
                             2982 ; 115  |    unsigned int B13 :1;
                             2983 ; 116  |    unsigned int B14 :1;
                             2984 ; 117  |    unsigned int B15 :1;
                             2985 ; 118  |    unsigned int B16 :1;
                             2986 ; 119  |    unsigned int B17 :1;
                             2987 ; 120  |    unsigned int B18 :1;
                             2988 ; 121  |    unsigned int B19 :1;
                             2989 ; 122  |    unsigned int B20 :1;
                             2990 ; 123  |    unsigned int B21 :1;
                             2991 ; 124  |    unsigned int B22 :1;
                             2992 ; 125  |    unsigned int B23 :1;
                             2993 ; 126  |};
                             2994 ; 127  |
                             2995 ; 128  |union BitInt {
                             2996 ; 129  |        struct Bitfield B;
                             2997 ; 130  |        int        I;
                             2998 ; 131  |};
                             2999 ; 132  |
                             3000 ; 133  |#define MAX_MSG_LENGTH 10
                             3001 ; 134  |struct CMessage
                             3002 ; 135  |{
                             3003 ; 136  |        unsigned int m_uLength;
                             3004 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             3005 ; 138  |};
                             3006 ; 139  |
                             3007 ; 140  |typedef struct {
                             3008 ; 141  |    WORD m_wLength;
                             3009 ; 142  |    WORD m_wMessage;
                             3010 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             3011 ; 144  |} Message;
                             3012 ; 145  |
                             3013 ; 146  |struct MessageQueueDescriptor
                             3014 ; 147  |{
                             3015 ; 148  |        int *m_pBase;
                             3016 ; 149  |        int m_iModulo;
                             3017 ; 150  |        int m_iSize;
                             3018 ; 151  |        int *m_pHead;
                             3019 ; 152  |        int *m_pTail;
                             3020 ; 153  |};
                             3021 ; 154  |
                             3022 ; 155  |struct ModuleEntry
                             3023 ; 156  |{
                             3024 ; 157  |    int m_iSignaledEventMask;
                             3025 ; 158  |    int m_iWaitEventMask;
                             3026 ; 159  |    int m_iResourceOfCode;
                             3027 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             3028 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                             3029 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             3030 ; 163  |    int m_uTimeOutHigh;
                             3031 ; 164  |    int m_uTimeOutLow;
                             3032 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             3033 ; 166  |};
                             3034 ; 167  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  51

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3035 ; 168  |union WaitMask{
                             3036 ; 169  |    struct B{
                             3037 ; 170  |        unsigned int m_bNone     :1;
                             3038 ; 171  |        unsigned int m_bMessage  :1;
                             3039 ; 172  |        unsigned int m_bTimer    :1;
                             3040 ; 173  |        unsigned int m_bButton   :1;
                             3041 ; 174  |    } B;
                             3042 ; 175  |    int I;
                             3043 ; 176  |} ;
                             3044 ; 177  |
                             3045 ; 178  |
                             3046 ; 179  |struct Button {
                             3047 ; 180  |        WORD wButtonEvent;
                             3048 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             3049 ; 182  |};
                             3050 ; 183  |
                             3051 ; 184  |struct Message {
                             3052 ; 185  |        WORD wMsgLength;
                             3053 ; 186  |        WORD wMsgCommand;
                             3054 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             3055 ; 188  |};
                             3056 ; 189  |
                             3057 ; 190  |union EventTypes {
                             3058 ; 191  |        struct CMessage msg;
                             3059 ; 192  |        struct Button Button ;
                             3060 ; 193  |        struct Message Message;
                             3061 ; 194  |};
                             3062 ; 195  |
                             3063 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             3064 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             3065 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             3066 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             3067 ; 200  |
                             3068 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             3069 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             3070 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             3071 ; 204  |
                             3072 ; 205  |#if DEBUG
                             3073 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             3074 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             3075 ; 208  |#else 
                             3076 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                             3077 ; 210  |#define DebugBuildAssert(x)    
                             3078 ; 211  |#endif
                             3079 ; 212  |
                             3080 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             3081 ; 214  |//  #pragma asm
                             3082 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             3083 ; 216  |//  #pragma endasm
                             3084 ; 217  |
                             3085 ; 218  |
                             3086 ; 219  |#ifdef COLOR_262K
                             3087 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                             3088 ; 221  |#elif defined(COLOR_65K)
                             3089 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                             3090 ; 223  |#else
                             3091 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                             3092 ; 225  |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  52

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3093 ; 226  |    
                             3094 ; 227  |#endif // #ifndef _TYPES_H
                             3095 
                             3097 
                             3098 ; 12   |#include "filesystem.h"
                             3099 
                             3101 
                             3102 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3103 ; 2    |//  Copyright(C) SigmaTel, Inc. 2001
                             3104 ; 3    |//
                             3105 ; 4    |//  File        : FileSystem.h
                             3106 ; 5    |//  Description : Header File for File System
                             3107 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3108 ; 7    |
                             3109 ; 8    |#ifndef _FILESYSTEM_H
                             3110 ; 9    |#define _FILESYSTEM_H
                             3111 ; 10   |
                             3112 ; 11   |#include "types.h"
                             3113 
                             3115 
                             3116 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3117 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             3118 ; 3    |//
                             3119 ; 4    |// Filename: types.h
                             3120 ; 5    |// Description: Standard data types
                             3121 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3122 ; 7    |
                             3123 ; 8    |#ifndef _TYPES_H
                             3124 ; 9    |#define _TYPES_H
                             3125 ; 10   |
                             3126 ; 11   |// TODO:  move this outta here!
                             3127 ; 12   |#if !defined(NOERROR)
                             3128 ; 13   |#define NOERROR 0
                             3129 ; 14   |#define SUCCESS 0
                             3130 ; 15   |#endif 
                             3131 ; 16   |#if !defined(SUCCESS)
                             3132 ; 17   |#define SUCCESS  0
                             3133 ; 18   |#endif
                             3134 ; 19   |#if !defined(ERROR)
                             3135 ; 20   |#define ERROR   -1
                             3136 ; 21   |#endif
                             3137 ; 22   |#if !defined(FALSE)
                             3138 ; 23   |#define FALSE 0
                             3139 ; 24   |#endif
                             3140 ; 25   |#if !defined(TRUE)
                             3141 ; 26   |#define TRUE  1
                             3142 ; 27   |#endif
                             3143 ; 28   |
                             3144 ; 29   |#if !defined(NULL)
                             3145 ; 30   |#define NULL 0
                             3146 ; 31   |#endif
                             3147 ; 32   |
                             3148 ; 33   |#define MAX_INT     0x7FFFFF
                             3149 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             3150 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             3151 ; 36   |#define MAX_ULONG   (-1) 
                             3152 ; 37   |
                             3153 ; 38   |#define WORD_SIZE   24              // word size in bits
                             3154 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             3155 ; 40   |
                             3156 ; 41   |
                             3157 ; 42   |#define BYTE    unsigned char       // btVarName
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  53

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3158 ; 43   |#define CHAR    signed char         // cVarName
                             3159 ; 44   |#define USHORT  unsigned short      // usVarName
                             3160 ; 45   |#define SHORT   unsigned short      // sVarName
                             3161 ; 46   |#define WORD    unsigned int        // wVarName
                             3162 ; 47   |#define INT     signed int          // iVarName
                             3163 ; 48   |#define DWORD   unsigned long       // dwVarName
                             3164 ; 49   |#define LONG    signed long         // lVarName
                             3165 ; 50   |#define BOOL    unsigned int        // bVarName
                             3166 ; 51   |#define FRACT   _fract              // frVarName
                             3167 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             3168 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             3169 ; 54   |#define FLOAT   float               // fVarName
                             3170 ; 55   |#define DBL     double              // dVarName
                             3171 ; 56   |#define ENUM    enum                // eVarName
                             3172 ; 57   |#define CMX     _complex            // cmxVarName
                             3173 ; 58   |typedef WORD UCS3;                   // 
                             3174 ; 59   |
                             3175 ; 60   |#define UINT16  unsigned short
                             3176 ; 61   |#define UINT8   unsigned char   
                             3177 ; 62   |#define UINT32  unsigned long
                             3178 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             3179 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             3180 ; 65   |#define WCHAR   UINT16
                             3181 ; 66   |
                             3182 ; 67   |//UINT128 is 16 bytes or 6 words
                             3183 ; 68   |typedef struct UINT128_3500 {   
                             3184 ; 69   |    int val[6];     
                             3185 ; 70   |} UINT128_3500;
                             3186 ; 71   |
                             3187 ; 72   |#define UINT128   UINT128_3500
                             3188 ; 73   |
                             3189 ; 74   |// Little endian word packed byte strings:   
                             3190 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3191 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3192 ; 77   |// Little endian word packed byte strings:   
                             3193 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3194 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3195 ; 80   |
                             3196 ; 81   |// Declare Memory Spaces To Use When Coding
                             3197 ; 82   |// A. Sector Buffers
                             3198 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             3199 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             3200 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             3201 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             3202 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             3203 ; 88   |// B. Media DDI Memory
                             3204 ; 89   |#define MEDIA_DDI_MEM _Y
                             3205 ; 90   |
                             3206 ; 91   |
                             3207 ; 92   |
                             3208 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             3209 ; 94   |// Examples of circular pointers:
                             3210 ; 95   |//    INT CIRC cpiVarName
                             3211 ; 96   |//    DWORD CIRC cpdwVarName
                             3212 ; 97   |
                             3213 ; 98   |#define RETCODE INT                 // rcVarName
                             3214 ; 99   |
                             3215 ; 100  |// generic bitfield structure
                             3216 ; 101  |struct Bitfield {
                             3217 ; 102  |    unsigned int B0  :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  54

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3218 ; 103  |    unsigned int B1  :1;
                             3219 ; 104  |    unsigned int B2  :1;
                             3220 ; 105  |    unsigned int B3  :1;
                             3221 ; 106  |    unsigned int B4  :1;
                             3222 ; 107  |    unsigned int B5  :1;
                             3223 ; 108  |    unsigned int B6  :1;
                             3224 ; 109  |    unsigned int B7  :1;
                             3225 ; 110  |    unsigned int B8  :1;
                             3226 ; 111  |    unsigned int B9  :1;
                             3227 ; 112  |    unsigned int B10 :1;
                             3228 ; 113  |    unsigned int B11 :1;
                             3229 ; 114  |    unsigned int B12 :1;
                             3230 ; 115  |    unsigned int B13 :1;
                             3231 ; 116  |    unsigned int B14 :1;
                             3232 ; 117  |    unsigned int B15 :1;
                             3233 ; 118  |    unsigned int B16 :1;
                             3234 ; 119  |    unsigned int B17 :1;
                             3235 ; 120  |    unsigned int B18 :1;
                             3236 ; 121  |    unsigned int B19 :1;
                             3237 ; 122  |    unsigned int B20 :1;
                             3238 ; 123  |    unsigned int B21 :1;
                             3239 ; 124  |    unsigned int B22 :1;
                             3240 ; 125  |    unsigned int B23 :1;
                             3241 ; 126  |};
                             3242 ; 127  |
                             3243 ; 128  |union BitInt {
                             3244 ; 129  |        struct Bitfield B;
                             3245 ; 130  |        int        I;
                             3246 ; 131  |};
                             3247 ; 132  |
                             3248 ; 133  |#define MAX_MSG_LENGTH 10
                             3249 ; 134  |struct CMessage
                             3250 ; 135  |{
                             3251 ; 136  |        unsigned int m_uLength;
                             3252 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             3253 ; 138  |};
                             3254 ; 139  |
                             3255 ; 140  |typedef struct {
                             3256 ; 141  |    WORD m_wLength;
                             3257 ; 142  |    WORD m_wMessage;
                             3258 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             3259 ; 144  |} Message;
                             3260 ; 145  |
                             3261 ; 146  |struct MessageQueueDescriptor
                             3262 ; 147  |{
                             3263 ; 148  |        int *m_pBase;
                             3264 ; 149  |        int m_iModulo;
                             3265 ; 150  |        int m_iSize;
                             3266 ; 151  |        int *m_pHead;
                             3267 ; 152  |        int *m_pTail;
                             3268 ; 153  |};
                             3269 ; 154  |
                             3270 ; 155  |struct ModuleEntry
                             3271 ; 156  |{
                             3272 ; 157  |    int m_iSignaledEventMask;
                             3273 ; 158  |    int m_iWaitEventMask;
                             3274 ; 159  |    int m_iResourceOfCode;
                             3275 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             3276 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                             3277 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             3278 ; 163  |    int m_uTimeOutHigh;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  55

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3279 ; 164  |    int m_uTimeOutLow;
                             3280 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             3281 ; 166  |};
                             3282 ; 167  |
                             3283 ; 168  |union WaitMask{
                             3284 ; 169  |    struct B{
                             3285 ; 170  |        unsigned int m_bNone     :1;
                             3286 ; 171  |        unsigned int m_bMessage  :1;
                             3287 ; 172  |        unsigned int m_bTimer    :1;
                             3288 ; 173  |        unsigned int m_bButton   :1;
                             3289 ; 174  |    } B;
                             3290 ; 175  |    int I;
                             3291 ; 176  |} ;
                             3292 ; 177  |
                             3293 ; 178  |
                             3294 ; 179  |struct Button {
                             3295 ; 180  |        WORD wButtonEvent;
                             3296 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             3297 ; 182  |};
                             3298 ; 183  |
                             3299 ; 184  |struct Message {
                             3300 ; 185  |        WORD wMsgLength;
                             3301 ; 186  |        WORD wMsgCommand;
                             3302 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             3303 ; 188  |};
                             3304 ; 189  |
                             3305 ; 190  |union EventTypes {
                             3306 ; 191  |        struct CMessage msg;
                             3307 ; 192  |        struct Button Button ;
                             3308 ; 193  |        struct Message Message;
                             3309 ; 194  |};
                             3310 ; 195  |
                             3311 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             3312 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             3313 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             3314 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             3315 ; 200  |
                             3316 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             3317 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             3318 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             3319 ; 204  |
                             3320 ; 205  |#if DEBUG
                             3321 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             3322 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             3323 ; 208  |#else 
                             3324 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                             3325 ; 210  |#define DebugBuildAssert(x)    
                             3326 ; 211  |#endif
                             3327 ; 212  |
                             3328 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             3329 ; 214  |//  #pragma asm
                             3330 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             3331 ; 216  |//  #pragma endasm
                             3332 ; 217  |
                             3333 ; 218  |
                             3334 ; 219  |#ifdef COLOR_262K
                             3335 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                             3336 ; 221  |#elif defined(COLOR_65K)
                             3337 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  56

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3338 ; 223  |#else
                             3339 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                             3340 ; 225  |#endif
                             3341 ; 226  |    
                             3342 ; 227  |#endif // #ifndef _TYPES_H
                             3343 
                             3345 
                             3346 ; 12   |
                             3347 ; 13   |
                             3348 ; 14   |// File attributes
                             3349 ; 15   |#ifndef _FS_ATTRIBUTES
                             3350 ; 16   |#define _FS_ATTRIBUTES
                             3351 ; 17   |#define READ        1
                             3352 ; 18   |#define WRITE       2
                             3353 ; 19   |#define WRITE_PLUS  3
                             3354 ; 20   |#define APPEND      4
                             3355 ; 21   |#define TRUNCATE    8
                             3356 ; 22   |#define CREATE      16
                             3357 ; 23   |#endif
                             3358 ; 24   |
                             3359 ; 25   |//#ifndef FAT12
                             3360 ; 26   |//#define FAT12   1
                             3361 ; 27   |//#endif
                             3362 ; 28   |//
                             3363 ; 29   |#ifndef FAT16
                             3364 ; 30   |#define FAT16   2
                             3365 ; 31   |#endif
                             3366 ; 32   |
                             3367 ; 33   |#define MEM_SPACE_P 0x100000
                             3368 ; 34   |#define MEM_SPACE_Y 0x400000
                             3369 ; 35   |#define MEM_SPACE_X 0x800000
                             3370 ; 36   |
                             3371 ; 37   |#define FILE_SYS_MODE_READ  0
                             3372 ; 38   |#define FILE_SYS_MODE_WRITE 1
                             3373 ; 39   | 
                             3374 ; 40   |#define ATTR_READ_ONLY      0x01
                             3375 ; 41   |#define ATTR_HIDDEN         0x02
                             3376 ; 42   |#define ATTR_SYSTEM         0x04
                             3377 ; 43   |#define ATTR_VOLUME_ID      0x08
                             3378 ; 44   |#define ATTR_DIRECTORY      0x10
                             3379 ; 45   |#define ATTR_ARCHIVE        0x20
                             3380 ; 46   |#define ATTR_LONG_NAME      ATTR_READ_ONLY|ATTR_HIDDEN|ATTR_SYSTEM|ATTR_VOLUME_ID
                             3381 ; 47   |
                             3382 ; 48   |#define SEEK_SET           -1
                             3383 ; 49   |#define SEEK_CUR            0
                             3384 ; 50   |#define SEEK_END            1
                             3385 ; 51   |
                             3386 ; 52   |#define DEVICE_INSTALLED              (WORD)(0)
                             3387 ; 53   |#define DEVICE_NOT_FOUND              (WORD)(2)
                             3388 ; 54   |#define INVALID_FILESYSTEM                        (WORD)(3)
                             3389 ; 55   |#define DEVICE_INVALID                (WORD)(-1)
                             3390 ; 56   |#define DEVICE_ERROR_WRITE_PROTECTED  (WORD)(-2)
                             3391 ; 57   |
                             3392 ; 58   |#define MEDIA_SIZE_TOTAL_SECTORS    0
                             3393 ; 59   |#define MEDIA_SIZE_TOTAL_BYTES      1
                             3394 ; 60   |#define MEDIA_SIZE_BYTES_PER_SECTOR 2
                             3395 ; 61   |#define MEDIA_SIZE_IN_MEGABYTES     3     
                             3396 ; 62   |
                             3397 ; 63   |#define READ_TYPE_NORMAL            0
                             3398 ; 64   |#define READ_TYPE_FAT               1
                             3399 ; 65   |#define READ_TYPE_RAW               2
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  57

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3400 ; 66   |
                             3401 ; 67   |
                             3402 ; 68   |#ifdef MEDIA_DDI_PARTIAL_SEQ_ENABLE
                             3403 ; 69   |    #define WRITE_TYPE_RANDOM                   0
                             3404 ; 70   |    #define WRITE_TYPE_SEQ_FIRST                1
                             3405 ; 71   |    #define WRITE_TYPE_SEQ_NEXT                 2
                             3406 ; 72   |    #define WRITE_TYPE_RESET_CLEAN_UP           3
                             3407 ; 73   |    #define WRITE_TYPE_PARTIAL_SEQ_FIRST        4
                             3408 ; 74   |    #define WRITE_TYPE_PARTIAL_SEQ_NEXT         5
                             3409 ; 75   |    #define WRITE_TYPE_PARTIAL_SEQ_LAST         6
                             3410 ; 76   |    #ifdef MEDIA_DDI_RAW_SECTOR_SERVER_ENABLE
                             3411 ; 77   |        #define WRITE_TYPE_RANDOM_RAW               7
                             3412 ; 78   |        #define WRITE_TYPE_SEQ_FIRST_RAW            8
                             3413 ; 79   |        #define WRITE_TYPE_SEQ_NEXT_RAW             9
                             3414 ; 80   |        #define WRITE_TYPE_PARTIAL_SEQ_FIRST_RAW    10
                             3415 ; 81   |        #define WRITE_TYPE_PARTIAL_SEQ_NEXT_RAW     11
                             3416 ; 82   |        #define WRITE_TYPE_PARTIAL_SEQ_LAST_RAW     12
                             3417 ; 83   |    #endif
                             3418 ; 84   |#else
                             3419 ; 85   |    #define WRITE_TYPE_RANDOM                   0
                             3420 ; 86   |    #define WRITE_TYPE_SEQ_FIRST                1
                             3421 ; 87   |    #define WRITE_TYPE_SEQ_NEXT                 2
                             3422 ; 88   |    #ifdef MEDIA_DDI_RAW_SECTOR_SERVER_ENABLE
                             3423 ; 89   |        #define WRITE_TYPE_RANDOM_RAW               3
                             3424 ; 90   |        #define WRITE_TYPE_SEQ_FIRST_RAW            4
                             3425 ; 91   |        #define WRITE_TYPE_SEQ_NEXT_RAW             5
                             3426 ; 92   |    #endif
                             3427 ; 93   |#endif
                             3428 ; 94   |    #define WRITE_TYPE_UNDEFINED 0xFFFFFF
                             3429 ; 95   |
                             3430 ; 96   |
                             3431 ; 97   |#ifndef MAX_FILENAME_LENGTH
                             3432 ; 98   |#define MAX_FILENAME_LENGTH 256
                             3433 ; 99   |#endif
                             3434 ; 100  |
                             3435 ; 101  |typedef struct {
                             3436 ; 102  |    WORD wNumberOfZones;
                             3437 ; 103  |    WORD wSizeInMegaBytes;
                             3438 ; 104  |} SMARTMEDIA_CHIP_INFO;
                             3439 ; 105  |
                             3440 ; 106  |typedef struct {
                             3441 ; 107  |    WORD wBootIdentification;
                             3442 ; 108  |    WORD wStartHeadNumber;
                             3443 ; 109  |    WORD wStartSectorNumber;
                             3444 ; 110  |    WORD wStartCylinderNumber;
                             3445 ; 111  |    WORD wSystemIdentification;
                             3446 ; 112  |    WORD wEndHeadNumber;
                             3447 ; 113  |    WORD wEndSectorNumber;
                             3448 ; 114  |    WORD wEndCylinderNumber;
                             3449 ; 115  |    WORD wStartLogicalSectorNumberHigh;
                             3450 ; 116  |    WORD wStartLogicalSectorNumberLow;
                             3451 ; 117  |    WORD wPartitionSizeHigh;
                             3452 ; 118  |    WORD wPartitionSizeLow;
                             3453 ; 119  |} SMARTMEDIA_PARTITION_TABLE;
                             3454 ; 120  |
                             3455 ; 121  |typedef struct {
                             3456 ; 122  |    WORD wWord0;
                             3457 ; 123  |    WORD wWord1;
                             3458 ; 124  |    WORD wWord2;
                             3459 ; 125  |} SMARTMEDIA_CIS_IDI_MANUFACTURER_NAME;
                             3460 ; 126  |
                             3461 ; 127  |typedef struct {
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  58

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3462 ; 128  |    WORD wWord0;
                             3463 ; 129  |    WORD wWord1;
                             3464 ; 130  |} SMARTMEDIA_CIS_IDI_PRODUCT_NAME;
                             3465 ; 131  |
                             3466 ; 132  |typedef struct {
                             3467 ; 133  |    WORD wWord0;
                             3468 ; 134  |    WORD wWord1;
                             3469 ; 135  |} SMARTMEDIA_CIS_IDI_PRODUCT_VERSION;
                             3470 ; 136  |
                             3471 ; 137  |typedef struct {
                             3472 ; 138  |    WORD wWord0;
                             3473 ; 139  |    WORD wWord1;
                             3474 ; 140  |    WORD wWord2;
                             3475 ; 141  |    WORD wWord3;
                             3476 ; 142  |} SMARTMEDIA_CIS_IDI_SERIAL_NUMBER;
                             3477 ; 143  |
                             3478 ; 144  |typedef struct {
                             3479 ; 145  |    WORD wWord0;
                             3480 ; 146  |} SMARTMEDIA_CIS_IDI_MODEL_NUMBER;
                             3481 
                             3504 
                             3505 ; 147  |
                             3506 ; 148  |typedef struct {
                             3507 ; 149  |    SMARTMEDIA_CIS_IDI_MANUFACTURER_NAME ManufacturerName;
                             3508 ; 150  |    SMARTMEDIA_CIS_IDI_PRODUCT_NAME ProductName;
                             3509 ; 151  |    SMARTMEDIA_CIS_IDI_PRODUCT_VERSION ProductVersion;
                             3510 ; 152  |    SMARTMEDIA_CIS_IDI_SERIAL_NUMBER SerialNumber;
                             3511 ; 153  |    SMARTMEDIA_CIS_IDI_MODEL_NUMBER ModelNumber;
                             3512 ; 154  |} SMARTMEDIA_CIS_IDI_TABLE;
                             3513 
                             3535 
                             3536 ; 155  |   
                             3537 ; 156  |typedef struct {
                             3538 ; 157  |    WORD wPageSizeInBytes;
                             3539 ; 158  |    WORD wRedundantAreaSizeInBytes;
                             3540 ; 159  |    WORD wNumberOfPagesPerBlock;
                             3541 ; 160  |    WORD wNumberOfBlocksPerZone;
                             3542 ; 161  |    WORD wNumberOfZonesInMedia;
                             3543 ; 162  |    WORD wMediaSizeInMBytes;
                             3544 ; 163  |    SMARTMEDIA_PARTITION_TABLE * pPartitionTable;
                             3545 ; 164  |    SMARTMEDIA_CIS_IDI_TABLE * pCisIdiTable;
                             3546 ; 165  |    WORD wMediaFlagStatus;
                             3547 ; 166  |    WORD wNumberOfBlocksToTheCisIdiBlock;
                             3548 ; 167  |    WORD wTotalNumberOfPhysicalBlocks;
                             3549 ; 168  |    WORD wNumberOfSystemBlocks;
                             3550 ; 169  |} SMARTMEDIA_ENTRY_TABLE;
                             3551 ; 170  |
                             3552 ; 171  |typedef struct {
                             3553 ; 172  |    WORD wDevice;        
                             3554 ; 173  |    WORD wDirtyBlockFlag;
                             3555 ; 174  |    WORD wCleanTailFlag; 
                             3556 ; 175  |    WORD wLogDOSPage;    
                             3557 ; 176  |    WORD wSrcLogBlock;   
                             3558 ; 177  |    WORD wSrcPhyBlock;   
                             3559 ; 178  |    WORD wDestPhyBlock;  
                             3560 ; 179  |    WORD wStartSrcPage;  
                             3561 ; 180  |    WORD wStartDestPage; 
                             3562 ; 181  |    WORD wPagesToCopy;   
                             3563 ; 182  |    WORD wReplaceBuff;   
                             3564 ; 183  |    WORD wReplaceRdnt;
                             3565 ; 184  |    #ifdef MEDIA_DDI_PARTIAL_SEQ_ENABLE
                             3566 ; 185  |        WORD wFirstCount;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  59

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3567 ; 186  |        WORD wNextCount;
                             3568 ; 187  |        WORD wLastCount;
                             3569 ; 188  |    #endif
                             3570 ; 189  |} SMARTMEDIA_FWPPS_TABLE;
                             3571 ; 190  |
                             3572 ; 191  |typedef struct {
                             3573 ; 192  |    WORD wWord0;
                             3574 ; 193  |    WORD wWord1;
                             3575 ; 194  |    WORD wWord2;
                             3576 ; 195  |    WORD wWord3;
                             3577 ; 196  |} DIRECTORY_NAME;
                             3578 ; 197  |
                             3579 ; 198  |typedef struct {
                             3580 ; 199  |    WORD wWord0;
                             3581 ; 200  |    WORD wWord1;
                             3582 ; 201  |} DIRECTORY_EXTENSION;
                             3583 ; 202  |
                             3584 ; 203  |typedef struct {
                             3585 ; 204  |    WORD wWord0;
                             3586 ; 205  |    WORD wWord1;
                             3587 ; 206  |} DIRECTORY_SIZE;
                             3588 
                             3603 
                             3604 ; 207  |
                             3605 ; 208  |typedef struct {
                             3606 ; 209  |    DIRECTORY_NAME Name;
                             3607 ; 210  |    DIRECTORY_EXTENSION Extension;
                             3608 ; 211  |    WORD wAttribute;
                             3609 ; 212  |    WORD wReserved[4];
                             3610 ; 213  |    WORD wCreationTime;
                             3611 ; 214  |    WORD wCreationData;
                             3612 ; 215  |    WORD wFirstCluster;
                             3613 ; 216  |    DIRECTORY_SIZE Size;
                             3614 ; 217  |    WORD wCurrentCluster;
                             3615 ; 218  |    WORD wPointer;
                             3616 ; 219  |    WORD wRecord;
                             3617 ; 220  |    WORD wRd;
                             3618 ; 221  |} DIRECTORY_FILE_CONTROL_BLOCK;
                             3619 ; 222  |
                             3620 ; 223  |// TODO:  clean this up.  There are two versions.
                             3621 ; 224  |struct FCB
                             3622 ; 225  |{
                             3623 ; 226  |    _packed BYTE m_szFileName[9];       //0-2
                             3624 ; 227  |    int     m_wReserved;                //3
                             3625 ; 228  |    _packed BYTE m_szExt[4];            //4-5
                             3626 ; 229  |    int     m_wAttributes;              //6
                             3627 ; 230  |    int     m_wReserved2[4];            //7,8,9,a
                             3628 ; 231  |    int     m_wTimeofCreation;          //b
                             3629 ; 232  |    int     m_wDateofCreation;          //c
                             3630 ; 233  |    int     m_wFirstCluster;            //d
                             3631 ; 234  |    int     m_wFileSizeHigh;            //e
                             3632 ; 235  |    int     m_wFileSizeLow;             //f
                             3633 ; 236  |};
                             3634 
                             3650 
                             3651 ; 237  |
                             3652 ; 238  |
                             3653 ; 239  |typedef struct {
                             3654 ; 240  |    WORD wFirstClusterCurrentDirectory;
                             3655 ; 241  |    WORD wFirstClusterParentDirectory;
                             3656 ; 242  |    WORD wAbsSectorCurrentlyCached;
                             3657 ; 243  |    WORD wCurrentRelativeSector;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  60

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3658 ; 244  |    WORD wNumberOfSectors;
                             3659 ; 245  |    WORD wCurrentRecordLoadedInDcb;
                             3660 ; 246  |    WORD wBufferedRecord;
                             3661 ; 247  |    WORD wMaxNumberRecordsCurrentDirectory;
                             3662 ; 248  |    WORD * pwPointerToBuffer;
                             3663 ; 249  |    WORD * pwPointerToPath;
                             3664 ; 250  |    DIRECTORY_FILE_CONTROL_BLOCK * pDirFcb;
                             3665 ; 251  |} DIRECTORY_CONTROL_BLOCK;
                             3666 ; 252  |
                             3667 ; 253  |typedef struct {
                             3668 ; 254  |    WORD wWord0;
                             3669 ; 255  |    WORD wWord1;
                             3670 ; 256  |    WORD wWord2;
                             3671 ; 257  |    WORD wWord3;
                             3672 ; 258  |} FILE_NAME;
                             3673 ; 259  |
                             3674 ; 260  |typedef struct {
                             3675 ; 261  |    WORD wWord0;
                             3676 ; 262  |    WORD wWord1;
                             3677 ; 263  |} FILE_EXTENSION;
                             3678 ; 264  |
                             3679 ; 265  |typedef struct {
                             3680 ; 266  |    WORD wWord0;
                             3681 ; 267  |    WORD wWord1;
                             3682 ; 268  |} FILE_SIZE;
                             3683 ; 269  |
                             3684 ; 270  |typedef union {
                             3685 ; 271  |    struct {
                             3686 ; 272  |        int Read        :1;
                             3687 ; 273  |        int Write       :1;
                             3688 ; 274  |        int Append      :1;
                             3689 ; 275  |        int Truncate    :1;
                             3690 ; 276  |        int Create      :1;
                             3691 ; 277  |        int Rsrv        :3;
                             3692 ; 278  |        int Mode        :8;
                             3693 ; 279  |        int Device      :8;
                             3694 ; 280  |    } B;
                             3695 ; 281  |    int I;
                             3696 ; 282  |} FILE_FLAGS;
                             3697 ; 283  |
                             3698 ; 284  |typedef struct {
                             3699 ; 285  |    WORD wWord0;
                             3700 ; 286  |    WORD wWord1;
                             3701 ; 287  |} FILE_BYTE_CURRENT;
                             3702 
                             3742 
                             3743 ; 288  |
                             3744 ; 289  |typedef struct {
                             3745 ; 290  |    FILE_NAME Name;
                             3746 ; 291  |    FILE_EXTENSION Extension;
                             3747 ; 292  |    WORD wAttributes;
                             3748 ; 293  |    WORD wReserved[4];
                             3749 ; 294  |    WORD wCreationTime;
                             3750 ; 295  |    WORD wCreationData;
                             3751 ; 296  |    WORD wFirstCluster;
                             3752 ; 297  |    FILE_SIZE Size;
                             3753 ; 298  |    WORD wCurrentCluster;
                             3754 ; 299  |    WORD wPointer;
                             3755 ; 300  |    WORD wRecord;
                             3756 ; 301  |    WORD wRd;
                             3757 ; 302  |    FILE_FLAGS Flags;
                             3758 ; 303  |    FILE_BYTE_CURRENT FcbByteCurrent;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  61

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3759 ; 304  |    WORD wFcbFlagEndOfCx;
                             3760 ; 305  |} FILE_CONTROL_BLOCK;    
                             3761 ; 306  |
                             3762 ; 307  |typedef struct {
                             3763 ; 308  |    WORD wWord0;
                             3764 ; 309  |    WORD wWord1;
                             3765 ; 310  |    WORD wWord2;
                             3766 ; 311  |    WORD wWord3;
                             3767 ; 312  |} VOLUME_LABEL;
                             3768 ; 313  |
                             3769 ; 314  |typedef struct {
                             3770 ; 315  |    WORD wFATPhysicalBlock1;
                             3771 ; 316  |    WORD wFATPhysicalBlock2;
                             3772 ; 317  |    WORD wFATPhysicalBlock3;
                             3773 ; 318  |    WORD wFATPhysicalBlock4;
                             3774 ; 319  |} FAT_PHYSICAL_BLOCK_LIST;
                             3775 
                             3782 
                             3783 ; 320  |
                             3784 ; 321  |typedef struct {
                             3785 ; 322  |    WORD wFATSectorInCache;
                             3786 ; 323  |    WORD wLastClusterFree;
                             3787 ; 324  |    WORD wNumberOfUsedClusters;
                             3788 ; 325  |    WORD wNumberOfFreeClusters;
                             3789 ; 326  |    WORD wNumberOfBadClusters;
                             3790 ; 327  |    WORD wNumberOfReservedClusters;
                             3791 ; 328  |    WORD wControl;
                             3792 ; 329  |    WORD * pwSectorCache;
                             3793 ; 330  |    FAT_PHYSICAL_BLOCK_LIST FATPhysicalLocationList;
                             3794 ; 331  |} FAT_TABLE;
                             3795 
                             3802 
                             3803 ; 332  |
                             3804 ; 333  |typedef struct {
                             3805 ; 334  |    WORD wStateMediaTable;
                             3806 ; 335  |    WORD wTypeFs;
                             3807 ; 336  |    WORD wBytesPerSector;
                             3808 ; 337  |    WORD wSectorsPerCluster;
                             3809 ; 338  |    WORD wNumberOfReservedSectors;
                             3810 ; 339  |    WORD wMaximumNumberOfFATs;
                             3811 ; 340  |    WORD wMaxRootDirectoryEntries;
                             3812 ; 341  |    WORD wTotalSectors;
                             3813 ; 342  |    WORD wNumberOfFATSectors;
                             3814 ; 343  |    WORD wNumberOfSectorsPerTrack;
                             3815 ; 344  |    WORD wNumberOfHeads;
                             3816 ; 345  |    WORD wNumberOfHiddenSectorsMSB;
                             3817 ; 346  |    WORD wNumberOfHiddenSectorsLSB;
                             3818 ; 347  |    WORD wTotalSectors32MSB;
                             3819 ; 348  |    WORD wTotalSectors32LSB;
                             3820 ; 349  |    WORD wDriverNumber;
                             3821 ; 350  |    WORD wExtendedBootSignature;
                             3822 ; 351  |    WORD wVolumeIDMSB;
                             3823 ; 352  |    WORD wVolumeIDLSB;
                             3824 ; 353  |    VOLUME_LABEL VolumeLabel;
                             3825 ; 354  |    WORD * pwWriteBuffer;
                             3826 ; 355  |    WORD wPrimaryFATRelativeSector;
                             3827 ; 356  |    WORD wSecondaryFATRelativeSector;
                             3828 ; 357  |    WORD wRootDirectoryRelativeSector;
                             3829 ; 358  |    WORD wFirstSectorNumberDataZone;
                             3830 ; 359  |    WORD wMaxNumberOfFATEntries;
                             3831 ; 360  |    WORD wRootDirectorySizeInSectors;
                             3832 ; 361  |    WORD wDataAreaSizeInSectors;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  62

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3833 ; 362  |} MEDIA_TABLE;
                             3834 
                             3891 
                             3892 ; 363  |
                             3893 ; 364  |typedef struct {
                             3894 ; 365  |    MEDIA_TABLE * pMediaTable;
                             3895 ; 366  |    DIRECTORY_CONTROL_BLOCK * pDirectoryControlBlock;
                             3896 ; 367  |    FAT_TABLE * pFATTable;
                             3897 ; 368  |} DEVICE_CONTROL_TABLE;
                             3898 ; 369  |    
                             3899 ; 370  |typedef struct {
                             3900 ; 371  |    WORD dwTotalSizeInMegaBytes;        // dwTotalSizeInMegaBytes is limited
                             3901 ; 372  |                                        //  to 2-bytes for compatibility with
                             3902 ; 373  |                                        //  older host drivers.
                             3903 ; 374  |    DWORD dwTotalNumberOfSectors;
                             3904 ; 375  |    DWORD dwTotalNumberOfBytes;
                             3905 ; 376  |    WORD wSectorSizeInBytes;
                             3906 ; 377  |} MEDIA_SIZE;
                             3907 ; 378  |
                             3908 ; 379  |typedef struct {
                             3909 ; 380  |    BOOL    bInstalled;
                             3910 ; 381  |    INT     iPbsSectorOffset;   // from the beginning of the data drive 
                             3911 ; 382  |    DWORD   dwSize;
                             3912 ; 383  |} DATA_DRIVE_PBS_LOC;
                             3913 ; 384  |extern  INT _reentrant FSFileOpen(_packed BYTE *fname,INT attribute, INT DeviceNumber);
                             3914 ; 385  |extern  INT _reentrant FSFastOpen(DWORD Key, INT attribute);
                             3915 ; 386  |extern  INT FSFileDelete(_packed BYTE *fname,INT DeviceNumber);
                             3916 ; 387  |extern  INT FSFileCreate(_packed BYTE *fname,INT DeviceNumber);
                             3917 ; 388  |extern  INT _reentrant FSChangeDir(_packed BYTE *dirname,INT DeviceNumber);
                             3918 ; 389  |extern  INT _reentrant FSCreateDir(_packed BYTE *dirname,INT DeviceNumber);
                             3919 ; 390  |extern  INT _reentrant FSDeleteDir(_packed BYTE *dirname,INT DeviceNumber);
                             3920 ; 391  |extern  INT _reentrant FSFileAppend(_packed BYTE *fname,INT DeviceNumber);
                             3921 ; 392  |extern  INT _reentrant FSFileRead(INT BytestoRead, INT Handle, INT memory_type, INT modulo
                                  , WORD *buffer);
                             3922 ; 393  |extern  INT _reentrant FSFileWrite(INT wNumberBytes, INT Handle, INT memory_type, INT iMod
                                  ulo, WORD *buffer);
                             3923 ; 394  |extern  INT _reentrant FSFileClose(INT Handle);
                             3924 ; 395  |extern  LONG _reentrant FSFileSize(INT HandleNumber);
                             3925 ; 396  |extern  LONG  FSSize(INT DeviceNum, INT TYPE);   
                             3926 ; 397  |extern  INT FSFreeClusters(INT Device);
                             3927 ; 398  |extern  INT BytesPerCluster(INT Device);
                             3928 ; 399  |
                             3929 ; 400  |
                             3930 ; 401  |
                             3931 ; 402  |//extern  INT FSFileCreate(_packed BYTE *pbFileName, BYTE bDevice);
                             3932 ; 403  |//extern  INT FSFileDelete(_packed BYTE *pbFileName, BYTE bDevice);
                             3933 ; 404  |extern  INT FSFileRename(_packed BYTE *pbCurFilename, _packed BYTE *pbNewFilename, BYTE bD
                                  evice);
                             3934 ; 405  |//extern  INT _reentrant FSFileAttribute(_packed BYTE *pbFilename, WORD wAttributes, BYTE 
                                  bDevice);
                             3935 ; 406  |//extern  INT FSFileAppend(_packed BYTE *pbFileName, BYTE bDevice);
                             3936 ; 407  |//extern  INT FSFileOpen(_packed BYTE *pbFileName, WORD wAttributes, BYTE bDevice);
                             3937 ; 408  |//extern  INT FSFileClose(INT bHandle);
                             3938 ; 409  |//extern  INT FSFileRead(WORD wNumberBytes, BYTE bHandle, WORD wMemSpace, INT iModulo, WOR
                                  D *pwBuffer);
                             3939 ; 410  |//extern  INT FSFileWrite(WORD wNumberBytes, BYTE bHandle, WORD wMemSpace, INT iModulo, WO
                                  RD *pwBuffer);
                             3940 ; 411  |extern  INT _reentrant fseek( INT handle , LONG offset, INT iOrigin );
                             3941 ; 412  |extern  INT _reentrant FSFileEof(INT Handle);
                             3942 ; 413  |extern INT _reentrant FSFileAttribute(INT Attributes, _packed BYTE *fname, INT DeviceNumbe
                                  r);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  63

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3943 ; 414  |extern INT _reentrant FSFileAttributeClear(INT Attributes, _packed BYTE *fname, INT Device
                                  Number);
                             3944 ; 415  |//extern  LONG FSFileSize(INT bHandle);
                             3945 ; 416  |extern _asmfunc INT FSPresent(BYTE bDevice);
                             3946 ; 417  |extern _asmfunc INT FSType(BYTE bDevice);
                             3947 ; 418  |//extern LONG FSSize(WORD wDevice, WORD wReturnType);
                             3948 ; 419  |//extern INT FSChangeDir(_packed BYTE *pbDirName, BYTE bDevice);
                             3949 ; 420  |//extern INT FSCreateDir(_packed BYTE *pbDirName, BYTE bDevice);
                             3950 ; 421  |//extern INT FSDeleteDir(_packed BYTE *pbDirName, BYTE bDevice);
                             3951 ; 422  |extern _asmfunc void SysLoadFATWrite(void);
                             3952 ; 423  |extern _asmfunc INT SysUnLoadFATWrite(void);
                             3953 ; 424  |extern LONG _reentrant ftell(INT iHandle);
                             3954 ; 425  |extern _asmfunc struct FCB * ReadDirectory(int iDevice, int iEntry);
                             3955 ; 426  |
                             3956 ; 427  |#endif
                             3957 
                             3959 
                             3960 ; 13   |#include "sectorarrayhandler.h"
                             3961 
                             3963 
                             3964 ; 1    |#ifndef __SECTOR_ARRAY_HANDLER_H
                             3965 ; 2    |#define __SECTOR_ARRAY_HANDLER_H
                             3966 ; 3    |
                             3967 ; 4    |#define SECTOR_STATE_FREE 0
                             3968 ; 5    |#define SECTOR_STATE_FILLING 1
                             3969 ; 6    |#define SECTOR_STATE_FILLED 2
                             3970 ; 7    |
                             3971 ; 8    |typedef struct
                             3972 ; 9    |{
                             3973 ; 10   |    int iState;
                             3974 ; 11   |    WORD _X *pwData;
                             3975 ; 12   |} SECTOR_TYPE;
                             3976 
                             3983 
                             3984 ; 13   |
                             3985 ; 14   |
                             3986 ; 15   |
                             3987 ; 16   |typedef struct SectorArray
                             3988 ; 17   |{
                             3989 ; 18   |    SECTOR_TYPE*pSectors;
                             3990 ; 19   |    INT iNumSectorBuffers;
                             3991 ; 20   |    WORD wHeadIndex;
                             3992 ; 21   |    WORD wFillingIndex;
                             3993 ; 22   |    WORD wTailIndex;
                             3994 ; 23   |    WORD wSectorsInFlight;
                             3995 ; 24   |}  SECTOR_ARRAY;
                             3996 
                             4007 
                             4008 ; 25   |
                             4009 ; 26   |
                             4010 ; 27   |
                             4011 ; 28   |_reentrant SECTOR_TYPE*ReadSectorArrayHandlerGetFreeSector(SECTOR_ARRAY*);
                             4012 ; 29   |_reentrant void ReadSectorArrayHandlerFreeSector(SECTOR_ARRAY*);
                             4013 ; 30   |_reentrant void ReadSectorArrayHandlerFreeAllSectors(SECTOR_ARRAY*);
                             4014 ; 31   |
                             4015 ; 32   |_reentrant SECTOR_TYPE*WriteSectorArrayHandlerGetFreeSector(SECTOR_ARRAY*);
                             4016 ; 33   |_reentrant SECTOR_TYPE*WriteSectorArrayHandlerGetFilledSector(SECTOR_ARRAY*);
                             4017 ; 34   |_reentrant void WriteSectorArrayHandlerFillSector(SECTOR_ARRAY*);
                             4018 ; 35   |_reentrant void WriteSectorArrayHandlerFreeSector(SECTOR_ARRAY*,SECTOR_TYPE*);
                             4019 ; 36   |
                             4020 ; 37   |_reentrant void SectorArrayInitialize(SECTOR_ARRAY *, WORD wSectorCount,WORD wSectorSize, 
                                  SECTOR_TYPE *pSectorTypeArray,WORD _X *pSectorDataBuffer);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  64

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4021 ; 38   |
                             4022 ; 39   |
                             4023 ; 40   |#endif 
                             4024 
                             4026 
                             4027 ; 14   |////////////////////////////////////////////////////////////////////////////////
                             4028 ; 15   |// Debug stuff
                             4029 ; 16   |////////////////////////////////////////////////////////////////////////////////
                             4030 ; 17   |
                             4031 ; 18   |    #ifdef SCSI_COMMAND_HISTORY
                             4032 ; 19   |#define SCSI_COMMAND_HISTORY_SIZE       500
                             4033 ; 20   |#define SCSI_CDB_SIZE_IN_WORDS          6
                             4034 ; 21   |    #endif
                             4035 ; 22   |    
                             4036 ; 23   |////////////////////////////////////////////////////////////////////////////////
                             4037 ; 24   |// Defs
                             4038 ; 25   |////////////////////////////////////////////////////////////////////////////////
                             4039 ; 26   |
                             4040 ; 27   |#define SCSI_CDB_BUFFER_OP_CODE_MASK    (WORD)0x0000FF
                             4041 ; 28   |
                             4042 ; 29   |////////////////////////////////////////////////////////////////////////////////
                             4043 ; 30   |// Supported SCSI commands
                             4044 ; 31   |#define SCSI_OPCODE_INQUIRY                         0x12
                             4045 ; 32   |#define SCSI_OPCODE_READ_CAPACITY                   0x25
                             4046 ; 33   |#define SCSI_OPCODE_READ_FORMAT_CAPACITIES          0x23
                             4047 ; 34   |#define SCSI_OPCODE_READ_6                          0x08
                             4048 ; 35   |#define SCSI_OPCODE_READ_10                         0x28
                             4049 ; 36   |#define SCSI_OPCODE_READ_12                         0xA8
                             4050 ; 37   |#define SCSI_OPCODE_READ_16                         0x88
                             4051 ; 38   |#define SCSI_OPCODE_WRITE_6                         0x0A
                             4052 ; 39   |#define SCSI_OPCODE_WRITE_10                        0x2A
                             4053 ; 40   |#define SCSI_OPCODE_WRITE_12                        0xAA
                             4054 ; 41   |#define SCSI_OPCODE_WRITE_16                        0x8A
                             4055 ; 42   |#define SCSI_OPCODE_REQUEST_SENSE                   0x03
                             4056 ; 43   |#define SCSI_OPCODE_TEST_UNIT_READY                 0x00
                             4057 ; 44   |#define SCSI_OPCODE_START_STOP_UNIT                 0x1B
                             4058 ; 45   |#define SCSI_OPCODE_FORMAT_UNIT                     0x04
                             4059 ; 46   |#define SCSI_OPCODE_RESERVE_10                      0x56
                             4060 ; 47   |#define SCSI_OPCODE_RELEASE_10                      0x57
                             4061 ; 48   |#define SCSI_OPCODE_SEND_DIAGNOSTIC                 0x1D
                             4062 ; 49   |#define SCSI_OPCODE_MODE_SENSE_6                    0x1A
                             4063 ; 50   |#define SCSI_OPCODE_MODE_SENSE_10                   0x5A
                             4064 ; 51   |#define SCSI_OPCODE_PREVENT_ALLOW_MEDIUM_REMOVAL    0x1E
                             4065 ; 52   |#define SCSI_OPCODE_START_STOP_UNIT                 0x1B // Start Stop Unit from the SBC-2
                                   spec
                             4066 ; 53   |#define SCSI_OPCODE_READ_BUFFER                     0x3C
                             4067 ; 54   |
                             4068 ; 55   |#define SCSI_CDB_SIZE_INQUIRY                       6
                             4069 ; 56   |#define SCSI_CDB_SIZE_READ_CAPACITY                 10
                             4070 ; 57   |#define SCSI_CDB_SIZE_READ_6                        6
                             4071 ; 58   |#define SCSI_CDB_SIZE_READ_10                       10
                             4072 ; 59   |#define SCSI_CDB_SIZE_READ_12                       12
                             4073 ; 60   |#define SCSI_CDB_SIZE_READ_16                       16
                             4074 ; 61   |#define SCSI_CDB_SIZE_WRITE_6                       6
                             4075 ; 62   |#define SCSI_CDB_SIZE_WRITE_10                      10
                             4076 ; 63   |#define SCSI_CDB_SIZE_WRITE_12                      12
                             4077 ; 64   |#define SCSI_CDB_SIZE_WRITE_16                      16
                             4078 ; 65   |#define SCSI_CDB_SIZE_REQUEST_SENSE                 6
                             4079 ; 66   |#define SCSI_CDB_SIZE_TEST_UNIT_READY               6
                             4080 ; 67   |#define SCSI_CDB_SIZE_START_STOP_UNIT               6
                             4081 ; 68   |#define SCSI_CDB_SIZE_FORMAT_UNIT                   6
                             4082 ; 69   |#define SCSI_CDB_SIZE_RESERVE_10                    10
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  65

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4083 ; 70   |#define SCSI_CDB_SIZE_RELEASE_10                    10
                             4084 ; 71   |#define SCSI_CDB_SIZE_SEND_DIAGNOSTIC               6
                             4085 ; 72   |#define SCSI_CDB_SIZE_MODE_SENSE_6                  6
                             4086 ; 73   |#define SCSI_CDB_SIZE_MODE_SENSE_10                 10
                             4087 ; 74   |#define SCSI_CDB_SIZE_PREVENT_ALLOW_MEDIUM_REMOVAL  6
                             4088 ; 75   |#define SCSI_CDB_SIZE_START_STOP_UNIT               6
                             4089 ; 76   |
                             4090 ; 77   |////////////////////////////////////////////////////////////////////////////////
                             4091 ; 78   |// Unsupported SCSI commands known to have been received.  Unknown SCSI commands
                             4092 ; 79   |//  not in this list are only trapped in development builds.  Release builds
                             4093 ; 80   |//  simply fail all commands not in this list.  Use the
                             4094 ; 81   |//  SCSI_TRAP_UNKNOWN_OPCODES build option in the make file to trap.
                             4095 ; 82   |#define SCSI_OPCODE_READ_FORMAT_CAPACITIES          0x23 // Read Format Capacities from th
                                  e
                             4096 ; 83   |                                                         //  SFF-8070i spec
                             4097 ; 84   |#define SCSI_OPCODE_VERIFY_10                       0x2F // Verify(10) from the SBC-2 spec
                                  
                             4098 ; 85   |
                             4099 ; 86   |////////////////////////////////////////////////////////////////////////////////
                             4100 ; 87   |// Data direction defs
                             4101 ; 88   |#define SCSI_DATA_TO_HOST               0
                             4102 ; 89   |#define SCSI_DATA_FROM_HOST             1
                             4103 ; 90   |
                             4104 ; 91   |////////////////////////////////////////////////////////////////////////////////
                             4105 ; 92   |// Sense Data defs
                             4106 ; 93   |#define SENSE_DATA_RESPONSE_CODE_CURRENT_ERRORS     0x70
                             4107 ; 94   |#define SENSE_DATA_RESPONSE_CODE_DEFERRED_ERRORS    0x71
                             4108 ; 95   |#define SENSE_DATA_INFORMATION_VALID                1<<7
                             4109 ; 96   |#define SENSE_DATA_INFORMATION_INVALID              0
                             4110 ; 97   |#define SENSE_DATA_ILI_CORRECT                      0<<4
                             4111 ; 98   |#define SENSE_DATA_ILI_INCORRECT                    1<<4
                             4112 ; 99   |
                             4113 ; 100  |////////////////////////////////////////////////////////////////////////////////
                             4114 ; 101  |// Sense Key defs
                             4115 ; 102  |#define SCSI_SENSE_KEY_NO_SENSE             0<<16
                             4116 ; 103  |#define SCSI_SENSE_KEY_RECOVERED_ERROR      1<<16
                             4117 ; 104  |#define SCSI_SENSE_KEY_NOT_READY            2<<16
                             4118 ; 105  |#define SCSI_SENSE_KEY_MEDIUM_ERROR         3<<16
                             4119 ; 106  |#define SCSI_SENSE_KEY_HARDWARE_ERROR       4<<16
                             4120 ; 107  |#define SCSI_SENSE_KEY_ILLEGAL_REQUEST      5<<16
                             4121 ; 108  |#define SCSI_SENSE_KEY_UNIT_ATTENTION       6<<16
                             4122 ; 109  |#define SCSI_SENSE_KEY_DATA_PROTECT         7<<16
                             4123 ; 110  |#define SCSI_SENSE_KEY_BLANK_CHECK          8<<16
                             4124 ; 111  |#define SCSI_SENSE_KEY_VENDOR_SPECIFIC      9<<16
                             4125 ; 112  |#define SCSI_SENSE_KEY_COPY_ABORTED         10<<16
                             4126 ; 113  |#define SCSI_SENSE_KEY_ABORTED_COMMAND      11<<16
                             4127 ; 114  |#define SCSI_SENSE_KEY_OBSOLETE             12<<16
                             4128 ; 115  |#define SCSI_SENSE_KEY_VOLUME_OVERFLOW      13<<16
                             4129 ; 116  |#define SCSI_SENSE_KEY_MISCOMPARE           14<<16
                             4130 ; 117  |#define SCSI_SENSE_KEY_RESERVED             15<<16
                             4131 ; 118  |
                             4132 ; 119  |////////////////////////////////////////////////////////////////////////////////
                             4133 ; 120  |// Additional Sense Code & Qualifier defs.  Asc is the LSB.
                             4134 ; 121  |#define SCSI_ASC_NO_ADDITIONAL_SENSE_INFO                               0x0000
                             4135 ; 122  |
                             4136 ; 123  |#define SCSI_ASC_LOGICAL_UNIT_NOT_READY_MANUAL_INTERVENTION_REQUIRED    0x0304
                             4137 ; 124  |
                             4138 ; 125  |#define SCSI_ASC_LOGICAL_UNIT_DOES_NOT_RESPOND_TO_SELECTION             0x0005
                             4139 ; 126  |
                             4140 ; 127  |#define SCSI_ASC_INVALID_COMMAND_OPERATION_CODE                         0x0020
                             4141 ; 128  |
                             4142 ; 129  |#define SCSI_ASC_LOGICAL_UNIT_NOT_SUPPORTED                             0x0025
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  66

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4143 ; 130  |
                             4144 ; 131  |#define SCSI_ASC_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE                     0x0021 
                             4145 ; 132  |
                             4146 ; 133  |#define SCSI_ASC_WRITE_PROTECTED                                        0x0027
                             4147 ; 134  |
                             4148 ; 135  |#define SCSI_ASC_NOT_READY_TO_READY_CHANGE_MEDIUM_MAY_HAVE_CHANGED      0x0028
                             4149 ; 136  |
                             4150 ; 137  |#define SCSI_ASC_DEVICE_INTERNAL_RESET                                  0x0429
                             4151 ; 138  |
                             4152 ; 139  |#define SCSI_ASC_INCOMPATIBLE_MEDIUM_INSTALLED                          0x0030
                             4153 ; 140  |#define SCSI_ASC_CANNOT_READ_MEDIUM_UNKNOWN_FORMAT                      0x0130
                             4154 ; 141  |#define SCSI_ASC_CANNOT_READ_MEDIUM_INCOMPATIBLE_FORMAT                 0x0230
                             4155 ; 142  |#define SCSI_ASC_CANNOT_WRITE_MEDIUM_UNKNOWN_FORMAT                     0x0430
                             4156 ; 143  |#define SCSI_ASC_CANNOT_WRITE_MEDIUM_INCOMPATIBLE_FORMAT                0x0530
                             4157 ; 144  |
                             4158 ; 145  |#define SCSI_ASC_MEDIUM_FORMAT_CORRUPTED                                0x0031
                             4159 ; 146  |
                             4160 ; 147  |#define SCSI_ASC_UNRECOVERED_READ_ERROR                                 0x0011
                             4161 ; 148  |
                             4162 ; 149  |#define SCSI_ASC_MEDIUM_NOT_PRESENT                                     0x003A
                             4163 ; 150  |#define SCSI_ASC_MEDIUM_DESTINATION_ELEMENT_FULL                        0x003B
                             4164 ; 151  |
                             4165 ; 152  |#define SCSI_ASC_INQUIRY_DATA_HAS_CHANGED                               0x033F
                             4166 ; 153  |#define SCSI_ASC_REPORTED_LUNS_DATA_HAS_CHANGED                         0x0E3F
                             4167 ; 154  |
                             4168 ; 155  |#define SCSI_ASC_LOGICIAL_UNIT_FAILED_SELF_CONFIGURATION                0x004C
                             4169 ; 156  |
                             4170 ; 157  |#define SCSI_ASC_INVALID_FIELD_IN_CDB                                   0x0024
                             4171 ; 158  |
                             4172 ; 159  |#define SCSI_ASC_LOGICAL_UNIT_FAILURE                                   0x013E
                             4173 ; 160  |#define SCSI_ASC_LOGICAL_UNIT_NOT_READY_INIT_CMD_REQUIRED               0x0204
                             4174 ; 161  |
                             4175 ; 162  |////////////////////////////////////////////////////////////////////////////////
                             4176 ; 163  |// Inquiry Peripheral Qualifier defs
                             4177 ; 164  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_LUN_CONNECTED         0
                             4178 ; 165  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_LUN_NOT_CONNECTED     1
                             4179 ; 166  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_RESERVED              2
                             4180 ; 167  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_NO_SUPPORT            3
                             4181 ; 168  |
                             4182 ; 169  |////////////////////////////////////////////////////////////////////////////////
                             4183 ; 170  |// Inquiry Peripheral Qualifier defs
                             4184 ; 171  |#define SCSI_INQUIRY_PERIPHERAL_DEVICE_TYPE_DIRECT_ACCESS       0
                             4185 ; 172  |#define SCSI_INQUIRY_PERIPHERAL_DEVICE_TYPE_NO_SUPPORT          0x1F
                             4186 ; 173  |
                             4187 ; 174  |////////////////////////////////////////////////////////////////////////////////
                             4188 ; 175  |// Inquiry RMB defs
                             4189 ; 176  |#define SCSI_INQUIRY_RMB_DEVICE_IS_NOT_REMOVABLE                0
                             4190 ; 177  |#define SCSI_INQUIRY_RMB_DEVICE_IS_REMOVABLE                    1
                             4191 ; 178  |
                             4192 ; 179  |////////////////////////////////////////////////////////////////////////////////
                             4193 ; 180  |// Inquiry Vendor Specific SigmaTel struct defs
                             4194 ; 181  |#define SCSI_INQUIRY_VENDOR_SPECIFIC_STRUCT_MDS                 1
                             4195 ; 182  |
                             4196 ; 183  |#define SCSI_MDS_FLAGS_SYSTEM_MEDIA_FLAG_NON_SYSTEM             (WORD)0x00
                             4197 ; 184  |#define SCSI_MDS_FLAGS_SYSTEM_MEDIA_FLAG_SYSTEM                 (WORD)0x01
                             4198 ; 185  |                                                                
                             4199 ; 186  |#define SCSI_MDS_MEDIA_TYPE_NAND                                (WORD)0x00
                             4200 ; 187  |#define SCSI_MDS_MEDIA_TYPE_SMARTMEDIA                          (WORD)0x01
                             4201 ; 188  |#define SCSI_MDS_MEDIA_TYPE_MMC_1_4                             (WORD)0x10
                             4202 ; 189  |#define SCSI_MDS_MEDIA_TYPE_MMC_2_1_1                           (WORD)0x11
                             4203 ; 190  |#define SCSI_MDS_MEDIA_TYPE_MMC_3_1                             (WORD)0x12
                             4204 ; 191  |#define SCSI_MDS_MEDIA_TYPE_MMC_UNKNOWN_VERSION                 (WORD)0x13
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  67

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4205 ; 192  |#define SCSI_MDS_MEDIA_TYPE_SD_1_0                              (WORD)0x20
                             4206 ; 193  |#define SCSI_MDS_MEDIA_TYPE_SD_UNKNOWN_VERSION                  (WORD)0x21
                             4207 ; 194  |
                             4208 ; 195  |////////////////////////////////////////////////////////////////////////////////
                             4209 ; 196  |// Error codes
                             4210 ; 197  |////////////////////////////////////////////////////////////////////////////////
                             4211 ; 198  |
                             4212 ; 199  |#define SCSI_PROJECT_SPECIFIC_INIT_FAILED                       (WORD)0x000001
                             4213 ; 200  |#define SCSI_DEVICE_INIT_ALL_FAILED                             (WORD)0x000002
                             4214 ; 201  |#define SCSI_ERROR_LUN_NOT_READY                                (WORD)0x000003
                             4215 ; 202  |#define SCSI_ERROR_INVALID_COMMAND                              (WORD)0x000004
                             4216 ; 203  |#define SCSI_ERROR_USB_MSC_RESET_DURING_SCSI_COMMAND            (WORD)0x000005
                             4217 ; 204  |#define SCSI_ERROR_READ_SECTOR_FAILURE                          (WORD)0x000006
                             4218 ; 205  |#define SCSI_ERROR_WRITE_SECTOR_FAILURE                         (WORD)0x000007
                             4219 ; 206  |#define SCSI_ERROR_WAIT_FOR_USB_TIMEOUT                         (WORD)0x000008
                             4220 ; 207  |#define SCSI_READ_FAILURE_TIMEOUT_USB_WILL_NOT_STOP             (WORD)0x000009
                             4221 ; 208  |#define SCSI_WRITE_FAILURE_TIMEOUT_USB_WILL_NOT_STOP            (WORD)0x00000A
                             4222 ; 209  |#define SCSI_ERROR_USB_DISCONNECT                               (WORD)0x00000B
                             4223 ; 210  |#define SCSI_ERROR_DDI_CALL_FAILED                              (WORD)0x00000C
                             4224 ; 211  |#define SCSI_ERROR_LBA_OUT_OF_RANGE                         (RETCODE)(0x000100)
                             4225 ; 212  |#define SCSI_WRITE_FAILURE_ZONE_FULL                        (RETCODE)(0x9AAAAA)
                             4226 ; 213  |
                             4227 ; 214  |////////////////////////////////////////////////////////////////////////////////
                             4228 ; 215  |// Typedefs
                             4229 ; 216  |////////////////////////////////////////////////////////////////////////////////
                             4230 ; 217  |
                             4231 ; 218  |typedef RETCODE (*SCSI_CH)(WORD wDeviceNum, WORD _X* pCdb);
                             4232 ; 219  |typedef RETCODE (*SCSI_PROJECT_INIT)(void);
                             4233 ; 220  |typedef RETCODE (*SCSI_LUN_FLAG_MEDIA_CHANGE_FUNCTION)(void);
                             4234 ; 221  |
                             4235 ; 222  |typedef struct
                             4236 ; 223  |{
                             4237 ; 224  |    WORD wValid;
                             4238 ; 225  |    WORD wSenseKey;
                             4239 ; 226  |    WORD wIli;
                             4240 ; 227  |    DWORD dwInformation;
                             4241 ; 228  |    WORD wAscqAsc; 
                             4242 ; 229  |    WORD wAddlData;
                             4243 ; 230  |} SCSI_SENSE_DATA;
                             4244 ; 231  |
                             4245 ; 232  |typedef enum
                             4246 ; 233  |{
                             4247 ; 234  |    ScsiMediaStateUnknown = 0,
                             4248 ; 235  |    ScsiMediaStateReady = 1,
                             4249 ; 236  |    ScsiMediaStateFormatRequired = 2,
                             4250 ; 237  |    ScsiMediaStateHardwareFailed = 3
                             4251 ; 238  |} SCSI_MEDIA_STATE;
                             4252 
                             4277 
                             4278 ; 239  |
                             4279 ; 240  |typedef struct
                             4280 ; 241  |{
                             4281 ; 242  |    DWORD dwNumBytesXferred;
                             4282 ; 243  |    WORD wCompletionStatus;
                             4283 ; 244  |    SCSI_SENSE_DATA SenseData;
                             4284 ; 245  |    BOOL bStopped;
                             4285 ; 246  |    BOOL bWriteProtected;
                             4286 ; 247  |    BOOL bMediaConnected;
                             4287 ; 248  |    BOOL bMediaIsRemovable;
                             4288 ; 249  |    WORD wRemovableType;
                             4289 ; 250  |    WORD wRemovableEntry;
                             4290 ; 251  |    WORD wRemovableMask;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  68

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4291 ; 252  |    BOOL bMediaEnumerated;
                             4292 ; 253  |    BOOL bMediaChanged;
                             4293 ; 254  |    BOOL bMediaInsertionDetected;
                             4294 ; 255  |    BOOL bMediaValid;
                             4295 ; 256  |    SCSI_MEDIA_STATE eMediaState;
                             4296 ; 257  |    WORD wFileSystemDriveNumber;
                             4297 ; 258  |    WORD wFileSystemMediaNumber;
                             4298 ; 259  |    BOOL bStartUnitAttention;
                             4299 ; 260  |    MEDIA_SIZE MediaSize;
                             4300 ; 261  |    WORD wInquiryVendorData[10];
                             4301 ; 262  |    WORD wInquiryVendorSpecific[7];
                             4302 ; 263  |    SCSI_LUN_FLAG_MEDIA_CHANGE_FUNCTION FlagMediaChange;
                             4303 ; 264  |    DWORD dwSequentialBoundaryMask;
                             4304 ; 265  |    DWORD dwSequentialBoundary;
                             4305 ; 266  |} SCSI_LUN;
                             4306 
                             4311 
                             4312 ; 267  |
                             4313 ; 268  |
                             4314 ; 269  |typedef struct SCSICommandEntryStruct
                             4315 ; 270  |{
                             4316 ; 271  |
                             4317 ; 272  |    WORD     wCommand;
                             4318 ; 273  |    SCSI_CH  pFunc;
                             4319 ; 274  |} SCSI_COMMAND_ENTRY;
                             4320 ; 275  |
                             4321 ; 276  |
                             4322 ; 277  |////////////////////////////////////////////////////////////////////////////////
                             4323 ; 278  |// Prototypes
                             4324 ; 279  |////////////////////////////////////////////////////////////////////////////////
                             4325 ; 280  |
                             4326 ; 281  |RETCODE _reentrant ScsiDeviceTaskRouter(WORD wDeviceNum, WORD _X * pCdb);
                             4327 ; 282  |RETCODE _reentrant ScsiDeviceTaskManager(WORD wDeviceNum, WORD wOpCode, WORD _X * pCdb, SC
                                  SI_CH pFunc);
                             4328 ; 283  |RETCODE _reentrant ScsiDeviceServer(WORD wDeviceNum, WORD _X* pCdb,    SCSI_CH pFunc);
                             4329 ; 284  |
                             4330 ; 285  |SCSI_CH _reentrant ScsiValidOperationCode(WORD wOpCode);
                             4331 
                             4336 
                             4337 ; 286  |SCSI_CH _reentrant SearchForSCSICommand(SCSI_COMMAND_ENTRY *pList, WORD wOpCode);
                             4338 ; 287  |
                             4339 ; 288  |RETCODE _reentrant ScsiInit(void);
                             4340 ; 289  |RETCODE _reentrant ScsiDeviceInitializeAll(void);
                             4341 ; 290  |RETCODE _reentrant ScsiDeviceInitialize(WORD wNum);
                             4342 ; 291  |RETCODE _reentrant ScsiLunInitialize(WORD wDevNum, WORD wLun);
                             4343 ; 292  |RETCODE ScsiLunSetupSize(WORD wDevNum, WORD wLun);
                             4344 ; 293  |RETCODE ScsiLunSetupInquiryVendorSpecificData(WORD wDevNum, WORD wLun);
                             4345 
                             4373 
                             4374 ; 294  |RETCODE _reentrant ScsiLunSetupDefaultSenseData(SCSI_LUN * pLun);
                             4375 ; 295  |RETCODE _reentrant ScsiDummyFlagMediaChange(void);
                             4376 ; 296  |
                             4377 ; 297  |#define SCSI_IDLE      0       // Not reading or writing
                             4378 ; 298  |#define SCSI_READING   1       // A read operation is in progress
                             4379 ; 299  |#define SCSI_WRITING   2       // A write operation is in progress
                             4380 ; 300  |
                             4381 ; 301  |extern WORD g_wSCSIActivityState;
                             4382 ; 302  |
                             4383 ; 303  |RETCODE _reentrant SCSIWriteSectorHelper(WORD wDevice, WORD wDrive, DWORD dwStartSector, W
                                  ORD wSectorCount, BOOL bUseMultiwrite);
                             4384 ; 304  |RETCODE _reentrant SCSIReadSectorHelper(WORD wDevice, WORD wDrive, DWORD dwStartSector, WO
                                  RD wSectorCount);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  69

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4385 ; 305  |
                             4386 ; 306  |SCSI_CH _reentrant GetVendorSpecificSCSIHandler(WORD wOpCode);
                             4387 ; 307  |SCSI_CH _reentrant GetCustomerExtentionSCSIHandler(WORD wOpCode);
                             4388 ; 308  |
                             4389 ; 309  |#endif // #ifndef _SCSI_H
                             4390 
                             4392 
                             4393 ; 18   |
                             4394 ; 19   |////////////////////////////////////////////////////////////////////////////////
                             4395 ; 20   |// Defs
                             4396 ; 21   |////////////////////////////////////////////////////////////////////////////////
                             4397 ; 22   |
                             4398 ; 23   |#define USB_INTERFACE_CLASS_MASS_STORAGE    0x08
                             4399 ; 24   |
                             4400 ; 25   |#define USB_INTERFACE_SUB_CLASS_RBC                             0x01
                             4401 ; 26   |#define USB_INTERFACE_SUB_CLASS_SFF_8020I                       0x02
                             4402 ; 27   |#define USB_INTERFACE_SUB_CLASS_MMC_2                           0x02
                             4403 ; 28   |#define USB_INTERFACE_SUB_CLASS_QIC_157                         0x03
                             4404 ; 29   |#define USB_INTERFACE_SUB_CLASS_UFI                             0x04
                             4405 ; 30   |#define USB_INTERFACE_SUB_CLASS_SFF_8070I                       0x05
                             4406 ; 31   |#define USB_INTERFACE_SUB_CLASS_SCSI_TRANSPARENT_COMMAND_SET    0x06
                             4407 ; 32   |
                             4408 ; 33   |#define USB_INTERFACE_PROTOCOL_CBI_CCI                          0x01
                             4409 ; 34   |#define USB_INTERFACE_PROTOCOL_CBI_NO_CCI                       0x02
                             4410 ; 35   |#define USB_INTERFACE_PROTOCOL_BULK_ONLY                        0x50
                             4411 ; 36   |
                             4412 ; 37   |#define USBMSC_CBW_SIGNATURE            (DWORD)0x43425355
                             4413 ; 38   |#define USBMSC_CBW_BULK_OUT_SIZE        (WORD)0x00001F
                             4414 ; 39   |
                             4415 ; 40   |#define USBMSC_BULK_OUT_SCSI_CDB_START  5
                             4416 ; 41   |
                             4417 ; 42   |// This is the number of sector buffers if the data area is interpreted as the smallest se
                                  ctor buffer size
                             4418 ; 43   |#define USBMSC_MAX_NUM_SECTOR_BUFFERS       (16)
                             4419 ; 44   |// We add one to pad at the beginning of the buffer and end of each entry to avoid the USB
                                   DMA defect
                             4420 ; 45   |#define USBMSC_TOTAL_BUFFER_SIZE            ((SECTOR_BUFFER_ALLOC_SIZE(SSFDC_SECTOR_TOTAL_
                                  SIZE)*USBMSC_MAX_NUM_SECTOR_BUFFERS)+1)
                             4421 ; 46   |
                             4422 ; 47   |#define USBMSC_CSW_SIGNATURE_LOW        (WORD)0x425355
                             4423 ; 48   |#define USBMSC_CSW_SIGNATURE_HIGH       (WORD)0x000053
                             4424 ; 49   |#define USBMSC_CSW_COMMAND_PASSED       (WORD)0x000000
                             4425 ; 50   |#define USBMSC_CSW_COMMAND_FAILED       (WORD)0x000001
                             4426 ; 51   |#define USBMSC_CSW_PHASE_ERROR          (WORD)0x000002
                             4427 ; 52   |
                             4428 ; 53   |#define GET_MAX_LUN_STAGE_DATA_0        (WORD)0x000000
                             4429 ; 54   |#define GET_MAX_LUN_STAGE_DATA_1        (WORD)0x000001
                             4430 ; 55   |
                             4431 ; 56   |#define USBMSC_MAX_LUNS                 4
                             4432 ; 57   |
                             4433 ; 58   |#define USBMSC_DEVICE_0                 0
                             4434 ; 59   |#define USBMSC_DEVICE_1                 1
                             4435 ; 60   |#define USBMSC_DEVICE_2                 2
                             4436 ; 61   |#define USBMSC_DEVICE_3                 3
                             4437 ; 62   |
                             4438 ; 63   |////////////////////////////////////////////////////////////////////////////////
                             4439 ; 64   |// Errors
                             4440 ; 65   |
                             4441 ; 66   |#define USBMSC_ERROR_INVALID_DEVICE                             (WORD)0xFFFFFF
                             4442 ; 67   |#define USBMSC_ERROR_INVALID_LUN                                (WORD)0xFFFFFE
                             4443 ; 68   |#define USBMSC_DEVICE_INIT_ALL_FAILED                           (WORD)0x000001
                             4444 ; 69   |#define USBMSC_DEVICE_INIT_FAILED                               (WORD)0x000002
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  70

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4445 ; 70   |
                             4446 ; 71   |////////////////////////////////////////////////////////////////////////////////
                             4447 ; 72   |// Typedefs
                             4448 ; 73   |////////////////////////////////////////////////////////////////////////////////
                             4449 ; 74   |
                             4450 ; 75   |typedef RETCODE (*USBMSC_DEVICE_INIT_FUNCTION)(void);
                             4451 ; 76   |typedef RETCODE (*USBMSC_DEVICE_RESET_FUNCTION)(void);
                             4452 ; 77   |
                             4453 ; 78   |typedef union
                             4454 ; 79   |{
                             4455 ; 80   |    struct
                             4456 ; 81   |    {
                             4457 ; 82   |        int Reserved    : 6;
                             4458 ; 83   |        int Obsolete    : 1;
                             4459 ; 84   |        int Direction   : 1;
                             4460 ; 85   |    } B;
                             4461 ; 86   |    int I;
                             4462 ; 87   |} USBMSC_CBW_FLAGS;
                             4463 
                             4475 
                             4476 ; 88   |
                             4477 ; 89   |typedef struct
                             4478 ; 90   |{
                             4479 ; 91   |    DWORD dwCBWSignature;
                             4480 ; 92   |    DWORD dwCBWTag;
                             4481 ; 93   |    DWORD dwCBWDataTransferLength;
                             4482 ; 94   |    USBMSC_CBW_FLAGS CBWFlags;
                             4483 ; 95   |    WORD wCBWLUN;
                             4484 ; 96   |    WORD wReserved0;
                             4485 ; 97   |    WORD wCBWCBLength;
                             4486 ; 98   |    WORD wReserved1;
                             4487 ; 99   |} USBMSC_CBW;
                             4488 
                             4507 
                             4508 ; 100  |
                             4509 ; 101  |
                             4510 ; 102  |
                             4511 ; 103  |
                             4512 ; 104  |typedef struct
                             4513 ; 105  |{
                             4514 ; 106  |    SyncObject  TransferObject;
                             4515 ; 107  |    WORD wDeviceNumber;
                             4516 ; 108  |    WORD wBulkInEndpointNum;
                             4517 ; 109  |    WORD _X *CommandOutBuffer;
                             4518 ; 110  |    WORD _X *CommandInBuffer;
                             4519 ; 111  |    WORD wTransferSize;
                             4520 ; 112  |    WORD wBulkOutEndpointNum;
                             4521 ; 113  |    WORD wInterface;
                             4522 ; 114  |    WORD wNumLunsSupported;
                             4523 ; 115  |    USBMSC_CBW CBW;
                             4524 ; 116  |    SCSI_LUN Lun[USBMSC_MAX_LUNS];
                             4525 ; 117  |    BOOL bCommandActive;
                             4526 ; 118  |    BOOL bMSCReset;
                             4527 ; 119  |    USBMSC_DEVICE_INIT_FUNCTION InitializeFunction;
                             4528 ; 120  |    USBMSC_DEVICE_RESET_FUNCTION ResetFunction;
                             4529 ; 121  |    SECTOR_ARRAY  SectorArray;
                             4530 ; 122  |} USBMSC_DEVICE;
                             4531 ; 123  |
                             4532 ; 124  |
                             4533 ; 125  |extern long int g_lUSBMSCBulkInBytes;
                             4534 ; 126  |extern long int g_lUSBMSCLastBulkInTime;
                             4535 ; 127  |extern long int g_lUSBMSCFirstBulkInTime;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  71

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4536 ; 128  |extern long int g_lUSBMSCBulkOutBytes;
                             4537 ; 129  |extern long int g_lUSBMSCLastBulkOutTime;
                             4538 ; 130  |extern long int g_lUSBMSCFirstBulkOutTime;
                             4539 
                             4559 
                             4560 ; 131  |
                             4561 ; 132  |extern USBMSC_DEVICE UsbMscDevice[];
                             4562 ; 133  |extern WORD g_wUsbMscNumDevices;
                             4563 ; 134  |
                             4564 ; 135  |
                             4565 ; 136  |////////////////////////////////////////////////////////////////////////////////
                             4566 ; 137  |// Prototypes
                             4567 ; 138  |////////////////////////////////////////////////////////////////////////////////
                             4568 ; 139  |
                             4569 ; 140  |void _reentrant UsbMscHandler0(void);
                             4570 ; 141  |void _reentrant UsbMscHandler1(void);
                             4571 ; 142  |RETCODE _reentrant UsbMscCbwProcessor(WORD wNum);
                             4572 ; 143  |RETCODE _reentrant UsbMscSendCsw(WORD wNum);
                             4573 ; 144  |RETCODE _reentrant UsbMscDriverInitialize(void);
                             4574 ; 145  |RETCODE _reentrant UsbMscDeviceInitializeAll(void);
                             4575 ; 146  |RETCODE _reentrant UsbMscDeviceInitialize(WORD wNum);
                             4576 ; 147  |RETCODE _reentrant UsbMscDeviceReset(WORD wNum);
                             4577 ; 148  |
                             4578 ; 149  |
                             4579 ; 150  |#define SECTOR_HANDLER  0x800000
                             4580 ; 151  |#define COMMAND_HANDLER 0x400000
                             4581 ; 152  |
                             4582 ; 153  |void _reentrant UsbMscBulkOutService(BOOL bSetup, BYTE btDirection, _packed BYTE _USB_MEM 
                                  *pBuffer, WORD wLength,WORD wPrivateData);
                             4583 ; 154  |void _reentrant UsbMscBulkInService(BOOL bSetup, BYTE btDirection, _packed BYTE _USB_MEM *
                                  pBuffer, WORD wLength,WORD wPrivateData);
                             4584 ; 155  |void _reentrant UsbMscResetService(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffe
                                  r, WORD wLength,WORD wPrivateData);
                             4585 ; 156  |void _reentrant UsbMscResumeService(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuff
                                  er, WORD wLength,WORD wPrivateData);
                             4586 ; 157  |void _reentrant UsbMscSuspendService(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuf
                                  fer, WORD wLength,WORD wPrivateData);
                             4587 ; 158  |
                             4588 ; 159  |RETCODE _reentrant UsbMscCheckDiskAll(void);
                             4589 ; 160  |
                             4590 ; 161  |#define DISPLAY_USB_ACTIVE  0       // Currently reading or writing
                             4591 ; 162  |#define USB_BLINK_RATE_ON       50      // 50msec
                             4592 ; 163  |#define USB_BLINK_RATE_OFF      300     // 450mse
                             4593 ; 164  |
                             4594 ; 165  |#define PERSISTANT_BIT_FOR_LOW_POWER_MODE (HW_RTC_PERSISTANT1.B.b0)
                             4595 ; 166  |
                             4596 ; 167  |
                             4597 ; 168  |#endif // #ifndef _USBMSC_H
                             4598 
                             4600 
                             4601 ; 11   |
                             4602 ; 12   |#include "mtp.h"
                             4603 
                             4605 
                             4606 ; 1    |/**
                             4607 ; 2    |***
                             4608 ; 3    |*** Filename: mtp.h
                             4609 ; 4    |*** Description: Main MTP constant definitions and function prototypes
                             4610 ; 5    |***
                             4611 ; 6    |***
                             4612 ; 7    |*** Copyright (c) SigmaTel, Inc. Unpublished
                             4613 ; 8    |***
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  72

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4614 ; 9    |*** SigmaTel, Inc.
                             4615 ; 10   |*** Proprietary & Confidential
                             4616 ; 11   |***
                             4617 ; 12   |*** This source code and the algorithms implemented therein constitute
                             4618 ; 13   |*** confidential information and may comprise trade secrets of SigmaTel, Inc.
                             4619 ; 14   |*** or its associates, and any use thereof is subject to the terms and
                             4620 ; 15   |*** conditions of the Confidential Disclosure Agreement pursuant to which this
                             4621 ; 16   |*** source code was originally received.
                             4622 ; 17   |**/
                             4623 ; 18   |//////////////////////////////////////////////////////////////////
                             4624 ; 19   |// Copyright  Microsoft Corporation, 2003
                             4625 ; 20   |//////////////////////////////////////////////////////////////////
                             4626 ; 21   |
                             4627 ; 22   |//////////////////////////////////////////////////////////////////
                             4628 ; 23   |//   Includes
                             4629 ; 24   |//////////////////////////////////////////////////////////////////
                             4630 ; 25   |#ifndef _MTP_H
                             4631 ; 26   |#define _MTP_H
                             4632 ; 27   |
                             4633 ; 28   |////////////////////////////////////////////////////////////////////////////////
                             4634 ; 29   |// Includes
                             4635 ; 30   |////////////////////////////////////////////////////////////////////////////////
                             4636 ; 31   |
                             4637 ; 32   |#include "kernel.h"
                             4638 
                             4640 
                             4641 ; 1    |///////////////////////////////////////////////////////////////////////////////
                             4642 ; 2    |///
                             4643 ; 3    |/// Filename: kernel.h
                             4644 ; 4    |/// Description: 
                             4645 ; 5    |///
                             4646 ; 6    |///
                             4647 ; 7    |/// Copyright (c) SigmaTel, Inc. Unpublished
                             4648 ; 8    |///
                             4649 ; 9    |/// SigmaTel, Inc.
                             4650 ; 10   |/// Proprietary  Confidential
                             4651 ; 11   |///
                             4652 ; 12   |/// This source code and the algorithms implemented therein constitute
                             4653 ; 13   |/// confidential information and may comprise trade secrets of SigmaTel, Inc.
                             4654 ; 14   |/// or its associates, and any use thereof is subject to the terms and
                             4655 ; 15   |/// conditions of the Confidential Disclosure Agreement pursuant to which this
                             4656 ; 16   |/// source code was originally received.
                             4657 ; 17   |///
                             4658 ; 18   |///////////////////////////////////////////////////////////////////////////////
                             4659 ; 19   |#ifndef __KERNEL_H
                             4660 ; 20   |#define __KERNEL_H
                             4661 ; 21   |
                             4662 ; 22   |
                             4663 ; 23   |#include "types.h"
                             4664 ; 24   |#include "gettime.h"
                             4665 ; 25   |#include "sysirq.h"
                             4666 ; 26   |#include "icoll.h"
                             4667 ; 27   |
                             4668 ; 28   |#ifndef SYS_MAX_MSG_PARAMS
                             4669 ; 29   |#define SYS_MAX_MSG_PARAMS 10
                             4670 ; 30   |#endif
                             4671 ; 31   |
                             4672 ; 32   |#ifndef MAX_REGIONS
                             4673 ; 33   |#define MAX_REGIONS 5
                             4674 ; 34   |#endif 
                             4675 ; 35   |
                             4676 ; 36   |#define TIMEOUT_IMMEDIATE 0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  73

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4677 ; 37   |
                             4678 ; 38   |struct TaskEntryStruct;
                             4679 ; 39   |
                             4680 ; 40   |union SyncObjectStruct;
                             4681 ; 41   |
                             4682 ; 42   |
                             4683 ; 43   |// JCP - Already defined in types.h
                             4684 ; 44   |
                             4685 ; 45   |//typedef struct {
                             4686 ; 46   |//    WORD m_wLength;
                             4687 ; 47   |//    WORD m_wMessage;
                             4688 ; 48   |//    WORD m_wParams[SYS_MAX_MSG_PARAMS];
                             4689 ; 49   |//} Message;
                             4690 ; 50   |
                             4691 ; 51   |typedef struct {
                             4692 ; 52   |    _circ WORD    *m_pHead;
                             4693 ; 53   |    _circ WORD    *m_pTail;
                             4694 ; 54   |} CircularBufferDescriptor;
                             4695 ; 55   |
                             4696 ; 56   |typedef struct MemoryRegionStruct {
                             4697 ; 57   |    WORD m_wResourceLoaded;
                             4698 ; 58   |    _P INT *m_StartAddress;
                             4699 ; 59   |    _P INT *m_EndAddress;
                             4700 ; 60   |} MemoryRegion;
                             4701 ; 61   |
                             4702 ; 62   |
                             4703 ; 63   |typedef struct TaskEntryStruct{
                             4704 ; 64   |    CircularBufferDescriptor *m_pMessageQueue;
                             4705 ; 65   |    void   *m_pWaitingOnPtr;                                //points to either an object o
                                  r a queue we're waiting on.
                             4706 ; 66   |    WORD    m_wWaitingOnWord;
                             4707 ; 67   |    WORD    m_wState;                                       //The state is used to indicat
                                  e what the task is waiting on.
                             4708 ; 68   |    WORD   *m_pStackPointer;
                             4709 ; 69   |    WORD    m_wTaskID;                                      //The kernel does not use this
                                   for any purpose.   This is set by the developer
                             4710 ; 70   |                                                            //  and returned by SysGetTask
                                  ID() for use by functions that are required to 
                             4711 ; 71   |                                                            //  be task aware.
                             4712 ; 72   |    long    m_lTimeout;                                     //This is in absolute time (ca
                                  n compare directly to the current system time
                             4713 ; 73   |    WORD    m_wRegionResources[MAX_REGIONS];                //a snapshot of the requiremen
                                  ts of the task in terms of which resources are loaded
                             4714 ; 74   |    WORD    m_wPriority;                                    
                             4715 ; 75   |    WORD   *m_pInitialStackPointer;                         //only used at init time
                             4716 ; 76   |    WORD    m_wStackSize;
                             4717 ; 77   |    _reentrant void   (*m_pEntryPoint)(void);               //only used at init time
                             4718 ; 78   |} TaskEntry;
                             4719 ; 79   |
                             4720 ; 80   |typedef union SyncObjectStruct {
                             4721 ; 81   |    TaskEntry   *m_pOwner;
                             4722 ; 82   |    struct
                             4723 ; 83   |    {
                             4724 ; 84   |    int          m_iOwner :16;
                             4725 ; 85   |    int          m_iCount : 8;
                             4726 ; 86   |    } counter;
                             4727 ; 87   |} SyncObject;
                             4728 ; 88   |
                             4729 ; 89   |typedef WORD SignalGroup;
                             4730 ; 90   |
                             4731 ; 91   |
                             4732 ; 92   |typedef struct {
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  74

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4733 ; 93   |    WORD    m_wMessageType;
                             4734 ; 94   |    CircularBufferDescriptor    *m_pDestination;
                             4735 ; 95   |}  RoutingEntry;
                             4736 ; 96   |
                             4737 ; 97   |extern RoutingEntry g_RoutingTable[];
                             4738 ; 98   |extern TaskEntry *g_TaskList[];
                             4739 ; 99   |extern MemoryRegion *g_RegionTable[];
                             4740 ; 100  |
                             4741 ; 101  |//Time Releated Functions
                             4742 ; 102  |_reentrant WORD SysWait(INT wTimeout);
                             4743 ; 103  |
                             4744 ; 104  |//Task Related Functions
                             4745 ; 105  |_reentrant WORD SysGetTaskID(void);
                             4746 ; 106  |
                             4747 ; 107  |//Message related functions
                             4748 ; 108  |_asmfunc WORD SysWaitOnMessage(INT wTimeout, Message *pMsg);
                             4749 ; 109  |_asmfunc WORD SysPeekMessage(CircularBufferDescriptor *pQueue, Message *pMsg);
                             4750 ; 110  |_reentrant WORD SysPostMessage(WORD wLength, ...);
                             4751 ; 111  |_reentrant WORD SysPostMessageWait(INT wTimeout, WORD wLength, ...);
                             4752 ; 112  |
                             4753 ; 113  |//maybe this is too much functionality?
                             4754 ; 114  |_asmfunc WORD SysWaitOnBoth(WORD wTimeout, SyncObject *pObject, Message *pMsg);
                             4755 ; 115  |
                             4756 ; 116  |//SyncObject Related functions
                             4757 ; 117  |_asmfunc WORD SysWaitOnObject(INT wTimeout, SyncObject *pObject);
                             4758 ; 118  |_asmfunc WORD SysAssignObject(SyncObject *pObject, TaskEntry *pTaskID);
                             4759 ; 119  |_reentrant void SysReleaseObject(SyncObject *pObject);
                             4760 ; 120  |_reentrant void ISRReleaseObject(SyncObject *pObject);
                             4761 ; 121  |
                             4762 ; 122  |//Queue Related Functions
                             4763 ; 123  |_asmfunc WORD SysWaitOnQueue(INT wTimeout,CircularBufferDescriptor *pQueue, INT wSizeToBeF
                                  ree);
                             4764 ; 124  |
                             4765 ; 125  |//Event Related Functions
                             4766 ; 126  |_asmfunc WORD SysWaitOnSignal(INT wTimeout, void * pSignalGroup, int iSignal);
                             4767 ; 127  |_asmfunc void SysSignal(SignalGroup *pSignalGroup, int iSignal);
                             4768 ; 128  |
                             4769 ; 129  |//ISR function
                             4770 ; 130  |
                             4771 ; 131  |//SysCallFunctions
                             4772 ; 132  |int _asmfunc exSysCallFunction_v(void);
                             4773 ; 133  |int _asmfunc exSysCallFunction_i(int);
                             4774 ; 134  |int _asmfunc exSysCallFunction_ii(int, int);
                             4775 ; 135  |int _asmfunc exSysCallFunction_iii(int, int, int);
                             4776 ; 136  |int _asmfunc SysCallFunction(WORD * RESOURCE,int _reentrant (int,int,int*),  int, int, int
                                   *);
                             4777 ; 137  |#define SysCallFunction(rsrc,func,a,b,p) SysCallFunction((void*)rsrc,(func),(a),(b),(p))
                             4778 ; 138  |
                             4779 ; 139  |void _asmfunc v_SysCallFunction_v(WORD * RESOURCE,void _reentrant (void));
                             4780 ; 140  |#define v_SysCallFunction_v(rsrc,func) v_SysCallFunction_v((void*)rsrc,(func))
                             4781 ; 141  |
                             4782 ; 142  |void _asmfunc SysCallFunction_i(WORD * RESOURCE,void _reentrant (int),int);
                             4783 ; 143  |#define SysCallFunction_i(rsrc,func,a,b,p) SysCallFunction_i((void*)rsrc,(func),(a),(b),(p
                                  ))
                             4784 ; 144  |
                             4785 ; 145  |int _asmfunc SysCallFunction_L(void* RESOURCE,int _reentrant (long,long,int*),  long, long
                                  , int *);
                             4786 ; 146  |
                             4787 ; 147  |int _asmfunc i_SysCallFunction_i(WORD * RESOURCE,int _reentrant (int), int);
                             4788 ; 148  |
                             4789 ; 149  |int _asmfunc i_SysCallFunction_iipp(WORD * RESOURCE,int _reentrant (int,int,int*,int*),  i
                                  nt, int, int *, int *);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  75

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4790 ; 150  |
                             4791 ; 151  |int _asmfunc i_SysCallFunction_iiip(WORD * RESOURCE,int _reentrant (int,int,int,int*),  in
                                  t, int, int, int *);
                             4792 ; 152  |
                             4793 ; 153  |int _asmfunc fSysCallFunction(WORD * RESOURCE,int _reentrant (int,int,int*),  int, int, in
                                  t *);
                             4794 ; 154  |
                             4795 ; 155  |
                             4796 ; 156  |//These values are return values, and also values that are set in the TaskEntry.m_wState t
                                  o indicate what the task
                             4797 ; 157  |//is waiting on.
                             4798 ; 158  |#define EVENT_TIMEOUT   0
                             4799 ; 159  |#define EVENT_MESSAGE   1
                             4800 ; 160  |#define EVENT_OBJECT    2
                             4801 ; 161  |#define EVENT_QUEUE     4
                             4802 ; 162  |#define EVENT_SIGNAL    5
                             4803 ; 163  |#define EVENT_RELEASING_OBJECT2 6
                             4804 ; 164  |#define EVENT_RELEASING_OBJECT1 7
                             4805 ; 165  |
                             4806 ; 166  |
                             4807 ; 167  |//this is the owner that a SyncObject should be assigned to if a task it going to wait on 
                                  a completion of the interrupt. 
                             4808 ; 168  |#define ISR_OWNER  ((TaskEntry*)(0xffff))
                             4809 ; 169  |#define KERNEL_OWNER  ((TaskEntry*)(0))
                             4810 ; 170  |
                             4811 ; 171  |
                             4812 ; 172  |#ifdef INSTRUMENT_ENABLE
                             4813 ; 173  |#include <regsgpio.h>
                             4814 ; 174  |
                             4815 ; 175  |//
                             4816 ; 176  |// Define the bit positions in the GPIO registers used for signalling.
                             4817 ; 177  |//
                             4818 ; 178  |#define GPIO_24     B0
                             4819 ; 179  |#define GPIO_36     B12
                             4820 ; 180  |#define GPIO_37     B13
                             4821 ; 181  |#define GPIO_38     B14
                             4822 ; 182  |#define GPIO_39     B15
                             4823 ; 183  |#define GPIO_42     B18
                             4824 ; 184  |#define GPIO_46     B22
                             4825 ; 185  |#define GPIO_47     B23
                             4826 ; 186  |
                             4827 ; 187  |//=============================================================================
                             4828 ; 188  |// SysSignalEvent
                             4829 ; 189  |//-----------------------------------------------------------------------------
                             4830 ; 190  |//! This macro allows code to set a gpio event that can be measured outside the
                             4831 ; 191  |//! part.
                             4832 ; 192  |//! \param wGPIONumber 
                             4833 ; 193  |//!     This should be one of the Macros defined above, and indicates which 
                             4834 ; 194  |//!     GPIO will be set.
                             4835 ; 195  |//!
                             4836 ; 196  |//! \return
                             4837 ; 197  |//!     None. 
                             4838 ; 198  |//!
                             4839 ; 199  |//=============================================================================
                             4840 ; 200  |#define SysSignalEvent(wGPIONumber)         \ 
                             4841 ; 201  |{                                           \ 
                             4842 ; 202  |    HW_GP1DOR.B.##wGPIONumber = 1;          \ 
                             4843 ; 203  |}
                             4844 ; 204  |
                             4845 ; 205  |//=============================================================================
                             4846 ; 206  |// SysClearEvent
                             4847 ; 207  |//-----------------------------------------------------------------------------
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  76

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4848 ; 208  |//! This macro allows code to clear a gpio event that can be measured outside 
                             4849 ; 209  |//! the part.
                             4850 ; 210  |//! \param wGPIONumber 
                             4851 ; 211  |//!     This should be one of the Macros defined above, and indicates which 
                             4852 ; 212  |//!     GPIO will be set.
                             4853 ; 213  |//!
                             4854 ; 214  |//! \return
                             4855 ; 215  |//!     None. 
                             4856 ; 216  |//!
                             4857 ; 217  |//=============================================================================
                             4858 ; 218  |#define SysClearEvent(wGPIONumber)          \ 
                             4859 ; 219  |{                                           \ 
                             4860 ; 220  |    HW_GP1DOR.B.##wGPIONumber = 0;          \ 
                             4861 ; 221  |}
                             4862 ; 222  |
                             4863 ; 223  |//=============================================================================
                             4864 ; 224  |// SysEnableEvent
                             4865 ; 225  |//-----------------------------------------------------------------------------
                             4866 ; 226  |//! This macro must be called by code before using the SysSetEvent or 
                             4867 ; 227  |//! SysClearEvent so that the GPIOs are set up correctly.
                             4868 ; 228  |//!
                             4869 ; 229  |//! \param wGPIONumber 
                             4870 ; 230  |//!     This should be one of the Macros defined above, and indicates which 
                             4871 ; 231  |//!     GPIO will be set.
                             4872 ; 232  |//!
                             4873 ; 233  |//! \return
                             4874 ; 234  |//!     None. 
                             4875 ; 235  |//!
                             4876 ; 236  |//=============================================================================
                             4877 ; 237  |#define SysEnableEvent(wGPIONumber)         \ 
                             4878 ; 238  |{                                           \ 
                             4879 ; 239  |    HW_GP1DOER.B.##wGPIONumber=1;           \ 
                             4880 ; 240  |    HW_GP1DOR.B.##wGPIONumber=0;            \ 
                             4881 ; 241  |    HW_GP1ENR.B.##wGPIONumber=1;            \ 
                             4882 ; 242  |    HW_GP1PWR.B.##wGPIONumber=1;            \ 
                             4883 ; 243  |}
                             4884 ; 244  |#else // INSTRUMENT_ENABLE
                             4885 ; 245  |#define SysSignalEvent(wGPIONumber)
                             4886 ; 246  |#define SysClearEvent(wGPIONumber)
                             4887 ; 247  |#define SysEnableEvent(wGPIONumber)
                             4888 ; 248  |#endif // INSTRUMENT_ENABLE
                             4889 ; 249  |    
                             4890 ; 250  |#endif
                             4891 
                             4893 
                             4894 ; 33   |#include "usb_api.h"
                             4895 
                             4897 
                             4898 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             4899 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                             4900 ; 3    |//
                             4901 ; 4    |// File : USB_API.H
                             4902 ; 5    |// Description : USB_API.H defines and structures definition for USB device
                             4903 ; 6    |//               driver API.
                             4904 ; 7    |//               This 
                             4905 ; 8    |////////////////////////////////////////////////////////////////////////////////
                             4906 ; 9    |
                             4907 ; 10   |#ifndef __usb_api_h__
                             4908 ; 11   |#define __usb_api_h__ 1
                             4909 ; 12   |
                             4910 ; 13   |#include "types.h"
                             4911 ; 14   |#include "project.h"
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  77

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4912 ; 15   |
                             4913 ; 16   |#ifndef _USB_MEM
                             4914 ; 17   |//if not overwridden, default to the compiler default memory space
                             4915 ; 18   |#define _USB_MEM
                             4916 ; 19   |#endif
                             4917 ; 20   |
                             4918 ; 21   |#define USB_LANGUAGE_ENGLISH 0x0409
                             4919 ; 22   |#define USB_LANGUAGE_CHINESE_PRC 0x0804
                             4920 ; 23   |#define USB_LANGUAGE_CHINESE_TAIWAN 0x0404
                             4921 ; 24   |#define USB_LANGUAGE_JAPANESE 0x0411
                             4922 ; 25   |
                             4923 ; 26   |#define MAX_STRING 30
                             4924 ; 27   |
                             4925 ; 28   |#define  USB_SPEED_FULL                      (0)
                             4926 ; 29   |#define  USB_SPEED_LOW                       (1)
                             4927 ; 30   |#define  USB_SPEED_HIGH                      (2)
                             4928 ; 31   |
                             4929 ; 32   |#define EP_FS_MAX_PACKET_SIZE               (64)    
                             4930 ; 33   |
                             4931 ; 34   |#define EP_HS_MAX_PACKET_SIZE               (512)   
                             4932 ; 35   |
                             4933 ; 36   |// Data transferred to devices based on Sigmatel 3500 chip may sometimes be 
                             4934 ; 37   |// corrupted. The corruption occurs when device is connected in USB High Speed 
                             4935 ; 38   |// mode, and size of the transfer in bytes is divisible by 128, but not 
                             4936 ; 39   |// divisible by the packet size. The workaround is implemented in Microsoft MTP 
                             4937 ; 40   |// driver to allow support for those devices.
                             4938 ; 41   |
                             4939 ; 42   |// the bug can corrupt the end of data buffer. It occurs when host sends out a 
                             4940 ; 43   |// short packet that is multiple of 128 bytes. During this scenario the USB core
                             4941 ; 44   |// does writes that are voided (byte enable == all zero), which was an undefined 
                             4942 ; 45   |// capability and thus the gasket did not apply a proper response. This should 
                             4943 ; 46   |// not affect Mass Storage applications because data transfers are 512 bytes and 
                             4944 ; 47   |// scsi commands are < 16 bytes. Other applications with their own driver will
                             4945 ; 48   |// need to pad the packets if they fall into the error case. "What this basically 
                             4946 ; 49   |// boils down to is that any time the host sends a short packet of 128, 256 or
                             4947 ; 50   |// 384 bytes to a high-speed connected player a number of bytes will be corrupted.
                             4948 ; 51   |// This is easiest to reproduce in SendObject commands but can strike any of the 
                             4949 ; 52   |// commands that take an arbitrary amount of data.
                             4950 ; 53   |#define ARC_HS_128_MODULO_BUG               (128)
                             4951 ; 54   |
                             4952 ; 55   |
                             4953 ; 56   |/* Error codes */
                             4954 ; 57   |#define USB_OK                              (0x00)
                             4955 ; 58   |#define USBERR_REGISTER_SERVICE             (0x01)  // Failed to register a service
                             4956 ; 59   |#define USBERR_NO_SERVICE                   (0x02)  // No registered service found 
                             4957 ; 60   |#define USBERR_TX_FAILED                    (0x03)  // Fail to prepare XD descriptor
                             4958 ; 61   |#define USBERR_SIZE_TOO_LARGE               (0x04)  // Number of bytes to transfer is too 
                                  large
                             4959 ; 62   |#define USBERR_EP_INIT_FAILED               (0x05)  // Endpoint init fail
                             4960 ; 63   |#define USBERR_CONFIG_FAILED                (0x06)  // Error reported by the application
                             4961 ; 64   |                                                    // if the new config failed or not sup
                                  ported
                             4962 ; 65   |#define USBERR_DEVICE_NOT_CONFIGURED        (0x07)  // Error reported by the transfer func
                                  tion
                             4963 ; 66   |                                                    // if attempting to transfer while the
                                   device
                             4964 ; 67   |                                                    // is not configured
                             4965 ; 68   |#define USBERR_INIT_FAILED                  (0x08)  // Fail to initialize the USB API
                             4966 ; 69   |
                             4967 ; 70   |
                             4968 ; 71   |/* Endpoint types */
                             4969 ; 72   |#define  USB_CONTROL_ENDPOINT             (0)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  78

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4970 ; 73   |#define  USB_ISOCHRONOUS_ENDPOINT         (1)
                             4971 ; 74   |#define  USB_BULK_ENDPOINT                (2)
                             4972 ; 75   |#define  USB_INTERRUPT_ENDPOINT           (3)
                             4973 ; 76   |
                             4974 ; 77   |/* End point direction */
                             4975 ; 78   |#define  USB_OUT                         (0)
                             4976 ; 79   |#define  USB_IN                          (1)
                             4977 ; 80   |
                             4978 ; 81   |/* End point packed size */
                             4979 ; 82   |#define  USB_FS_MAX_PACKET_SIZE           (64)
                             4980 ; 83   |#define  USB_HS_BULK_OUT_MAX_PACKET_SIZE  (256)
                             4981 ; 84   |#define  USB_HS_BULK_IN_MAX_PACKET_SIZE   (128)
                             4982 ; 85   |
                             4983 ; 86   |
                             4984 ; 87   |#define  USB_TEST_MODE_TEST_J             (0x01)
                             4985 ; 88   |#define  USB_TEST_MODE_TEST_K             (0x02)
                             4986 ; 89   |#define  USB_TEST_MODE_TEST_SE0_NAK       (0x03)
                             4987 ; 90   |#define  USB_TEST_MODE_TEST_PACKET        (0x04)
                             4988 ; 91   |
                             4989 ; 92   |/* Available service types */
                             4990 ; 93   |/* Services 0 through 15 are reserved for endpoints */
                             4991 ; 94   |#define  USB_SERVICE_EP0                  (0x00)
                             4992 ; 95   |#define  USB_SERVICE_EP1                  (0x01)
                             4993 ; 96   |#define  USB_SERVICE_EP2                  (0x02)
                             4994 ; 97   |#define  USB_SERVICE_EP3                  (0x03)
                             4995 ; 98   |#define  USB_SERVICE_EP4                  (0x04)
                             4996 ; 99   |#define  USB_SERVICE_EP5                  (0x05)
                             4997 ; 100  |#define  USB_SERVICE_EP6                  (0x06)
                             4998 ; 101  |#define  USB_SERVICE_EP7                  (0x07)
                             4999 ; 102  |#define  USB_SERVICE_EP8                  (0x08)
                             5000 ; 103  |#define  USB_SERVICE_EP9                  (0x09)
                             5001 ; 104  |#define  USB_SERVICE_EP10                 (0x0a)
                             5002 ; 105  |#define  USB_SERVICE_EP11                 (0x0b)
                             5003 ; 106  |#define  USB_SERVICE_EP12                 (0x0c)
                             5004 ; 107  |#define  USB_SERVICE_EP13                 (0x0d)
                             5005 ; 108  |#define  USB_SERVICE_EP14                 (0x0e)
                             5006 ; 109  |#define  USB_SERVICE_EP15                 (0x0f)
                             5007 ; 110  |#define  USB_SERVICE_BUS_RESET            (0x10)
                             5008 ; 111  |#define  USB_SERVICE_SUSPEND              (0x11)
                             5009 ; 112  |#define  USB_SERVICE_SOF                  (0x12)
                             5010 ; 113  |#define  USB_SERVICE_RESUME               (0x13)
                             5011 ; 114  |#define  USB_SERVICE_SLEEP                (0x14)
                             5012 ; 115  |#define  USB_SERVICE_SPEED_DETECTION      (0x15)
                             5013 ; 116  |#define  USB_SERVICE_TEST                 (0x16)
                             5014 ; 117  |#define  USB_SERVICE_CHANGE_CONFIG        (0x17)
                             5015 ; 118  |#define  USB_SERVICE_CHANGE_IFACE         (0x18)   
                             5016 ; 119  |#define  NON_EP_SERVICES                  (USB_SERVICE_SPEED_DETECTION - USB_SERVICE_EP15)
                                  
                             5017 ; 120  |
                             5018 ; 121  |// This is the maximum service structures allocated 
                             5019 ; 122  |// One for each End point + the common services (non endpoint services) 
                             5020 ; 123  |#define MAX_NUMBER_SERVICES               (MAX_NUM_EP + NON_EP_SERVICES)  
                             5021 ; 124  |
                             5022 ; 125  |#define NUMBER_BYTES_IN_SETUP               (8)
                             5023 ; 126  |
                             5024 ; 127  |// possible values of btStatus on the xd_struct
                             5025 ; 128  |#define  USB_STATUS_TRANSFER_IDLE           (0)
                             5026 ; 129  |#define  USB_STATUS_TRANSFER_SUCCESS        (1)            
                             5027 ; 130  |#define  USB_STATUS_TRANSFER_ACCEPTED       (2)
                             5028 ; 131  |#define  USB_STATUS_TRANSFER_IN_PROGRESS    (3)
                             5029 ; 132  |#define  USB_STATUS_TRANSFER_ERROR          (4)
                             5030 ; 133  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  79

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5031 ; 134  |// types of status set/returned by set_status() and get_status()
                             5032 ; 135  |#define  USB_STATUS_DEVICE_STATE          (0x01)
                             5033 ; 136  |#define  USB_STATUS_INTERFACE             (0x02)
                             5034 ; 137  |#define  USB_STATUS_ADDRESS               (0x03)
                             5035 ; 138  |#define  USB_STATUS_CURRENT_CONFIG        (0x04)
                             5036 ; 139  |#define  USB_STATUS_SOF_COUNT             (0x05)
                             5037 ; 140  |#define  USB_STATUS                       (0x06)
                             5038 ; 141  |#define  USB_STATUS_TEST_MODE             (0x07)
                             5039 ; 142  |#define  USB_STATUS_DEVICE_SPEED          (0x08)  
                             5040 ; 143  |#define  USB_STATUS_DEVICE_TEST           (0x09)  
                             5041 ; 144  |#define  USB_STATUS_CURRENT_IFACE         (0x0a)
                             5042 ; 145  |#define  USB_STATUS_CONNECTION            (0x0b)  
                             5043 ; 146  |// For status endpoint, the endpoint number is coded in the less significant nibble
                             5044 ; 147  |#define  USB_STATUS_ENDPOINT              (0x10)
                             5045 ; 148  |#define  USB_STATUS_ENDPOINT_NUMBER_MASK  (0x0F)
                             5046 ; 149  |
                             5047 ; 150  |#define USB_MAX_SIZE_PER_TRANSFER       (0x4000)    // This is the maximum size that
                             5048 ; 151  |                                                    // we allow per transfer
                             5049 ; 152  |
                             5050 ; 153  |//Possible states the device can be in
                             5051 ; 154  |#define  USB_STATE_UNKNOWN                   (0xff)
                             5052 ; 155  |#define  USB_STATE_UNPLUGGED                 (0x05) // USB Cable unplugged
                             5053 ; 156  |#define  USB_STATE_PLUGGED                   (0x04) // USB Cable inserted
                             5054 ; 157  |#define  USB_STATE_POWERED                   (0x03)
                             5055 ; 158  |#define  USB_STATE_DEFAULT                   (0x02)
                             5056 ; 159  |#define  USB_STATE_ADDRESSED                 (0x01)
                             5057 ; 160  |#define  USB_STATE_CONFIGURED                (0x00)
                             5058 ; 161  |#define  USB_STATE_SUSPENDED                 (0x80)
                             5059 ; 162  |
                             5060 ; 163  |// Possible states the connection can be in
                             5061 ; 164  |//#define USB_STATE_UNKNOWN                 (0xff)
                             5062 ; 165  |#define USB_CONNECTED                       (0x00)
                             5063 ; 166  |#define USB_DISCONNECTED                    (0x01)
                             5064 ; 167  |
                             5065 ; 168  |
                             5066 ; 169  |
                             5067 ; 170  |typedef union
                             5068 ; 171  |{
                             5069 ; 172  |    struct
                             5070 ; 173  |    {
                             5071 ; 174  |        int Recipient               : 5;
                             5072 ; 175  |        int Type                    : 2;
                             5073 ; 176  |        int DataTransferDirection   : 1;
                             5074 ; 177  |        int Request                 : 8;
                             5075 ; 178  |        int                         : 8;
                             5076 ; 179  |    } B;
                             5077 ; 180  |    
                             5078 ; 181  |    int I;
                             5079 ; 182  |} USBRequestType ;
                             5080 ; 183  |
                             5081 ; 184  |typedef struct {
                             5082 ; 185  |   BYTE     bValid;
                             5083 ; 186  |   USBRequestType RequestType;
                             5084 ; 187  |   BYTE     btRequest;
                             5085 ; 188  |   WORD     wValue;
                             5086 ; 189  |   WORD     wIndex;
                             5087 ; 190  |   WORD     wLength;
                             5088 ; 191  |    } USB_SetupData;
                             5089 ; 192  |
                             5090 ; 193  |// Descriptor sizes in bytes
                             5091 ; 194  |#define SIZE_DEVICE_DESCRIPTOR_IN_BYTES     (18)
                             5092 ; 195  |#define SIZE_DEVICE_DESCRIPTOR_IN_WORDS     (6)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  80

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5093 ; 196  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES   (10)
                             5094 ; 197  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_WORDS   (4)
                             5095 ; 198  |#define SIZE_CONFIG_DESCRIPTOR_IN_BYTES     (9)
                             5096 ; 199  |#define SIZE_CONFIG_DESCRIPTOR_IN_WORDS     (3)
                             5097 ; 200  |#define SIZE_INTERFACE_DESCRIPTOR_IN_BYTES  (9)
                             5098 ; 201  |#define SIZE_INTERFACE_DESCRIPTOR_IN_WORDS  (3)
                             5099 ; 202  |#define SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES   (7)
                             5100 ; 203  |
                             5101 ; 204  |
                             5102 ; 205  |// Descriptor types
                             5103 ; 206  |#define DESCRIPTOR_TYPE_DEVICE              (0x01)
                             5104 ; 207  |#define DESCRIPTOR_TYPE_CONFIG              (0x02)
                             5105 ; 208  |#define DESCRIPTOR_TYPE_STRING              (0x03)
                             5106 ; 209  |#define DESCRIPTOR_TYPE_INTERFACE           (0x04)
                             5107 ; 210  |#define DESCRIPTOR_TYPE_ENDPOINT            (0x05)
                             5108 ; 211  |#define DESCRIPTOR_TYPE_DEVICE_QUALIFIER    (0x06)
                             5109 ; 212  |#define DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG  (0x07)
                             5110 ; 213  |#define DESCRIPTOR_TYPE_INTERFACE_POWER     (0x08)
                             5111 ; 214  |
                             5112 ; 215  |
                             5113 ; 216  |#define USB_REQUEST_DIRECTION_HOST_TO_DEVICE    ((WORD)0x000000)
                             5114 ; 217  |#define USB_REQUEST_DIRECTION_DEVICE_TO_HOST    ((WORD)0x000001)
                             5115 ; 218  |
                             5116 ; 219  |#define USB_REQUEST_TYPE_STANDARD               ((WORD)0x000000)
                             5117 ; 220  |#define USB_REQUEST_TYPE_CLASS                  ((WORD)0x000001)
                             5118 ; 221  |#define USB_REQUEST_TYPE_VENDOR                 ((WORD)0x000002)
                             5119 ; 222  |#define USB_REQUEST_TYPE_RESERVED               ((WORD)0x000003)
                             5120 ; 223  |
                             5121 ; 224  |#define USB_REQUEST_RECIPIENT_DEVICE            ((WORD)0x000000)
                             5122 ; 225  |#define USB_REQUEST_RECIPIENT_INTERFACE         ((WORD)0x000001)
                             5123 ; 226  |#define USB_REQUEST_RECIPIENT_ENDPOINT          ((WORD)0x000002)
                             5124 ; 227  |#define USB_REQUEST_RECIPIENT_OTHER             ((WORD)0x000003)
                             5125 ; 228  |
                             5126 ; 229  |#define USB_REQUEST_STANDARD_GET_STATUS         ((WORD)0x000000)
                             5127 ; 230  |#define USB_REQUEST_STANDARD_CLEAR_FEATURE      ((WORD)0x000001)
                             5128 ; 231  |#define USB_REQUEST_STANDARD_RESERVED_1         ((WORD)0x000002)
                             5129 ; 232  |#define USB_REQUEST_STANDARD_SET_FEATURE        ((WORD)0x000003)
                             5130 ; 233  |#define USB_REQUEST_STANDARD_RESERVED_2         ((WORD)0x000004)
                             5131 ; 234  |#define USB_REQUEST_STANDARD_SET_ADDRESS        ((WORD)0x000005)
                             5132 ; 235  |#define USB_REQUEST_STANDARD_GET_DESCRIPTOR     ((WORD)0x000006)
                             5133 ; 236  |#define USB_REQUEST_STANDARD_SET_DESCRIPTOR     ((WORD)0x000007)
                             5134 ; 237  |#define USB_REQUEST_STANDARD_GET_CONFIGURATION  ((WORD)0x000008)
                             5135 ; 238  |#define USB_REQUEST_STANDARD_SET_CONFIGURATION  ((WORD)0x000009)
                             5136 ; 239  |#define USB_REQUEST_STANDARD_GET_INTERFACE      ((WORD)0x00000A)
                             5137 ; 240  |#define USB_REQUEST_STANDARD_SET_INTERFACE      ((WORD)0x00000B)
                             5138 ; 241  |#define USB_REQUEST_STANDARD_SYNCH_FRAME        ((WORD)0x00000C)
                             5139 ; 242  |
                             5140 ; 243  |#define USB_CLEAR_FEATURE_ENDPOINT_HALT         (0)
                             5141 ; 244  |#define USB_CLEAR_FEATURE_REMOTE_WAKEUP         (1)
                             5142 ; 245  |
                             5143 ; 246  |
                             5144 ; 247  |// Struct Device Descriptor
                             5145 ; 248  |typedef struct {
                             5146 ; 249  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (18)
                             5147 ; 250  |    BYTE    btDescriptorType;       // (1) Device descriptor type (1)
                             5148 ; 251  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             5149 ; 252  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             5150 ; 253  |    BYTE    btDeviceClass;          // (4) Class code
                             5151 ; 254  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             5152 ; 255  |    BYTE    btDeviceProtocol;       // (6) Protocol code
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  81

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5153 ; 256  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 (8, 16, 32 o
                                  r 64)
                             5154 ; 257  |    BYTE    btIdVendorLsb;          // (8) Vendor Id
                             5155 ; 258  |    BYTE    btIdVendorMsb;          // (9)
                             5156 ; 259  |    BYTE    btIdProductLsb;         // (10) Product Id
                             5157 ; 260  |    BYTE    btIdProductMsb;         // (11)
                             5158 ; 261  |    BYTE    btBcdReleaseLsb;        // (12) Device release number in BCD
                             5159 ; 262  |    BYTE    btBcdReleaseMsb;        // (13)
                             5160 ; 263  |    BYTE    btIndexManufacturer;    // (14) Index of string descriptor describing Manufact
                                  urer
                             5161 ; 264  |    BYTE    btIndexProduct;         // (15) Index of string descriptor describing Product
                             5162 ; 265  |    BYTE    btIndexSerialNumber;    // (16) Index of string descriptor describing Device S
                                  erial Number
                             5163 ; 266  |    BYTE    btNumConfigurations;    // (17) Number of possible configurations
                             5164 ; 267  |} Struct_Standard_Dev_Desc;
                             5165 ; 268  |
                             5166 ; 269  |// Struct Device Qualifier Descriptor
                             5167 ; 270  |typedef struct {
                             5168 ; 271  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (10)
                             5169 ; 272  |    BYTE    btDescriptorType;       // (1) Device descriptor type (6)
                             5170 ; 273  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             5171 ; 274  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             5172 ; 275  |    BYTE    btDeviceClass;          // (4) Class code
                             5173 ; 276  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             5174 ; 277  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             5175 ; 278  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 other speed 
                                  (8, 16, 32 or 64)
                             5176 ; 279  |    BYTE    btNumConfigurations;    // (8) Number of other-speed possible configurations
                             5177 ; 280  |    BYTE    btReserved;             // (9) Reserved for future use, must be 0
                             5178 ; 281  |} Struct_Dev_Qualifier_Desc;
                             5179 ; 282  |
                             5180 ; 283  |// Struct Configuration Descriptor
                             5181 ; 284  |typedef struct {
                             5182 ; 285  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             5183 ; 286  |    BYTE    btDescriptorType;       // (1) Device descriptor type (2 or 7)
                             5184 ; 287  |    BYTE    btTotalLengthLsb;       // (2) Total length of data returned for this config.
                             5185 ; 288  |    BYTE    btTotalLengthMsb;       // (3)                                  
                             5186 ; 289  |    BYTE    btNumInterfaces;        // (4) Number of Interfaces supported by this configur
                                  ation
                             5187 ; 290  |    BYTE    btConfigurationValue;   // (5) Value to use as an argument to the SetConfigura
                                  tion() request
                             5188 ; 291  |    BYTE    btIndexConfiguration;   // (6) Index of string descriptor describing this conf
                                  iguration
                             5189 ; 292  |    BYTE    btBitMapAttributes;     // (7) Configuration Characteristics
                             5190 ; 293  |                                    //     D7:      Reserved (set to one)
                             5191 ; 294  |                                    //     D6:      Self-powered
                             5192 ; 295  |                                    //     D5:      Remote Wakeup
                             5193 ; 296  |                                    //     D4..0:   Reserved (reset to zero)        
                             5194 ; 297  |    BYTE    btMaxPower;             // (8) Maximum power consumption expressed in 2mA unit
                                  s.
                             5195 ; 298  |} Struct_Standard_Config_Desc, Struct_Other_Speed_Config_Desc;
                             5196 ; 299  |
                             5197 ; 300  |// Struct Interface Descriptor
                             5198 ; 301  |typedef struct {
                             5199 ; 302  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             5200 ; 303  |    BYTE    btDescriptorType;       // (1) Device descriptor type (4)
                             5201 ; 304  |    BYTE    btInterfaceNum;         // (2) Number of this interface. Zero-based value.
                             5202 ; 305  |    BYTE    btAlternateSetting;     // (3)                                  
                             5203 ; 306  |    BYTE    btNumEndpoints;         // (4) Number of endpointsused by this interface (excl
                                  uding endpoint 0).
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  82

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5204 ; 307  |    BYTE    btInterfaceClass;       // (5) Class code
                             5205 ; 308  |    BYTE    btInterfaceSubClass;    // (6) Sub Class code
                             5206 ; 309  |    BYTE    btInterfaceProtocol;    // (7) Protocol Code
                             5207 ; 310  |    BYTE    btIndexInterface;       // (8) Index of string descriptor describing this inte
                                  rface
                             5208 ; 311  |} Struct_Standard_Interface_Desc;
                             5209 ; 312  |
                             5210 ; 313  |// Struct Endpoint Descriptor
                             5211 ; 314  |typedef struct {
                             5212 ; 315  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (7)
                             5213 ; 316  |    BYTE    btDescriptorType;       // (1) Device descriptor type (5)
                             5214 ; 317  |    BYTE    btEndpointAddress;      // (2) Address of the endpoint on the USB device descr
                                  ibed by this descriptor
                             5215 ; 318  |                                    //      Bit 3..0: Endpoint number
                             5216 ; 319  |                                    //      Bit 6..4: Reserved, reset to zero
                             5217 ; 320  |                                    //      Bit 7:    Direction. Ignored for control endpo
                                  ints (0 OUT, 1 IN)
                             5218 ; 321  |    BYTE    btBitMapAttributes;     // (3) Endpoint attributes
                             5219 ; 322  |                                    //      bits 1..0: Transfer Type (00 Control, 01 Iso, 
                                  10 Bulk, 11 Int)
                             5220 ; 323  |                                    //      bits 5..2: If not an iso endpoints, they are r
                                  eserved and must be reset to zero.
                             5221 ; 324  |                                    //      bits 7..6: Reserved bits, must be reset to zer
                                  o.                                    
                             5222 ; 325  |    BYTE    btMaxPacketSizeLsb;     // (4) Maximum packet size. Refer to standard for bits
                                   specification
                             5223 ; 326  |    BYTE    btMaxPacketSizeMsb;     // (5)
                             5224 ; 327  |    BYTE    btInterval;             // (6) Interval for polling endpoint for data transfer
                                  s (refer to standard)
                             5225 ; 328  |} Struct_Standard_Endpoint_Desc;
                             5226 ; 329  |
                             5227 ; 330  |typedef struct {
                             5228 ; 331  |    BYTE    btLength;                   // (0) Size of this descriptor in bytes (2*MAX_USB
                                  _LANG + 2)
                             5229 ; 332  |    BYTE    btDescriptorType;           // (1) String descriptor type (3)
                             5230 ; 333  |    BYTE    btString[MAX_STRING*2];       
                             5231 ; 334  |} Struct_String_Desc;
                             5232 ; 335  |
                             5233 ; 336  |//
                             5234 ; 337  |// Externals
                             5235 ; 338  |//
                             5236 ; 339  |extern void _reentrant usb_dci_chip_enable (void);
                             5237 ; 340  |extern void _reentrant usb_dci_shutdown(void);
                             5238 ; 341  |
                             5239 ; 342  |BYTE _reentrant usb_device_init(void);
                             5240 ; 343  |void _inline usb_device_shutdown(void)
                             5241 ; 344  |{
                             5242 ; 345  |    usb_dci_shutdown();
                             5243 ; 346  |}
                             5244 ; 347  |
                             5245 ; 348  |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYT
                                  E btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData)); 
                             5246 ; 349  |//Remove unused function usb_device_get_service() to reclain _P memroy.
                             5247 ; 350  |//BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE b
                                  tDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength)); 
                             5248 ; 351  |
                             5249 ; 352  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btD
                                  irection, BYTE btType, BOOL bFlag);
                             5250 ; 353  |
                             5251 ; 354  |extern USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             5252 ; 355  |#define usb_device_read_setup_data(btEndpoint) usb_dci_get_setup_data(btEndpoint)
                             5253 ; 356  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  83

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5254 ; 357  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus);
                             5255 ; 358  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus);
                             5256 ; 359  |BYTE _reentrant usb_device_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             5257 ; 360  |
                             5258 ; 361  |extern void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             5259 ; 362  |#define usb_device_stall_endpoint(btEndpoint, btDirection) usb_dci_stall_endpoint((btEndpo
                                  int), (btDirection))
                             5260 ; 363  |
                             5261 ; 364  |extern void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             5262 ; 365  |#define usb_device_unstall_endpoint(btEndpoint, btDirection) usb_dci_unstall_endpoint((btE
                                  ndpoint), (btDirection))
                             5263 ; 366  |
                             5264 ; 367  |extern void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             5265 ; 368  |#define usb_device_finish_transaction(btEndpoint) usb_dci_finish_transaction(btEndpoint);
                             5266 ; 369  |
                             5267 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             5268 ; 371  |//
                             5269 ; 372  |//>  Name:          usb_device_enable
                             5270 ; 373  |//
                             5271 ; 374  |//   Type:          Function
                             5272 ; 375  |//
                             5273 ; 376  |//   Description:   Enables the USB device for transfers
                             5274 ; 377  |//
                             5275 ; 378  |//   Inputs:        none
                             5276 ; 379  |//
                             5277 ; 380  |//   Outputs:       USB_OK or error code
                             5278 ; 381  |//
                             5279 ; 382  |//   Notes:         none
                             5280 ; 383  |//<
                             5281 ; 384  |////////////////////////////////////////////////////////////////////////////////
                             5282 ; 385  |void _inline usb_device_enable(void)
                             5283 ; 386  |{
                             5284 ; 387  |    usb_dci_chip_enable();
                             5285 ; 388  |}
                             5286 ; 389  |
                             5287 ; 390  |void _reentrant usb_device_release(void);
                             5288 ; 391  |void _reentrant usb_device_hold(void);
                             5289 ; 392  |BYTE _reentrant usb_device_is_hold(void);
                             5290 ; 393  |void _reentrant usb_device_data_phase_required(void);
                             5291 ; 394  |
                             5292 ; 395  |BOOL _reentrant usb_device_is_first_init(void);
                             5293 ; 396  |void _reentrant usb_device_set_first_init(void);
                             5294 ; 397  |void _reentrant usb_device_clear_first_init(void);
                             5295 ; 398  |
                             5296 ; 399  |WORD _reentrant usb_get_current_limit(void);
                             5297 ; 400  |RETCODE _reentrant usb_set_current_limit(WORD);
                             5298 ; 401  |
                             5299 ; 402  |////////////////////////////////////////////////////////////////////
                             5300 ; 403  |extern BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             5301 ; 404  |#define usb_device_get_endpoint_status(btEndpoint) usb_dci_get_endpoint_status(btEndpoint)
                                  
                             5302 ; 405  |
                             5303 ; 406  |#define USB_ENDPOINT_STATUS_OK                          0
                             5304 ; 407  |#define USB_ENDPOINT_STATUS_STALLED                     1
                             5305 ; 408  |#define USB_ENDPOINT_STATUS_RECIEVED_UNSTALL_REQUEST    2
                             5306 ; 409  |// WHQL
                             5307 ; 410  |#define USB_ENDPOINT_STATUS_HOST_STALLED                3
                             5308 ; 411  |////////////////////////////////////////////////////////////////////
                             5309 ; 412  |
                             5310 ; 413  |
                             5311 ; 414  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  84

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5312 ; 415  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             5313 ; 416  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLen
                                  gth,WORD wPrivateData);
                             5314 ; 417  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             5315 ; 418  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateDa
                                  ta, 
                             5316 ; 419  |                                         BOOL bIsDataPhase, WORD wDirection);
                             5317 ; 420  |
                             5318 ; 421  |#ifndef CUSTOMIZE_UNICODE
                             5319 ; 422  |extern const BYTE g_Manufacturer[];
                             5320 ; 423  |extern const BYTE g_ProductName[];
                             5321 ; 424  |extern const BYTE g_ConfigString[];
                             5322 ; 425  |extern const BYTE g_Interface0String[];
                             5323 ; 426  |extern const BYTE g_Interface1String[];
                             5324 ; 427  |extern const BYTE g_MSOSDescriptorString[];
                             5325 ; 428  |#else   // CUSTOMIZE_UNICODE
                             5326 ; 429  |extern const WORD g_Manufacturer[];
                             5327 ; 430  |extern const WORD g_ProductName[];
                             5328 ; 431  |extern const WORD g_ConfigString[];
                             5329 ; 432  |extern const WORD g_Interface0String[];
                             5330 ; 433  |extern const WORD g_Interface1String[];
                             5331 ; 434  |extern const WORD g_MSOSDescriptorString[];
                             5332 ; 435  |#endif
                             5333 ; 436  |extern WORD g_LanguageList[];
                             5334 ; 437  |
                             5335 ; 438  |extern const BYTE g_SCSIVendorID[];
                             5336 ; 439  |extern const BYTE g_SCSIProductID[];
                             5337 ; 440  |extern void *g_pStrings[];
                             5338 ; 441  |
                             5339 ; 442  |extern WORD g_wUSBVendorID;
                             5340 ; 443  |extern WORD g_wUSBProductID;
                             5341 ; 444  |extern WORD g_wUSBReleaseID;
                             5342 ; 445  |
                             5343 ; 446  |#endif
                             5344 ; 447  |/* EOF */
                             5345 ; 448  |
                             5346 
                             5348 
                             5349 ; 34   |#include "ptp.h"
                             5350 
                             5352 
                             5353 ; 1    |/****************************************************************************
                             5354 ; 2    | *
                             5355 ; 3    | * @module      ptp.h
                             5356 ; 4    | *
                             5357 ; 5    | * @created     17-Februrary-2004
                             5358 ; 6    | *
                             5359 ; 7    | * @abstract    PTP functions and structures
                             5360 ; 8    | *
                             5361 ; 9    | * @copyright   (C) COPYRIGHT POWER Q INC., 2004
                             5362 ; 10   | *
                             5363 ; 11   | ****************************************************************************/
                             5364 ; 12   |
                             5365 ; 13   |#ifndef __PTP_H__
                             5366 ; 14   |#define __PTP_H__
                             5367 ; 15   |
                             5368 ; 16   |/*
                             5369 ; 17   | *  Define standard min and max macros
                             5370 ; 18   | */
                             5371 ; 19   |
                             5372 ; 20   |#define MIN(a,b) (((a) < (b)) ? (a) : (b))
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  85

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5373 ; 21   |
                             5374 ; 22   |#define MAX(a,b) (((a) > (b)) ? (a) : (b))
                             5375 ; 23   |
                             5376 ; 24   |
                             5377 ; 25   |/*
                             5378 ; 26   | * PTP Data type codes.
                             5379 ; 27   | */
                             5380 ; 28   |#define PTP_DATATYPE_UNDEFINED   0x0000
                             5381 ; 29   |#define PTP_DATATYPE_INT8        0x0001
                             5382 ; 30   |#define PTP_DATATYPE_UINT8       0x0002
                             5383 ; 31   |#define PTP_DATATYPE_INT16       0x0003
                             5384 ; 32   |#define PTP_DATATYPE_UINT16      0x0004
                             5385 ; 33   |#define PTP_DATATYPE_INT32       0x0005
                             5386 ; 34   |#define PTP_DATATYPE_UINT32      0x0006
                             5387 ; 35   |#define PTP_DATATYPE_INT64       0x0007
                             5388 ; 36   |#define PTP_DATATYPE_UINT64      0x0008
                             5389 ; 37   |#define PTP_DATATYPE_INT128      0x0009
                             5390 ; 38   |#define PTP_DATATYPE_UINT128     0x000A
                             5391 ; 39   |#define PTP_DATATYPE_AINT8       0x4001
                             5392 ; 40   |#define PTP_DATATYPE_AUINT8      0x4002
                             5393 ; 41   |#define PTP_DATATYPE_AINT16      0x4003
                             5394 ; 42   |#define PTP_DATATYPE_AUINT16     0x4004
                             5395 ; 43   |#define PTP_DATATYPE_AINT32      0x4005
                             5396 ; 44   |#define PTP_DATATYPE_AUINT32     0x4006
                             5397 ; 45   |#define PTP_DATATYPE_AINT64      0x4007
                             5398 ; 46   |#define PTP_DATATYPE_AUINT64     0x4008
                             5399 ; 47   |#define PTP_DATATYPE_AINT128     0x4009
                             5400 ; 48   |#define PTP_DATATYPE_AUINT128    0x400A
                             5401 ; 49   |#define PTP_DATATYPE_STRING      0xFFFF
                             5402 ; 50   |#define PTP_DATATYPE_ARRAYMASK   0x4FF0
                             5403 ; 51   |#define PTP_DATATYPE_ARRAY       0x4000
                             5404 ; 52   |#define PTP_DATATYPE_VALUEMASK   0xFFF0
                             5405 ; 53   |#define PTP_DATATYPE_VALUE       0x0000
                             5406 ; 54   |
                             5407 ; 55   |
                             5408 ; 56   |
                             5409 ; 57   |/*
                             5410 ; 58   | * Data code ranges and masks. Each data code has 16 bits:
                             5411 ; 59   | *
                             5412 ; 60   | * Bit 15(std/vendor)
                             5413 ; 61   | *    0 -- the code is defined by PTP standard
                             5414 ; 62   | *    1 -- the code is vendor specific
                             5415 ; 63   | *
                             5416 ; 64   | * Bit 14 - 12(data type)
                             5417 ; 65   | *   14 13 12
                             5418 ; 66   | *   0  0  0    -- undefined data type
                             5419 ; 67   | *   0  0  1    -- op code
                             5420 ; 68   | *   0  1  0    -- response code
                             5421 ; 69   | *   0  1  1    -- format code
                             5422 ; 70   | *   1  0  0    -- event code
                             5423 ; 71   | *   1  0  1    -- property code
                             5424 ; 72   | *   1  1  0    -- reserved
                             5425 ; 73   | *   1  1  1    -- reserved
                             5426 ; 74   | *
                             5427 ; 75   | * Bit 11 - bit 0 (data value)
                             5428 ; 76   | */
                             5429 ; 77   |#define  PTP_DATACODE_VENDORMASK           0x8000
                             5430 ; 78   |#define  PTP_DATACODE_TYPEMASK             0x7000
                             5431 ; 79   |#define  PTP_DATACODE_VALUEMASK            0x0FFF
                             5432 ; 80   |#define  PTP_DATACODE_TYPE_UNKNOWN         0x0000
                             5433 ; 81   |#define  PTP_DATACODE_TYPE_OPERATION       0x1000
                             5434 ; 82   |#define  PTP_DATACODE_TYPE_RESPONSE        0x2000
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  86

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5435 ; 83   |#define  PTP_DATACODE_TYPE_FORMAT          0x3000
                             5436 ; 84   |#define  PTP_DATACODE_TYPE_EVENT           0x4000
                             5437 ; 85   |#define  PTP_DATACODE_TYPE_PROPERTY        0x5000
                             5438 ; 86   |#define  PTP_DATACODE_TYPE_RESERVED_1      0x6000
                             5439 ; 87   |#define  PTP_DATACODE_TYPE_RESERVED_2      0x7000
                             5440 ; 88   |
                             5441 ; 89   |/*
                             5442 ; 90   | * To verify an op code
                             5443 ; 91   | *  (Code & PTP_DATACODE_TYPEMASK) == PTP_DATACODE_TYPE_OPERATION
                             5444 ; 92   | * To verify a response code
                             5445 ; 93   | *  (Code & PTP_DATACODE_TYPEMASK) == PTP_DATACODE_TYPE_RESPONSE)
                             5446 ; 94   | */
                             5447 ; 95   |
                             5448 ; 96   |/*
                             5449 ; 97   | * Image format codes receive special treatment.
                             5450 ; 98   | */
                             5451 ; 99   |#define  PTP_DATACODE_TYPEIMAGEMASK        0x7800;
                             5452 ; 100  |#define  PTP_DATACODE_TYPE_IMAGEFORMAT     0x3800;
                             5453 ; 101  |#define  PTP_DATACODE_VALUE_IMAGEVMASK     0x07FF;
                             5454 ; 102  |/*
                             5455 ; 103  | * To verify an image code
                             5456 ; 104  | * (Code & PTP_DATACODE_TYPEIMAGEMASK) == PTP_DATACODE_TYPE_IMAGEFORMAT
                             5457 ; 105  | */
                             5458 ; 106  |
                             5459 ; 107  |/*
                             5460 ; 108  | * PTP specially defined constants
                             5461 ; 109  | */
                             5462 ; 110  |#define PTP_OBJECTHANDLE_ALL          0xFFFFFFFF
                             5463 ; 111  |#define PTP_OBJECTHANDLE_UNDEFINED    0x0
                             5464 ; 112  |#define PTP_OBJECTHANDLE_ROOT         0x0
                             5465 ; 113  |#define PTP_PROPERTY_ALL              0xFFFFFFFF
                             5466 ; 114  |#define PTP_PROPERTY_UNDEFINED        0x0
                             5467 ; 115  |#define PTP_STORAGEID_ALL             0xFFFFFFFF
                             5468 ; 116  |#define PTP_STORAGEID_DEFAULT         0
                             5469 ; 117  |#define PTP_STORAGEID_UNDEFINED       0
                             5470 ; 118  |#define PTP_STORAGEID_PHYSICAL        0x0000FFFF
                             5471 ; 119  |#define PTP_STORAGEID_LOGICAL         0xFFFF0000
                             5472 ; 120  |#define PTP_SESSIONID_ALL             0
                             5473 ; 121  |#define PTP_SESSIONID_NOSESSION       0
                             5474 ; 122  |#define PTP_FORMATCODE_NOTUSED        0x0
                             5475 ; 123  |#define PTP_FORMATCODE_ALL            0xFFFFFFFF
                             5476 ; 124  |#define PTP_FORMATCODE_DEFAULT        0x0000
                             5477 ; 125  |#define PTP_TRANSACTIONID_ALL         0xFFFFFFFF
                             5478 ; 126  |#define PTP_TRANSACTIONID_NOSESSION   0
                             5479 ; 127  |
                             5480 ; 128  |/*
                             5481 ; 129  | * standard operation codes:
                             5482 ; 130  | */
                             5483 ; 131  |#define PTP_OPCODE_UNDEFINED               0x1000
                             5484 ; 132  |#define PTP_OPCODE_GETDEVICEINFO           0x1001
                             5485 ; 133  |#define PTP_OPCODE_OPENSESSION             0x1002
                             5486 ; 134  |#define PTP_OPCODE_CLOSESESSION            0x1003
                             5487 ; 135  |#define PTP_OPCODE_GETSTORAGEIDS           0x1004
                             5488 ; 136  |#define PTP_OPCODE_GETSTORAGEINFO          0x1005
                             5489 ; 137  |#define PTP_OPCODE_GETNUMOBJECTS           0x1006
                             5490 ; 138  |#define PTP_OPCODE_GETOBJECTHANDLES        0x1007
                             5491 ; 139  |#define PTP_OPCODE_GETOBJECTINFO           0x1008
                             5492 ; 140  |#define PTP_OPCODE_GETOBJECT               0x1009
                             5493 ; 141  |#define PTP_OPCODE_GETTHUMB                0x100A
                             5494 ; 142  |#define PTP_OPCODE_DELETEOBJECT            0x100B
                             5495 ; 143  |#define PTP_OPCODE_SENDOBJECTINFO          0x100C
                             5496 ; 144  |#define PTP_OPCODE_SENDOBJECT              0x100D
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  87

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5497 ; 145  |#define PTP_OPCODE_INITIATECAPTURE         0x100E
                             5498 ; 146  |#define PTP_OPCODE_FORMATSTORE             0x100F
                             5499 ; 147  |#define PTP_OPCODE_RESETDEVICE             0x1010
                             5500 ; 148  |#define PTP_OPCODE_SELFTEST                0x1011
                             5501 ; 149  |#define PTP_OPCODE_SETOBJECTPROTECTION     0x1012
                             5502 ; 150  |#define PTP_OPCODE_POWERDOWN               0x1013
                             5503 ; 151  |#define PTP_OPCODE_GETDEVICEPROPDESC       0x1014
                             5504 ; 152  |#define PTP_OPCODE_GETDEVICEPROPVALUE      0x1015
                             5505 ; 153  |#define PTP_OPCODE_SETDEVICEPROPVALUE      0x1016
                             5506 ; 154  |#define PTP_OPCODE_RESETDEVICEPROPVALUE    0x1017
                             5507 ; 155  |#define PTP_OPCODE_TERMINATECAPTURE        0x1018
                             5508 ; 156  |#define PTP_OPCODE_MOVEOBJECT              0x1019
                             5509 ; 157  |#define PTP_OPCODE_COPYOBJECT              0x101A
                             5510 ; 158  |#define PTP_OPCODE_GETPARTIALOBJECT        0x101B
                             5511 ; 159  |#define PTP_OPCODE_INITIATEOPENCAPTURE     0x101C
                             5512 ; 160  |#define PTP_OPCODE_VENDOREXTENDEDBASE      0x9000
                             5513 ; 161  |
                             5514 ; 162  |/*
                             5515 ; 163  | * MTP extended operations
                             5516 ; 164  | */
                             5517 ; 165  |#define MTP_OPCODE_UNDEFINED               0x9800
                             5518 ; 166  |#define MTP_OPCODE_GETOBJECTPROPSUPPORTED  0x9801
                             5519 ; 167  |#define MTP_OPCODE_GETOBJECTPROPDESC       0x9802
                             5520 ; 168  |#define MTP_OPCODE_GETOBJECTPROPVALUE      0x9803
                             5521 ; 169  |#define MTP_OPCODE_SETOBJECTPROPVALUE      0x9804
                             5522 ; 170  |#define MTP_OPCODE_GETOBJECTPROPLIST       0x9805
                             5523 ; 171  |#define MTP_OPCODE_SETOBJECTPROPLIST       0x9806
                             5524 ; 172  |#define MTP_OPCODE_RESETOBJECTPROPVALUE    0x9807
                             5525 ; 173  |#define MTP_OPCODE_SENDOBJECTPROPLIST      0x9808
                             5526 ; 174  |#define MTP_OPCODE_GETOBJECTREFERENCES     0x9810
                             5527 ; 175  |#define MTP_OPCODE_SETOBJECTREFERENCES     0x9811
                             5528 ; 176  |
                             5529 ; 177  |/*
                             5530 ; 178  | * Operations for Janus MTP extension
                             5531 ; 179  | */
                             5532 ; 180  |#define MTP_OPCODE_JANUS_GETSECURETIMECHALLENGE     0x9101
                             5533 ; 181  |#define MTP_OPCODE_JANUS_SETSECURETIMERESPONSE      0x9102
                             5534 ; 182  |#define MTP_OPCODE_JANUS_SETLICENSERESPONSE         0x9103
                             5535 ; 183  |#define MTP_OPCODE_JANUS_GETSYNCLIST                0x9104
                             5536 ; 184  |#define MTP_OPCODE_JANUS_SEND_METER_CHALLENGE_QUERY 0x9105
                             5537 ; 185  |#define MTP_OPCODE_JANUS_GET_METER_CHALLENGE        0x9106
                             5538 ; 186  |#define MTP_OPCODE_JANUS_SET_METER_RESPONSE         0x9107
                             5539 ; 187  |#define MTP_OPCODE_JANUS_CLEANDATASTORE             0x9108
                             5540 ; 188  |#define MTP_OPCODE_JANUS_GET_LICENSE_STATE          0x9109
                             5541 ; 189  |#define MTP_OPCODE_JANUS_SEND_WMDRMPD_COMMAND       0x910A
                             5542 ; 190  |#define MTP_OPCODE_JANUS_SEND_WMDRMPD_REQUEST       0x910B
                             5543 ; 191  |
                             5544 ; 192  |
                             5545 ; 193  |/*
                             5546 ; 194  | * SigmaTel vendor-specific operations.
                             5547 ; 195  | * Note 9/12/05: sgtl changed middle 2 nibbles for undefined, reset and eraseboot to be mo
                                  re unique.
                             5548 ; 196  | *                                 eg: x9200 is now 0x97F0.
                             5549 ; 197  | *     Sdk3.1 stupdater required (has these values also). So do not use stupdater from sdk
                                  3.0x.
                             5550 ; 198  | */
                             5551 ; 199  |#define MTP_OPCODE_SIGMATEL_UNDEFINED               0x97F0
                             5552 ; 200  |#define MTP_OPCODE_SIGMATEL_RESET                   0x97F1
                             5553 ; 201  |#define MTP_OPCODE_SIGMATEL_ERASEBOOT               0x97F2
                             5554 ; 202  |
                             5555 ; 203  |/*
                             5556 ; 204  | * standard event codes:
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  88

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5557 ; 205  | */
                             5558 ; 206  |#define PTP_EVENTCODE_UNDEFINED                0x4000
                             5559 ; 207  |#define PTP_EVENTCODE_CANCELTRANSACTION        0x4001
                             5560 ; 208  |#define PTP_EVENTCODE_OBJECTADDED              0x4002
                             5561 ; 209  |#define PTP_EVENTCODE_OBJECTREMOVED            0x4003
                             5562 ; 210  |#define PTP_EVENTCODE_STOREADDED               0x4004
                             5563 ; 211  |#define PTP_EVENTCODE_STOREREMOVED             0x4005
                             5564 ; 212  |#define PTP_EVENTCODE_DEVICEPROPCHANGED        0x4006
                             5565 ; 213  |#define PTP_EVENTCODE_OBJECTINFOCHANGED        0x4007
                             5566 ; 214  |#define PTP_EVENTCODE_DEVICEINFOCHANGED        0x4008
                             5567 ; 215  |#define PTP_EVENTCODE_REQUESTOBJECTTRANSFER    0x4009
                             5568 ; 216  |#define PTP_EVENTCODE_STOREFULL                0x400A
                             5569 ; 217  |#define PTP_EVENTCODE_DEVICERESET              0x400B
                             5570 ; 218  |#define PTP_EVENTCODE_STORAGEINFOCHANGED       0x400C
                             5571 ; 219  |#define PTP_EVENTCODE_CAPTURECOMPLETE          0x400D
                             5572 ; 220  |#define PTP_EVENTCODE_UNREPORTEDSTATUS         0x400E
                             5573 ; 221  |#define PTP_EVENTCODE_VENDOREXTENTION1         0xC001
                             5574 ; 222  |#define PTP_EVENTCODE_VENDOREXTENTION2         0xC002
                             5575 ; 223  |
                             5576 ; 224  |/*
                             5577 ; 225  | * MTP-extended Events
                             5578 ; 226  | */
                             5579 ; 227  |#define MTP_EVENTCODE_UNDEFINED                0xB800
                             5580 ; 228  |#define MTP_EVENTCODE_OBJECTPROPCHANGED        0xB801
                             5581 ; 229  |#define MTP_EVENTCODE_OBJECTPROPDESCCHANGED    0xB802
                             5582 ; 230  |#define MTP_EVENTCODE_OBJECTREFERENCESCHANGED  0xB803
                             5583 ; 231  |#define MTP_EVENTCODE_DEVICEPROPDESCCHANGED    0xB804
                             5584 ; 232  |
                             5585 ; 233  |/* Events for Janus MTP extension */
                             5586 ; 234  |#define MTP_EVENTCODE_JANUS_UNDEFINED          0xC100
                             5587 ; 235  |#define MTP_EVENTCODE_JANUS_EVENT1             0xC101
                             5588 ; 236  |
                             5589 ; 237  |
                             5590 ; 238  |/*
                             5591 ; 239  | * standard response codes:
                             5592 ; 240  | */
                             5593 ; 241  |#define PTP_RESPONSECODE_UNDEFINED                     0x2000
                             5594 ; 242  |#define PTP_RESPONSECODE_OK                            0x2001
                             5595 ; 243  |#define PTP_RESPONSECODE_GENERALERROR                  0x2002
                             5596 ; 244  |#define PTP_RESPONSECODE_SESSIONNOTOPEN                0x2003
                             5597 ; 245  |#define PTP_RESPONSECODE_INVALIDTRANSACTIONID          0x2004
                             5598 ; 246  |#define PTP_RESPONSECODE_OPERATIONNOTSUPPORTED         0x2005
                             5599 ; 247  |#define PTP_RESPONSECODE_PARAMETERNOTSUPPORTED         0x2006
                             5600 ; 248  |#define PTP_RESPONSECODE_INCOMPLETETRANSFER            0x2007
                             5601 ; 249  |#define PTP_RESPONSECODE_INVALIDSTORAGEID              0x2008
                             5602 ; 250  |#define PTP_RESPONSECODE_INVALIDOBJECTHANDLE           0x2009
                             5603 ; 251  |#define PTP_RESPONSECODE_PROPERTYNOTSUPPORTED          0x200A
                             5604 ; 252  |#define PTP_RESPONSECODE_INVALIDOBJECTFORMATCODE       0x200B
                             5605 ; 253  |#define PTP_RESPONSECODE_STOREFULL                     0x200C
                             5606 ; 254  |#define PTP_RESPONSECODE_OBJECTWRITEPROTECTED          0x200D
                             5607 ; 255  |#define PTP_RESPONSECODE_STOREWRITEPROTECTED           0x200E
                             5608 ; 256  |#define PTP_RESPONSECODE_ACCESSDENIED                  0x200F
                             5609 ; 257  |#define PTP_RESPONSECODE_NOTHUMBNAILPRESENT            0x2010
                             5610 ; 258  |#define PTP_RESPONSECODE_SELFTESTFAILED                0x2011
                             5611 ; 259  |#define PTP_RESPONSECODE_PARTIALDELETION               0x2012
                             5612 ; 260  |#define PTP_RESPONSECODE_STORENOTAVAILABLE             0x2013
                             5613 ; 261  |#define PTP_RESPONSECODE_NOSPECIFICATIONBYFORMAT       0x2014
                             5614 ; 262  |#define PTP_RESPONSECODE_NOVALIDOBJECTINFO             0x2015
                             5615 ; 263  |#define PTP_RESPONSECODE_INVALIDCODEFORMAT             0x2016
                             5616 ; 264  |#define PTP_RESPONSECODE_UNKNOWNVENDORCODE             0x2017
                             5617 ; 265  |#define PTP_RESPONSECODE_CAPTUREALREADYTERMINATED      0x2018
                             5618 ; 266  |#define PTP_RESPONSECODE_DEVICEBUSY                    0x2019
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  89

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5619 ; 267  |#define PTP_RESPONSECODE_INVALIDPARENT                 0x201A
                             5620 ; 268  |#define PTP_RESPONSECODE_INVALIDPROPFORMAT             0x201B
                             5621 ; 269  |#define PTP_RESPONSECODE_INVALIDPROPVALUE              0x201C
                             5622 ; 270  |#define PTP_RESPONSECODE_INVALIDPARAMETER              0x201D
                             5623 ; 271  |#define PTP_RESPONSECODE_SESSIONALREADYOPENED          0x201E
                             5624 ; 272  |#define PTP_RESPONSECODE_TRANSACTIONCANCELLED          0x201F
                             5625 ; 273  |/*
                             5626 ; 274  | * MTP responses
                             5627 ; 275  | */
                             5628 ; 276  |#define MTP_RESPONSECODE_UNDEFINED                     0xA800
                             5629 ; 277  |#define MTP_RESPONSECODE_INVALIDOBJECTPROPCODE         0xA801
                             5630 ; 278  |#define MTP_RESPONSECODE_INVALIDOBJECTPROPFORMAT       0xA802
                             5631 ; 279  |#define MTP_RESPONSECODE_INVALIDOBJECTPROPVALUE        0xA803
                             5632 ; 280  |#define MTP_RESPONSECODE_INVALIDOBJECTREFERENCE        0xA804
                             5633 ; 281  |
                             5634 ; 282  |#define MTP_RESPONSECODE_GROUPUNSUPPORTED              0xA807
                             5635 ; 283  |#define MTP_RESPONSECODE_DEPTHUNSUPPORTED              0xA808
                             5636 ; 284  |#define MTP_RESPONSECODE_OBJECTTOOLARGE                0xA809
                             5637 ; 285  |
                             5638 ; 286  |/* Responses for Janus MTP extension  */
                             5639 ; 287  |#define MTP_RESPONSECODE_JANUS_UNDEFINED               0xA100
                             5640 ; 288  |#define MTP_RESPONSECODE_JANUS_WMDRMPD_FAIL            0xA101
                             5641 ; 289  |
                             5642 ; 290  |
                             5643 ; 291  |/*
                             5644 ; 292  | * standard property codes:
                             5645 ; 293  | */
                             5646 ; 294  |#define PTP_PROPERTYCODE_UNDEFINED                 0x5000
                             5647 ; 295  |#define PTP_PROPERTYCODE_BATTERYLEVEL              0x5001
                             5648 ; 296  |#define PTP_PROPERTYCODE_FUNCTIONMODE              0x5002
                             5649 ; 297  |#define PTP_PROPERTYCODE_IMAGESIZE                 0x5003
                             5650 ; 298  |#define PTP_PROPERTYCODE_COMPRESSIONSETTING        0x5004
                             5651 ; 299  |#define PTP_PROPERTYCODE_WHITEBALANCE              0x5005
                             5652 ; 300  |#define PTP_PROPERTYCODE_RGBGAIN                   0x5006
                             5653 ; 301  |#define PTP_PROPERTYCODE_FNUMBER                   0x5007
                             5654 ; 302  |#define PTP_PROPERTYCODE_FOCALLENGTH               0x5008
                             5655 ; 303  |#define PTP_PROPERTYCODE_FOCUSDISTANCE             0x5009
                             5656 ; 304  |#define PTP_PROPERTYCODE_FOCUSMODE                 0x500A
                             5657 ; 305  |#define PTP_PROPERTYCODE_EXPOSUREMETERINGMODE      0x500B
                             5658 ; 306  |#define PTP_PROPERTYCODE_FLASHMODE                 0x500C
                             5659 ; 307  |#define PTP_PROPERTYCODE_EXPOSURETIME              0x500D
                             5660 ; 308  |#define PTP_PROPERTYCODE_EXPOSUREPROGRAMMODE       0x500E
                             5661 ; 309  |#define PTP_PROPERTYCODE_EXPOSUREINDEX             0x500F
                             5662 ; 310  |#define PTP_PROPERTYCODE_EXPOSURECOMPENSATION      0x5010
                             5663 ; 311  |#define PTP_PROPERTYCODE_DATETIME                  0x5011
                             5664 ; 312  |#define PTP_PROPERTYCODE_CAPTUREDELAY              0x5012
                             5665 ; 313  |#define PTP_PROPERTYCODE_STILLCAPTUREMODE          0x5013
                             5666 ; 314  |#define PTP_PROPERTYCODE_CONTRAST                  0x5014
                             5667 ; 315  |#define PTP_PROPERTYCODE_SHARPNESS                 0x5015
                             5668 ; 316  |#define PTP_PROPERTYCODE_DIGITALZOOM               0x5016
                             5669 ; 317  |#define PTP_PROPERTYCODE_EFFECTMODE                0x5017
                             5670 ; 318  |#define PTP_PROPERTYCODE_BURSTNUMBER               0x5018
                             5671 ; 319  |#define PTP_PROPERTYCODE_BURSTINTERVAL             0x5019
                             5672 ; 320  |#define PTP_PROPERTYCODE_TIMELAPSENUMBER           0x501A
                             5673 ; 321  |#define PTP_PROPERTYCODE_TIMELAPSEINTERVAL         0x501B
                             5674 ; 322  |#define PTP_PROPERTYCODE_FOCUSMETERINGMODE         0x501C
                             5675 ; 323  |#define PTP_PROPERTYCODE_UPLOADURL                 0x501D
                             5676 ; 324  |#define PTP_PROPERTYCODE_ARTIST                            0x501E
                             5677 ; 325  |#define PTP_PROPERTYCODE_COPYRIGHT                         0x501F
                             5678 ; 326  |#define PTP_PROPERTYCODE_VENDOREXTENTION1          0xD001
                             5679 ; 327  |#define PTP_PROPERTYCODE_VENDOREXTENTION2          0xD002
                             5680 ; 328  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  90

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5681 ; 329  |//
                             5682 ; 330  |// MTP defined Device properties
                             5683 ; 331  |//
                             5684 ; 332  |#define MTP_PROPERTYCODE_UNDEFINED                 0xD400
                             5685 ; 333  |#define MTP_PROPERTYCODE_SYNCHRONIZATIONPARTNER    0xD401
                             5686 ; 334  |#define MTP_PROPERTYCODE_DEVICEFRIENDLYNAME                0xD402
                             5687 ; 335  |
                             5688 ; 336  |// Audible Device property extension
                             5689 ; 337  |#define MTP_PROPERTYCODE_AUDIBLE_ACTIVATION_DATA   0xD100
                             5690 ; 338  |
                             5691 ; 339  |// Device properties for Janus MTP extension
                             5692 ; 340  |#define MTP_PROPERTYCODE_JANUS_SECURETIME          0xD101
                             5693 ; 341  |#define MTP_PROPERTYCODE_JANUS_DEVICECERTIFICATE   0xD102
                             5694 ; 342  |
                             5695 ; 343  |
                             5696 ; 344  |// Audible Object Properties
                             5697 ; 345  |#define MTP_OBJ_PROPERTYCODE_AUDIBLECODEC                  0xDA00
                             5698 ; 346  |#define MTP_OBJ_PROPERTYCODE_AUDIBLEPRODUCTID      0xDA01
                             5699 ; 347  |#define MTP_OBJ_PROPERTYCODE_AUDIBLEPLAYBACKPOS    0xDA02
                             5700 ; 348  |#define MTP_OBJ_PROPERTYCODE_AUDIBLEPLAYEDTHROUGH  0xDA03
                             5701 ; 349  |#define MTP_OBJ_PROPERTYCODE_AUDIBLETITLESEGMENT   0xDA04
                             5702 ; 350  |//
                             5703 ; 351  |// MTP extended object property codes:
                             5704 ; 352  |//
                             5705 ; 353  |
                             5706 ; 354  |#define MTP_OBJ_PROPERTYCODE_STORAGEID             0xDC01
                             5707 ; 355  |#define MTP_OBJ_PROPERTYCODE_OBJECTFORMAT          0xDC02
                             5708 ; 356  |#define MTP_OBJ_PROPERTYCODE_PROTECTIONSTATUS      0xDC03
                             5709 ; 357  |#define MTP_OBJ_PROPERTYCODE_OBJECTSIZE            0xDC04
                             5710 ; 358  |#define MTP_OBJ_PROPERTYCODE_ASSOCIATIONTYPE       0xDC05
                             5711 ; 359  |#define MTP_OBJ_PROPERTYCODE_ASSOCIATIONDESC       0xDC06
                             5712 ; 360  |#define MTP_OBJ_PROPERTYCODE_OBJECTFILENAME        0xDC07
                             5713 ; 361  |#define MTP_OBJ_PROPERTYCODE_DATECREATED           0xDC08
                             5714 ; 362  |#define MTP_OBJ_PROPERTYCODE_DATEMODIFIED          0xDC09
                             5715 ; 363  |#define MTP_OBJ_PROPERTYCODE_KEYWORDS              0xDC0A
                             5716 ; 364  |#define MTP_OBJ_PROPERTYCODE_PARENT                0xDC0B
                             5717 ; 365  |
                             5718 ; 366  |#define MTP_OBJ_PROPERTYCODE_PERSISTENTGUID        0xDC41
                             5719 ; 367  |#define MTP_OBJ_PROPERTYCODE_SYNCID                0xDC42
                             5720 ; 368  |#define MTP_OBJ_PROPERTYCODE_PROPERTYBAG           0xDC43
                             5721 ; 369  |#define MTP_OBJ_PROPERTYCODE_NAME                  0xDC44
                             5722 ; 370  |#define MTP_OBJ_PROPERTYCODE_CREATEDBY             0xDC45
                             5723 ; 371  |#define MTP_OBJ_PROPERTYCODE_ARTIST                0xDC46
                             5724 ; 372  |#define MTP_OBJ_PROPERTYCODE_DATEAUTHORED          0xDC47
                             5725 ; 373  |#define MTP_OBJ_PROPERTYCODE_DESCRIPTION           0xDC48
                             5726 ; 374  |#define MTP_OBJ_PROPERTYCODE_URLREFERENCE          0xDC49
                             5727 ; 375  |#define MTP_OBJ_PROPERTYCODE_LANGUAGELOCALE        0xDC4A
                             5728 ; 376  |#define MTP_OBJ_PROPERTYCODE_COPYRIGHTINFO         0xDC4B
                             5729 ; 377  |#define MTP_OBJ_PROPERTYCODE_SOURCE                0xDC4C
                             5730 ; 378  |#define MTP_OBJ_PROPERTYCODE_ORIGINLOCATION        0xDC4D
                             5731 ; 379  |#define MTP_OBJ_PROPERTYCODE_DATEADDED             0xDC4E
                             5732 ; 380  |#define MTP_OBJ_PROPERTYCODE_NONCONSUMABLE         0xDC4F
                             5733 ; 381  |#define MTP_OBJ_PROPERTYCODE_CORRUPTUNPLAYABLE     0xDC50
                             5734 ; 382  |
                             5735 ; 383  |#define MTP_OBJ_PROPERTYCODE_SAMPLEFORMAT          0xDC81
                             5736 ; 384  |#define MTP_OBJ_PROPERTYCODE_SAMPLESIZE            0xDC82
                             5737 ; 385  |#define MTP_OBJ_PROPERTYCODE_SAMPLEHEIGHT          0xDC83
                             5738 ; 386  |#define MTP_OBJ_PROPERTYCODE_SAMPLEWIDTH           0xDC84
                             5739 ; 387  |#define MTP_OBJ_PROPERTYCODE_SAMPLEDURATION        0xDC85
                             5740 ; 388  |#define MTP_OBJ_PROPERTYCODE_SAMPLEDATA            0xDC86
                             5741 ; 389  |#define MTP_OBJ_PROPERTYCODE_WIDTH                 0xDC87
                             5742 ; 390  |#define MTP_OBJ_PROPERTYCODE_HEIGHT                0xDC88
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  91

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5743 ; 391  |#define MTP_OBJ_PROPERTYCODE_DURATION              0xDC89
                             5744 ; 392  |#define MTP_OBJ_PROPERTYCODE_USERRATING            0xDC8A
                             5745 ; 393  |#define MTP_OBJ_PROPERTYCODE_TRACK                 0xDC8B
                             5746 ; 394  |#define MTP_OBJ_PROPERTYCODE_GENRE                 0xDC8C
                             5747 ; 395  |#define MTP_OBJ_PROPERTYCODE_CREDITS               0xDC8D
                             5748 ; 396  |#define MTP_OBJ_PROPERTYCODE_LYRICS                0xDC8E
                             5749 ; 397  |#define MTP_OBJ_PROPERTYCODE_SUBSCRIPCONTENTID     0xDC8F
                             5750 ; 398  |#define MTP_OBJ_PROPERTYCODE_PRODUCEDBY            0xDC90
                             5751 ; 399  |#define MTP_OBJ_PROPERTYCODE_USECOUNT              0xDC91
                             5752 ; 400  |#define MTP_OBJ_PROPERTYCODE_SKIPCOUNT             0xDC92
                             5753 ; 401  |#define MTP_OBJ_PROPERTYCODE_LASTACCESSED          0xDC93
                             5754 ; 402  |#define MTP_OBJ_PROPERTYCODE_PARENTALRATING        0xDC94
                             5755 ; 403  |#define MTP_OBJ_PROPERTYCODE_METAGENRE             0xDC95
                             5756 ; 404  |#define MTP_OBJ_PROPERTYCODE_COMPOSER              0xDC96
                             5757 ; 405  |#define MTP_OBJ_PROPERTYCODE_EFFECTIVERATING       0xDC97
                             5758 ; 406  |#define MTP_OBJ_PROPERTYCODE_SUBTITLE              0xDC98
                             5759 ; 407  |#define MTP_OBJ_PROPERTYCODE_ORIGINALRELEASEDATE   0xDC99
                             5760 ; 408  |#define MTP_OBJ_PROPERTYCODE_ALBUMNAME             0xDC9A
                             5761 ; 409  |#define MTP_OBJ_PROPERTYCODE_ALBUMARTIST           0xDC9B
                             5762 ; 410  |#define MTP_OBJ_PROPERTYCODE_MOOD                  0xDC9C
                             5763 ; 411  |#define MTP_OBJ_PROPERTYCODE_DRMSTATUS             0xDC9D
                             5764 ; 412  |#define MTP_OBJ_PROPERTYCODE_SUBDESCRIPTION        0xDC9E
                             5765 ; 413  |
                             5766 ; 414  |#define MTP_OBJ_PROPERTYCODE_ISCROPPED             0xDCD1
                             5767 ; 415  |#define MTP_OBJ_PROPERTYCODE_ISCOLORCORRECTED      0xDCD2
                             5768 ; 416  |
                             5769 ; 417  |#define MTP_OBJ_PROPERTYCODE_TOTALBITRATE          0xDE91
                             5770 ; 418  |#define MTP_OBJ_PROPERTYCODE_BITRATETYPE           0xDE92
                             5771 ; 419  |#define MTP_OBJ_PROPERTYCODE_SAMPLERATE            0xDE93
                             5772 ; 420  |#define MTP_OBJ_PROPERTYCODE_NUMBEROFCHANNELS      0xDE94
                             5773 ; 421  |#define MTP_OBJ_PROPERTYCODE_AUDIOBITDEPTH         0xDE95
                             5774 ; 422  |#define MTP_OBJ_PROPERTYCODE_SCANTYPE              0xDE97
                             5775 ; 423  |#define MTP_OBJ_PROPERTYCODE_AUDIOWAVECODEC        0xDE99
                             5776 ; 424  |#define MTP_OBJ_PROPERTYCODE_AUDIOBITRATE          0xDE9A
                             5777 ; 425  |#define MTP_OBJ_PROPERTYCODE_VIDEOFOURCCCODEC      0xDE9B
                             5778 ; 426  |#define MTP_OBJ_PROPERTYCODE_VIDEOBITRATE          0xDE9C
                             5779 ; 427  |#define MTP_OBJ_PROPERTYCODE_FRAMESPER1KSECONDS    0xDE9D
                             5780 ; 428  |#define MTP_OBJ_PROPERTYCODE_KEYFRAMEDISTANCE      0xDE9E
                             5781 ; 429  |#define MTP_OBJ_PROPERTYCODE_BUFFERSIZE            0xDE9F
                             5782 ; 430  |#define MTP_OBJ_PROPERTYCODE_ENCODINGQUALITY       0xDEA0
                             5783 ; 431  |
                             5784 ; 432  |
                             5785 ; 433  |/*
                             5786 ; 434  | * standard format codes:
                             5787 ; 435  | */
                             5788 ; 436  |#define  PTP_FORMATMASK_IMAGE                   0x0800
                             5789 ; 437  |
                             5790 ; 438  |#define  PTP_FORMATCODE_UNDEFINED               0x3000//
                             5791 ; 439  |#define  PTP_FORMATCODE_ASSOCIATION             0x3001
                             5792 ; 440  |#define  PTP_FORMATCODE_SCRIPT                  0x3002
                             5793 ; 441  |#define  PTP_FORMATCODE_EXECUTABLE              0x3003
                             5794 ; 442  |#define  PTP_FORMATCODE_TEXT                    0x3004//
                             5795 ; 443  |#define  PTP_FORMATCODE_HTML                    0x3005
                             5796 ; 444  |#define  PTP_FORMATCODE_DPOF                    0x3006
                             5797 ; 445  |#define  PTP_FORMATCODE_AIFF                    0x3007
                             5798 ; 446  |#define  PTP_FORMATCODE_WAVE                    0x3008//
                             5799 ; 447  |#define  PTP_FORMATCODE_MP3                     0x3009//
                             5800 ; 448  |#define  PTP_FORMATCODE_AVI                     0x300A
                             5801 ; 449  |#define  PTP_FORMATCODE_MPEG                    0x300B
                             5802 ; 450  |#define  PTP_FORMATCODE_ASF                     0x300C
                             5803 ; 451  |#define  MTP_UNDEFINED_FIRMWARE                         0xB802
                             5804 ; 452  |#define  MTP_FORMATCODE_WMA                                     0xB901//
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  92

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5805 ; 453  |#define  MTP_FORMATCODE_AUDIBLE             0xB904
                             5806 ; 454  |#define  MTP_FORMAT_CODE_ABSTRACT_PLAYLIST      0xBA05
                             5807 ; 455  |
                             5808 ; 456  |#define  PTP_FORMATCODE_IMAGE_UNDEFINED    0x3800
                             5809 ; 457  |#define  PTP_FORMATCODE_IMAGE_EXIF         0x3801
                             5810 ; 458  |#define  PTP_FORMATCODE_IMAGE_TIFFEP       0x3802
                             5811 ; 459  |#define  PTP_FORMATCODE_IMAGE_FLASHPIX     0x3803
                             5812 ; 460  |#define  PTP_FORMATCODE_IMAGE_BMP          0x3804
                             5813 ; 461  |#define  PTP_FORMATCODE_IMAGE_CIFF         0x3805
                             5814 ; 462  |#define  PTP_FORMATCODE_IMAGE_GIF          0x3807
                             5815 ; 463  |#define  PTP_FORMATCODE_IMAGE_JFIF         0x3808
                             5816 ; 464  |#define  PTP_FORMATCODE_IMAGE_PCD          0x3809
                             5817 ; 465  |#define  PTP_FORMATCODE_IMAGE_PICT         0x380A
                             5818 ; 466  |#define  PTP_FORMATCODE_IMAGE_PNG          0x380B
                             5819 ; 467  |#define  PTP_FORMATCODE_IMAGE_TIFF         0x380D
                             5820 ; 468  |#define  PTP_FORMATCODE_IMAGE_TIFFIT       0x380E
                             5821 ; 469  |#define  PTP_FORMATCODE_IMAGE_JP2          0x380F
                             5822 ; 470  |#define  PTP_FORMATCODE_IMAGE_JPX          0x3810
                             5823 ; 471  |
                             5824 ; 472  |/*
                             5825 ; 473  | * Property values definitions
                             5826 ; 474  | */
                             5827 ; 475  |
                             5828 ; 476  |/*
                             5829 ; 477  | * Property description data set form flags definitions
                             5830 ; 478  | */
                             5831 ; 479  |#define PTP_FORMFLAGS_NONE          0x00
                             5832 ; 480  |#define PTP_FORMFLAGS_RANGE         0x01
                             5833 ; 481  |#define PTP_FORMFLAGS_ENUM          0x02
                             5834 ; 482  |#define PTP_FORMFLAGS_DATETIME      0x03
                             5835 ; 483  |#define PTP_FORMFLAGS_FIXED         0x04
                             5836 ; 484  |#define PTP_FORMFLAGS_REGULAR_EXP   0x05
                             5837 ; 485  |#define PTP_FORMFLAGS_BYTE_ARRAY    0x06
                             5838 ; 486  |#define PTP_FORMFLAGS_LONG_STRING   0xff
                             5839 ; 487  |
                             5840 ; 488  |/*
                             5841 ; 489  | * power states:
                             5842 ; 490  | */
                             5843 ; 491  |#define PTP_POWERSTATE_DEVICEOFF     0x0000
                             5844 ; 492  |#define PTP_POWERSTATE_SLEEP         0x0001
                             5845 ; 493  |#define PTP_POWERSTATE_FULL          0x0002
                             5846 ; 494  |
                             5847 ; 495  |
                             5848 ; 496  |/*
                             5849 ; 497  | * white balances:
                             5850 ; 498  | */
                             5851 ; 499  |#define PTP_WHITEBALANCE_UNDEFINED     0x0000
                             5852 ; 500  |#define PTP_WHILEBALANCE_MANUAL        0x0001
                             5853 ; 501  |#define PTP_WHITEBALANCE_AUTOMATIC     0x0002
                             5854 ; 502  |#define PTP_WHITEBALANCE_ONEPUSHAUTO   0x0003
                             5855 ; 503  |#define PTP_WHITEBALANCE_DAYLIGHT      0x0004
                             5856 ; 504  |#define PTP_WHITEBALANCE_FLORESCENT    0x0005
                             5857 ; 505  |#define PTP_WHITEBALANCE_TUNGSTEN      0x0006
                             5858 ; 506  |#define PTP_WHITEBALANCE_FLASH         0x0007
                             5859 ; 507  |
                             5860 ; 508  |
                             5861 ; 509  |/*
                             5862 ; 510  | * focus modes:
                             5863 ; 511  | */
                             5864 ; 512  |#define PTP_FOCUSMODE_UNDEFINED   0x0000
                             5865 ; 513  |#define PTP_FOCUSMODE_MANUAL      0x0001
                             5866 ; 514  |#define PTP_FOCUSMODE_AUTO        0x0002
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  93

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5867 ; 515  |#define PTP_FOCUSMODE_MACRO       0x0003
                             5868 ; 516  |
                             5869 ; 517  |/*
                             5870 ; 518  | * focus metering:
                             5871 ; 519  | */
                             5872 ; 520  |#define  PTP_FOCUSMETERING_UNDEFINED      0x0000
                             5873 ; 521  |#define  PTP_FOCUSMETERING_CENTERSPOT     0x0001
                             5874 ; 522  |#define  PTP_FOCUSMETERING_MULTISPOT      0x0002
                             5875 ; 523  |
                             5876 ; 524  |/*
                             5877 ; 525  | * flash modes:
                             5878 ; 526  | */
                             5879 ; 527  |#define PTP_FLASHMODE_UNDEFINED       0x0000
                             5880 ; 528  |#define PTP_FLASHMODE_AUTO            0x0001
                             5881 ; 529  |#define PTP_FLASHMODE_OFF             0x0002
                             5882 ; 530  |#define PTP_FLASHMODE_FILL            0x0003
                             5883 ; 531  |#define PTP_FLASHMODE_REDEYEAUTO      0x0004
                             5884 ; 532  |#define PTP_FLASHMODE_REDEYEFILL      0x0005
                             5885 ; 533  |#define PTP_FLASHMODE_EXTERNALSYNC    0x0006
                             5886 ; 534  |#define PTP_FLASHMODE_MASK            0xFFF0
                             5887 ; 535  |
                             5888 ; 536  |/*
                             5889 ; 537  | * exposure modes:
                             5890 ; 538  | */
                             5891 ; 539  |#define PTP_EXPOSUREMODE_UNDEFINED             0x0000
                             5892 ; 540  |#define PTP_EXPOSUREMODE_MANUALSETTING         0x0001
                             5893 ; 541  |#define PTP_EXPOSUREMODE_AUTOPROGRAM           0x0002
                             5894 ; 542  |#define PTP_EXPOSUREMODE_APERTUREPRIORITY      0x0003
                             5895 ; 543  |#define PTP_EXPOSUREMODE_SHUTTERPRIORITY       0x0004
                             5896 ; 544  |#define PTP_EXPOSUREMODE_PROGRAMCREATIVE       0x0005
                             5897 ; 545  |#define PTP_EXPOSUREMODE_PROGRAMACTION         0x0006
                             5898 ; 546  |#define PTP_EXPOSUREMODE_PORTRAIT              0x0007
                             5899 ; 547  |
                             5900 ; 548  |/*
                             5901 ; 549  | * capturing modes:
                             5902 ; 550  | */
                             5903 ; 551  |#define  PTP_CAPTUREMODE_UNDEFINED      0x0000
                             5904 ; 552  |#define  PTP_CAPTUREMODE_NORMAL         0x0001
                             5905 ; 553  |#define  PTP_CAPTUREMODE_BURST          0x0002
                             5906 ; 554  |#define  PTP_CAPTUREMODE_TIMELAPSE      0x0003
                             5907 ; 555  |
                             5908 ; 556  |/*
                             5909 ; 557  | * focus metering modes:
                             5910 ; 558  | */
                             5911 ; 559  |#define  PTP_FOCUSMETERMODE_UNDEFINED   0x0000
                             5912 ; 560  |#define  PTP_FOCUSMETERMODE_CENTERSPOT  0x0001
                             5913 ; 561  |#define  PTP_FOCUSMETERMODE_MULTISPOT   0x0002
                             5914 ; 562  |
                             5915 ; 563  |
                             5916 ; 564  |/*
                             5917 ; 565  | * effect modes:
                             5918 ; 566  | */
                             5919 ; 567  |#define PTP_EFFECTMODE_UNDEFINED   0x0000
                             5920 ; 568  |#define PTP_EFFECTMODE_COLOR       0x0001
                             5921 ; 569  |#define PTP_EFFECTMODE_BW          0x0002
                             5922 ; 570  |#define PTP_EFFECTMODE_SEPIA       0x0003
                             5923 ; 571  |
                             5924 ; 572  |
                             5925 ; 573  |/*
                             5926 ; 574  | * storage types:
                             5927 ; 575  | */
                             5928 ; 576  |#define PTP_STORAGETYPE_UNDEFINED       0x0000
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  94

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5929 ; 577  |#define PTP_STORAGETYPE_FIXEDROM        0x0001
                             5930 ; 578  |#define PTP_STORAGETYPE_REMOVABLEROM    0x0002
                             5931 ; 579  |#define PTP_STORAGETYPE_FIXEDRAM        0x0003
                             5932 ; 580  |#define PTP_STORAGETYPE_REMOVABLERAM    0x0004
                             5933 ; 581  |
                             5934 ; 582  |/*
                             5935 ; 583  | * storage access capabilities:
                             5936 ; 584  | */
                             5937 ; 585  |#define PTP_STORAGEACCESS_RWD   0x0000
                             5938 ; 586  |#define PTP_STORAGEACCESS_R     0x0001
                             5939 ; 587  |#define PTP_STORAGEACCESS_RD    0x0002
                             5940 ; 588  |
                             5941 ; 589  |/*
                             5942 ; 590  | * association types:
                             5943 ; 591  | */
                             5944 ; 592  |#define PTP_ASSOCIATIONTYPE_UNDEFINED          0x0000
                             5945 ; 593  |#define PTP_ASSOCIATIONTYPE_FOLDER             0x0001
                             5946 ; 594  |#define PTP_ASSOCIATIONTYPE_ALBUM              0x0002
                             5947 ; 595  |#define PTP_ASSOCIATIONTYPE_BURST              0x0003
                             5948 ; 596  |#define PTP_ASSOCIATIONTYPE_HPANORAMA          0x0004
                             5949 ; 597  |#define PTP_ASSOCIATIONTYPE_VPANORAMA          0x0005
                             5950 ; 598  |#define PTP_ASSOCIATIONTYPE_2DPANORAMA         0x0006
                             5951 ; 599  |#define PTP_ASSOCIATIONTYPE_ANCILLARYDATA      0x0007
                             5952 ; 600  |#define PTP_ASSOCIATIONTYPE_MASK               0xFFF0
                             5953 ; 601  |
                             5954 ; 602  |/*
                             5955 ; 603  | * protection status:
                             5956 ; 604  | */
                             5957 ; 605  |#define PTP_PROTECTIONSTATUS_NONE          0x0000
                             5958 ; 606  |#define PTP_PROTECTIONSTATUS_READONLY      0x0001
                             5959 ; 607  |#define PTP_PROTECTIONSTATUS_READONLY_DATA 0x8002
                             5960 ; 608  |#define PTP_PROTECTIONSTATUS_NON_XFER      0x8003
                             5961 ; 609  |
                             5962 ; 610  |#define MTP_PROTECTIONSTATUS_NOPROTECTION       0x0000
                             5963 ; 611  |#define MTP_PROTECTIONSTATUS_READONLY           0x0001
                             5964 ; 612  |#define MTP_PROTECTIONSTATUS_READONLY_PERMANENT 0x0002
                             5965 ; 613  |#define MTP_PROTECTIONSTATUS_ABSTRACT_OBJECT    0x0003
                             5966 ; 614  |
                             5967 ; 615  |//
                             5968 ; 616  |// file system types:
                             5969 ; 617  |//
                             5970 ; 618  |#define PTP_FILESYSTEMTYPE_UNDEFINED       0x0000
                             5971 ; 619  |#define PTP_FILESYSTEMTYPE_FLAT            0x0001
                             5972 ; 620  |#define PTP_FILESYSTEMTYPE_HIERARCHICAL    0x0002
                             5973 ; 621  |#define PTP_FILESYSTEMTYPE_DCF             0x0003
                             5974 ; 622  |
                             5975 ; 623  |/*
                             5976 ; 624  | * functional modes:
                             5977 ; 625  | */
                             5978 ; 626  |#define  PTP_FUNCTIONMODE_STDANDARD    0x0000
                             5979 ; 627  |#define  PTP_FUNCTIONMODE_SLEEP        0x0001
                             5980 ; 628  |
                             5981 ; 629  |/*
                             5982 ; 630  | * Get/Set
                             5983 ; 631  | */
                             5984 ; 632  |#define  PTP_PROPGETSET_GETONLY    0x00
                             5985 ; 633  |#define  PTP_PROPGETSET_GETSET     0x01
                             5986 ; 634  |
                             5987 ; 635  |//
                             5988 ; 636  |// Common Audio Sample Rate
                             5989 ; 637  |//
                             5990 ; 638  |#define MTP_AUDIO_SAMPLERATE_32K        32000
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  95

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5991 ; 639  |#define MTP_AUDIO_SAMPLERATE_CD         44100
                             5992 ; 640  |#define MTP_AUDIO_SAMPLERATE_48K        48000
                             5993 ; 641  |#define MTP_AUDIO_SAMPLERATE_DVD        96000
                             5994 ; 642  |
                             5995 ; 643  |//
                             5996 ; 644  |// Common Audio Bit Rate
                             5997 ; 645  |//
                             5998 ; 646  |#define MTP_AUDIO_BITRATE_GSM           13000
                             5999 ; 647  |#define MTP_AUDIO_BITRATE_G721          32000
                             6000 ; 648  |#define MTP_AUDIO_BITRATE_G711          64000
                             6001 ; 649  |#define MTP_AUDIO_BITRATE_128K          128000
                             6002 ; 650  |#define MTP_AUDIO_BITRATE_CDDA          144100
                             6003 ; 651  |#define MTP_AUDIO_BITRATE_160K          160000
                             6004 ; 652  |#define MTP_AUDIO_BITRATE_192K          192000
                             6005 ; 653  |#define MTP_AUDIO_BITRATE_256K          256000
                             6006 ; 654  |#define MTP_AUDIO_BITRATE_STUDIO        384000
                             6007 ; 655  |
                             6008 ; 656  |//
                             6009 ; 657  |// Common Metagenre defined
                             6010 ; 658  |//
                             6011 ; 659  |#define MTP_METAGENRE_NOT_USED                          0x0000
                             6012 ; 660  |#define MTP_METAGENRE_GENERIC_MUSIC_AUDIO_FILE          0x0001
                             6013 ; 661  |#define MTP_METAGENRE_GENERIC_NONMUSIC_AUDIO_FILE       0x0011
                             6014 ; 662  |#define MTP_METAGENRE_SPOKEN_WORD_AUDIO_BOOK_FILES      0x0012
                             6015 ; 663  |#define MTP_METAGENRE_SPOKEN_WORD_NONAUDIO_BOOK_FILES   0x0013
                             6016 ; 664  |#define MTP_METAGENRE_SPOKEN_WORD_NEWS                  0x0014
                             6017 ; 665  |#define MTP_METAGENRE_SPOKEN_WORD_TALK_SHOWS            0x0015
                             6018 ; 666  |#define MTP_METAGENRE_GENERIC_VIDEO_FILE                0x0021
                             6019 ; 667  |#define MTP_METAGENRE_NEWS_VIDEO_FILE                   0x0022
                             6020 ; 668  |#define MTP_METAGENRE_MUSIC_VIDEO_FILE                  0x0023
                             6021 ; 669  |#define MTP_METAGENRE_HOME_VIDEO_FILE                   0x0024
                             6022 ; 670  |#define MTP_METAGENRE_FEATURE_FILM_VIDEO_FILE           0x0025
                             6023 ; 671  |#define MTP_METAGENRE_TV_SHOW_VIDEO_FILE                0x0026
                             6024 ; 672  |#define MTP_METAGENRE_TRAINING_VIDEO_FILE               0x0027
                             6025 ; 673  |#define MTP_METAGENRE_PHOTO_MONTAGE_VIDEO_FILE          0x0028
                             6026 ; 674  |#define MTP_METAGENRE_GENERIC_NONAUDIO_NONVIDEO_FILE    0x0030
                             6027 ; 675  |#define MTP_METAGENRE_VENDOR_DEFINED_MASK               0x8000
                             6028 ; 676  |
                             6029 ; 677  |//
                             6030 ; 678  |// Common NumberOfChannels defined
                             6031 ; 679  |//
                             6032 ; 680  |#define MTP_CHANNELS_NOT_USED                           0x0000
                             6033 ; 681  |#define MTP_CHANNELS_MONO                               0x0001
                             6034 ; 682  |#define MTP_CHANNELS_STEREO                             0x0002
                             6035 ; 683  |#define MTP_CHANNELS_2DOT1                              0x0003
                             6036 ; 684  |#define MTP_CHANNELS_3                                  0x0004
                             6037 ; 685  |#define MTP_CHANNELS_3DOT1                              0x0005
                             6038 ; 686  |#define MTP_CHANNELS_4                                  0x0006
                             6039 ; 687  |#define MTP_CHANNELS_4DOT1                              0x0007
                             6040 ; 688  |#define MTP_CHANNELS_5                                  0x0008
                             6041 ; 689  |#define MTP_CHANNELS_5DOT1                              0x0009
                             6042 ; 690  |#define MTP_CHANNELS_6                                  0x000A
                             6043 ; 691  |#define MTP_CHANNELS_6DOT1                              0x000B
                             6044 ; 692  |#define MTP_CHANNELS_7                                  0x000C
                             6045 ; 693  |#define MTP_CHANNELS_7DOT1                              0x000D
                             6046 ; 694  |#define MTP_CHANNELS_8                                  0x000E
                             6047 ; 695  |#define MTP_CHANNELS_8DOT1                              0x000F
                             6048 ; 696  |#define MTP_CHANNELS_9                                  0x0010
                             6049 ; 697  |#define MTP_CHANNELS_9DOT1                              0x0011
                             6050 ; 698  |
                             6051 ; 699  |/*
                             6052 ; 700  | * Every structure must be packed on byte boundary
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  96

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6053 ; 701  | */
                             6054 ; 702  |
                             6055 ; 703  |/**
                             6056 ; 704  | * USB Setup Data Packet
                             6057 ; 705  | *
                             6058 ; 706  | * BYTE bmRequestType:
                             6059 ; 707  | *  ---------------------------------
                             6060 ; 708  | *  | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
                             6061 ; 709  | *  ---------------------------------
                             6062 ; 710  | *  0-4 - Recipient Value.
                             6063 ; 711  | *          0 = Device
                             6064 ; 712  | *          1 = Interface
                             6065 ; 713  | *          2 = Endpoint
                             6066 ; 714  | *          3 = Other
                             6067 ; 715  | *          4-31 = Reserved
                             6068 ; 716  | *  5-6 - Type
                             6069 ; 717  | *          0 = Standard
                             6070 ; 718  | *          1 = Class
                             6071 ; 719  | *          2 = Vendor
                             6072 ; 720  | *          3 = Reserved
                             6073 ; 721  | *  7 - Data transfer direction
                             6074 ; 722  | *          0 = Host-to-device
                             6075 ; 723  | *          1 = Device-to-host
                             6076 ; 724  | *
                             6077 ; 725  | * BYTE bRequest:
                             6078 ; 726  | *  Specific request (refer to Table 9-3).
                             6079 ; 727  | *
                             6080 ; 728  | * WORD wValue:
                             6081 ; 729  | *  Varies according to request type.
                             6082 ; 730  | *
                             6083 ; 731  | * WORD wIndex:
                             6084 ; 732  | *  Varies according to request, but is typically used as a index or offset.
                             6085 ; 733  | *
                             6086 ; 734  | * WORD wLength:
                             6087 ; 735  | *  Number of bytes to transfer if there is a data stage.
                             6088 ; 736  | */
                             6089 ; 737  |typedef struct tagUsbSetupData
                             6090 ; 738  |{
                             6091 ; 739  |    BYTE    bmRequestType;
                             6092 ; 740  |    BYTE    bRequest;
                             6093 ; 741  |    UINT16    wValue;
                             6094 ; 742  |    UINT16    wIndex;
                             6095 ; 743  |    UINT16    wLength;
                             6096 ; 744  |} USB_SETUP_DATA, *PUSB_SETUP_DATA;
                             6097 ; 745  |
                             6098 ; 746  |/*
                             6099 ; 747  | * USB class-specific requests
                             6100 ; 748  | */
                             6101 ; 749  |#define USB_PTPREQUEST_TYPE_OUT   0x21    /* Host to Device */
                             6102 ; 750  |#define USB_PTPREQUEST_TYPE_IN    0xA1    /* Device to Host */
                             6103 ; 751  |#define USB_PTPREQUEST_CANCELIO   0x64    /* Cancel request */
                             6104 ; 752  |#define USB_PTPREQUEST_GETEVENT   0x65    /* Get extened event data */
                             6105 ; 753  |#define USB_PTPREQUEST_RESET      0x66    /* Reset Device */
                             6106 ; 754  |#define USB_PTPREQUEST_GETSTATUS  0x67    /* Get Device Status */
                             6107 ; 755  |
                             6108 ; 756  |#define USB_PTPCANCELIO_ID   0x4001
                             6109 ; 757  |
                             6110 ; 758  |/**
                             6111 ; 759  | * PTP Cancellation Request
                             6112 ; 760  | *
                             6113 ; 761  | * WORD wCancelIOCode:
                             6114 ; 762  | *  Identifier for cancellation.  This must equal USB_PTPCANCELIO_ID.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  97

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6115 ; 763  | *
                             6116 ; 764  | * UINT32 TransactionId:
                             6117 ; 765  | *  Transaction to cancel.
                             6118 ; 766  | */
                             6119 ; 767  |typedef struct tagCancelReqData
                             6120 ; 768  |{
                             6121 ; 769  |    UINT16 wCancelIOCode;       //Identifier for cancellation.  This must equal USB_PTPCAN
                                  CELIO_ID
                             6122 ; 770  |    UINT32 TransactionId;       //Transaction to cancel.
                             6123 ; 771  |} USB_PTP_CANCELREQ_DATA, *PUSB_PTP_CANCELREQ_DATA;
                             6124 ; 772  |
                             6125 ; 773  |/*
                             6126 ; 774  | * PTP Cancellation Request
                             6127 ; 775  | *
                             6128 ; 776  | * WORD wLength:
                             6129 ; 777  | *  Total length of the status data.
                             6130 ; 778  | *
                             6131 ; 779  | * WORD Code:
                             6132 ; 780  | *  Response code.
                             6133 ; 781  | *
                             6134 ; 782  | * UINT32 Params.
                             6135 ; 783  | *  Params depends on the status code.
                             6136 ; 784  | */
                             6137 ; 785  |
                             6138 ; 786  |typedef struct tagStatusReqData
                             6139 ; 787  |{
                             6140 ; 788  |    UINT16    wLength;          //Total length of the status data
                             6141 ; 789  |    UINT16    Code;                     //Response code
                             6142 ; 790  |//    UINT16   Params[1];       //Params depends on the status code
                             6143 ; 791  |    UINT16   Params[2];         //Params depends on the status code
                             6144 ; 792  |} USB_PTP_STATUSREQ_DATA, *PUSB_PTP_STATUSREQ_DATA;
                             6145 ; 793  |
                             6146 ; 794  |
                             6147 ; 795  |
                             6148 ; 796  |/*
                             6149 ; 797  | * Every structure must be packed on byte boundary
                             6150 ; 798  | */
                             6151 ; 799  |
                             6152 ; 800  |typedef enum eContainerType
                             6153 ; 801  |{
                             6154 ; 802  |  Undefined = 0x00,
                             6155 ; 803  |  CommandBlock = 0x01,
                             6156 ; 804  |  DataBlock = 0x02,
                             6157 ; 805  |  ResponseBlock = 0x03,
                             6158 ; 806  |  EventBlock = 0x04
                             6159 ; 807  |} ContainerType;
                             6160 ; 808  |
                             6161 ; 809  |#define MAX_MTP_PARAMS 5
                             6162 ; 810  |#define MAX_MTP_EVENT_PARAMS 1
                             6163 ; 811  |#define SIZE_IN_BYTES_Usb_Container_Header 12
                             6164 ; 812  |#define SIZE_IN_WORDS_Usb_Container_Header 4
                             6165 ; 813  |#define MAX_SIZE_IN_BYTES_Usb_Container SIZE_IN_BYTES_Usb_Container_Header + (4*MAX_MTP_PA
                                  RAMS)
                             6166 ; 814  |#define SIZE_IN_BYTES_Usb_Event_Container SIZE_IN_BYTES_Usb_Container_Header + (4*MAX_MTP_
                                  EVENT_PARAMS)
                             6167 ; 815  |
                             6168 ; 816  |typedef struct sUsbGenericContainerHeader
                             6169 ; 817  |{
                             6170 ; 818  |  UINT32 Length;         /* the valid size, in BYTES, of the container  */
                             6171 ; 819  |  UINT16 Type;           /* Container type */
                             6172 ; 820  |  UINT16 Code;           /* Operation code, response code, or Event code */
                             6173 ; 821  |  UINT32 TransactionID;  /* host generated number */
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  98

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6174 ; 822  |} UsbGenericContainerHeader;
                             6175 ; 823  |
                             6176 ; 824  |typedef struct sUsbGenericContainer
                             6177 ; 825  |{
                             6178 ; 826  |  UINT32 Length;         /* the valid size, in BYTES, of the container */
                             6179 ; 827  |  UINT16 Type;           /* Container type */
                             6180 ; 828  |  UINT16 Code;           /* Operation code, response code, or Event code */
                             6181 ; 829  |  UINT32 TransactionID;  /* host generated number */
                             6182 ; 830  |  UINT32 Params[MAX_MTP_PARAMS];
                             6183 ; 831  |  UINT32 NumParams;
                             6184 ; 832  |} UsbGenericContainer;
                             6185 ; 833  |
                             6186 ; 834  |
                             6187 ; 835  |typedef struct sUsbDataContainer
                             6188 ; 836  |{
                             6189 ; 837  |  UINT32 Length;         /* the valid size, in BYTES, of the container */
                             6190 ; 838  |  UINT16 Type;           /* Container type */
                             6191 ; 839  |  UINT16 Code;           /* Operation code, response code, or Event code */
                             6192 ; 840  |  UINT32 TransactionID;  /* host generated number */
                             6193 ; 841  |  UINT32 Params[MAX_MTP_PARAMS];
                             6194 ; 842  |  UINT32 NumParams;
                             6195 ; 843  |  BYTE *pData;
                             6196 ; 844  |} UsbDataContainer;
                             6197 
                             6207 
                             6208 ; 845  |
                             6209 ; 846  |typedef UsbGenericContainer SUsbCmdBlock;
                             6210 ; 847  |typedef UsbGenericContainer SUsbResponseBlock;
                             6211 
                             6223 
                             6224 ; 848  |typedef UsbDataContainer    SUsbDataBlock;
                             6225 ; 849  |
                             6226 ; 850  |#endif
                             6227 ; 851  |
                             6228 
                             6230 
                             6231 ; 35   |#include "ptpstring.h"
                             6232 
                             6234 
                             6235 ; 1    |/**
                             6236 ; 2    |***
                             6237 ; 3    |*** Filename: ptpstring.h
                             6238 ; 4    |*** Description: PTP string and array function prototypes
                             6239 ; 5    |***
                             6240 ; 6    |***
                             6241 ; 7    |*** Copyright (c) SigmaTel, Inc. Unpublished
                             6242 ; 8    |***
                             6243 ; 9    |*** SigmaTel, Inc.
                             6244 ; 10   |*** Proprietary & Confidential
                             6245 ; 11   |***
                             6246 ; 12   |*** This source code and the algorithms implemented therein constitute
                             6247 ; 13   |*** confidential information and may comprise trade secrets of SigmaTel, Inc.
                             6248 ; 14   |*** or its associates, and any use thereof is subject to the terms and
                             6249 ; 15   |*** conditions of the Confidential Disclosure Agreement pursuant to which this
                             6250 ; 16   |*** source code was originally received.
                             6251 ; 17   |**/
                             6252 ; 18   |//////////////////////////////////////////////////////////////////
                             6253 ; 19   |// Copyright  Microsoft Corporation, 2003
                             6254 ; 20   |//////////////////////////////////////////////////////////////////
                             6255 ; 21   |
                             6256 ; 22   |//////////////////////////////////////////////////////////////////
                             6257 ; 23   |//   Includes
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  99

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6258 ; 24   |//////////////////////////////////////////////////////////////////
                             6259 ; 25   |#ifndef __PTPSTRING_H_INCLUDED
                             6260 ; 26   |#define __PTPSTRING_H_INCLUDED
                             6261 ; 27   |
                             6262 ; 28   |#include "types.h"
                             6263 
                             6265 
                             6266 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             6267 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             6268 ; 3    |//
                             6269 ; 4    |// Filename: types.h
                             6270 ; 5    |// Description: Standard data types
                             6271 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             6272 ; 7    |
                             6273 ; 8    |#ifndef _TYPES_H
                             6274 ; 9    |#define _TYPES_H
                             6275 ; 10   |
                             6276 ; 11   |// TODO:  move this outta here!
                             6277 ; 12   |#if !defined(NOERROR)
                             6278 ; 13   |#define NOERROR 0
                             6279 ; 14   |#define SUCCESS 0
                             6280 ; 15   |#endif 
                             6281 ; 16   |#if !defined(SUCCESS)
                             6282 ; 17   |#define SUCCESS  0
                             6283 ; 18   |#endif
                             6284 ; 19   |#if !defined(ERROR)
                             6285 ; 20   |#define ERROR   -1
                             6286 ; 21   |#endif
                             6287 ; 22   |#if !defined(FALSE)
                             6288 ; 23   |#define FALSE 0
                             6289 ; 24   |#endif
                             6290 ; 25   |#if !defined(TRUE)
                             6291 ; 26   |#define TRUE  1
                             6292 ; 27   |#endif
                             6293 ; 28   |
                             6294 ; 29   |#if !defined(NULL)
                             6295 ; 30   |#define NULL 0
                             6296 ; 31   |#endif
                             6297 ; 32   |
                             6298 ; 33   |#define MAX_INT     0x7FFFFF
                             6299 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             6300 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             6301 ; 36   |#define MAX_ULONG   (-1) 
                             6302 ; 37   |
                             6303 ; 38   |#define WORD_SIZE   24              // word size in bits
                             6304 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             6305 ; 40   |
                             6306 ; 41   |
                             6307 ; 42   |#define BYTE    unsigned char       // btVarName
                             6308 ; 43   |#define CHAR    signed char         // cVarName
                             6309 ; 44   |#define USHORT  unsigned short      // usVarName
                             6310 ; 45   |#define SHORT   unsigned short      // sVarName
                             6311 ; 46   |#define WORD    unsigned int        // wVarName
                             6312 ; 47   |#define INT     signed int          // iVarName
                             6313 ; 48   |#define DWORD   unsigned long       // dwVarName
                             6314 ; 49   |#define LONG    signed long         // lVarName
                             6315 ; 50   |#define BOOL    unsigned int        // bVarName
                             6316 ; 51   |#define FRACT   _fract              // frVarName
                             6317 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             6318 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             6319 ; 54   |#define FLOAT   float               // fVarName
                             6320 ; 55   |#define DBL     double              // dVarName
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 100

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6321 ; 56   |#define ENUM    enum                // eVarName
                             6322 ; 57   |#define CMX     _complex            // cmxVarName
                             6323 ; 58   |typedef WORD UCS3;                   // 
                             6324 ; 59   |
                             6325 ; 60   |#define UINT16  unsigned short
                             6326 ; 61   |#define UINT8   unsigned char   
                             6327 ; 62   |#define UINT32  unsigned long
                             6328 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             6329 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             6330 ; 65   |#define WCHAR   UINT16
                             6331 ; 66   |
                             6332 ; 67   |//UINT128 is 16 bytes or 6 words
                             6333 ; 68   |typedef struct UINT128_3500 {   
                             6334 ; 69   |    int val[6];     
                             6335 ; 70   |} UINT128_3500;
                             6336 ; 71   |
                             6337 ; 72   |#define UINT128   UINT128_3500
                             6338 ; 73   |
                             6339 ; 74   |// Little endian word packed byte strings:   
                             6340 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             6341 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             6342 ; 77   |// Little endian word packed byte strings:   
                             6343 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             6344 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             6345 ; 80   |
                             6346 ; 81   |// Declare Memory Spaces To Use When Coding
                             6347 ; 82   |// A. Sector Buffers
                             6348 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             6349 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             6350 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             6351 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             6352 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             6353 ; 88   |// B. Media DDI Memory
                             6354 ; 89   |#define MEDIA_DDI_MEM _Y
                             6355 ; 90   |
                             6356 ; 91   |
                             6357 ; 92   |
                             6358 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             6359 ; 94   |// Examples of circular pointers:
                             6360 ; 95   |//    INT CIRC cpiVarName
                             6361 ; 96   |//    DWORD CIRC cpdwVarName
                             6362 ; 97   |
                             6363 ; 98   |#define RETCODE INT                 // rcVarName
                             6364 ; 99   |
                             6365 ; 100  |// generic bitfield structure
                             6366 ; 101  |struct Bitfield {
                             6367 ; 102  |    unsigned int B0  :1;
                             6368 ; 103  |    unsigned int B1  :1;
                             6369 ; 104  |    unsigned int B2  :1;
                             6370 ; 105  |    unsigned int B3  :1;
                             6371 ; 106  |    unsigned int B4  :1;
                             6372 ; 107  |    unsigned int B5  :1;
                             6373 ; 108  |    unsigned int B6  :1;
                             6374 ; 109  |    unsigned int B7  :1;
                             6375 ; 110  |    unsigned int B8  :1;
                             6376 ; 111  |    unsigned int B9  :1;
                             6377 ; 112  |    unsigned int B10 :1;
                             6378 ; 113  |    unsigned int B11 :1;
                             6379 ; 114  |    unsigned int B12 :1;
                             6380 ; 115  |    unsigned int B13 :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 101

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6381 ; 116  |    unsigned int B14 :1;
                             6382 ; 117  |    unsigned int B15 :1;
                             6383 ; 118  |    unsigned int B16 :1;
                             6384 ; 119  |    unsigned int B17 :1;
                             6385 ; 120  |    unsigned int B18 :1;
                             6386 ; 121  |    unsigned int B19 :1;
                             6387 ; 122  |    unsigned int B20 :1;
                             6388 ; 123  |    unsigned int B21 :1;
                             6389 ; 124  |    unsigned int B22 :1;
                             6390 ; 125  |    unsigned int B23 :1;
                             6391 ; 126  |};
                             6392 ; 127  |
                             6393 ; 128  |union BitInt {
                             6394 ; 129  |        struct Bitfield B;
                             6395 ; 130  |        int        I;
                             6396 ; 131  |};
                             6397 ; 132  |
                             6398 ; 133  |#define MAX_MSG_LENGTH 10
                             6399 ; 134  |struct CMessage
                             6400 ; 135  |{
                             6401 ; 136  |        unsigned int m_uLength;
                             6402 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             6403 ; 138  |};
                             6404 ; 139  |
                             6405 ; 140  |typedef struct {
                             6406 ; 141  |    WORD m_wLength;
                             6407 ; 142  |    WORD m_wMessage;
                             6408 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             6409 ; 144  |} Message;
                             6410 ; 145  |
                             6411 ; 146  |struct MessageQueueDescriptor
                             6412 ; 147  |{
                             6413 ; 148  |        int *m_pBase;
                             6414 ; 149  |        int m_iModulo;
                             6415 ; 150  |        int m_iSize;
                             6416 ; 151  |        int *m_pHead;
                             6417 ; 152  |        int *m_pTail;
                             6418 ; 153  |};
                             6419 ; 154  |
                             6420 ; 155  |struct ModuleEntry
                             6421 ; 156  |{
                             6422 ; 157  |    int m_iSignaledEventMask;
                             6423 ; 158  |    int m_iWaitEventMask;
                             6424 ; 159  |    int m_iResourceOfCode;
                             6425 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             6426 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                             6427 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             6428 ; 163  |    int m_uTimeOutHigh;
                             6429 ; 164  |    int m_uTimeOutLow;
                             6430 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             6431 ; 166  |};
                             6432 ; 167  |
                             6433 ; 168  |union WaitMask{
                             6434 ; 169  |    struct B{
                             6435 ; 170  |        unsigned int m_bNone     :1;
                             6436 ; 171  |        unsigned int m_bMessage  :1;
                             6437 ; 172  |        unsigned int m_bTimer    :1;
                             6438 ; 173  |        unsigned int m_bButton   :1;
                             6439 ; 174  |    } B;
                             6440 ; 175  |    int I;
                             6441 ; 176  |} ;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 102

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6442 ; 177  |
                             6443 ; 178  |
                             6444 ; 179  |struct Button {
                             6445 ; 180  |        WORD wButtonEvent;
                             6446 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             6447 ; 182  |};
                             6448 ; 183  |
                             6449 ; 184  |struct Message {
                             6450 ; 185  |        WORD wMsgLength;
                             6451 ; 186  |        WORD wMsgCommand;
                             6452 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             6453 ; 188  |};
                             6454 ; 189  |
                             6455 ; 190  |union EventTypes {
                             6456 ; 191  |        struct CMessage msg;
                             6457 ; 192  |        struct Button Button ;
                             6458 ; 193  |        struct Message Message;
                             6459 ; 194  |};
                             6460 ; 195  |
                             6461 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             6462 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             6463 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             6464 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             6465 ; 200  |
                             6466 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             6467 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             6468 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             6469 ; 204  |
                             6470 ; 205  |#if DEBUG
                             6471 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             6472 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             6473 ; 208  |#else 
                             6474 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                             6475 ; 210  |#define DebugBuildAssert(x)    
                             6476 ; 211  |#endif
                             6477 ; 212  |
                             6478 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             6479 ; 214  |//  #pragma asm
                             6480 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             6481 ; 216  |//  #pragma endasm
                             6482 ; 217  |
                             6483 ; 218  |
                             6484 ; 219  |#ifdef COLOR_262K
                             6485 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                             6486 ; 221  |#elif defined(COLOR_65K)
                             6487 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                             6488 ; 223  |#else
                             6489 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                             6490 ; 225  |#endif
                             6491 ; 226  |    
                             6492 ; 227  |#endif // #ifndef _TYPES_H
                             6493 
                             6495 
                             6496 ; 29   |/*****************************************************************************
                             6497 ; 30   | * Defines the PTP string structure
                             6498 ; 31   | *****************************************************************************/
                             6499 ; 32   |
                             6500 ; 33   |#define MAX_PTP_STRING_CHARS        256
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 103

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6501 ; 34   |#define MAX_PTP_SHORT_STRING_CHARS   32 
                             6502 ; 35   |
                             6503 ; 36   |typedef enum _STRING_TYPE {
                             6504 ; 37   |    SHORT_STRING,
                             6505 ; 38   |    LONG_STRING
                             6506 ; 39   |} STRING_TYPE;
                             6507 ; 40   |
                             6508 ; 41   |typedef struct SPtpString
                             6509 ; 42   |{
                             6510 ; 43   |  INT  NumChars; /* Number of chars in the string (including the NULL) */
                             6511 ; 44   |  WCHAR StringChars[MAX_PTP_STRING_CHARS];  /* Holds actual Unicode string with 2 bytes ch
                                  aracters, NULL-terminated */
                             6512 ; 45   |} SPtpString;
                             6513 ; 46   |
                             6514 ; 47   |//
                             6515 ; 48   |// This is needed becuase you cannot do sizeof(SPtpString) to check the size of
                             6516 ; 49   |// this structure during preprocessor run.
                             6517 ; 50   |//
                             6518 ; 51   |#define SPTPSTRING_SIZE (MAX_PTP_STRING_CHARS + 1)
                             6519 ; 52   |
                             6520 ; 53   |typedef struct SPtpShortString
                             6521 ; 54   |{
                             6522 ; 55   |  INT  NumChars; /* Number of chars in the string (including the NULL) */
                             6523 ; 56   |  WCHAR StringChars[MAX_PTP_SHORT_STRING_CHARS];  /* Holds actual Unicode string with 2 by
                                  tes characters, NULL-terminated */
                             6524 ; 57   |} SPtpShortString;
                             6525 ; 58   |
                             6526 ; 59   |// from time.h
                             6527 ; 60   |struct tm
                             6528 ; 61   |{
                             6529 ; 62   |  int   tm_sec;         /* seconds after the minute - [0, 59]   */
                             6530 ; 63   |  int   tm_min;         /* minutes after the hour - [0, 59]     */
                             6531 ; 64   |  int   tm_hour;        /* hours since midnight - [0, 23]       */
                             6532 ; 65   |  int   tm_mday;        /* day of the month - [1, 31]           */
                             6533 ; 66   |  int   tm_mon;         /* months since January - [0, 11]       */
                             6534 ; 67   |  int   tm_year;        /* year since 1900                      */
                             6535 ; 68   |  int   tm_wday;        /* days since Sunday - [0, 6]           */
                             6536 ; 69   |  int   tm_yday;        /* days since January 1 - [0, 365]      */
                             6537 ; 70   |  int   tm_isdst;       /* Daylight Saving Time flag            */
                             6538 ; 71   |};
                             6539 
                             6545 
                             6546 ; 72   |/**
                             6547 ; 73   | * Initializes the PTP string by zeroing out the string.
                             6548 ; 74   | */
                             6549 ; 75   |void initPtpString(SPtpString * pString);
                             6550 ; 76   |
                             6551 ; 77   |
                             6552 ; 78   |/**
                             6553 ; 79   | * Deallocates the memory for the PtpString structure
                             6554 ; 80   | */
                             6555 ; 81   |void destroyPtpString(SPtpString *pString);
                             6556 ; 82   |
                             6557 ; 83   |/**
                             6558 ; 84   | * Copies the pStr into the PtpString structure.  The size parameter indicates
                             6559 ; 85   | * if the pStr is composed of 8-bit characters or 16-bit characters.
                             6560 ; 86   | */
                             6561 ; 87   |_reentrant void initChar2PtpString(SPtpString *pString, void * pStr, UINT16 word_size, STR
                                  ING_TYPE _type);
                             6562 
                             6567 
                             6568 ; 88   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 104

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6569 ; 89   |/**
                             6570 ; 90   | * Concatenates the pStr into the PtpString structure.  The size parameter indicates
                             6571 ; 91   | * if the pStr is composed of 8-bit characters or 16-bit characters.
                             6572 ; 92   | */
                             6573 ; 93   |_reentrant void catChar2PtpString(SPtpString *pString, void * pStr, UINT16 word_size, STRI
                                  NG_TYPE _type);
                             6574 ; 94   |
                             6575 ; 95   |/**
                             6576 ; 96   | * Concatenates the two PtpString structures into the first.
                             6577 ; 97   | */
                             6578 ; 98   |_reentrant void catPtpString(SPtpString *pDstString, SPtpString *pSrcString, STRING_TYPE _
                                  type);
                             6579 
                             6585 
                             6586 ; 99   |
                             6587 ; 100  |/**
                             6588 ; 101  | * Copies the time set by lpTime and converts it to a PTP String.
                             6589 ; 102  | */
                             6590 ; 103  |_reentrant void initTime2PtpString(SPtpShortString *pString, struct tm *lTime);
                             6591 ; 104  |
                             6592 ; 105  |/**
                             6593 ; 106  | * extracts time from PtpString and stores it in time object.
                             6594 ; 107  | */
                             6595 ; 108  |_reentrant void initPtpString2Time(SPtpShortString *pString, struct tm *lTime);
                             6596 ; 109  |
                             6597 ; 110  |/**
                             6598 ; 111  | * extracts number from string.
                             6599 ; 112  | */
                             6600 ; 113  |_reentrant void MtpExtractNumberFromPtpString( WCHAR *pUnicodeString, INT iDigits, INT iOf
                                  fset, INT * iNumber);
                             6601 ; 114  |
                             6602 ; 115  |/**
                             6603 ; 116  |* Converts the number to PtpString
                             6604 ; 117  |*/
                             6605 ; 118  |_reentrant void MtpStringPrintNumber(WCHAR *pUnicodeString,INT iNumber, INT iDigits, INT i
                                  Filler);
                             6606 ; 119  |
                             6607 ; 120  |/**
                             6608 ; 121  | * Copies one string into another.
                             6609 ; 122  | */
                             6610 ; 123  |_reentrant void copyPtpString(SPtpString *pDst, SPtpString *pSrc);
                             6611 ; 124  |
                             6612 ; 125  |/* copy Ptpstring in _X memory; usually in raw data from host */
                             6613 ; 126  |_reentrant void copy_XPtpString(SPtpString *pDst, void _X *pSrc, UINT16 *byteOffset);
                             6614 ; 127  |
                             6615 ; 128  |/**
                             6616 ; 129  | * Copies the void * pSrc string to the PTP string pDst.
                             6617 ; 130  | */
                             6618 ; 131  |_reentrant void copyChar2PtpString(SPtpString *pDst, void *pSrc);
                             6619 ; 132  |
                             6620 ; 133  |/**
                             6621 ; 134  | * Checks to see if two different PTP strings are equal.
                             6622 ; 135  | */
                             6623 ; 136  |_reentrant BOOL isEqualPtpString(SPtpString *pDst, SPtpString *pSrc);
                             6624 ; 137  |
                             6625 ; 138  |/**
                             6626 ; 139  | * Returns the size in bytes of the PTP string.
                             6627 ; 140  | */
                             6628 ; 141  |UINT32 sizeInBytesPtpString(SPtpString *pString);
                             6629 ; 142  |    
                             6630 ; 143  |
                             6631 ; 144  |/**
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 105

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6632 ; 145  | * packs the PTP string into a packed char string
                             6633 ; 146  | */
                             6634 ; 147  |_reentrant UINT16 copyPtpToPackedString (_packed char *packedStr, SPtpString *pPtpStr);
                             6635 ; 148  |
                             6636 ; 149  |/**
                             6637 ; 150  | * copies packed string into PTP string
                             6638 ; 151  | */
                             6639 ; 152  |_reentrant UINT16 copyPackedToPtpString (_packed char *packedStr, SPtpString *pPtpStr);
                             6640 ; 153  |
                             6641 ; 154  |
                             6642 ; 155  |/*****************************************************************************
                             6643 ; 156  | * Defines the PTP array structure
                             6644 ; 157  | *****************************************************************************/
                             6645 ; 158  |    
                             6646 ; 159  |#define ELEMENT_NOT_FOUND   -1
                             6647 ; 160  |#define INITIAL_ARRAY_SIZE  20
                             6648 ; 161  |
                             6649 ; 162  |typedef enum DATATYPE
                             6650 ; 163  |{
                             6651 ; 164  |  UINT8_TYPE,
                             6652 ; 165  |  UINT16_TYPE,
                             6653 ; 166  |  UINT32_TYPE
                             6654 ; 167  |} DATATYPE;
                             6655 
                             6661 
                             6662 ; 168  |
                             6663 ; 169  |typedef struct SPtpArray
                             6664 ; 170  |{
                             6665 ; 171  |  DATATYPE type;
                             6666 ; 172  |  UINT32 ArraySize;
                             6667 ; 173  |  UINT32 NumElements;
                             6668 ; 174  |  UINT32 *ArrayEntry;
                             6669 ; 175  |} SPtpArray;
                             6670 
                             6679 
                             6680 ; 176  |
                             6681 ; 177  |
                             6682 ; 178  |/**
                             6683 ; 179  | * Initializes the PTP array with the type and the default
                             6684 ; 180  | * array size.
                             6685 ; 181  | */
                             6686 ; 182  |_reentrant void initPtpArray(SPtpArray *pArray, DATATYPE type, UINT32 arraySize, UINT32 *p
                                  ActualArray);
                             6687 ; 183  |
                             6688 ; 184  |/**
                             6689 ; 185  | * Returns the size in bytes of the PTP array structure and data.
                             6690 ; 186  | */
                             6691 ; 187  |_reentrant UINT32 sizeInBytesPtpArray(SPtpArray *pArray);
                             6692 ; 188  |
                             6693 ; 189  |
                             6694 ; 190  |/**
                             6695 ; 191  | * Finds and returns the index of the desired element.
                             6696 ; 192  | */
                             6697 ; 193  |_reentrant UINT32 findElementPtpArray(SPtpArray *pArray, UINT32 element);
                             6698 ; 194  |
                             6699 ; 195  |/**
                             6700 ; 196  | * Appends the desired element to the end of the array.
                             6701 ; 197  | */
                             6702 ; 198  |_reentrant BOOL appendElementPtpArray(SPtpArray *pArray, UINT32 element);
                             6703 ; 199  |
                             6704 ; 200  |/**
                             6705 ; 201  | * Removes the specified element from the array.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 106

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6706 ; 202  | */
                             6707 ; 203  |_reentrant BOOL removeElementPtpArray(SPtpArray *pArray, UINT32 element);
                             6708 ; 204  |
                             6709 ; 205  |/**
                             6710 ; 206  | * Copies the PTP array from one structure to the other.
                             6711 ; 207  | * Note that the destination array's allocated data buffer
                             6712 ; 208  | * may be smaller than the source's available data buffer.
                             6713 ; 209  | */
                             6714 ; 210  |_reentrant BOOL copyPtpArray(SPtpArray *pDst, SPtpArray *pSrc);
                             6715 ; 211  |
                             6716 ; 212  |/**
                             6717 ; 213  | * Packs the data within the PTP array into a byte array preceded
                             6718 ; 214  | * by the number of bytes.
                             6719 ; 215  | */
                             6720 ; 216  |_reentrant UINT32 packPtpArray(UINT16 _X *pBuf, UINT32 *dwBytesWritten, SPtpArray *pArray)
                                  ;
                             6721 ; 217  |
                             6722 ; 218  |
                             6723 ; 219  |#endif 
                             6724 
                             6726 
                             6727 ; 36   |#include "mtpProperty.h"
                             6728 
                             6730 
                             6731 ; 1    |/****************************************************************************
                             6732 ; 2    | *
                             6733 ; 3    | * @module      MtpProperty.h
                             6734 ; 4    | *
                             6735 ; 5    | * @created     18-Feburary-2004
                             6736 ; 6    | *
                             6737 ; 7    | * @abstract    Contains the declaration of the SMtpDeviceProperty object
                             6738 ; 8    | *              and SMtpObjectPropDesc object.
                             6739 ; 9    | *
                             6740 ; 10   | * @copyright   (C) COPYRIGHT POWER Q INC., 2004
                             6741 ; 11   | *
                             6742 ; 12   | ****************************************************************************/
                             6743 ; 13   |#ifndef __MTPPROPERTY_H_INCLUDED
                             6744 ; 14   |#define __MTPPROPERTY_H_INCLUDED
                             6745 ; 15   |
                             6746 ; 16   |#include "PtpString.h"
                             6747 
                             6749 
                             6750 ; 1    |/**
                             6751 ; 2    |***
                             6752 ; 3    |*** Filename: ptpstring.h
                             6753 ; 4    |*** Description: PTP string and array function prototypes
                             6754 ; 5    |***
                             6755 ; 6    |***
                             6756 ; 7    |*** Copyright (c) SigmaTel, Inc. Unpublished
                             6757 ; 8    |***
                             6758 ; 9    |*** SigmaTel, Inc.
                             6759 ; 10   |*** Proprietary & Confidential
                             6760 ; 11   |***
                             6761 ; 12   |*** This source code and the algorithms implemented therein constitute
                             6762 ; 13   |*** confidential information and may comprise trade secrets of SigmaTel, Inc.
                             6763 ; 14   |*** or its associates, and any use thereof is subject to the terms and
                             6764 ; 15   |*** conditions of the Confidential Disclosure Agreement pursuant to which this
                             6765 ; 16   |*** source code was originally received.
                             6766 ; 17   |**/
                             6767 ; 18   |//////////////////////////////////////////////////////////////////
                             6768 ; 19   |// Copyright  Microsoft Corporation, 2003
                             6769 ; 20   |//////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 107

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6770 ; 21   |
                             6771 ; 22   |//////////////////////////////////////////////////////////////////
                             6772 ; 23   |//   Includes
                             6773 ; 24   |//////////////////////////////////////////////////////////////////
                             6774 ; 25   |#ifndef __PTPSTRING_H_INCLUDED
                             6775 ; 26   |#define __PTPSTRING_H_INCLUDED
                             6776 ; 27   |
                             6777 ; 28   |#include "types.h"
                             6778 ; 29   |/*****************************************************************************
                             6779 ; 30   | * Defines the PTP string structure
                             6780 ; 31   | *****************************************************************************/
                             6781 ; 32   |
                             6782 ; 33   |#define MAX_PTP_STRING_CHARS        256
                             6783 ; 34   |#define MAX_PTP_SHORT_STRING_CHARS   32 
                             6784 ; 35   |
                             6785 ; 36   |typedef enum _STRING_TYPE {
                             6786 ; 37   |    SHORT_STRING,
                             6787 ; 38   |    LONG_STRING
                             6788 ; 39   |} STRING_TYPE;
                             6789 ; 40   |
                             6790 ; 41   |typedef struct SPtpString
                             6791 ; 42   |{
                             6792 ; 43   |  INT  NumChars; /* Number of chars in the string (including the NULL) */
                             6793 ; 44   |  WCHAR StringChars[MAX_PTP_STRING_CHARS];  /* Holds actual Unicode string with 2 bytes ch
                                  aracters, NULL-terminated */
                             6794 ; 45   |} SPtpString;
                             6795 ; 46   |
                             6796 ; 47   |//
                             6797 ; 48   |// This is needed becuase you cannot do sizeof(SPtpString) to check the size of
                             6798 ; 49   |// this structure during preprocessor run.
                             6799 ; 50   |//
                             6800 ; 51   |#define SPTPSTRING_SIZE (MAX_PTP_STRING_CHARS + 1)
                             6801 ; 52   |
                             6802 ; 53   |typedef struct SPtpShortString
                             6803 ; 54   |{
                             6804 ; 55   |  INT  NumChars; /* Number of chars in the string (including the NULL) */
                             6805 ; 56   |  WCHAR StringChars[MAX_PTP_SHORT_STRING_CHARS];  /* Holds actual Unicode string with 2 by
                                  tes characters, NULL-terminated */
                             6806 ; 57   |} SPtpShortString;
                             6807 ; 58   |
                             6808 ; 59   |// from time.h
                             6809 ; 60   |struct tm
                             6810 ; 61   |{
                             6811 ; 62   |  int   tm_sec;         /* seconds after the minute - [0, 59]   */
                             6812 ; 63   |  int   tm_min;         /* minutes after the hour - [0, 59]     */
                             6813 ; 64   |  int   tm_hour;        /* hours since midnight - [0, 23]       */
                             6814 ; 65   |  int   tm_mday;        /* day of the month - [1, 31]           */
                             6815 ; 66   |  int   tm_mon;         /* months since January - [0, 11]       */
                             6816 ; 67   |  int   tm_year;        /* year since 1900                      */
                             6817 ; 68   |  int   tm_wday;        /* days since Sunday - [0, 6]           */
                             6818 ; 69   |  int   tm_yday;        /* days since January 1 - [0, 365]      */
                             6819 ; 70   |  int   tm_isdst;       /* Daylight Saving Time flag            */
                             6820 ; 71   |};
                             6821 ; 72   |/**
                             6822 ; 73   | * Initializes the PTP string by zeroing out the string.
                             6823 ; 74   | */
                             6824 ; 75   |void initPtpString(SPtpString * pString);
                             6825 ; 76   |
                             6826 ; 77   |
                             6827 ; 78   |/**
                             6828 ; 79   | * Deallocates the memory for the PtpString structure
                             6829 ; 80   | */
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 108

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6830 ; 81   |void destroyPtpString(SPtpString *pString);
                             6831 ; 82   |
                             6832 ; 83   |/**
                             6833 ; 84   | * Copies the pStr into the PtpString structure.  The size parameter indicates
                             6834 ; 85   | * if the pStr is composed of 8-bit characters or 16-bit characters.
                             6835 ; 86   | */
                             6836 ; 87   |_reentrant void initChar2PtpString(SPtpString *pString, void * pStr, UINT16 word_size, STR
                                  ING_TYPE _type);
                             6837 ; 88   |
                             6838 ; 89   |/**
                             6839 ; 90   | * Concatenates the pStr into the PtpString structure.  The size parameter indicates
                             6840 ; 91   | * if the pStr is composed of 8-bit characters or 16-bit characters.
                             6841 ; 92   | */
                             6842 ; 93   |_reentrant void catChar2PtpString(SPtpString *pString, void * pStr, UINT16 word_size, STRI
                                  NG_TYPE _type);
                             6843 ; 94   |
                             6844 ; 95   |/**
                             6845 ; 96   | * Concatenates the two PtpString structures into the first.
                             6846 ; 97   | */
                             6847 ; 98   |_reentrant void catPtpString(SPtpString *pDstString, SPtpString *pSrcString, STRING_TYPE _
                                  type);
                             6848 ; 99   |
                             6849 ; 100  |/**
                             6850 ; 101  | * Copies the time set by lpTime and converts it to a PTP String.
                             6851 ; 102  | */
                             6852 ; 103  |_reentrant void initTime2PtpString(SPtpShortString *pString, struct tm *lTime);
                             6853 ; 104  |
                             6854 ; 105  |/**
                             6855 ; 106  | * extracts time from PtpString and stores it in time object.
                             6856 ; 107  | */
                             6857 ; 108  |_reentrant void initPtpString2Time(SPtpShortString *pString, struct tm *lTime);
                             6858 ; 109  |
                             6859 ; 110  |/**
                             6860 ; 111  | * extracts number from string.
                             6861 ; 112  | */
                             6862 ; 113  |_reentrant void MtpExtractNumberFromPtpString( WCHAR *pUnicodeString, INT iDigits, INT iOf
                                  fset, INT * iNumber);
                             6863 ; 114  |
                             6864 ; 115  |/**
                             6865 ; 116  |* Converts the number to PtpString
                             6866 ; 117  |*/
                             6867 ; 118  |_reentrant void MtpStringPrintNumber(WCHAR *pUnicodeString,INT iNumber, INT iDigits, INT i
                                  Filler);
                             6868 ; 119  |
                             6869 ; 120  |/**
                             6870 ; 121  | * Copies one string into another.
                             6871 ; 122  | */
                             6872 ; 123  |_reentrant void copyPtpString(SPtpString *pDst, SPtpString *pSrc);
                             6873 ; 124  |
                             6874 ; 125  |/* copy Ptpstring in _X memory; usually in raw data from host */
                             6875 ; 126  |_reentrant void copy_XPtpString(SPtpString *pDst, void _X *pSrc, UINT16 *byteOffset);
                             6876 ; 127  |
                             6877 ; 128  |/**
                             6878 ; 129  | * Copies the void * pSrc string to the PTP string pDst.
                             6879 ; 130  | */
                             6880 ; 131  |_reentrant void copyChar2PtpString(SPtpString *pDst, void *pSrc);
                             6881 ; 132  |
                             6882 ; 133  |/**
                             6883 ; 134  | * Checks to see if two different PTP strings are equal.
                             6884 ; 135  | */
                             6885 ; 136  |_reentrant BOOL isEqualPtpString(SPtpString *pDst, SPtpString *pSrc);
                             6886 ; 137  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 109

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6887 ; 138  |/**
                             6888 ; 139  | * Returns the size in bytes of the PTP string.
                             6889 ; 140  | */
                             6890 ; 141  |UINT32 sizeInBytesPtpString(SPtpString *pString);
                             6891 ; 142  |    
                             6892 ; 143  |
                             6893 ; 144  |/**
                             6894 ; 145  | * packs the PTP string into a packed char string
                             6895 ; 146  | */
                             6896 ; 147  |_reentrant UINT16 copyPtpToPackedString (_packed char *packedStr, SPtpString *pPtpStr);
                             6897 ; 148  |
                             6898 ; 149  |/**
                             6899 ; 150  | * copies packed string into PTP string
                             6900 ; 151  | */
                             6901 ; 152  |_reentrant UINT16 copyPackedToPtpString (_packed char *packedStr, SPtpString *pPtpStr);
                             6902 ; 153  |
                             6903 ; 154  |
                             6904 ; 155  |/*****************************************************************************
                             6905 ; 156  | * Defines the PTP array structure
                             6906 ; 157  | *****************************************************************************/
                             6907 ; 158  |    
                             6908 ; 159  |#define ELEMENT_NOT_FOUND   -1
                             6909 ; 160  |#define INITIAL_ARRAY_SIZE  20
                             6910 ; 161  |
                             6911 ; 162  |typedef enum DATATYPE
                             6912 ; 163  |{
                             6913 ; 164  |  UINT8_TYPE,
                             6914 ; 165  |  UINT16_TYPE,
                             6915 ; 166  |  UINT32_TYPE
                             6916 ; 167  |} DATATYPE;
                             6917 ; 168  |
                             6918 ; 169  |typedef struct SPtpArray
                             6919 ; 170  |{
                             6920 ; 171  |  DATATYPE type;
                             6921 ; 172  |  UINT32 ArraySize;
                             6922 ; 173  |  UINT32 NumElements;
                             6923 ; 174  |  UINT32 *ArrayEntry;
                             6924 ; 175  |} SPtpArray;
                             6925 ; 176  |
                             6926 ; 177  |
                             6927 ; 178  |/**
                             6928 ; 179  | * Initializes the PTP array with the type and the default
                             6929 ; 180  | * array size.
                             6930 ; 181  | */
                             6931 ; 182  |_reentrant void initPtpArray(SPtpArray *pArray, DATATYPE type, UINT32 arraySize, UINT32 *p
                                  ActualArray);
                             6932 ; 183  |
                             6933 ; 184  |/**
                             6934 ; 185  | * Returns the size in bytes of the PTP array structure and data.
                             6935 ; 186  | */
                             6936 ; 187  |_reentrant UINT32 sizeInBytesPtpArray(SPtpArray *pArray);
                             6937 ; 188  |
                             6938 ; 189  |
                             6939 ; 190  |/**
                             6940 ; 191  | * Finds and returns the index of the desired element.
                             6941 ; 192  | */
                             6942 ; 193  |_reentrant UINT32 findElementPtpArray(SPtpArray *pArray, UINT32 element);
                             6943 ; 194  |
                             6944 ; 195  |/**
                             6945 ; 196  | * Appends the desired element to the end of the array.
                             6946 ; 197  | */
                             6947 ; 198  |_reentrant BOOL appendElementPtpArray(SPtpArray *pArray, UINT32 element);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 110

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6948 ; 199  |
                             6949 ; 200  |/**
                             6950 ; 201  | * Removes the specified element from the array.
                             6951 ; 202  | */
                             6952 ; 203  |_reentrant BOOL removeElementPtpArray(SPtpArray *pArray, UINT32 element);
                             6953 ; 204  |
                             6954 ; 205  |/**
                             6955 ; 206  | * Copies the PTP array from one structure to the other.
                             6956 ; 207  | * Note that the destination array's allocated data buffer
                             6957 ; 208  | * may be smaller than the source's available data buffer.
                             6958 ; 209  | */
                             6959 ; 210  |_reentrant BOOL copyPtpArray(SPtpArray *pDst, SPtpArray *pSrc);
                             6960 ; 211  |
                             6961 ; 212  |/**
                             6962 ; 213  | * Packs the data within the PTP array into a byte array preceded
                             6963 ; 214  | * by the number of bytes.
                             6964 ; 215  | */
                             6965 ; 216  |_reentrant UINT32 packPtpArray(UINT16 _X *pBuf, UINT32 *dwBytesWritten, SPtpArray *pArray)
                                  ;
                             6966 ; 217  |
                             6967 ; 218  |
                             6968 ; 219  |#endif 
                             6969 
                             6971 
                             6972 ; 17   |
                             6973 ; 18   |#define MAX_SIZE_IN_BYTES_OF_PROP_VALUE   256
                             6974 ; 19   |
                             6975 ; 20   |#define     MAX_DEFAULT_PROP_VALUES     5
                             6976 ; 21   |#define     MAX_CURRENT_PROP_VALUES     5
                             6977 ; 22   |#define     MAX_DEVICE_PROP_VALUES      5
                             6978 ; 23   |#define     MAX_ENUM_VALUES                             10
                             6979 ; 24   |
                             6980 ; 25   |typedef enum PropFormFlag
                             6981 ; 26   |{
                             6982 ; 27   |  None              = 0x00, 
                             6983 ; 28   |  RangeForm             = 0x01,
                             6984 ; 29   |  EnumForm              = 0x02,
                             6985 ; 30   |  DateTimeForm          = 0x03,
                             6986 ; 31   |  FixedLengthArrayForm  = 0x04,
                             6987 ; 32   |  RegularExpressionForm = 0x05,
                             6988 ; 33   |  ByteArray             = 0x06,
                             6989 ; 34   |  LongStringForm        = 0xFF
                             6990 ; 35   |} ePropFormFlag;
                             6991 ; 36   |
                             6992 ; 37   |typedef enum _GroupCodeFlag
                             6993 ; 38   |{
                             6994 ; 39   |  GroupCodeNone        = 0x0000,
                             6995 ; 40   |  GroupCodeImages      = 0x0001,
                             6996 ; 41   |  GroupCodeAvi         = 0x0002,
                             6997 ; 42   |  GroupCodeAll         = 0xFFFF
                             6998 ; 43   |}GroupCodeFlag;
                             6999 ; 44   |
                             7000 ; 45   |typedef struct MtpDevicePropDesc
                             7001 ; 46   |{
                             7002 ; 47   |    UINT16  PropCode;       /* Property code for this property */
                             7003 ; 48   |    UINT16  DataType;       /* Contains the type of the data (2=BYTE, 4=WORD, 6=DWORD, 0xF
                                  FFF=String) */
                             7004 ; 49   |                            /* For array data type, assume no form for now (no such proper
                                  ty defined) */
                             7005 ; 50   |    BYTE    GetSet;         /* Indicates whether the property can be set or not (0=get-onl
                                  y, 1=get-set) */
                             7006 ; 51   |    /* Default value */
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 111

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7007 ; 52   |    union
                             7008 ; 53   |    {
                             7009 ; 54   |        UINT32       Integer;    /* Default value for any integer value type (UINT8, UINT1
                                  6, UINT32) */
                             7010 ; 55   |        SPtpString  Str;     /* Default value for a String value type */
                             7011 ; 56   |        SPtpArray Array;    /* Default array */
                             7012 ; 57   |        UINT32    DataArray[MAX_DEFAULT_PROP_VALUES];
                             7013 ; 58   |    } Default;
                             7014 ; 59   |
                             7015 ; 60   |    /* Current Value */
                             7016 ; 61   |    union
                             7017 ; 62   |    {
                             7018 ; 63   |        UINT32       Integer;    /* Current value for any integer value type (UINT8, UINT1
                                  6, UINT32) */
                             7019 ; 64   |        SPtpString  Str;     /* Current value for a String value type */
                             7020 ; 65   |        SPtpArray  Array;    /* Current value for array data type (AINT8, AUINT8) */
                             7021 ; 66   |        UINT32      DataArray[MAX_CURRENT_PROP_VALUES];
                             7022 ; 67   |    } Current;
                             7023 ; 68   |
                             7024 ; 69   |    BYTE    FormFlag;       /* Indicates the form of the valid values (0=none, 1=range, 2=
                                  enum) */
                             7025 ; 70   |    /*
                             7026 ; 71   |     * Range values
                             7027 ; 72   |     */
                             7028 ; 73   |    union 
                             7029 ; 74   |    {
                             7030 ; 75   |                union {
                             7031 ; 76   |                        struct
                             7032 ; 77   |                        {
                             7033 ; 78   |                                UINT32    dwRangeMin;            /* Minimum value */
                             7034 ; 79   |                                UINT32    dwRangeMax;            /* Maximum value */
                             7035 ; 80   |                                UINT32    dwRangeStep;           /* Step value    */
                             7036 ; 81   |                        } Integer;
                             7037 ; 82   |                        struct
                             7038 ; 83   |                        {
                             7039 ; 84   |        //fam:            SPtpString StrRangeMin;
                             7040 ; 85   |        //fam:            SPtpString StrRangeMax;
                             7041 ; 86   |        //fam:            SPtpString StrRangeStep;
                             7042 ; 87   |                                SPtpShortString StrRangeMin;
                             7043 ; 88   |                                SPtpShortString StrRangeMax;
                             7044 ; 89   |                                SPtpShortString StrRangeStep;
                             7045 ; 90   |                        } PtpString;
                             7046 ; 91   |                } Range;
                             7047 ; 92   |
                             7048 ; 93   |                /*
                             7049 ; 94   |                * Enumeration values
                             7050 ; 95   |                */
                             7051 ; 96   |//              SLinkList SupportedValueList;
                             7052 ; 97   |                struct {
                             7053 ; 98   |                        // sigmatel device shall not support enums of type strings
                             7054 ; 99   |                        UINT16 NumEnumValues;
                             7055 ; 100  |                        UINT32 SupportedValueList[MAX_ENUM_VALUES];             
                             7056 ; 101  |                } EnumList;
                             7057 ; 102  |    } Form;
                             7058 
                             7065 
                             7066 ; 103  |
                             7067 ; 104  |    UINT32   dwSizeDTS;      /* Count of Byte Size of the Data-Type-Specific value (DTS) *
                                  /
                             7068 ; 105  |        GroupCodeFlag   GroupCode;
                             7069 ; 106  |} SMtpDevicePropDesc;
                             7070 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 112

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7110 
                             7111 ; 107  |
                             7112 ; 108  |/**
                             7113 ; 109  | * Allocates the memory for a MTP device property structure.
                             7114 ; 110  | */
                             7115 ; 111  |//SMtpDeviceProperty *allocMtpDeviceProperty();
                             7116 ; 112  |/**
                             7117 ; 113  | * Frees up the memory used by the Mtp Device Property structure.  It also
                             7118 ; 114  | * deallocates all the memory used by the different elements of the structure.
                             7119 ; 115  | */
                             7120 ; 116  |//void destroyMtpDeviceProperty(SMtpDeviceProperty *pProp);
                             7121 ; 117  |
                             7122 ; 118  |/**
                             7123 ; 119  | * Checks to see if the value is a valid property
                             7124 ; 120  | */
                             7125 ; 121  |BOOL isValidInteger(SMtpDevicePropDesc *pProp, UINT32 dwValue);
                             7126 ; 122  |
                             7127 ; 123  |/**
                             7128 ; 124  | * Checks to see if the string is a valid property
                             7129 ; 125  | */
                             7130 ; 126  |BOOL isValidString(SMtpDevicePropDesc *pProp, SPtpString* pStrValue);
                             7131 ; 127  |
                             7132 ; 128  |/**
                             7133 ; 129  | * Sets the value of the current integer.
                             7134 ; 130  | */
                             7135 ; 131  |BOOL setCurrentInteger(SMtpDevicePropDesc *pProp, UINT32 dwValue);
                             7136 ; 132  |
                             7137 ; 133  |/**
                             7138 ; 134  | * Sets the value of the current string with a unicode character
                             7139 ; 135  | * array.
                             7140 ; 136  | */
                             7141 ; 137  |BOOL setCurrentString(SMtpDevicePropDesc *pProp, SPtpString* pStrValue);
                             7142 ; 138  |
                             7143 ; 139  |/**
                             7144 ; 140  | * Sets the value of the current array.
                             7145 ; 141  | */
                             7146 ; 142  |BOOL  setCurrentArray(SMtpDevicePropDesc *pProp, WORD _X *pRawArray);
                             7147 ; 143  |
                             7148 ; 144  |/**
                             7149 ; 145  | * Sets the value of the current union from a raw array of data.
                             7150 ; 146  | */
                             7151 ; 147  |BOOL setCurrentRaw(SMtpDevicePropDesc *pProp, WORD _X *pRawValue, UINT32 cbSize);
                             7152 ; 148  |
                             7153 ; 149  |
                             7154 ; 150  |/**
                             7155 ; 151  | * Sets the range for the integer.
                             7156 ; 152  | */
                             7157 ; 153  |BOOL  setRangeInteger(SMtpDevicePropDesc *pProp, UINT32 dwRangeMin, UINT32 dwRangeMax, UIN
                                  T32 dwRangeStep);
                             7158 ; 154  |
                             7159 ; 155  |/**
                             7160 ; 156  | * Sets the range for the string.
                             7161 ; 157  | */
                             7162 ; 158  |BOOL  setRangeString(SMtpDevicePropDesc *pProp, WCHAR* pszRangeMin, WCHAR* pszRangeMax, WC
                                  HAR* pszRangeStep);
                             7163 ; 159  |
                             7164 ; 160  |/**
                             7165 ; 161  | * Adds a supported value for the property.
                             7166 ; 162  | */
                             7167 ; 163  |BOOL  addSupportedValueInteger(SMtpDevicePropDesc *pProp, UINT32 dwValue);
                             7168 ; 164  |
                             7169 ; 165  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 113

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7170 ; 166  |/**
                             7171 ; 167  | * Returns the sizeof the value in bytes.
                             7172 ; 168  | */
                             7173 ; 169  |UINT32 valueSizeInBytesMtpDevicePropDesc(SMtpDevicePropDesc *pProp);
                             7174 ; 170  |
                             7175 ; 171  |
                             7176 ; 172  |/**
                             7177 ; 173  | * Initializes the MTP device property description structure.
                             7178 ; 174  | */
                             7179 ; 175  |void initMtpDevicePropDesc(SMtpDevicePropDesc *pDesc, UINT16 PropCode,
                             7180 ; 176  |    UINT16 DataType, BYTE GetSet, BYTE FormFlag, UINT32 Groupcode);
                             7181 ; 177  |
                             7182 ; 178  |/**
                             7183 ; 179  | * Allocates memory and initalizes the property description structure.
                             7184 ; 180  | */
                             7185 ; 181  |SMtpDevicePropDesc *allocMtpDevicePropDesc(void);
                             7186 ; 182  |
                             7187 ; 183  |/**
                             7188 ; 184  | * Frees all the memory allocated by the property description structure.
                             7189 ; 185  | */
                             7190 ; 186  |void destroyMtpDevicePropDesc(SMtpDevicePropDesc *pDesc);
                             7191 ; 187  |
                             7192 ; 188  |/**
                             7193 ; 189  | * Sets the default integer value.
                             7194 ; 190  | */
                             7195 ; 191  |BOOL setDefaultIntegerDesc(SMtpDevicePropDesc *pDesc, UINT32 dwValue);
                             7196 ; 192  |
                             7197 ; 193  |/**
                             7198 ; 194  | * Sets the default string value.
                             7199 ; 195  | */
                             7200 ; 196  |BOOL setDefaultStringDesc(SMtpDevicePropDesc *pDesc, char * pValue);
                             7201 ; 197  |
                             7202 ; 198  |/**
                             7203 ; 199  | * Sets the default array value.
                             7204 ; 200  | */
                             7205 ; 201  |BOOL setDefaultArrayDesc(SMtpDevicePropDesc *pDesc, BYTE* pArray, UINT32 dwNumOfElements);
                                  
                             7206 ; 202  |
                             7207 ; 203  |/**
                             7208 ; 204  | * Sets the integer range in the device property description.
                             7209 ; 205  | */
                             7210 ; 206  |BOOL  setRangeIntegerDesc(SMtpDevicePropDesc *pDesc, UINT32 dwRangeMin, UINT32 dwRangeMax,
                                   UINT32 dwRangeStep);
                             7211 ; 207  |
                             7212 ; 208  |/**
                             7213 ; 209  | * Sets the string rage in the device property description.
                             7214 ; 210  | */
                             7215 ; 211  |BOOL  setRangeStringDesc(SMtpDevicePropDesc *pDesc, WCHAR* pszRangeMin, WCHAR* pszRangeMax
                                  , WCHAR* pszRangeStep);
                             7216 ; 212  |
                             7217 ; 213  |/**
                             7218 ; 214  | * Adds a supported integer value to the description.
                             7219 ; 215  | */
                             7220 ; 216  |BOOL  addSupportedValueIntegerDesc(SMtpDevicePropDesc *pDesc, UINT32 dwValue);
                             7221 ; 217  |
                             7222 ; 218  |/**
                             7223 ; 219  | * Checks to see if the value is a valid integer.
                             7224 ; 220  | */
                             7225 ; 221  |BOOL  isValidIntegerDesc(SMtpDevicePropDesc *pDesc, UINT32 dwValue);
                             7226 ; 222  |
                             7227 ; 223  |/**
                             7228 ; 224  | * Checks to see if the string is a valid string.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 114

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7229 ; 225  | */
                             7230 ; 226  |BOOL  isValidStringDesc(SMtpDevicePropDesc *pDesc, SPtpString* pStrValue);
                             7231 ; 227  |
                             7232 ; 228  |/**
                             7233 ; 229  | * Finds the size of the Mtp device property description.
                             7234 ; 230  | */
                             7235 ; 231  |UINT32  sizeInBytesMtpDevicePropDesc(SMtpDevicePropDesc *pDesc);
                             7236 ; 232  |
                             7237 ; 233  |/**
                             7238 ; 234  | * Packs the device property description into a raw byte array.
                             7239 ; 235  | */
                             7240 ; 236  |//UINT32 packMtpDevicePropDesc(SMtpDevicePropDesc *pDesc, BYTE* pBuf, UINT32 cbBufSize);
                             7241 ; 237  |
                             7242 ; 238  |
                             7243 ; 239  |
                             7244 ; 240  |
                             7245 ; 241  |typedef struct MtpDevicePropValue
                             7246 ; 242  |{
                             7247 ; 243  |    SMtpDevicePropDesc * pDesc;
                             7248 ; 244  |/*    union
                             7249 ; 245  |    {
                             7250 ; 246  |      UINT32       Integer;      // Current value for any integer value type (UINT8, UINT1
                                  6, UINT32)
                             7251 ; 247  |      SPtpString  Str;    // Current value for a String value type
                             7252 ; 248  |      SPtpArray Array;
                             7253 ; 249  |      UINT32    DataArray[MAX_DEVICE_PROP_VALUES];
                             7254 ; 250  |    } Current;
                             7255 ; 251  |*/
                             7256 ; 252  |} SMtpDevicePropValue;
                             7257 
                             7263 
                             7264 ; 253  |
                             7265 ; 254  |UINT32 GetPropCode(SMtpDevicePropValue *pVal);
                             7266 ; 255  |UINT32 GetDataType(SMtpDevicePropValue *pVal);
                             7267 ; 256  |UINT32 GetGroupCode(SMtpDevicePropValue *pVal);
                             7268 ; 257  |BYTE* Get(SMtpDevicePropValue *pVal); 
                             7269 ; 258  |void  initMtpDevicePropValue(SMtpDevicePropValue *pVal, SMtpDevicePropDesc* pDesc);
                             7270 ; 259  |SMtpDevicePropValue * allocMtpDevicePropValue(SMtpDevicePropDesc *pDesc);
                             7271 ; 260  |UINT32  sizeInBytesMtpDevicePropValue(SMtpDevicePropValue *pVal);
                             7272 ; 261  |void  destroyMtpDevicePropValue(SMtpDevicePropValue *pVal);
                             7273 ; 262  |UINT32  packMtpDevicePropValue(SMtpDevicePropValue *pVal, BYTE* pBuf, UINT32 cbBufSize);
                             7274 ; 263  |BOOL  setCurrentIntegerVal(SMtpDevicePropValue *pVal, UINT32 dwValue);
                             7275 ; 264  |BOOL  setCurrentStringVal(SMtpDevicePropValue *pVal, SPtpString* pStrValue);
                             7276 ; 265  |BOOL  setCurrentArrayVal(SMtpDevicePropValue *pVal, WORD _X *pRawArray, UINT32 *pActualArr
                                  ay);
                             7277 ; 266  |BOOL  setCurrentRawVal(SMtpDevicePropValue *pVal, WORD _X *pRawValue, UINT32 cbSize);
                             7278 ; 267  |void  resetMtpDevicePropVal(SMtpDevicePropValue *pVal);
                             7279 ; 268  |
                             7280 ; 269  |
                             7281 ; 270  |/*
                             7282 ; 271  | * Define ObjectPropQuad and CMtpObjectPropList for GetObjectPropList
                             7283 ; 272  | */
                             7284 ; 273  |typedef struct tagObjectPropQuad
                             7285 ; 274  |{
                             7286 ; 275  |    UINT32 ObjectHandle;
                             7287 ; 276  |    UINT16 PropCode;
                             7288 ; 277  |    UINT16 DataType;
                             7289 ; 278  |    BYTE* pValue;
                             7290 ; 279  |    UINT32 dwValueSize;    // a useful helper, not part of the Object Property Quadruple
                             7291 ; 280  |} SObjectPropQuad;
                             7292 ; 281  |/*
                             7293 ; 282  |typedef struct MtpDevicePropList
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 115

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7294 ; 283  |{
                             7295 ; 284  |  SLinkList PropQuadList;
                             7296 ; 285  |} SMtpDevicePropList;
                             7297 ; 286  |*/
                             7298 ; 287  |//UINT32  sizeInBytesMtpDevicePropList(SMtpDevicePropList *pList);
                             7299 ; 288  |//UINT32  packMtpDevicePropList(SMtpDevicePropList *pList, BYTE* pBuf, UINT32 cbBufSize);
                             7300 ; 289  |//BOOL   appendMtpDevicePropList(SMtpDevicePropList *pList, UINT32 ObjectHandle, 
                             7301 ; 290  |//                      UINT16 PropCode, UINT16 DataType, BYTE* pValue);
                             7302 ; 291  |//SMtpDevicePropList *allocMtpDevicePropList();
                             7303 ; 292  |//void destroyMtpDevicePropList(SMtpDevicePropList *pList);
                             7304 ; 293  |//UINT32 countMtpDevicePropList(SMtpDevicePropList *pList);
                             7305 ; 294  |
                             7306 ; 295  |
                             7307 ; 296  |#endif
                             7308 
                             7310 
                             7311 ; 37   |
                             7312 ; 38   |////////////////////////////////////////////////////////////////////////////////
                             7313 ; 39   |// Defs
                             7314 ; 40   |////////////////////////////////////////////////////////////////////////////////
                             7315 ; 41   |#define BufByte(a,b,c) b[a/3] |= c<<(8*(a%3))           //a specifies Byte in Array, b spe
                                  cifies buffer, c specifies actual data
                             7316 ; 42   |#define BufWord(a,b,c) BufByte(a,b,(c&0xff)); BufByte(a+1,b,((c>>8) & 0xff))  
                             7317 ; 43   |#define BufDWord(a,b,c) BufWord(a, b,(c&0xffff)); BufWord(a+2,b,((c>>16) & 0xffff)) 
                             7318 ; 44   |
                             7319 ; 45   |#define BufDDWord(a,b,c) BufWord(a, b,(c&0xffff)); BufWord(a+2,b,((c>>16) & 0xffff)) 
                             7320 ; 46   |
                             7321 ; 47   |#define USB_INTERFACE_CLASS_MASS_STORAGE    0x08
                             7322 ; 48   |
                             7323 ; 49   |#define USB_INTERFACE_SUB_CLASS_RBC                             0x01
                             7324 ; 50   |#define USB_INTERFACE_SUB_CLASS_SFF_8020I                       0x02
                             7325 ; 51   |#define USB_INTERFACE_SUB_CLASS_MMC_2                           0x02
                             7326 ; 52   |#define USB_INTERFACE_SUB_CLASS_QIC_157                         0x03
                             7327 ; 53   |#define USB_INTERFACE_SUB_CLASS_UFI                             0x04
                             7328 ; 54   |#define USB_INTERFACE_SUB_CLASS_SFF_8070I                       0x05
                             7329 ; 55   |#define USB_INTERFACE_SUB_CLASS_SCSI_TRANSPARENT_COMMAND_SET    0x06
                             7330 ; 56   |
                             7331 ; 57   |#define USB_INTERFACE_PROTOCOL_CBI_CCI                          0x01
                             7332 ; 58   |#define USB_INTERFACE_PROTOCOL_CBI_NO_CCI                       0x02
                             7333 ; 59   |#define USB_INTERFACE_PROTOCOL_BULK_ONLY                        0x50
                             7334 ; 60   |
                             7335 ; 61   |
                             7336 ; 62   |#define TRANSFER_IN_BUFFER_SIZE 2052 
                             7337 ; 63   |#define TRANSFER_BUFFER_SIZE    512
                             7338 ; 64   |
                             7339 ; 65   |#define MIN_AVAILABLE_THRESHOLD         2048 // 2048KB = 2MB
                             7340 ; 66   |
                             7341 ; 67   |#define SIZEOF_UINT8            1
                             7342 ; 68   |#define SIZEOF_UINT16           2
                             7343 ; 69   |#define SIZEOF_UINT32           4
                             7344 ; 70   |#define SIZEOF_UINT64           8
                             7345 ; 71   |
                             7346 ; 72   |
                             7347 ; 73   |// For static arrays.  These must be updated by manufacturer to reflect capabilities of pr
                                  oduct
                             7348 ; 74   |#define         NUM_OPS_SUPPORTED                   36
                             7349 ; 75   |#define         NUM_EVENTS_SUPPORTED            2//fam:16
                             7350 ; 76   |#define         NUM_CAPTURE_FORMATS                     0
                             7351 ; 77   |#ifdef AUDIBLE
                             7352 ; 78   |#define         NUM_OBJECT_FORMATS                      6  //Audible adds 1 format from ba
                                  se SDK
                             7353 ; 79   |#define         NUM_DEVICE_PROPERTIES           3  //Audible adds 1 device property
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 116

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7354 ; 80   |#else
                             7355 ; 81   |#define         NUM_OBJECT_FORMATS                      5//fam:11
                             7356 ; 82   |#define         NUM_DEVICE_PROPERTIES           2//fam:5
                             7357 ; 83   |#endif
                             7358 ; 84   |#define     MAX_STORAGE_IDS             1 // 2 for MMC
                             7359 ; 85   |
                             7360 ; 86   |#define     MAX_CHILD_HANDLES           20
                             7361 ; 87   |#define     MAX_OBJECT_REFERENCES       2
                             7362 ; 88   |
                             7363 ; 89   |#define     INVALID_OBJECTHANDLE        0xFFFFFFFF
                             7364 ; 90   |
                             7365 ; 91   |////////////////////////////////////////////////////////////////////////////////
                             7366 ; 92   |// Errors
                             7367 ; 93   |
                             7368 ; 94   |//#define USBMSC_ERROR_INVALID_DEVICE                             (WORD)0xFFFFFF
                             7369 ; 95   |//#define USBMSC_ERROR_INVALID_LUN                                (WORD)0xFFFFFE
                             7370 ; 96   |#define MTP_DEVICE_INIT_ALL_FAILED                           (WORD)0x000001
                             7371 ; 97   |#define MTP_DEVICE_INIT_FAILED                               (WORD)0x000002
                             7372 ; 98   |
                             7373 ; 99   |////////////////////////////////////////////////////////////////////////////////
                             7374 ; 100  |// Typedefs
                             7375 ; 101  |////////////////////////////////////////////////////////////////////////////////
                             7376 ; 102  |
                             7377 ; 103  |typedef RETCODE (*MTP_DEVICE_INIT_FUNCTION)(void);
                             7378 ; 104  |typedef RETCODE (*MTP_DEVICE_RESET_FUNCTION)(void);
                             7379 ; 105  |
                             7380 ; 106  |/**
                             7381 ; 107  | * \enum eDevicePhase
                             7382 ; 108  | *
                             7383 ; 109  | * Defines which phase the device is currently in.
                             7384 ; 110  | */
                             7385 ; 111  |typedef enum DevicePhase 
                             7386 ; 112  |{
                             7387 ; 113  |    DEVICE_PHASE_NOTREADY = 0,  /**< Device is in a busy state. */
                             7388 ; 114  |    DEVICE_PHASE_IDLE = 1,      /**< Device is in an idle state. */
                             7389 ; 115  |    DEVICE_PHASE_COMMAND = 2,   /**< Device is in the command phase. */
                             7390 ; 116  |    DEVICE_PHASE_DATAIN = 3,    /**< Device is in the data in phase. */
                             7391 ; 117  |    DEVICE_PHASE_DATAOUT = 4,   /**< Device is in the data out phase. */
                             7392 ; 118  |    DEVICE_PHASE_RESP0NSE = 5,  /**< Device is in the response phase. */
                             7393 ; 119  |    DEVICE_PHASE_STALLED = 6    /**< Device endpoints were stalled. */
                             7394 ; 120  |} eDevicePhase;
                             7395 ; 121  |
                             7396 ; 122  |typedef enum DeviceStatus
                             7397 ; 123  |{
                             7398 ; 124  |        DEVICE_STATUSOK = 0,      /**< Device OK. */
                             7399 ; 125  |        DEVICE_LOWBATTERY = 1,    /**< Fatal error, can't continue operation. */
                             7400 ; 126  |        DEVICE_OUTOFMEMORY = 2,   /**< Out of memory, Can't continue. */
                             7401 ; 127  |        DEVICE_STOREREMOVED = 3,  /**< Fatal error, especially if during a data transfer. 
                                  */
                             7402 ; 128  |        DEVICE_DEVICEERROR = 4,    /**< Unidentified fatal device error, can't continue. *
                                  /
                             7403 ; 129  |        DEVICE_HOST_CANCELLED_OP = 5,   /**< Operation cancelled; cleanup required */ 
                             7404 ; 130  |        DEVICE_CANCELLED_OP = 6,  /**< Device initiated operation cancellation */
                             7405 ; 131  |        DEVICE_FS_CRITICAL = 7,   /**< Critical file system error; unrecoverable */
                             7406 ; 132  |        DEVICE_STORE_CRITICAL = 8 /**< Critcal STMP store error; unrecoverable */
                             7407 ; 133  |} eDeviceStatus;
                             7408 ; 134  |
                             7409 ; 135  |
                             7410 ; 136  |
                             7411 ; 137  |/**
                             7412 ; 138  | * SStorageInfo
                             7413 ; 139  | *
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 117

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7414 ; 140  | * SStorageInfo is the structure for storing all the information for all storage
                             7415 ; 141  | * on the device.
                             7416 ; 142  | */
                             7417 ; 143  |
                             7418 ; 144  |typedef struct StorageInfo
                             7419 ; 145  |{
                             7420 ; 146  |    /* PTP Storage Info Members */
                             7421 ; 147  |    WORD        StorageType;           // storage type
                             7422 ; 148  |    WORD        FileSystemType;        // file system type
                             7423 ; 149  |    WORD        AccessCapability;      // access capability (e.g. read/write)
                             7424 ; 150  |    UINT64      MaxCapacity;           // maximum capacity in bytes
                             7425 ; 151  |    UINT64      FreeSpaceInBytes;      // free space in bytes
                             7426 ; 152  |    DWORD       FreeSpaceInObjects;    // free space in objects
                             7427 ; 153  |
                             7428 ; 154  |    SPtpShortString  StorageDescription;    // optional storage description: variable leng
                                  th
                             7429 ; 155  |    SPtpShortString  VolumeLabel;           // optional volume label: variable length
                             7430 ; 156  |} SStorageInfo;
                             7431 
                             7442 
                             7443 ; 157  |typedef struct MtpStore
                             7444 ; 158  |{
                             7445 ; 159  |    /* Root path to the store */
                             7446 ; 160  |    SPtpShortString szRootPath;
                             7447 ; 161  |    DWORD           StorageID;
                             7448 ; 162  |    SStorageInfo    StorageInfo;
                             7449 ; 163  |//    SLinkList       ObjectList;
                             7450 ; 164  |}SMtpStore;
                             7451 ; 165  |
                             7452 ; 166  |
                             7453 ; 167  |
                             7454 ; 168  |//
                             7455 ; 169  |// This structure defines the static device info data returned on MtpGetDeviceInfo calls.
                             7456 ; 170  |// It is initialized in mtp_ids.c and extracted as a data resource loaded in MtpGetDeviceI
                                  nfo().
                             7457 ; 171  |//
                             7458 ; 172  |typedef struct 
                             7459 ; 173  |{
                             7460 ; 174  |    UINT16          StandardVersion;          /**< Version of the MTP standard supported. 
                                  */
                             7461 ; 175  |    UINT32          VendorExtensionID;        /**< Vendor extension ID. */
                             7462 ; 176  |    UINT16          VendorExtensionVersion;   /**< Vendor extension version. */
                             7463 ; 177  |    SPtpString      VendorExtensionDesc;/**< Vendor extension description string. */
                             7464 ; 178  |    UINT16          FunctionalMode;           /**< Funtional mode. */
                             7465 ; 179  |    UINT32          OpsSupported;
                             7466 ; 180  |    UINT16          OP_SUPPORTED_LIST[NUM_OPS_SUPPORTED];
                             7467 ; 181  |    UINT32          EventsSupported;
                             7468 ; 182  |    UINT16          EVENT_SUPPORTED_LIST[NUM_EVENTS_SUPPORTED];
                             7469 ; 183  |    UINT32          DevicePropsSupported;
                             7470 ; 184  |    UINT16          DEVICE_PROPS_SUPPORTED_LIST[NUM_DEVICE_PROPERTIES];
                             7471 ; 185  |    UINT32          CaptureFormatsSupported;
                             7472 ; 186  |    // There would be a list of Capture Formats here that we support, but
                             7473 ; 187  |    // we don't support any.  
                             7474 ; 188  |    UINT32          ObjectFormatsSupported;
                             7475 ; 189  |    UINT16          OBJECT_FORMAT_LIST[NUM_OBJECT_FORMATS];
                             7476 ; 190  |    SPtpShortString Manufacturer;       /**< The manufacturer's name. */
                             7477 ; 191  |    SPtpShortString Model;             /**< A string containing the model name. */
                             7478 ; 192  |    SPtpShortString DeviceVersion;    /**< A string contaiing the device version. */
                             7479 ; 193  |    SPtpShortString SerialNumber;   /**< The serial number string. */
                             7480 ; 194  |} StaticRscMtpDeviceInfo;
                             7481 
                             7503 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 118

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7504 ; 195  |
                             7505 ; 196  |typedef struct
                             7506 ; 197  |{
                             7507 ; 198  |    SyncObject  TransferObject;
                             7508 ; 199  |    SyncObject  InterruptObject;
                             7509 ; 200  |    WORD wDeviceNumber;
                             7510 ; 201  |    WORD wBulkInEndpointNum;
                             7511 ; 202  |    WORD _X *CommandOutBuffer;
                             7512 ; 203  |    WORD _X *CommandInBuffer;
                             7513 ; 204  |    eDevicePhase        Phase;              /**< Current device phase. */
                             7514 ; 205  |    eDeviceStatus       Status;
                             7515 ; 206  |    WORD wTransferSize;
                             7516 ; 207  |    WORD wBulkOutEndpointNum;
                             7517 ; 208  |    WORD wInterruptEndpointNum;
                             7518 ; 209  |    WORD wInterface;
                             7519 ; 210  |    BYTE                numStores;      /**< Number of valid MtpStores in the array */
                             7520 ; 211  |    DWORD               DefaultStorageID;           /**< Used when SendObjectInfo doesn't 
                                  specify StorageID. */
                             7521 ; 212  |    DWORD               DefaultParentHandle;        /**< Used when SendObjectInfo doesn't 
                                  specify Parent Object Handle. */
                             7522 ; 213  |    SUsbCmdBlock PtpCmd;
                             7523 ; 214  | //   MTP_DEVICE_INIT_FUNCTION InitializeFunction;
                             7524 ; 215  |//    MTP_DEVICE_RESET_FUNCTION ResetFunction;
                             7525 ; 216  |} USBMTP_DEVICE, *PUSBMTP_DEVICE;
                             7526 ; 217  |
                             7527 ; 218  |
                             7528 ; 219  |extern long int g_lBulkInBytes;
                             7529 ; 220  |extern long int g_lLastBulkInTime;
                             7530 ; 221  |extern long int g_lFirstBulkInTime;
                             7531 ; 222  |extern long int g_lBulkOutBytes;
                             7532 ; 223  |extern long int g_lLastBulkOutTime;
                             7533 ; 224  |extern long int g_lFirstBulkOutTime;
                             7534 
                             7553 
                             7554 ; 225  |
                             7555 ; 226  |
                             7556 ; 227  |extern USBMTP_DEVICE UsbMtpDevice;
                             7557 ; 228  |
                             7558 ; 229  |
                             7559 ; 230  |////////////////////////////////////////////////////////////////////////////////
                             7560 ; 231  |// Prototypes
                             7561 ; 232  |////////////////////////////////////////////////////////////////////////////////
                             7562 ; 233  |
                             7563 ; 234  |void _reentrant MtpHandler0(void);
                             7564 ; 235  |void _reentrant MtpHandler1(void);
                             7565 ; 236  |RETCODE _reentrant MtpCbwProcessor(WORD wNum);
                             7566 ; 237  |//RETCODE _reentrant UsbMscSendCsw(WORD wNum);
                             7567 ; 238  |RETCODE _reentrant MtpDriverInitialize(void);
                             7568 ; 239  |//RETCODE _reentrant UsbMscDeviceInitializeAll(void);
                             7569 ; 240  |//RETCODE _reentrant MtpDeviceInitialize(WORD wNum);
                             7570 ; 241  |RETCODE _reentrant MtpDeviceReset(WORD wNum);
                             7571 ; 242  |void MtpCheckStore(void);
                             7572 ; 243  |
                             7573 ; 244  |#define SECTOR_HANDLER  0x800000
                             7574 ; 245  |#define COMMAND_HANDLER 0x400000
                             7575 ; 246  |
                             7576 ; 247  |void MtpBulkOutService(BOOL bSetup, BYTE btDirection, _packed BYTE _USB_MEM *pBuffer, WORD
                                   wLength,WORD wPrivateData);
                             7577 ; 248  |void MtpBulkInService(BOOL bSetup, BYTE btDirection, _packed BYTE _USB_MEM *pBuffer, WORD 
                                  wLength,WORD wPrivateData);
                             7578 ; 249  |void MtpInterruptService(BOOL bSetup, BYTE btDirection, _packed BYTE _USB_MEM *pBuffer, WO
                                  RD wLength,WORD wPrivateData);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 119

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7579 ; 250  |void MtpResetService(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLengt
                                  h,WORD wPrivateData);
                             7580 ; 251  |void MtpResumeService(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLeng
                                  th,WORD wPrivateData);
                             7581 ; 252  |void MtpSuspendService(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLen
                                  gth,WORD wPrivateData);
                             7582 ; 253  |void _reentrant MtpLastPacketHandler(BYTE btEndPoint, WORD wDirection, DWORD dwSizeOfLastP
                                  acket, WORD wPrivateData, SyncObject * pSyncObject);
                             7583 ; 254  |
                             7584 ; 255  |//
                             7585 ; 256  |// Stall the BULKIN/OUT endpoints
                             7586 ; 257  |//
                             7587 ; 258  |void Stall(void);
                             7588 ; 259  |
                             7589 ; 260  |//
                             7590 ; 261  |// Unstall the BULKIN/OUT endpoints
                             7591 ; 262  |//
                             7592 ; 263  |void Unstall(void);
                             7593 ; 264  |
                             7594 ; 265  |//RETCODE _reentrant UsbMscCheckDiskAll(void);
                             7595 ; 266  |
                             7596 ; 267  |#define DISPLAY_USB_ACTIVE  0       // Currently reading or writing
                             7597 ; 268  |#define USB_BLINK_RATE_ON       50      // 50msec
                             7598 ; 269  |#define USB_BLINK_RATE_OFF      300     // 450mse
                             7599 ; 270  |
                             7600 ; 271  |#define PERSISTANT_BIT_FOR_LOW_POWER_MODE (HW_RTC_PERSISTANT1.B.b0)
                             7601 ; 272  |
                             7602 ; 273  |// These can be used by MTP code to signal a change in the animations used in the user int
                                  erface task
                             7603 ; 274  |// They match with SCSI_x defines in scsi.h
                             7604 ; 275  |#define MTP_IDLE      0       // Not reading or writing
                             7605 ; 276  |#define MTP_READING   1       // A read operation is in progress
                             7606 ; 277  |#define MTP_WRITING   2       // A write operation is in progress
                             7607 
                             7611 
                             7612 ; 278  |
                             7613 ; 279  |/**
                             7614 ; 280  | * Initializes the Mtp Device Info structure.
                             7615 ; 281  | *
                             7616 ; 282  | * @param pInfo Pointer to the device information structure.
                             7617 ; 283  | * @param pDevice Pointer to the device structure to initialize.
                             7618 ; 284  | */
                             7619 ; 285  |// void initMtpDeviceInfo(SMtpDeviceInfo *pInfo, USBMTP_DEVICE *pDevice);
                             7620 ; 286  |/**
                             7621 ; 287  | * Initializes the MTP device structure.
                             7622 ; 288  | *
                             7623 ; 289  | * @param pMtpDevice Pointer to the MTP device structure.
                             7624 ; 290  | * @return TRUE or FALSE depending on the initialization results.
                             7625 ; 291  | */
                             7626 ; 292  |BOOL  InitializeMtpDevice(PUSBMTP_DEVICE pMtpDevice);
                             7627 ; 293  |/**
                             7628 ; 294  | * Initializes the MTP device.  This function should only be called once
                             7629 ; 295  | * during the initialization of the device.
                             7630 ; 296  | * 
                             7631 ; 297  | * @param pMtpDevice Pointer to the MTP device structure to initialize.
                             7632 ; 298  | * @return TRUE or FALSE depending on the initialization results.
                             7633 ; 299  | */
                             7634 ; 300  |int _reentrant OneTimeInitDeviceMtpDevice(int unused1, int unused2, int * piHandle);
                             7635 ; 301  |
                             7636 ; 302  |/**
                             7637 ; 303  | * Cleans up the MTP device structure.
                             7638 ; 304  | *
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 120

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7639 ; 305  | * @param pMtpDevice Pointer to the MTP device to be cleaned up.
                             7640 ; 306  | */
                             7641 ; 307  |void  CleanupMtpDevice(USBMTP_DEVICE * pMtpDevice);
                             7642 ; 308  |/**
                             7643 ; 309  | * Resets the MTP device.
                             7644 ; 310  | *
                             7645 ; 311  | * @param pMtpDevice Pointer to the MTP device to be reset.
                             7646 ; 312  | */
                             7647 ; 313  |void  ResetDeviceMtpDevice(PUSBMTP_DEVICE pMtpDevice);
                             7648 ; 314  |/**
                             7649 ; 315  | * Gets the specified device property of the MTP device.
                             7650 ; 316  | *
                             7651 ; 317  | * @param pMtpDevice Pointer to the MTP device structure.
                             7652 ; 318  | * @param PropCode The property code to be retreived.
                             7653 ; 319  | * @return A pointer to the MTP device property structure.
                             7654 ; 320  | */SMtpDevicePropDesc*  GetDevicePropertyMtpDevice(PUSBMTP_DEVICE pMtpDevice, UINT16 PropC
                                  ode);
                             7655 ; 321  |
                             7656 ; 322  |#endif // #ifndef _MTP_H
                             7657 
                             7659 
                             7660 ; 13   |#include "mtprequests.h"
                             7661 
                             7663 
                             7664 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             7665 ; 2    |// Copyright(C) SigmaTel, Inc. 2002
                             7666 ; 3    |//
                             7667 ; 4    |// Filename: usbmscrequests.h
                             7668 ; 5    |// Description: 
                             7669 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             7670 ; 7    |
                             7671 ; 8    |#ifndef _MTPREQUESTS_H
                             7672 ; 9    |#define _MTPREQUESTS_H
                             7673 ; 10   |
                             7674 ; 11   |////////////////////////////////////////////////////////////////////////////////
                             7675 ; 12   |// Defs
                             7676 ; 13   |////////////////////////////////////////////////////////////////////////////////
                             7677 ; 14   |#define MSOS_VENDORCODE_TO_GET_MS_DESCRIPTOR    0x01
                             7678 ; 15   |#define MSOS_FEATURE_INDEX_EXTENDED_CONFIG_DESC 0x0004
                             7679 ; 16   |#define MSOS_FEATURE_INDEX_EXTENDED_PROP_DESC   0x0005
                             7680 ; 17   |
                             7681 ; 18   |#define MS_OS_NUMBER_OF_FUNCTIONS_OF_DEVICE   0x01
                             7682 ; 19   |
                             7683 ; 20   |#define HOST_TO_DEVICE          (0<<7)  // xfer direction OUT
                             7684 ; 21   |#define DEVICE_TO_HOST          (1<<7)  // xfer direction IN
                             7685 ; 22   |//
                             7686 ; 23   |#define STANDARD                (0<<5)  // Type
                             7687 ; 24   |#define CLASS                   (1<<5)  // Type
                             7688 ; 25   |#define VENDOR                  (2<<5)  // Type
                             7689 ; 26   |#define RESERVED                (3<<5)  // Type
                             7690 ; 27   |// 
                             7691 ; 28   |#define RECIPIENT_DEVICE        0       // Recipient
                             7692 ; 29   |#define RECIPIENT_INTERFACE     1       // Recipient
                             7693 ; 30   |#define RECIPIENT_ENDPOINT      2       // Recipient
                             7694 ; 31   |#define RECIPIENT_OTHER         3       // Recipient
                             7695 ; 32   |////////////////////////////////////////////////////////////////////////////////
                             7696 ; 33   |// Errors
                             7697 ; 34   |////////////////////////////////////////////////////////////////////////////////
                             7698 ; 35   |
                             7699 ; 36   |////////////////////////////////////////////////////////////////////////////////
                             7700 ; 37   |// Typedefs
                             7701 ; 38   |////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 121

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7702 ; 39   |typedef struct _MSOS_EXT_CONFIG_DESCRIPTOR_HEADER
                             7703 ; 40   |{
                             7704 ; 41   |    UINT32 dwLength;         // Length of the entire Extended Configuration Descriptor
                             7705 ; 42   |    UINT16 bcdVersion;       // Version info in BCD: 0x0100 ~ 1.00
                             7706 ; 43   |    UINT16 wIndex;           // must be MSOS_FEATURE_INDEX_EXTENDED_CONFIG_DESC, or 0x0004
                                  
                             7707 ; 44   |    BYTE  bCount;           // total number of Function Sections that follow the header se
                                  ction
                             7708 ; 45   |    BYTE  bReserved[7];     // RESERVED, should be 0x00
                             7709 ; 46   |}   MSOS_EXT_CONFIG_DESCRIPTOR_HEADER , *PMSOS_EXT_CONFIG_DESCRIPTOR_HEADER ;
                             7710 ; 47   |
                             7711 ; 48   |typedef struct _MSOS_EXT_CONFIG_DESCRIPTOR_FUNCTION
                             7712 ; 49   |{
                             7713 ; 50   |    BYTE  bFirstInterfaceNumber; // Starting Interface Number for this function
                             7714 ; 51   |    BYTE  bInterfaceCount;       // Total number of interfaces 
                             7715 ; 52   |    BYTE  compatibleID[8];       // Compatible ID as defined by Microsoft
                             7716 ; 53   |    BYTE  subCompatibleID[8];    // The Sub Compatible ID as defined by Microsoft
                             7717 ; 54   |    BYTE  bReserved[6];          // RESERVED, should be 0x00
                             7718 ; 55   |}   MSOS_EXT_CONFIG_DESCRIPTOR_FUNCTION , *PMSOS_EXT_CONFIG_DESCRIPTOR_FUNCTION ;
                             7719 ; 56   |
                             7720 ; 57   |typedef struct _MSOS_EXT_PROP_DESCRIPTOR_HEADER
                             7721 ; 58   |{
                             7722 ; 59   |    UINT32 dwLength;         // Length of the entire Extended Property Descriptor
                             7723 ; 60   |    UINT16 bcdVersion;       // Version info in BCD: 0x0100 ~ 1.00
                             7724 ; 61   |    UINT16 wIndex;           // must be MSOS_FEATURE_INDEX_EXTENDED_PROP_DESC, or 0x0005
                             7725 ; 62   |    UINT16 wCount;           // total number of Custom Proeprty Sections that follow the h
                                  eader section
                             7726 ; 63   |}   MSOS_EXT_PROP_DESCRIPTOR_HEADER , *PMSOS_EXT_PROP_DESCRIPTOR_HEADER ;
                             7727 
                             7745 
                             7746 ; 64   |
                             7747 ; 65   |typedef struct _MS_OS_EXTENDED_CONFIGURATION_DESCRIPTOR
                             7748 ; 66   |{   // A USB configuration contains all interfaces and all endpoint descriptors
                             7749 ; 67   |    MSOS_EXT_CONFIG_DESCRIPTOR_HEADER   HeaderSection;
                             7750 ; 68   |    MSOS_EXT_CONFIG_DESCRIPTOR_FUNCTION FunctionSection[MS_OS_NUMBER_OF_FUNCTIONS_OF_DEVIC
                                  E];
                             7751 ; 69   |} MS_OS_EXTENDED_CONFIGURATION_DESCRIPTOR, * PMS_OS_EXTENDED_CONFIGURATION_DESCRIPTOR;
                             7752 ; 70   |
                             7753 ; 71   |////////////////////////////////////////////////////////////////////////////////
                             7754 ; 72   |// Prototypes
                             7755 ; 73   |////////////////////////////////////////////////////////////////////////////////
                             7756 ; 74   |void _reentrant MTPRequestHandler(BOOL bSetup, BYTE btDirection, WORD  _X *pbtBuffer, WORD
                                   wLength,WORD wPrivateData);
                             7757 ; 75   |
                             7758 ; 76   |
                             7759 ; 77   |
                             7760 ; 78   |#endif // #ifndef _MTPREQUESTS_H
                             7761 
                             7763 
                             7764 ; 14   |
                             7765 ; 15   |#include "sysserialnumber.h"
                             7766 
                             7768 
                             7769 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             7770 ; 2    |// Copyright(C) SigmaTel, Inc. 2002-2003
                             7771 ; 3    |//
                             7772 ; 4    |// Filename: sysserialnumber.h
                             7773 ; 5    |// Description: 
                             7774 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             7775 ; 7    |
                             7776 ; 8    |#ifndef _SYSSERIALNUMBER_H
                             7777 ; 9    |#define _SYSSERIALNUMBER_H
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 122

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7778 ; 10   |
                             7779 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             7780 ; 12   |// Definitions
                             7781 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             7782 ; 14   |#define CHIP_ID_BYTES       (INT)8     // Currently 64 bits.
                             7783 ; 15   |#define CHIP_ID_DIGITS      (INT)(CHIP_ID_BYTES*2)
                             7784 ; 16   |#define CHIP_ID_LOOPS1      (INT)((CHIP_ID_DIGITS+5)/6)
                             7785 ; 17   |#define CHIP_ID_LOOPS2      (INT)(CHIP_ID_DIGITS/3)
                             7786 ; 18   |
                             7787 ; 19   |#define MMC_CARD_TYPE_SD_PSN_SIZE_BYTES 4
                             7788 ; 20   |#define MMC_CARD_TYPE_NONSD_SPEC14_SN_SIZE_BYTES 12
                             7789 ; 21   |#define MMC_CARD_TYPE_NONSD_SPEC20AND31_SN_SIZE_BYTES 4
                             7790 ; 22   |
                             7791 ; 23   |#define NUM_RAW_SERIAL_NUMBER_BYTES         8
                             7792 ; 24   |#define NUM_RAW_SERIAL_NUMBER_BYTES_NULL    10
                             7793 ; 25   |#define MAX_NUM_RAW_SERIAL_NUMBER_WORDS     7
                             7794 ; 26   |#define MAX_NUM_ASCII_SERIAL_NUMBER_WORDS (MMC_CARD_TYPE_NONSD_SPEC14_SN_SIZE_BYTES*2)
                             7795 ; 27   |
                             7796 ; 28   |
                             7797 ; 29   |///////////////////////////////////////////////////////////////////////////////
                             7798 ; 30   |// Error codes
                             7799 ; 31   |///////////////////////////////////////////////////////////////////////////////
                             7800 ; 32   |
                             7801 ; 33   |///////////////////////////////////////////////////////////////////////////////
                             7802 ; 34   |// Structure definitions
                             7803 ; 35   |///////////////////////////////////////////////////////////////////////////////
                             7804 ; 36   |typedef struct {
                             7805 ; 37   |    WORD wRawSizeInBytes;
                             7806 ; 38   |    WORD wAsciiSizeInBytes;
                             7807 ; 39   |    WORD wRaw[MAX_NUM_RAW_SERIAL_NUMBER_WORDS];
                             7808 ; 40   |    BYTE btAscii[MAX_NUM_ASCII_SERIAL_NUMBER_WORDS];
                             7809 ; 41   |} SERIAL_NUMBER, * P_SERIAL_NUMBER;
                             7810 ; 42   |
                             7811 ; 43   |///////////////////////////////////////////////////////////////////////////////
                             7812 ; 44   |// Prototypes
                             7813 ; 45   |///////////////////////////////////////////////////////////////////////////////
                             7814 ; 46   |
                             7815 ; 47   |RETCODE _reentrant ChipSerialNumberInit(void);
                             7816 ; 48   |RETCODE _reentrant InternalMediaSerialNumberInit(void);
                             7817 ; 49   |
                             7818 ; 50   |// The following two functions are project-specific and should be defined in
                             7819 ; 51   |//  the project/system/miscproject.c file
                             7820 ; 52   |RETCODE _reentrant SerialNumberEnableInit(void);
                             7821 ; 53   |BOOL _reentrant SerialNumbersEnabled(void);
                             7822 ; 54   |
                             7823 ; 55   |// The two helper functions below are driver-private and not part of the API. Shared with 
                                  MMC.
                             7824 ; 56   |RETCODE _reentrant ChipGetSerialNumber(WORD * pwBuffer);
                             7825 
                             7835 
                             7836 ; 57   |RETCODE _reentrant CreateNullSerialNumber(P_SERIAL_NUMBER pSerialNumber);
                             7837 ; 58   |WORD _reentrant ConvertHexToASCII(WORD wInHex);
                             7838 
                             7840 
                             7841 ; 59   |
                             7842 ; 60   |extern _Y SERIAL_NUMBER g_ChipSerialNumber;
                             7843 ; 61   |extern _Y SERIAL_NUMBER g_InternalMediaSerialNumber;
                             7844 ; 62   |extern SERIAL_NUMBER g_MmcSerialNumber;
                             7845 ; 63   |
                             7846 ; 64   |#endif // #ifndef _SYSSERIALNUMBER_H
                             7847 
                             7869 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 123

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7870 ; 16   |
                             7871 ; 17   |// Defined, allocated and initialized in project specific file usbstrings.asm
                             7872 ; 18   |
                             7873 ; 19   |Struct_Standard_Dev_Desc _USB_MEM StDescDevice = {
                             7874 
                             7875 
Y:0000                       7876         org     y,".ydatadescriptors_3500",init:
                             7877 FStDescDevice:
Y:0000 000012 000001         7878         dc      $12,$01,$00,$02,$00,$00,$00,"@","o",$06,$00,"5",$00,$00,$01,$02,$03,$01
       000000 000002              
       000000 000000              
       000000 000040              
       00006F 000006              
       000000 000035              
       000000 000000              
       000001 000002              
       000003 000001              
                             7893 
                             7894 ; 20   |    SIZE_DEVICE_DESCRIPTOR_IN_BYTES,    // (0) Size of this descriptor in bytes (18)
                             7895 ; 21   |    DESCRIPTOR_TYPE_DEVICE,             // (1) Device descriptor type (1)
                             7896 ; 22   |    0x00,                               // (2) USB specification release number (for versi
                                  on 2.00 0x00)
                             7897 ; 23   |    0x02,                               // (3)                                  (for versi
                                  on 2.00 0x02)     
                             7898 ; 24   |    0x00,                               // (4) Class code
                             7899 ; 25   |    0x00,                               // (5) Subclass code
                             7900 ; 26   |    0x00,                               // (6) Protocol code
                             7901 ; 27   |    64,                                 // (7) Maximum packet size for endpoint 0 (8, 16, 
                                  32 or 64)
                             7902 ; 28   |    0x6f,                               // (8) Vendor Id 
                             7903 ; 29   |    0x06,                               // (9)
                             7904 ; 30   |    0x00,                               // (10) Product Id - Auto fill by reading Revision
                                   Register
                             7905 ; 31   |    0x35,                               // (11)
                             7906 ; 32   |    0,                                  // (12) Device release number in BCD - Auto fill i
                                  n
                             7907 ; 33   |    0,                                  // (13) by reading the REVID Register
                             7908 ; 34   |    0x01,                               // (14) Index of string descriptor describing Manu
                                  facturer
                             7909 ; 35   |    0x02,                               // (15) Index of string descriptor describing Prod
                                  uct
                             7910 ; 36   |    0x03,                               // (16) Index of string descriptor describing Devi
                                  ce Serial Number
                             7911 ; 37   |    1                                   // (17) Number of possible configurations
                             7912 ; 38   |};
                             7913 ; 39   |
                             7914 ; 40   |
                             7915 ; 41   |//================================================================================
                             7916 ; 42   |// Describes information about a high-speed capable device that would change if
                             7917 ; 43   |// the device were operating at the other speed.
                             7918 ; 44   |//
                             7919 ; 45   |// In this application, the device operates in the same manner at both speeds.
                             7920 ; 46   |//================================================================================
                             7921 ; 47   |Struct_Dev_Qualifier_Desc _USB_MEM StDescDeviceQualFs = {
                             7922 
                             7923 FStDescDeviceQualFs:
Y:0012 00000A 000006         7924         dc      $0a,$06,$00,$02,$00,$00,$00,"@",$01,$00
       000000 000002              
       000000 000000              
       000000 000040              
       000001 000000              
                             7927 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 124

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7928 ; 48   |    SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES,  // (0) Size of this descriptor in bytes (1
                                  0)
                             7929 ; 49   |    DESCRIPTOR_TYPE_DEVICE_QUALIFIER,   // (1) Device descriptor type (6)
                             7930 ; 50   |    0x00,                               // (2) USB specification release number (for versi
                                  on 2.00 0x00)
                             7931 ; 51   |    0x02,                               // (3)                                  (for versi
                                  on 2.00 0x02)     
                             7932 ; 52   |    0x00,                               // (4) Class code
                             7933 ; 53   |    0x00,                               // (5) Subclass code
                             7934 ; 54   |    0x00,                               // (6) Protocol code
                             7935 ; 55   |    64,                                 // (7) Maximum packet size for endpoint 0 (8, 16, 
                                  32 or 64)
                             7936 ; 56   |    1,                                  // (8) Number of possible configurations
                             7937 ; 57   |    0x00                                // (9) Reserved must be zero
                             7938 ; 58   |};
                             7939 ; 59   |
                             7940 ; 60   |Struct_Dev_Qualifier_Desc _USB_MEM StDescDeviceQualHs = {
                             7941 
                             7942 FStDescDeviceQualHs:
Y:001C 00000A 000006         7943         dc      $0a,$06,$00,$02,$00,$00,$00,"@",$01,$00
       000000 000002              
       000000 000000              
       000000 000040              
       000001 000000              
                             7957 
                             7958 ; 61   |    SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES,  // (0) Size of this descriptor in bytes (1
                                  0)
                             7959 ; 62   |    DESCRIPTOR_TYPE_DEVICE_QUALIFIER,   // (1) Device descriptor type (6)
                             7960 ; 63   |    0x00,                               // (2) USB specification release number (for versi
                                  on 2.00 0x00)
                             7961 ; 64   |    0x02,                               // (3)                                  (for versi
                                  on 2.00 0x02)     
                             7962 ; 65   |    0x00,                               // (4) Class code
                             7963 ; 66   |    0x00,                               // (5) Subclass code
                             7964 ; 67   |    0x00,                               // (6) Protocol code
                             7965 ; 68   |    64,                                 // (7) Maximum packet size for endpoint 0 (8, 16, 
                                  32 or 64)
                             7966 ; 69   |    1,                                  // (8) Number of possible configurations
                             7967 ; 70   |    0x00                                // (9) Reserved must be zero
                             7968 ; 71   |};
                             7969 ; 72   |
                             7970 ; 73   |
                             7971 ; 74   |
                             7972 ; 75   |// Full/High Speed Device Descriptor
                             7973 ; 76   |// Members (2) and (3) are filled automatically
                             7974 ; 77   |Struct_Standard_Config_Desc _USB_MEM StDescConfig = {
                             7975 
                             7976 FStDescConfig:
Y:0026 000009 000002         7977         dc      $09,$02,$00,$00
       000000 000000              
                             7978 
                             7979 ; 78   |        // Config Descriptor
                             7980 ; 79   |        SIZE_CONFIG_DESCRIPTOR_IN_BYTES,    // (0) Size of this descriptor in bytes (9)
                             7981 ; 80   |        DESCRIPTOR_TYPE_CONFIG,             // (1) Device descriptor type (2 or 7)
                             7982 ; 81   |        0x00,                               // (2) Total length of data returned for this 
                                  config.
                             7983 ; 82   |        0x00,                               // (3)                                  
                             7984 ; 83   |#if ((NUM_REMOVABLE_MEDIA == 1) && (MULTI_LUN_BUILD==0))
                             7985 ; 84   |        2,                                  // (4) Number of Interfaces supported by this 
                                  configuration
                             7986 ; 85   |#else
                             7987 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 125

M:ADDR CODE           CYCLES LINE SOURCELINE
Y:002A 000001                7988         dc      $01
                             7989 
                             7990 ; 86   |        1,
                             7991 ; 87   |#endif
                             7992 
Y:002B 000001 000004         7993         dc      $01,$04,"",$fa
       000080 0000FA              
                             8007 
                             8008 ; 88   |        0x01,                               // (5) Value to use as an argument to the SetC
                                  onfiguration() request
                             8009 ; 89   |        0x04,                               // (6) Index of string descriptor describing t
                                  his configuration
                             8010 ; 90   |        0x80,                               // (7) Configuration Characteristics
                             8011 ; 91   |                                            //     D7:      Reserved (set to one)
                             8012 ; 92   |                                            //     D6:      Self-powered
                             8013 ; 93   |                                            //     D5:      Remote Wakeup
                             8014 ; 94   |                                            //     D4..0:   Reserved (reset to zero)      
                                    
                             8015 ; 95   |                                            // (8) Maximum USB current expressed in 2mA un
                                  its. 0xFA gives 500mA. 0x32 for 100mA.
                             8016 ; 96   |                                            //     In non (battery charge or MMC builds), 
                                  early API call sets this field for 100mA.
                             8017 ; 97   |       0xFA
                             8018 ; 98   |    };
                             8019 ; 99   |
                             8020 ; 100  |    
                             8021 ; 101  |// This interface is used for both Configs (Full and High Speed)
                             8022 ; 102  |Struct_Standard_Interface_Desc _USB_MEM StDescInterface0 = {
                             8023 
                             8024 FStDescInterface0:
Y:002F 000009 000004         8025         dc      $09,$04,$00,$00,$02,$08,$06,"P",$05
       000000 000000              
       000002 000008              
       000006 000050              
       000005                     
                             8037 
                             8038 ; 103  |        // Interface Descriptor (One unique interface)
                             8039 ; 104  |        SIZE_INTERFACE_DESCRIPTOR_IN_BYTES, // (0) Size of this descriptor in bytes (9)
                             8040 ; 105  |        DESCRIPTOR_TYPE_INTERFACE,          // (1) Device descriptor type (4)
                             8041 ; 106  |        0x00,                               // (2) Number of this interface. Zero-based va
                                  lue.
                             8042 ; 107  |        0x00,                               // (3)                                  
                             8043 ; 108  |        2,                                  // (4) Number of endpointsused by this interfa
                                  ce (excluding endpoint 0).
                             8044 ; 109  |        USB_INTERFACE_CLASS_MASS_STORAGE,   // (5) Class code
                             8045 ; 110  |        USB_INTERFACE_SUB_CLASS_SCSI_TRANSPARENT_COMMAND_SET,// (6) Sub Class code
                             8046 ; 111  |        USB_INTERFACE_PROTOCOL_BULK_ONLY,   // (7) Protocol Code
                             8047 ; 112  |        0x05                                // (8) Index of string descriptor describing t
                                  his interface
                             8048 ; 113  |    };            
                             8049 ; 114  |
                             8050 ; 115  |// Endpoint #1 for Full Speed Configuration
                             8051 ; 116  |Struct_Standard_Endpoint_Desc _USB_MEM StDescEndPoint1FS = {
                             8052 
                             8053 FStDescEndPoint1FS:
Y:0038 000007 000005         8054         dc      $07,$05,$81,$02,"@",$00,$00
       000081 000002              
       000040 000000              
       000000                     
                             8057 
                             8058 ; 117  |        // Endpoint Descriptor 
                             8059 ; 118  |        SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES,  // (0) Size of this descriptor in bytes (7)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 126

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8060 ; 119  |        DESCRIPTOR_TYPE_ENDPOINT,           // (1) Device descriptor type (5)
                             8061 ; 120  |        0x81,                               // (2) Address of the endpoint on the USB devi
                                  ce described by this descriptor
                             8062 ; 121  |                                            //      Bit 3..0: Endpoint number
                             8063 ; 122  |                                            //      Bit 6..4: Reserved, reset to zero
                             8064 ; 123  |                                            //      Bit 7:    Direction. Ignored for contr
                                  ol endpoints (0 OUT, 1 IN)
                             8065 ; 124  |        0x02,                               // (3) Endpoint attributes
                             8066 ; 125  |                                            //      bits 1..0: Transfer Type (00 Control, 
                                  01 Iso, 10 Bulk, 11 Int)
                             8067 ; 126  |                                            //      bits 5..2: If not an iso endpoints, th
                                  ey are reserved and must be reset to zero.
                             8068 ; 127  |                                            //      bits 7..6: Reserved bits, must be rese
                                  t to zero.                                    
                             8069 ; 128  |        EP_FS_MAX_PACKET_SIZE,              // (4) Maximum packet size. Refer to standard 
                                  for bits specification
                             8070 ; 129  |        0x00,                               // (5)
                             8071 ; 130  |        0x00                                // (6) Interval for polling endpoint for data 
                                  transfers (refer to standard)
                             8072 ; 131  |    };
                             8073 ; 132  |Struct_Standard_Endpoint_Desc _USB_MEM StDescEndPoint2FS = {
                             8074 
                             8075 FStDescEndPoint2FS:
Y:003F 000007 000005         8076         dc      $07,$05,$02,$02,"@",$00,$00
       000002 000002              
       000040 000000              
       000000                     
                             8079 
                             8080 ; 133  |        // Endpoint Descriptor 
                             8081 ; 134  |        SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES,  // (0) Size of this descriptor in bytes (7)
                             8082 ; 135  |        DESCRIPTOR_TYPE_ENDPOINT,           // (1) Device descriptor type (5)
                             8083 ; 136  |        0x02,                               // (2) Address of the endpoint on the USB devi
                                  ce described by this descriptor
                             8084 ; 137  |                                            //      Bit 3..0: Endpoint number
                             8085 ; 138  |                                            //      Bit 6..4: Reserved, reset to zero
                             8086 ; 139  |                                            //      Bit 7:    Direction. Ignored for contr
                                  ol endpoints (0 OUT, 1 IN)
                             8087 ; 140  |        0x02,                               // (3) Endpoint attributes
                             8088 ; 141  |                                            //      bits 1..0: Transfer Type (00 Control, 
                                  01 Iso, 10 Bulk, 11 Int)
                             8089 ; 142  |                                            //      bits 5..2: If not an iso endpoints, th
                                  ey are reserved and must be reset to zero.
                             8090 ; 143  |                                            //      bits 7..6: Reserved bits, must be rese
                                  t to zero.                                    
                             8091 ; 144  |        EP_FS_MAX_PACKET_SIZE,              // (4) Maximum packet size. Refer to standard 
                                  for bits specification
                             8092 ; 145  |        0x00,                               // (5)
                             8093 ; 146  |        0x00                                // (6) Interval for polling endpoint for data 
                                  transfers (refer to standard)
                             8094 ; 147  |    };
                             8095 ; 148  |
                             8096 ; 149  |Struct_Standard_Endpoint_Desc _USB_MEM StDescEndPoint1HS = {
                             8097 
                             8098 FStDescEndPoint1HS:
Y:0046 000007 000005         8099         dc      $07,$05,$81,$02,$00,$02,$00
       000081 000002              
       000000 000002              
       000000                     
                             8102 
                             8103 ; 150  |        // Endpoint Descriptor 
                             8104 ; 151  |        SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES,  // (0) Size of this descriptor in bytes (7)
                             8105 ; 152  |        DESCRIPTOR_TYPE_ENDPOINT,           // (1) Device descriptor type (5)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 127

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8106 ; 153  |        0x81,                               // (2) Address of the endpoint on the USB devi
                                  ce described by this descriptor
                             8107 ; 154  |                                            //      Bit 3..0: Endpoint number
                             8108 ; 155  |                                            //      Bit 6..4: Reserved, reset to zero
                             8109 ; 156  |                                            //      Bit 7:    Direction. Ignored for contr
                                  ol endpoints (0 OUT, 1 IN)
                             8110 ; 157  |        0x02,                               // (3) Endpoint attributes
                             8111 ; 158  |                                            //      bits 1..0: Transfer Type (00 Control, 
                                  01 Iso, 10 Bulk, 11 Int)
                             8112 ; 159  |                                            //      bits 5..2: If not an iso endpoints, th
                                  ey are reserved and must be reset to zero.
                             8113 ; 160  |                                            //      bits 7..6: Reserved bits, must be rese
                                  t to zero.                                    
                             8114 ; 161  |        (EP_HS_MAX_PACKET_SIZE & 0xff),     // (4) Maximum packet size. Refer to standard 
                                  for bits specification
                             8115 ; 162  |        ((EP_HS_MAX_PACKET_SIZE >> 8) & 0xff), // (5)
                             8116 ; 163  |        0x00                                // (6) Interval for polling endpoint for data 
                                  transfers (refer to standard)
                             8117 ; 164  |    };
                             8118 ; 165  |Struct_Standard_Endpoint_Desc _USB_MEM StDescEndPoint2HS = {
                             8119 
                             8120 FStDescEndPoint2HS:
Y:004D 000007 000005         8121         dc      $07,$05,$02,$02,$00,$02,$00
       000002 000002              
       000000 000002              
       000000                     
                             8124 
                             8125 ; 166  |        // Endpoint Descriptor 
                             8126 ; 167  |        SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES,  // (0) Size of this descriptor in bytes (7)
                             8127 ; 168  |        DESCRIPTOR_TYPE_ENDPOINT,           // (1) Device descriptor type (5)
                             8128 ; 169  |        0x02,                               // (2) Address of the endpoint on the USB devi
                                  ce described by this descriptor
                             8129 ; 170  |                                            //      Bit 3..0: Endpoint number
                             8130 ; 171  |                                            //      Bit 6..4: Reserved, reset to zero
                             8131 ; 172  |                                            //      Bit 7:    Direction. Ignored for contr
                                  ol endpoints (0 OUT, 1 IN)
                             8132 ; 173  |        0x02,                               // (3) Endpoint attributes
                             8133 ; 174  |                                            //      bits 1..0: Transfer Type (00 Control, 
                                  01 Iso, 10 Bulk, 11 Int)
                             8134 ; 175  |                                            //      bits 5..2: If not an iso endpoints, th
                                  ey are reserved and must be reset to zero.
                             8135 ; 176  |                                            //      bits 7..6: Reserved bits, must be rese
                                  t to zero.                                    
                             8136 ; 177  |        (EP_HS_MAX_PACKET_SIZE & 0xff),     // (4) Maximum packet size. Refer to standard 
                                  for bits specification
                             8137 ; 178  |        ((EP_HS_MAX_PACKET_SIZE >> 8) & 0xff), // (5)
                             8138 ; 179  |        0x00                                // (6) Interval for polling endpoint for data 
                                  transfers (refer to standard)
                             8139 ; 180  |    };
                             8140 ; 181  |
                             8141 ; 182  |
                             8142 ; 183  |#if ((NUM_REMOVABLE_MEDIA == 1) && (MULTI_LUN_BUILD==0))
                             8143 ; 184  |Struct_Standard_Interface_Desc _USB_MEM StDescInterface1 = {
                             8144 ; 185  |        // Interface Descriptor (One unique interface)
                             8145 ; 186  |        SIZE_INTERFACE_DESCRIPTOR_IN_BYTES, // (0) Size of this descriptor in bytes (9)
                             8146 ; 187  |        DESCRIPTOR_TYPE_INTERFACE,          // (1) Device descriptor type (4)
                             8147 ; 188  |        0x01,                               // (2) Number of this interface. Zero-based va
                                  lue.
                             8148 ; 189  |        0x00,                               // (3)                                  
                             8149 ; 190  |        2,                                  // (4) Number of endpointsused by this interfa
                                  ce (excluding endpoint 0).
                             8150 ; 191  |        USB_INTERFACE_CLASS_MASS_STORAGE,   // (5) Class code
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 128

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8151 ; 192  |        USB_INTERFACE_SUB_CLASS_SCSI_TRANSPARENT_COMMAND_SET,// (6) Sub Class code
                             8152 ; 193  |        USB_INTERFACE_PROTOCOL_BULK_ONLY,   // (7) Protocol Code
                             8153 ; 194  |        0x06                                // (8) Index of string descriptor describing t
                                  his interface
                             8154 ; 195  |    };            
                             8155 ; 196  |
                             8156 ; 197  |Struct_Standard_Endpoint_Desc _USB_MEM StDescEndPoint2FS = {
                             8157 ; 198  |        // Endpoint Descriptor 
                             8158 ; 199  |        SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES,  // (0) Size of this descriptor in bytes (7)
                             8159 ; 200  |        DESCRIPTOR_TYPE_ENDPOINT,           // (1) Device descriptor type (5)
                             8160 ; 201  |        0x02,                               // (2) Address of the endpoint on the USB devi
                                  ce described by this descriptor
                             8161 ; 202  |                                            //      Bit 3..0: Endpoint number
                             8162 ; 203  |                                            //      Bit 6..4: Reserved, reset to zero
                             8163 ; 204  |                                            //      Bit 7:    Direction. Ignored for contr
                                  ol endpoints (0 OUT, 1 IN)
                             8164 ; 205  |        0x02,                               // (3) Endpoint attributes
                             8165 ; 206  |                                            //      bits 1..0: Transfer Type (00 Control, 
                                  01 Iso, 10 Bulk, 11 Int)
                             8166 ; 207  |                                            //      bits 5..2: If not an iso endpoints, th
                                  ey are reserved and must be reset to zero.
                             8167 ; 208  |                                            //      bits 7..6: Reserved bits, must be rese
                                  t to zero.                                    
                             8168 ; 209  |        EP_FS_MAX_PACKET_SIZE,              // (4) Maximum packet size. Refer to standard 
                                  for bits specification
                             8169 ; 210  |        0,                                  // (5)
                             8170 ; 211  |        0x00                                // (6) Interval for polling endpoint for data 
                                  transfers (refer to standard)
                             8171 ; 212  |    };
                             8172 ; 213  |
                             8173 ; 214  |Struct_Standard_Endpoint_Desc _USB_MEM StDescEndPoint5FS = {
                             8174 ; 215  |        // Endpoint Descriptor 
                             8175 ; 216  |        SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES,  // (0) Size of this descriptor in bytes (7)
                             8176 ; 217  |        DESCRIPTOR_TYPE_ENDPOINT,           // (1) Device descriptor type (5)
                             8177 ; 218  |        0x85,                               // (2) Address of the endpoint on the USB devi
                                  ce described by this descriptor
                             8178 ; 219  |                                            //      Bit 3..0: Endpoint number
                             8179 ; 220  |                                            //      Bit 6..4: Reserved, reset to zero
                             8180 ; 221  |                                            //      Bit 7:    Direction. Ignored for contr
                                  ol endpoints (0 OUT, 1 IN)
                             8181 ; 222  |        0x02,                               // (3) Endpoint attributes
                             8182 ; 223  |                                            //      bits 1..0: Transfer Type (00 Control, 
                                  01 Iso, 10 Bulk, 11 Int)
                             8183 ; 224  |                                            //      bits 5..2: If not an iso endpoints, th
                                  ey are reserved and must be reset to zero.
                             8184 ; 225  |                                            //      bits 7..6: Reserved bits, must be rese
                                  t to zero.                                    
                             8185 ; 226  |        EP_FS_MAX_PACKET_SIZE,              // (4) Maximum packet size. Refer to standard 
                                  for bits specification
                             8186 ; 227  |        0,                                  // (5)
                             8187 ; 228  |        0x00                                // (6) Interval for polling endpoint for data 
                                  transfers (refer to standard)
                             8188 ; 229  |    };
                             8189 ; 230  |Struct_Standard_Endpoint_Desc _USB_MEM StDescEndPoint2HS = {
                             8190 ; 231  |        // Endpoint Descriptor 
                             8191 ; 232  |        SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES,  // (0) Size of this descriptor in bytes (7)
                             8192 ; 233  |        DESCRIPTOR_TYPE_ENDPOINT,           // (1) Device descriptor type (5)
                             8193 ; 234  |        0x02,                               // (2) Address of the endpoint on the USB devi
                                  ce described by this descriptor
                             8194 ; 235  |                                            //      Bit 3..0: Endpoint number
                             8195 ; 236  |                                            //      Bit 6..4: Reserved, reset to zero
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 129

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8196 ; 237  |                                            //      Bit 7:    Direction. Ignored for contr
                                  ol endpoints (0 OUT, 1 IN)
                             8197 ; 238  |        0x02,                               // (3) Endpoint attributes
                             8198 ; 239  |                                            //      bits 1..0: Transfer Type (00 Control, 
                                  01 Iso, 10 Bulk, 11 Int)
                             8199 ; 240  |                                            //      bits 5..2: If not an iso endpoints, th
                                  ey are reserved and must be reset to zero.
                             8200 ; 241  |                                            //      bits 7..6: Reserved bits, must be rese
                                  t to zero.                                    
                             8201 ; 242  |        (EP_HS_MAX_PACKET_SIZE & 0xff),     // (4) Maximum packet size. Refer to standard 
                                  for bits specification
                             8202 ; 243  |        ((EP_HS_MAX_PACKET_SIZE>>8)&0xff),  // (5)
                             8203 ; 244  |        0x00                                // (6) Interval for polling endpoint for data 
                                  transfers (refer to standard)
                             8204 ; 245  |    };
                             8205 ; 246  |
                             8206 ; 247  |Struct_Standard_Endpoint_Desc _USB_MEM StDescEndPoint5HS = {
                             8207 ; 248  |        // Endpoint Descriptor 
                             8208 ; 249  |        SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES,  // (0) Size of this descriptor in bytes (7)
                             8209 ; 250  |        DESCRIPTOR_TYPE_ENDPOINT,           // (1) Device descriptor type (5)
                             8210 ; 251  |        0x85,                               // (2) Address of the endpoint on the USB devi
                                  ce described by this descriptor
                             8211 ; 252  |                                            //      Bit 3..0: Endpoint number
                             8212 ; 253  |                                            //      Bit 6..4: Reserved, reset to zero
                             8213 ; 254  |                                            //      Bit 7:    Direction. Ignored for contr
                                  ol endpoints (0 OUT, 1 IN)
                             8214 ; 255  |        0x02,                               // (3) Endpoint attributes
                             8215 ; 256  |                                            //      bits 1..0: Transfer Type (00 Control, 
                                  01 Iso, 10 Bulk, 11 Int)
                             8216 ; 257  |                                            //      bits 5..2: If not an iso endpoints, th
                                  ey are reserved and must be reset to zero.
                             8217 ; 258  |                                            //      bits 7..6: Reserved bits, must be rese
                                  t to zero.                                    
                             8218 ; 259  |        (EP_HS_MAX_PACKET_SIZE & 0xff),     // (4) Maximum packet size. Refer to standard 
                                  for bits specification
                             8219 ; 260  |        ((EP_HS_MAX_PACKET_SIZE>>8)&0xff),  // (5)
                             8220 ; 261  |        0x00                                // (6) Interval for polling endpoint for data 
                                  transfers (refer to standard)
                             8221 ; 262  |    };
                             8222 ; 263  |#endif
                             8223 ; 264  |
                             8224 ; 265  |
                             8225 ; 266  |/////////////////////////////////////////////////////////////////////////////
                             8226 ; 267  |//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IMPORTANT !!!!!!!!!!!! !!!!!!!!!!!!!!!!!
                             8227 ; 268  |// Terminate the configuration rule with a NULL pointer
                             8228 ; 269  |/////////////////////////////////////////////////////////////////////////////
                             8229 ; 270  |BYTE _USB_MEM * Config1FSRule[] = 
                             8230 
                             8231 FConfig1FSRule:
Y:0054 rrrrrr rrrrrr         8232         dc      FStDescConfig,FStDescInterface0,FStDescEndPoint1FS,FStDescEndPoint2FS
       rrrrrr rrrrrr              
                             8233 
                             8234 ; 271  |            { // Full Speed Configuration
                             8235 ; 272  |                (BYTE _USB_MEM *) &StDescConfig,
                             8236 ; 273  |                (BYTE _USB_MEM *) &StDescInterface0,
                             8237 ; 274  |                (BYTE _USB_MEM *) &StDescEndPoint1FS,
                             8238 ; 275  |                (BYTE _USB_MEM *) &StDescEndPoint2FS,
                             8239 ; 276  |#if ((NUM_REMOVABLE_MEDIA == 1) && (MULTI_LUN_BUILD==0))
                             8240 ; 277  |                (BYTE _USB_MEM *) &StDescInterface1,
                             8241 ; 278  |                (BYTE _USB_MEM *) &StDescEndPoint2FS,
                             8242 ; 279  |                (BYTE _USB_MEM *) &StDescEndPoint5FS,
                             8243 ; 280  |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 130

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8244 
Y:0058 000000                8245         dc      $000000
                             8249 
                             8250 ; 281  |                NULL
                             8251 ; 282  |            };
                             8252 ; 283  |BYTE _USB_MEM * Config1HSRule[] = 
                             8253 
                             8254 FConfig1HSRule:
Y:0059 rrrrrr rrrrrr         8255         dc      FStDescConfig,FStDescInterface0,FStDescEndPoint1HS,FStDescEndPoint2HS
       rrrrrr rrrrrr              
                             8256 
                             8257 ; 284  |            { // High Speed Configuration
                             8258 ; 285  |                (BYTE _USB_MEM *) &StDescConfig,
                             8259 ; 286  |                (BYTE _USB_MEM *) &StDescInterface0,
                             8260 ; 287  |                (BYTE _USB_MEM *) &StDescEndPoint1HS,
                             8261 ; 288  |                (BYTE _USB_MEM *) &StDescEndPoint2HS,
                             8262 ; 289  |#if ((NUM_REMOVABLE_MEDIA == 1) && (MULTI_LUN_BUILD==0))
                             8263 ; 290  |                (BYTE _USB_MEM *) &StDescInterface1,
                             8264 ; 291  |                (BYTE _USB_MEM *) &StDescEndPoint2HS,
                             8265 ; 292  |                (BYTE _USB_MEM *) &StDescEndPoint5HS,
                             8266 ; 293  |#endif
                             8267 
Y:005D 000000                8268         dc      $000000
                             8276 
                             8277 ; 294  |                NULL
                             8278 ; 295  |            };
                             8279 ; 296  |
                             8280 ; 297  |//
                             8281 ; 298  |// This variable is unused in stand alone usbmsc mode but it must be defined
                             8282 ; 299  |// in order for the linker to be happy.
                             8283 ; 300  |//
                             8284 ; 301  |
                             8285 ; 302  |MS_OS_EXTENDED_CONFIGURATION_DESCRIPTOR Transfer_MSOS_Extended_Configuration;
                             8286 ; 303  |
                             8287 ; 304  |
                             8288 ; 305  |// The 1st configuration pointer is always the Full Speed
                             8289 ; 306  |// The 2nd configuration pointer is always the High Speed
                             8290 ; 307  |// If Full and High Speed configurations are the same set
                             8291 ; 308  |// both entries to point the same configuration
                             8292 ; 309  |BYTE _USB_MEM * ConfigStruct[] = 
                             8293 
                             8294 FConfigStruct:
Y:005E rrrrrr rrrrrr         8295         dc      FConfig1FSRule,FConfig1HSRule,$000000
       000000                     
                             8299 
                             8300 ; 310  |            {
                             8301 ; 311  |                (BYTE _USB_MEM *) Config1FSRule, 
                             8302 ; 312  |                (BYTE _USB_MEM *) Config1HSRule,
                             8303 ; 313  |                NULL
                             8304 ; 314  |            };
                             8305 ; 315  |
                             8306 ; 316  |
                             8307 ; 317  |////////////////////////////////////////////////////////////////////////////////////
                             8308 ; 318  |////////////////////////////////////////////////////////////////////////////////////
                             8309 ; 319  |//
                             8310 ; 320  |//
                             8311 ; 321  |//              USB Strings
                             8312 ; 322  |//
                             8313 ; 323  |//
                             8314 ; 324  |////////////////////////////////////////////////////////////////////////////////////
                             8315 ; 325  |////////////////////////////////////////////////////////////////////////////////////
                             8316 ; 326  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 131

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8317 ; 327  |
                             8318 ; 328  |
                             8319 ; 329  |//Languages is a special case, and must be the first in the list of strings.
                             8320 ; 330  |WORD g_LanguageList[] = {USB_LANGUAGE_ENGLISH,0};
                             8321 
                             8322 Fg_LanguageList:
Y:0061 000409 000000         8323         dc      $000409,$000000
                             8327 
                             8328 ; 331  |
                             8329 ; 332  |
                             8330 ; 333  |//The serial number is 16 characters long, it will be filled in later by the USB startup.
                             8331 ; 334  |//BYTE g_SerialNumber[]="0123456789012345";
                             8332 ; 335  |
                             8333 ; 336  |
                             8334 ; 337  |//Languages is a special case, and must be the first in the list of strings.
                             8335 ; 338  |void *g_pStrings[]= 
                             8336 
                             8337 Fg_pStrings:
Y:0063 rrrrrr rrrrrr         8338         dc      Fg_LanguageList,Fg_Manufacturer,Fg_ProductName,Fg_ChipSerialNumber+9
       rrrrrr rrrrrr              
Y:0067 rrrrrr rrrrrr         8339         dc      Fg_ConfigString,Fg_Interface0String,Fg_Interface1String,$000000
       rrrrrr 000000              
                             8343 
                             8344 ; 339  |{
                             8345 ; 340  |    g_LanguageList,
                             8346 ; 341  |    (BYTE *)g_Manufacturer,
                             8347 ; 342  |    (BYTE *)g_ProductName,
                             8348 ; 343  |    g_ChipSerialNumber.btAscii,
                             8349 ; 344  |    (BYTE *)g_ConfigString,
                             8350 ; 345  |    (BYTE *)g_Interface0String,
                             8351 ; 346  |    (BYTE *)g_Interface1String,
                             8352 ; 347  |    NULL
                             8353 ; 348  |};
                             8354 ; 349  |
                             8355 
                             8360 
                             8363 
Y:0000                       8364         org     y,".ybssdescriptors_3500",bss:
                             8365 FTransfer_MSOS_Extended_Configuration:
Y:0000                       8366         ds      36
   |   RESERVED                   
Y:0023
                             8371 
                             8372         extern  y:Fg_ChipSerialNumber, y:Fg_ConfigString
                             8373         extern  y:Fg_Interface0String, y:Fg_Interface1String
                             8374         extern  y:Fg_Manufacturer, y:Fg_ProductName
                             8375 
                             8376         global  FConfig1FSRule, FConfig1HSRule, FConfigStruct
                             8377         global  FStDescConfig, FStDescDevice, FStDescDeviceQualFs
                             8378         global  FStDescDeviceQualHs, FStDescEndPoint1FS
                             8379         global  FStDescEndPoint1HS, FStDescEndPoint2FS, FStDescEndPoint2HS
                             8380         global  FStDescInterface0, FTransfer_MSOS_Extended_Configuration
                             8381         global  Fg_LanguageList, Fg_pStrings
                             8382 
