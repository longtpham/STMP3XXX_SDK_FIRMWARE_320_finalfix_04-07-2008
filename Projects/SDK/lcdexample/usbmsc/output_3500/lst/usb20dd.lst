TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   1
C:\STMP3XXX_SDK_FIRMWARE_320_finalfix\Projects\SDK\lcdexample\usbmsc\Make\cc8719cb.src
M:ADDR CODE           CYCLES LINE SOURCELINE
                                1 ; TASKING DSP2410 C compiler v1.5r1 Build 208 SN 00100122
                                2 ; options: -OG -si -w68 -w66 -I..\output_3500\include
                                3 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\usbmsc -I -I..\..
                                4 ;          -I..\..\..\..\..\inc -I..\..\..\..\..\System\Common
                                5 ;          -I..\..\..\..\..\System\Common\symbols -I
                                6 ;          -I..\..\..\..\..\Algorithms\DRM\janus\src\h
                                7 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                                8 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                                9 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               10 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               11 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               12 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\Media
                               13 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\HAL\include
                               14 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               15 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive\include
                               16 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               17 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               18 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive
                               19 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               20 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive\include
                               21 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               22 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               23 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive
                               24 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               25 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media\include
                               26 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               27 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               28 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media
                               29 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               30 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               31 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               32 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               33 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive\include
                               34 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               35 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               36 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive
                               37 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include -I
                               38 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               39 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               40 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               41 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               42 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               43 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               44 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               45 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               46 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common
                               47 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               48 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive\include
                               49 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               50 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               51 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive
                               52 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               53 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media\include
                               54 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               55 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               56 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media
                               57 ;          -I..\..\..\..\..\devicedriver\media\include
                               58 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               59 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               60 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               61 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               62 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL
                               63 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               64 ;          -I..\..\..\..\..\DeviceDriver\Media\include
                               65 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash\include
                               66 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash
                               67 ;          -I..\..\..\..\..\system\common\resourcemanager -I..\..\..\..\..\inc
                               68 ;          -I..\..\..\..\..\DeviceDriver\Media\usb\Ch9
                               69 ;          -I..\..\..\..\..\DeviceDriver\Media\scsi
                               70 ;          -I..\..\..\..\..\DeviceDriver\Media\usbmsc
                               71 ;          -I..\..\..\..\..\DeviceDriver\Media\mtp
                               72 ;          -I..\..\..\..\..\System\Common\updater
                               73 ;          -I..\..\..\..\..\libsource\sysserialnumber -DALL -DD3500 -DMMC
                               74 ;          -DLIION -DTUNER_STFM1000 -DSTFM1000_LCD=TRUE -DDCDC_POWER_TRANSFER
                               75 ;          -DBACKLIGHT -DWMAAPI_NO_DRM -DREVB_ENGR_BD -DSED15XX_LCD -DFAT16
                               76 ;          -DDEVICE_3500 -DENGR_BD -DUSBMSC_BUILD -DBATTERY_TYPE_LI_ION
                               77 ;          -DBATTERY_CHARGE -DUSE_PLAYLIST3_HOST -DASCII_ONLY -DRETAIL
                               78 ;          -DDEVICE_3500 -DMMC -Dk_opt_performance_enhancement
                               79 ;          -I..\..\..\..\..\devicedriver\display
                               80 ;          -I..\..\..\..\..\System\MsgModules\Hardware\Display -g -O2 -R -Cs
                               81 ;          -MmyL
                               82 
                               90 
                               91 ;      usb20dd.c:
                               92 ; 1    |////////////////////////////////////////////////////////////////////////////////
                               93 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2005
                               94 ; 3    |//
                               95 ; 4    |// File : usb20dd.c
                               96 ; 5    |// Description : USB2.0 device Controller Interface functions
                               97 ; 6    |////////////////////////////////////////////////////////////////////////////////
                               98 ; 7    |
                               99 ; 8    |////////////////////////////////////////////////////////////////////////////////
                              100 ; 9    |//  Macros
                              101 ; 10   |////////////////////////////////////////////////////////////////////////////////
                              102 ; 11   |
                              103 ; 12   |////////////////////////////////////////////////////////////////////////////////
                              104 ; 13   |//  Includes
                              105 ; 14   |////////////////////////////////////////////////////////////////////////////////
                              106 ; 15   |
                              107 ; 16   |#include "types.h"
                              108 
                              110 
                              111 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              112 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              113 ; 3    |//
                              114 ; 4    |// Filename: types.h
                              115 ; 5    |// Description: Standard data types
                              116 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              117 ; 7    |
                              118 ; 8    |#ifndef _TYPES_H
                              119 ; 9    |#define _TYPES_H
                              120 ; 10   |
                              121 ; 11   |// TODO:  move this outta here!
                              122 ; 12   |#if !defined(NOERROR)
                              123 ; 13   |#define NOERROR 0
                              124 ; 14   |#define SUCCESS 0
                              125 ; 15   |#endif 
                              126 ; 16   |#if !defined(SUCCESS)
                              127 ; 17   |#define SUCCESS  0
                              128 ; 18   |#endif
                              129 ; 19   |#if !defined(ERROR)
                              130 ; 20   |#define ERROR   -1
                              131 ; 21   |#endif
                              132 ; 22   |#if !defined(FALSE)
                              133 ; 23   |#define FALSE 0
                              134 ; 24   |#endif
                              135 ; 25   |#if !defined(TRUE)
                              136 ; 26   |#define TRUE  1
                              137 ; 27   |#endif
                              138 ; 28   |
                              139 ; 29   |#if !defined(NULL)
                              140 ; 30   |#define NULL 0
                              141 ; 31   |#endif
                              142 ; 32   |
                              143 ; 33   |#define MAX_INT     0x7FFFFF
                              144 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              145 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              146 ; 36   |#define MAX_ULONG   (-1) 
                              147 ; 37   |
                              148 ; 38   |#define WORD_SIZE   24              // word size in bits
                              149 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              150 ; 40   |
                              151 ; 41   |
                              152 ; 42   |#define BYTE    unsigned char       // btVarName
                              153 ; 43   |#define CHAR    signed char         // cVarName
                              154 ; 44   |#define USHORT  unsigned short      // usVarName
                              155 ; 45   |#define SHORT   unsigned short      // sVarName
                              156 ; 46   |#define WORD    unsigned int        // wVarName
                              157 ; 47   |#define INT     signed int          // iVarName
                              158 ; 48   |#define DWORD   unsigned long       // dwVarName
                              159 ; 49   |#define LONG    signed long         // lVarName
                              160 ; 50   |#define BOOL    unsigned int        // bVarName
                              161 ; 51   |#define FRACT   _fract              // frVarName
                              162 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              163 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              164 ; 54   |#define FLOAT   float               // fVarName
                              165 ; 55   |#define DBL     double              // dVarName
                              166 ; 56   |#define ENUM    enum                // eVarName
                              167 ; 57   |#define CMX     _complex            // cmxVarName
                              168 ; 58   |typedef WORD UCS3;                   // 
                              169 ; 59   |
                              170 ; 60   |#define UINT16  unsigned short
                              171 ; 61   |#define UINT8   unsigned char   
                              172 ; 62   |#define UINT32  unsigned long
                              173 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              174 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              175 ; 65   |#define WCHAR   UINT16
                              176 ; 66   |
                              177 ; 67   |//UINT128 is 16 bytes or 6 words
                              178 ; 68   |typedef struct UINT128_3500 {   
                              179 ; 69   |    int val[6];     
                              180 ; 70   |} UINT128_3500;
                              181 ; 71   |
                              182 ; 72   |#define UINT128   UINT128_3500
                              183 ; 73   |
                              184 ; 74   |// Little endian word packed byte strings:   
                              185 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              186 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              187 ; 77   |// Little endian word packed byte strings:   
                              188 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              189 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              190 ; 80   |
                              191 ; 81   |// Declare Memory Spaces To Use When Coding
                              192 ; 82   |// A. Sector Buffers
                              193 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              194 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              195 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              196 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              197 
                              199 
                              200 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              201 ; 88   |// B. Media DDI Memory
                              202 ; 89   |#define MEDIA_DDI_MEM _Y
                              203 ; 90   |
                              204 ; 91   |
                              205 ; 92   |
                              206 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              207 ; 94   |// Examples of circular pointers:
                              208 ; 95   |//    INT CIRC cpiVarName
                              209 ; 96   |//    DWORD CIRC cpdwVarName
                              210 ; 97   |
                              211 ; 98   |#define RETCODE INT                 // rcVarName
                              212 ; 99   |
                              213 ; 100  |// generic bitfield structure
                              214 ; 101  |struct Bitfield {
                              215 ; 102  |    unsigned int B0  :1;
                              216 ; 103  |    unsigned int B1  :1;
                              217 ; 104  |    unsigned int B2  :1;
                              218 ; 105  |    unsigned int B3  :1;
                              219 ; 106  |    unsigned int B4  :1;
                              220 ; 107  |    unsigned int B5  :1;
                              221 ; 108  |    unsigned int B6  :1;
                              222 ; 109  |    unsigned int B7  :1;
                              223 ; 110  |    unsigned int B8  :1;
                              224 ; 111  |    unsigned int B9  :1;
                              225 ; 112  |    unsigned int B10 :1;
                              226 ; 113  |    unsigned int B11 :1;
                              227 ; 114  |    unsigned int B12 :1;
                              228 ; 115  |    unsigned int B13 :1;
                              229 ; 116  |    unsigned int B14 :1;
                              230 ; 117  |    unsigned int B15 :1;
                              231 ; 118  |    unsigned int B16 :1;
                              232 ; 119  |    unsigned int B17 :1;
                              233 ; 120  |    unsigned int B18 :1;
                              234 ; 121  |    unsigned int B19 :1;
                              235 ; 122  |    unsigned int B20 :1;
                              236 ; 123  |    unsigned int B21 :1;
                              237 ; 124  |    unsigned int B22 :1;
                              238 ; 125  |    unsigned int B23 :1;
                              239 ; 126  |};
                              240 ; 127  |
                              241 ; 128  |union BitInt {
                              242 ; 129  |        struct Bitfield B;
                              243 ; 130  |        int        I;
                              244 ; 131  |};
                              245 ; 132  |
                              246 ; 133  |#define MAX_MSG_LENGTH 10
                              247 ; 134  |struct CMessage
                              248 ; 135  |{
                              249 ; 136  |        unsigned int m_uLength;
                              250 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              251 ; 138  |};
                              252 ; 139  |
                              253 ; 140  |typedef struct {
                              254 ; 141  |    WORD m_wLength;
                              255 ; 142  |    WORD m_wMessage;
                              256 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              257 ; 144  |} Message;
                              258 ; 145  |
                              259 ; 146  |struct MessageQueueDescriptor
                              260 ; 147  |{
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   2

M:ADDR CODE           CYCLES LINE SOURCELINE
                              261 ; 148  |        int *m_pBase;
                              262 ; 149  |        int m_iModulo;
                              263 ; 150  |        int m_iSize;
                              264 ; 151  |        int *m_pHead;
                              265 ; 152  |        int *m_pTail;
                              266 ; 153  |};
                              267 ; 154  |
                              268 ; 155  |struct ModuleEntry
                              269 ; 156  |{
                              270 ; 157  |    int m_iSignaledEventMask;
                              271 ; 158  |    int m_iWaitEventMask;
                              272 ; 159  |    int m_iResourceOfCode;
                              273 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              274 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                              275 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              276 ; 163  |    int m_uTimeOutHigh;
                              277 ; 164  |    int m_uTimeOutLow;
                              278 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              279 ; 166  |};
                              280 ; 167  |
                              281 ; 168  |union WaitMask{
                              282 ; 169  |    struct B{
                              283 ; 170  |        unsigned int m_bNone     :1;
                              284 ; 171  |        unsigned int m_bMessage  :1;
                              285 ; 172  |        unsigned int m_bTimer    :1;
                              286 ; 173  |        unsigned int m_bButton   :1;
                              287 ; 174  |    } B;
                              288 ; 175  |    int I;
                              289 ; 176  |} ;
                              290 ; 177  |
                              291 ; 178  |
                              292 ; 179  |struct Button {
                              293 ; 180  |        WORD wButtonEvent;
                              294 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              295 ; 182  |};
                              296 ; 183  |
                              297 ; 184  |struct Message {
                              298 ; 185  |        WORD wMsgLength;
                              299 ; 186  |        WORD wMsgCommand;
                              300 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              301 ; 188  |};
                              302 ; 189  |
                              303 ; 190  |union EventTypes {
                              304 ; 191  |        struct CMessage msg;
                              305 ; 192  |        struct Button Button ;
                              306 ; 193  |        struct Message Message;
                              307 ; 194  |};
                              308 ; 195  |
                              309 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              310 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              311 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              312 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              313 ; 200  |
                              314 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              315 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              316 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              317 ; 204  |
                              318 ; 205  |#if DEBUG
                              319 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              320 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              321 ; 208  |#else 
                              322 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                              323 ; 210  |#define DebugBuildAssert(x)    
                              324 ; 211  |#endif
                              325 ; 212  |
                              326 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              327 ; 214  |//  #pragma asm
                              328 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              329 ; 216  |//  #pragma endasm
                              330 ; 217  |
                              331 ; 218  |
                              332 ; 219  |#ifdef COLOR_262K
                              333 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                              334 ; 221  |#elif defined(COLOR_65K)
                              335 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                              336 ; 223  |#else
                              337 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                              338 ; 225  |#endif
                              339 ; 226  |    
                              340 ; 227  |#endif // #ifndef _TYPES_H
                              341 
                              343 
                              344 ; 17   |#include "usb_api.h"
                              345 
                              347 
                              348 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              349 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                              350 ; 3    |//
                              351 ; 4    |// File : USB_API.H
                              352 ; 5    |// Description : USB_API.H defines and structures definition for USB device
                              353 ; 6    |//               driver API.
                              354 ; 7    |//               This 
                              355 ; 8    |////////////////////////////////////////////////////////////////////////////////
                              356 ; 9    |
                              357 ; 10   |#ifndef __usb_api_h__
                              358 ; 11   |#define __usb_api_h__ 1
                              359 ; 12   |
                              360 ; 13   |#include "types.h"
                              361 
                              363 
                              364 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              365 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              366 ; 3    |//
                              367 ; 4    |// Filename: types.h
                              368 ; 5    |// Description: Standard data types
                              369 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              370 ; 7    |
                              371 ; 8    |#ifndef _TYPES_H
                              372 ; 9    |#define _TYPES_H
                              373 ; 10   |
                              374 ; 11   |// TODO:  move this outta here!
                              375 ; 12   |#if !defined(NOERROR)
                              376 ; 13   |#define NOERROR 0
                              377 ; 14   |#define SUCCESS 0
                              378 ; 15   |#endif 
                              379 ; 16   |#if !defined(SUCCESS)
                              380 ; 17   |#define SUCCESS  0
                              381 ; 18   |#endif
                              382 ; 19   |#if !defined(ERROR)
                              383 ; 20   |#define ERROR   -1
                              384 ; 21   |#endif
                              385 ; 22   |#if !defined(FALSE)
                              386 ; 23   |#define FALSE 0
                              387 ; 24   |#endif
                              388 ; 25   |#if !defined(TRUE)
                              389 ; 26   |#define TRUE  1
                              390 ; 27   |#endif
                              391 ; 28   |
                              392 ; 29   |#if !defined(NULL)
                              393 ; 30   |#define NULL 0
                              394 ; 31   |#endif
                              395 ; 32   |
                              396 ; 33   |#define MAX_INT     0x7FFFFF
                              397 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              398 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              399 ; 36   |#define MAX_ULONG   (-1) 
                              400 ; 37   |
                              401 ; 38   |#define WORD_SIZE   24              // word size in bits
                              402 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              403 ; 40   |
                              404 ; 41   |
                              405 ; 42   |#define BYTE    unsigned char       // btVarName
                              406 ; 43   |#define CHAR    signed char         // cVarName
                              407 ; 44   |#define USHORT  unsigned short      // usVarName
                              408 ; 45   |#define SHORT   unsigned short      // sVarName
                              409 ; 46   |#define WORD    unsigned int        // wVarName
                              410 ; 47   |#define INT     signed int          // iVarName
                              411 ; 48   |#define DWORD   unsigned long       // dwVarName
                              412 ; 49   |#define LONG    signed long         // lVarName
                              413 ; 50   |#define BOOL    unsigned int        // bVarName
                              414 ; 51   |#define FRACT   _fract              // frVarName
                              415 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              416 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              417 ; 54   |#define FLOAT   float               // fVarName
                              418 ; 55   |#define DBL     double              // dVarName
                              419 ; 56   |#define ENUM    enum                // eVarName
                              420 ; 57   |#define CMX     _complex            // cmxVarName
                              421 ; 58   |typedef WORD UCS3;                   // 
                              422 ; 59   |
                              423 ; 60   |#define UINT16  unsigned short
                              424 ; 61   |#define UINT8   unsigned char   
                              425 ; 62   |#define UINT32  unsigned long
                              426 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              427 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              428 ; 65   |#define WCHAR   UINT16
                              429 ; 66   |
                              430 ; 67   |//UINT128 is 16 bytes or 6 words
                              431 ; 68   |typedef struct UINT128_3500 {   
                              432 ; 69   |    int val[6];     
                              433 ; 70   |} UINT128_3500;
                              434 ; 71   |
                              435 ; 72   |#define UINT128   UINT128_3500
                              436 ; 73   |
                              437 ; 74   |// Little endian word packed byte strings:   
                              438 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              439 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              440 ; 77   |// Little endian word packed byte strings:   
                              441 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              442 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              443 ; 80   |
                              444 ; 81   |// Declare Memory Spaces To Use When Coding
                              445 ; 82   |// A. Sector Buffers
                              446 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              447 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              448 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              449 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              450 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              451 ; 88   |// B. Media DDI Memory
                              452 ; 89   |#define MEDIA_DDI_MEM _Y
                              453 ; 90   |
                              454 ; 91   |
                              455 ; 92   |
                              456 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              457 ; 94   |// Examples of circular pointers:
                              458 ; 95   |//    INT CIRC cpiVarName
                              459 ; 96   |//    DWORD CIRC cpdwVarName
                              460 ; 97   |
                              461 ; 98   |#define RETCODE INT                 // rcVarName
                              462 ; 99   |
                              463 ; 100  |// generic bitfield structure
                              464 ; 101  |struct Bitfield {
                              465 ; 102  |    unsigned int B0  :1;
                              466 ; 103  |    unsigned int B1  :1;
                              467 ; 104  |    unsigned int B2  :1;
                              468 ; 105  |    unsigned int B3  :1;
                              469 ; 106  |    unsigned int B4  :1;
                              470 ; 107  |    unsigned int B5  :1;
                              471 ; 108  |    unsigned int B6  :1;
                              472 ; 109  |    unsigned int B7  :1;
                              473 ; 110  |    unsigned int B8  :1;
                              474 ; 111  |    unsigned int B9  :1;
                              475 ; 112  |    unsigned int B10 :1;
                              476 ; 113  |    unsigned int B11 :1;
                              477 ; 114  |    unsigned int B12 :1;
                              478 ; 115  |    unsigned int B13 :1;
                              479 ; 116  |    unsigned int B14 :1;
                              480 ; 117  |    unsigned int B15 :1;
                              481 ; 118  |    unsigned int B16 :1;
                              482 ; 119  |    unsigned int B17 :1;
                              483 ; 120  |    unsigned int B18 :1;
                              484 ; 121  |    unsigned int B19 :1;
                              485 ; 122  |    unsigned int B20 :1;
                              486 ; 123  |    unsigned int B21 :1;
                              487 ; 124  |    unsigned int B22 :1;
                              488 ; 125  |    unsigned int B23 :1;
                              489 ; 126  |};
                              490 ; 127  |
                              491 ; 128  |union BitInt {
                              492 ; 129  |        struct Bitfield B;
                              493 ; 130  |        int        I;
                              494 ; 131  |};
                              495 ; 132  |
                              496 ; 133  |#define MAX_MSG_LENGTH 10
                              497 ; 134  |struct CMessage
                              498 ; 135  |{
                              499 ; 136  |        unsigned int m_uLength;
                              500 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              501 ; 138  |};
                              502 ; 139  |
                              503 ; 140  |typedef struct {
                              504 ; 141  |    WORD m_wLength;
                              505 ; 142  |    WORD m_wMessage;
                              506 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              507 ; 144  |} Message;
                              508 ; 145  |
                              509 ; 146  |struct MessageQueueDescriptor
                              510 ; 147  |{
                              511 ; 148  |        int *m_pBase;
                              512 ; 149  |        int m_iModulo;
                              513 ; 150  |        int m_iSize;
                              514 ; 151  |        int *m_pHead;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   3

M:ADDR CODE           CYCLES LINE SOURCELINE
                              515 ; 152  |        int *m_pTail;
                              516 ; 153  |};
                              517 ; 154  |
                              518 ; 155  |struct ModuleEntry
                              519 ; 156  |{
                              520 ; 157  |    int m_iSignaledEventMask;
                              521 ; 158  |    int m_iWaitEventMask;
                              522 ; 159  |    int m_iResourceOfCode;
                              523 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              524 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                              525 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              526 ; 163  |    int m_uTimeOutHigh;
                              527 ; 164  |    int m_uTimeOutLow;
                              528 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              529 ; 166  |};
                              530 ; 167  |
                              531 ; 168  |union WaitMask{
                              532 ; 169  |    struct B{
                              533 ; 170  |        unsigned int m_bNone     :1;
                              534 ; 171  |        unsigned int m_bMessage  :1;
                              535 ; 172  |        unsigned int m_bTimer    :1;
                              536 ; 173  |        unsigned int m_bButton   :1;
                              537 ; 174  |    } B;
                              538 ; 175  |    int I;
                              539 ; 176  |} ;
                              540 ; 177  |
                              541 ; 178  |
                              542 ; 179  |struct Button {
                              543 ; 180  |        WORD wButtonEvent;
                              544 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              545 ; 182  |};
                              546 ; 183  |
                              547 ; 184  |struct Message {
                              548 ; 185  |        WORD wMsgLength;
                              549 ; 186  |        WORD wMsgCommand;
                              550 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              551 ; 188  |};
                              552 ; 189  |
                              553 ; 190  |union EventTypes {
                              554 ; 191  |        struct CMessage msg;
                              555 ; 192  |        struct Button Button ;
                              556 ; 193  |        struct Message Message;
                              557 ; 194  |};
                              558 ; 195  |
                              559 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              560 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              561 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              562 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              563 ; 200  |
                              564 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              565 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              566 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              567 ; 204  |
                              568 ; 205  |#if DEBUG
                              569 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              570 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              571 ; 208  |#else 
                              572 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                              573 ; 210  |#define DebugBuildAssert(x)    
                              574 ; 211  |#endif
                              575 ; 212  |
                              576 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              577 ; 214  |//  #pragma asm
                              578 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              579 ; 216  |//  #pragma endasm
                              580 ; 217  |
                              581 ; 218  |
                              582 ; 219  |#ifdef COLOR_262K
                              583 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                              584 ; 221  |#elif defined(COLOR_65K)
                              585 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                              586 ; 223  |#else
                              587 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                              588 ; 225  |#endif
                              589 ; 226  |    
                              590 ; 227  |#endif // #ifndef _TYPES_H
                              591 
                              593 
                              594 ; 14   |#include "project.h"
                              595 
                              597 
                              598 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                              599 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                              600 ; 3    |//  Filename: project.inc
                              601 ; 4    |//  Description: 
                              602 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                              603 ; 6    |
                              604 ; 7    |#if (!defined(_PROJECT_INC))
                              605 ; 8    |#define _PROJECT_INC 1
                              606 ; 9    |
                              607 ; 10   |#if defined(STMP_BUILD_PLAYER)
                              608 ; 11   |#include "hwequ.h"
                              609 ; 12   |#else 
                              610 ; 13   |//include "regscodec.inc"
                              611 ; 14   |#endif
                              612 ; 15   |
                              613 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                              614 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults ON) & 
                              615 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm. STMP00012148
                              616 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal). 
                              617 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's specs can 
                              618 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player mode.  
                              619 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                              620 ; 23   |
                              621 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                              622 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                              623 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                              624 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define below by defining
                              625 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                              626 ; 29   |#define ATTEMPT_FAST_BOOT 1
                              627 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                              628 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot config above- 
                              629 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down threshholds by maybe 50mV.
                              630 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed.
                              631 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                              632 ; 35   |
                              633 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                              634 ; 37   |// MEDIA DEFINITIONS
                              635 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                              636 ; 39   |
                              637 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                              638 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                              639 ; 42   |#if defined(NAND1)
                              640 ; 43   |#define SM_INTERNAL_CHIPS 1
                              641 ; 44   |#else 
                              642 ; 45   |#if defined(NAND2)
                              643 ; 46   |#define SM_INTERNAL_CHIPS 2
                              644 ; 47   |#else 
                              645 ; 48   |#if defined(NAND3)
                              646 ; 49   |#define SM_INTERNAL_CHIPS 3
                              647 ; 50   |#else 
                              648 ; 51   |#if defined(NAND4)
                              649 ; 52   |#define SM_INTERNAL_CHIPS 4
                              650 ; 53   |#else 
                              651 ; 54   |#define SM_INTERNAL_CHIPS 1
                              652 ; 55   |#endif
                              653 ; 56   |#endif
                              654 ; 57   |#endif
                              655 ; 58   |#endif
                              656 ; 59   |
                              657 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                              658 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                              659 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it reads 0.  
                              660 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                              661 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it reads 1.
                              662 ; 65   |//*** comment out if active high ****
                              663 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                              664 ; 67   |
                              665 ; 68   |#if defined(SMEDIA)
                              666 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                              667 ; 70   |#define NUM_SM_EXTERNAL 1
                              668 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                              669 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                              670 ; 73   |#else 
                              671 ; 74   |#if defined(MMC)
                              672 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                              673 ; 76   |#define NUM_SM_EXTERNAL 0
                              674 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                              675 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                              676 ; 79   |#else 
                              677 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                              678 ; 81   |#define NUM_SM_EXTERNAL 0
                              679 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                              680 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                              681 ; 84   |#endif
                              682 ; 85   |#endif
                              683 ; 86   |
                              684 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                              685 ; 88   |// Mass Storage Class definitions
                              686 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                              687 ; 90   |// Set to 0 if Composite Device build is desired.    
                              688 ; 91   |#define MULTI_LUN_BUILD 1   
                              689 ; 92   |
                              690 ; 93   |////////////////////////////////////////////////////////////////////////////////
                              691 ; 94   |//  SCSI
                              692 ; 95   |#if (MULTI_LUN_BUILD==0)
                              693 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                              694 ; 97   |    #define SCSI_NUM_TARGETS                        2
                              695 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              696 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                              697 ; 100  |  #else
                              698 ; 101  |    #define SCSI_NUM_TARGETS                        1
                              699 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              700 ; 103  |  #endif
                              701 ; 104  |#else
                              702 ; 105  |    #define SCSI_NUM_TARGETS                        1
                              703 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                              704 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                              705 ; 108  |  #else
                              706 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                              707 ; 110  |  #endif
                              708 ; 111  |#endif
                              709 ; 112  |
                              710 ; 113  |
                              711 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                              712 ; 115  |
                              713 ; 116  |
                              714 ; 117  |////////////////////////////////////////////////////////////////////////////////
                              715 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                              716 ; 119  |////////////////////////////////////////////////////////////////////////////////
                              717 ; 120  |#ifdef MMC
                              718 ; 121  |#ifdef MTP_BUILD
                              719 ; 122  |// --------------------
                              720 ; 123  |// MTP and MMC
                              721 ; 124  |// --------------------
                              722 ; 125  |#define NUM_LOGICAL_MEDIA       2
                              723 ; 126  |#define NUM_LOGICAL_DRIVES      8
                              724 ; 127  |#else  // ifndef MTP_BUILD
                              725 ; 128  |#ifdef STMP_BUILD_PLAYER
                              726 ; 129  |// --------------------
                              727 ; 130  |// Player and MMC
                              728 ; 131  |// --------------------
                              729 ; 132  |#else
                              730 ; 133  |// --------------------
                              731 ; 134  |// USBMSC and MMC
                              732 ; 135  |// --------------------
                              733 ; 136  |#define NUM_LOGICAL_MEDIA       3
                              734 ; 137  |#define NUM_LOGICAL_DRIVES      8
                              735 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                              736 ; 139  |#endif // ifdef MTP_BUILD
                              737 ; 140  |#else  // ifndef MMC
                              738 ; 141  |#ifdef MTP_BUILD
                              739 ; 142  |// --------------------
                              740 ; 143  |// MTP and NAND only
                              741 ; 144  |// --------------------
                              742 ; 145  |#define NUM_LOGICAL_MEDIA       1
                              743 ; 146  |#define NUM_LOGICAL_DRIVES      7
                              744 ; 147  |#else  // ifndef MTP_BUILD
                              745 ; 148  |#ifdef STMP_BUILD_PLAYER
                              746 ; 149  |// --------------------
                              747 ; 150  |// Player and NAND only
                              748 ; 151  |// --------------------
                              749 ; 152  |#else
                              750 ; 153  |// --------------------
                              751 ; 154  |// USBMSC and NAND only
                              752 ; 155  |// --------------------
                              753 ; 156  |#define NUM_LOGICAL_MEDIA       2
                              754 ; 157  |#define NUM_LOGICAL_DRIVES      7
                              755 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                              756 ; 159  |#endif // ifdef MTP_BUILD
                              757 ; 160  |#endif // ifdef MMC 
                              758 ; 161  |
                              759 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                              760 ; 163  |#if (defined(MTP_BUILD))
                              761 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                              762 ; 165  |
                              763 ; 166  |////!
                              764 ; 167  |////! This varible holds the watchdog count for the store flush.
                              765 ; 168  |////!
                              766 ; 169  |///
                              767 ; 170  |#include <types.h>
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   4

M:ADDR CODE           CYCLES LINE SOURCELINE
                              768 ; 171  |extern volatile INT g_StoreWatchDogCount;
                              769 ; 172  |extern const INT g_StoreWatchDogTimeout;
                              770 ; 173  |#endif
                              771 ; 174  |
                              772 ; 175  |////////////////////////////////////////////////////////////////////////////////
                              773 ; 176  |// These are needed here for Mass Storage Class
                              774 ; 177  |// Needs to be cleaned up
                              775 ; 178  |////////////////////////////////////////////////////////////////////////////////
                              776 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                              777 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                              778 ; 181  |#define SCRATCH_USER_X_SIZE 512
                              779 ; 182  |
                              780 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                              781 ; 184  |
                              782 ; 185  |#endif
                              783 ; 186  |
                              784 ; 187  |
                              785 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                              786 ; 189  |// SmartMedia/NAND defs
                              787 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                              788 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                              789 ; 192  |
                              790 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                              791 ; 194  |// Sysloadresources defs
                              792 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                              793 ; 196  |
                              794 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                              795 ; 198  |// MMC defs
                              796 ; 199  |#define MMC_MAX_PARTITIONS 1
                              797 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                              798 ; 201  |
                              799 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                              800 ; 203  |// SPI defs
                              801 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                              802 ; 205  |
                              803 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                              804 ; 207  |// Global media defs
                              805 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                              806 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                              807 ; 210  |
                              808 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                              809 ; 212  |// DO NOT CHANGE THESE!!!
                              810 ; 213  |#define SM_MAX_PARTITIONS 4
                              811 ; 214  |#define MAX_HANDLES 2
                              812 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                              813 ; 216  |
                              814 ; 217  |
                              815 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                              816 ; 219  |// Battery LRADC Values 
                              817 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                              818 ; 221  |// brownout trip point in mV (moved by RS)
                              819 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                              820 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                              821 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                              822 ; 225  |//     audio recording to media.
                              823 ; 226  |#define BATT_SAFETY_MARGIN 10
                              824 ; 227  |
                              825 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                              826 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline voltage to do a refresh.
                              827 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                              828 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                              829 ; 232  |
                              830 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc presence.
                              831 ; 234  |
                              832 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                              833 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat check.
                              834 ; 237  |#if (!defined(CLCD))
                              835 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                              836 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                              837 ; 240  |#else 
                              838 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                              839 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                              840 ; 243  |#endif
                              841 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                              842 ; 245  |
                              843 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                              844 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIon.
                              845 ; 248  |// See mp3 encoder overlay.
                              846 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                              847 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                              848 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                              849 ; 252  |
                              850 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                              851 ; 254  |// Voice recording filenames
                              852 ; 255  |// number of digits in filename Vxxx.wav
                              853 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                              854 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                              855 ; 258  |
                              856 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                              857 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                              858 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                              859 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                              860 ; 263  |#if defined(DEVICE_3500)
                              861 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                              862 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                              863 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                              864 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, & demo player)
                              865 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                              866 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                              867 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                              868 ; 271  |
                              869 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn when bias not yet ready.
                              870 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                              871 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevention if you use rec button from outside voice menu.
                              872 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latency in the record-from-music-menu use-case.
                              873 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                              874 ; 277  |
                              875 ; 278  |#else 
                              876 ; 279  |// STMP3410
                              877 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                              878 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                              879 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                              880 ; 283  |#endif
                              881 ; 284  |
                              882 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                              883 ; 286  |// Number of available soft timers
                              884 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                              885 ; 288  |#if defined(SYNC_LYRICS)
                              886 ; 289  |#define SOFT_TIMERS 10
                              887 ; 290  |#else 
                              888 ; 291  |#if defined(JPEG_DECODER)
                              889 ; 292  |#define SOFT_TIMERS 10
                              890 ; 293  |#else 
                              891 ; 294  |#define SOFT_TIMERS 9
                              892 ; 295  |#endif
                              893 ; 296  |#endif
                              894 ; 297  |
                              895 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                              896 ; 299  |//  sizes
                              897 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                              898 ; 301  |#if defined(MMC)
                              899 ; 302  |#if defined(USE_PLAYLIST5)
                              900 ; 303  |#define MENU_STACK_SIZE 1500
                              901 ; 304  |#else 
                              902 ; 305  |#define MENU_STACK_SIZE 1250
                              903 ; 306  |#endif //if @def('USE_PLAYLIST5')
                              904 ; 307  |#else 
                              905 ; 308  |#if defined(USE_PLAYLIST5)
                              906 ; 309  |#define MENU_STACK_SIZE 1500
                              907 ; 310  |#else 
                              908 ; 311  |#define MENU_STACK_SIZE 1250
                              909 ; 312  |#endif //if @def('USE_PLAYLIST5')
                              910 ; 313  |#endif //if @def('MMC')
                              911 ; 314  |
                              912 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 750 else 550 for other builds? TOVERIFY. MYALLOC
                              913 ; 316  |// 
                              914 ; 317  |#define STACK_L1_SIZE 750
                              915 ; 318  |#define STACK_L2_SIZE 100
                              916 ; 319  |#define STACK_L3_SIZE 160
                              917 ; 320  |
                              918 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                              919 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                              920 ; 323  |// is ok with switching code.
                              921 ; 324  |#if defined(MTP_BUILD)
                              922 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                              923 ; 326  |#endif
                              924 ; 327  |
                              925 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                              926 ; 329  |// maximum number of nested funclets 
                              927 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                              928 ; 331  |#define MAX_NESTED_FUNCLET 6 
                              929 ; 332  |
                              930 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                              931 ; 334  |//    LCD DEFINITIONS
                              932 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                              933 ; 336  |
                              934 ; 337  |#define SPACE_CHAR 0x000020          
                              935 ; 338  |#define ZERO_CHAR 0x000030
                              936 ; 339  |#define COLON_CHAR 0x00003A
                              937 ; 340  |#define PERIOD_CHAR 0x00002E
                              938 ; 341  |
                              939 ; 342  |#if (defined(S6B33B0A_LCD))
                              940 ; 343  |#define LCD_X_SIZE 128
                              941 ; 344  |#define LCD_Y_SIZE 159
                              942 ; 345  |#endif
                              943 ; 346  |
                              944 ; 347  |#if (defined(SED15XX_LCD))
                              945 ; 348  |#define LCD_X_SIZE 128
                              946 ; 349  |#define LCD_Y_SIZE 64
                              947 ; 350  |#endif
                              948 ; 351  |
                              949 ; 352  |
                              950 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                              951 ; 354  |//   Details on Customizing Contrast
                              952 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                              953 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                              954 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                              955 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                              956 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                              957 ; 360  |//   unless the ezact sequence is remembered.
                              958 ; 361  |//   To find out what range your player supports: 
                              959 ; 362  |//   change these equs to full range or comment out (full range is default)
                              960 ; 363  |//;;;;;;
                              961 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                              962 ; 365  |// recommended calibration using player -- uncomment 
                              963 ; 366  |//;;;;;;
                              964 ; 367  |//CONTRAST_CALIBRATION    equ  1
                              965 ; 368  |////////////////////////////
                              966 ; 369  |#if (defined(DEMO_HW))
                              967 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi LCD (June6'05)
                              968 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                              969 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                              970 ; 373  |#else 
                              971 ; 374  |
                              972 ; 375  |#if (defined(S6B33B0A_LCD))
                              973 ; 376  |#define LCD_MAX_CONTRAST 210
                              974 ; 377  |#define LCD_MIN_CONTRAST 160    
                              975 ; 378  |#endif
                              976 ; 379  |
                              977 ; 380  |#if (defined(SED15XX_LCD))
                              978 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                              979 ; 382  |// Engineering board regs support range [17-37].
                              980 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                              981 ; 384  |//   One default contrast range [24-42] works for both.
                              982 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                              983 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                              984 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                              985 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                              986 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                              987 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                              988 ; 391  |
                              989 ; 392  |#if (defined(NEWSHINGYIH))
                              990 ; 393  |#define LCD_MAX_CONTRAST 250
                              991 ; 394  |#define LCD_MIN_CONTRAST 0
                              992 ; 395  |#else 
                              993 ; 396  |//-----
                              994 ; 397  |// Near optimal for OLD LCD with NEW file. 
                              995 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for both LCDs.
                              996 ; 399  |#define LCD_MAX_CONTRAST 250
                              997 ; 400  |#define LCD_MIN_CONTRAST 0
                              998 ; 401  |
                              999 ; 402  |//=====
                             1000 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                             1001 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this historic ver.
                             1002 ; 405  |//LCD_MAX_CONTRAST equ 42
                             1003 ; 406  |//LCD_MIN_CONTRAST equ 24 
                             1004 ; 407  |
                             1005 ; 408  |#endif
                             1006 ; 409  |#endif
                             1007 ; 410  |
                             1008 ; 411  |#endif
                             1009 ; 412  |
                             1010 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                             1011 ; 414  |// The default value of the lcd contrast in % of range
                             1012 ; 415  |//   the default value is used when no settings.dat is available
                             1013 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                             1014 ; 417  |
                             1015 ; 418  |#if (defined(S6B33B0A_LCD))
                             1016 ; 419  |// 60% of range is default value
                             1017 ; 420  |#define DEFAULT_CONTRAST 50 
                             1018 ; 421  |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   5

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1019 ; 422  |
                             1020 ; 423  |#if (defined(SED15XX_LCD))
                             1021 ; 424  |// % of range is default value (was 60%)
                             1022 ; 425  |#define DEFAULT_CONTRAST 50 
                             1023 ; 426  |#endif
                             1024 ; 427  |
                             1025 ; 428  |
                             1026 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                             1027 ; 430  |// make lower when doing calibration
                             1028 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                             1029 ; 432  |
                             1030 ; 433  |
                             1031 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                             1032 ; 435  |// For FFWD and RWND
                             1033 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                             1034 ; 437  |#define SECONDS_TO_SKIP 1
                             1035 ; 438  |#define SECONDS_TO_SKIP1 3
                             1036 ; 439  |#define SECONDS_TO_SKIP2 6
                             1037 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                             1038 ; 441  |#define PREV_SONG_THRESHOLD 5  
                             1039 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1040 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                             1041 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1042 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                             1043 ; 446  |
                             1044 ; 447  |// For audible FFW/RWD
                             1045 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                             1046 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                             1047 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                             1048 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                             1049 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1050 ; 453  |#define LEVEL1_BOUNDARY 17 
                             1051 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1052 ; 455  |#define LEVEL2_BOUNDARY 33 
                             1053 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1054 ; 457  |#define LEVEL3_BOUNDARY 50 
                             1055 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                             1056 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                             1057 ; 460  |// Short Song Time, songs too short to play.
                             1058 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                             1059 ; 462  |
                             1060 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             1061 ; 464  |// MP3 Sync Values
                             1062 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                             1063 ; 466  |// # bytes to look for sync before marking it bad
                             1064 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                             1065 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                             1066 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                             1067 ; 470  |// once we have sync'd, the isr should be called this frequently
                             1068 ; 471  |#define MP3_DECODERISR_FAST 7500  
                             1069 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                             1070 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                             1071 ; 474  |
                             1072 ; 475  |
                             1073 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                             1074 ; 477  |//// Multi-Stage Volume Control Definitions
                             1075 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                             1076 ; 479  |//// Use Multi-Stage Volume
                             1077 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                             1078 ; 481  |
                             1079 ; 482  |//// Master Volume definitions
                             1080 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                             1081 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                             1082 ; 485  |
                             1083 ; 486  |//// DAC-Mode definitions
                             1084 ; 487  |//// Adjusts 0dB point
                             1085 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                             1086 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                             1087 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines above.
                             1088 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                             1089 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provides 1.5 dB gain on Stmp34x0; 
                             1090 ; 493  |//                                               Max gain possible: 8 step diff would provide +12dB gain.   
                             1091 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                             1092 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                             1093 ; 496  |
                             1094 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                             1095 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                             1096 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                             1097 ; 500  |
                             1098 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not the default
                             1099 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoint.
                             1100 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                             1101 ; 504  |
                             1102 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the default
                             1103 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                             1104 ; 507  |
                             1105 ; 508  |
                             1106 ; 509  |//// Line In definitions (used for Line-In 1)
                             1107 ; 510  |//// 0dB point of the Line In
                             1108 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                             1109 ; 512  |//// Minimum volume of Line In
                             1110 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                             1111 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                             1112 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                             1113 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                             1114 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                             1115 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS+1)
                             1116 ; 519  |
                             1117 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                             1118 ; 521  |//// 0dB point of the Line In
                             1119 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                             1120 ; 523  |//// Minimum volume of Line In
                             1121 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                             1122 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                             1123 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                             1124 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                             1125 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                             1126 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                             1127 ; 530  |
                             1128 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                             1129 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid deadlock states & recovers. 
                             1130 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                             1131 ; 534  |#define FM_WATCHDOG_ENABLE 1
                             1132 ; 535  |
                             1133 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                             1134 ; 537  |////
                             1135 ; 538  |////! This varible holds the lcd display state for the mtp project.
                             1136 ; 539  |////
                             1137 ; 540  |///
                             1138 ; 541  |#include <types.h>
                             1139 
                             1141 
                             1142 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1143 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1144 ; 3    |//
                             1145 ; 4    |// Filename: types.h
                             1146 ; 5    |// Description: Standard data types
                             1147 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1148 ; 7    |
                             1149 ; 8    |#ifndef _TYPES_H
                             1150 ; 9    |#define _TYPES_H
                             1151 ; 10   |
                             1152 ; 11   |// TODO:  move this outta here!
                             1153 ; 12   |#if !defined(NOERROR)
                             1154 ; 13   |#define NOERROR 0
                             1155 ; 14   |#define SUCCESS 0
                             1156 ; 15   |#endif 
                             1157 ; 16   |#if !defined(SUCCESS)
                             1158 ; 17   |#define SUCCESS  0
                             1159 ; 18   |#endif
                             1160 ; 19   |#if !defined(ERROR)
                             1161 ; 20   |#define ERROR   -1
                             1162 ; 21   |#endif
                             1163 ; 22   |#if !defined(FALSE)
                             1164 ; 23   |#define FALSE 0
                             1165 ; 24   |#endif
                             1166 ; 25   |#if !defined(TRUE)
                             1167 ; 26   |#define TRUE  1
                             1168 ; 27   |#endif
                             1169 ; 28   |
                             1170 ; 29   |#if !defined(NULL)
                             1171 ; 30   |#define NULL 0
                             1172 ; 31   |#endif
                             1173 ; 32   |
                             1174 ; 33   |#define MAX_INT     0x7FFFFF
                             1175 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             1176 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             1177 ; 36   |#define MAX_ULONG   (-1) 
                             1178 ; 37   |
                             1179 ; 38   |#define WORD_SIZE   24              // word size in bits
                             1180 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             1181 ; 40   |
                             1182 ; 41   |
                             1183 ; 42   |#define BYTE    unsigned char       // btVarName
                             1184 ; 43   |#define CHAR    signed char         // cVarName
                             1185 ; 44   |#define USHORT  unsigned short      // usVarName
                             1186 ; 45   |#define SHORT   unsigned short      // sVarName
                             1187 ; 46   |#define WORD    unsigned int        // wVarName
                             1188 ; 47   |#define INT     signed int          // iVarName
                             1189 ; 48   |#define DWORD   unsigned long       // dwVarName
                             1190 ; 49   |#define LONG    signed long         // lVarName
                             1191 ; 50   |#define BOOL    unsigned int        // bVarName
                             1192 ; 51   |#define FRACT   _fract              // frVarName
                             1193 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             1194 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             1195 ; 54   |#define FLOAT   float               // fVarName
                             1196 ; 55   |#define DBL     double              // dVarName
                             1197 ; 56   |#define ENUM    enum                // eVarName
                             1198 ; 57   |#define CMX     _complex            // cmxVarName
                             1199 ; 58   |typedef WORD UCS3;                   // 
                             1200 ; 59   |
                             1201 ; 60   |#define UINT16  unsigned short
                             1202 ; 61   |#define UINT8   unsigned char   
                             1203 ; 62   |#define UINT32  unsigned long
                             1204 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1205 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1206 ; 65   |#define WCHAR   UINT16
                             1207 ; 66   |
                             1208 ; 67   |//UINT128 is 16 bytes or 6 words
                             1209 ; 68   |typedef struct UINT128_3500 {   
                             1210 ; 69   |    int val[6];     
                             1211 ; 70   |} UINT128_3500;
                             1212 ; 71   |
                             1213 ; 72   |#define UINT128   UINT128_3500
                             1214 ; 73   |
                             1215 ; 74   |// Little endian word packed byte strings:   
                             1216 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1217 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1218 ; 77   |// Little endian word packed byte strings:   
                             1219 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1220 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1221 ; 80   |
                             1222 ; 81   |// Declare Memory Spaces To Use When Coding
                             1223 ; 82   |// A. Sector Buffers
                             1224 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             1225 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             1226 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             1227 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             1228 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             1229 ; 88   |// B. Media DDI Memory
                             1230 ; 89   |#define MEDIA_DDI_MEM _Y
                             1231 ; 90   |
                             1232 ; 91   |
                             1233 ; 92   |
                             1234 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             1235 ; 94   |// Examples of circular pointers:
                             1236 ; 95   |//    INT CIRC cpiVarName
                             1237 ; 96   |//    DWORD CIRC cpdwVarName
                             1238 ; 97   |
                             1239 ; 98   |#define RETCODE INT                 // rcVarName
                             1240 ; 99   |
                             1241 ; 100  |// generic bitfield structure
                             1242 ; 101  |struct Bitfield {
                             1243 ; 102  |    unsigned int B0  :1;
                             1244 ; 103  |    unsigned int B1  :1;
                             1245 ; 104  |    unsigned int B2  :1;
                             1246 ; 105  |    unsigned int B3  :1;
                             1247 ; 106  |    unsigned int B4  :1;
                             1248 ; 107  |    unsigned int B5  :1;
                             1249 ; 108  |    unsigned int B6  :1;
                             1250 ; 109  |    unsigned int B7  :1;
                             1251 ; 110  |    unsigned int B8  :1;
                             1252 ; 111  |    unsigned int B9  :1;
                             1253 ; 112  |    unsigned int B10 :1;
                             1254 ; 113  |    unsigned int B11 :1;
                             1255 ; 114  |    unsigned int B12 :1;
                             1256 ; 115  |    unsigned int B13 :1;
                             1257 ; 116  |    unsigned int B14 :1;
                             1258 ; 117  |    unsigned int B15 :1;
                             1259 ; 118  |    unsigned int B16 :1;
                             1260 ; 119  |    unsigned int B17 :1;
                             1261 ; 120  |    unsigned int B18 :1;
                             1262 ; 121  |    unsigned int B19 :1;
                             1263 ; 122  |    unsigned int B20 :1;
                             1264 ; 123  |    unsigned int B21 :1;
                             1265 ; 124  |    unsigned int B22 :1;
                             1266 ; 125  |    unsigned int B23 :1;
                             1267 ; 126  |};
                             1268 ; 127  |
                             1269 ; 128  |union BitInt {
                             1270 ; 129  |        struct Bitfield B;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   6

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1271 ; 130  |        int        I;
                             1272 ; 131  |};
                             1273 ; 132  |
                             1274 ; 133  |#define MAX_MSG_LENGTH 10
                             1275 ; 134  |struct CMessage
                             1276 ; 135  |{
                             1277 ; 136  |        unsigned int m_uLength;
                             1278 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1279 ; 138  |};
                             1280 ; 139  |
                             1281 ; 140  |typedef struct {
                             1282 ; 141  |    WORD m_wLength;
                             1283 ; 142  |    WORD m_wMessage;
                             1284 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1285 ; 144  |} Message;
                             1286 ; 145  |
                             1287 ; 146  |struct MessageQueueDescriptor
                             1288 ; 147  |{
                             1289 ; 148  |        int *m_pBase;
                             1290 ; 149  |        int m_iModulo;
                             1291 ; 150  |        int m_iSize;
                             1292 ; 151  |        int *m_pHead;
                             1293 ; 152  |        int *m_pTail;
                             1294 ; 153  |};
                             1295 ; 154  |
                             1296 ; 155  |struct ModuleEntry
                             1297 ; 156  |{
                             1298 ; 157  |    int m_iSignaledEventMask;
                             1299 ; 158  |    int m_iWaitEventMask;
                             1300 ; 159  |    int m_iResourceOfCode;
                             1301 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1302 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             1303 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1304 ; 163  |    int m_uTimeOutHigh;
                             1305 ; 164  |    int m_uTimeOutLow;
                             1306 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1307 ; 166  |};
                             1308 ; 167  |
                             1309 ; 168  |union WaitMask{
                             1310 ; 169  |    struct B{
                             1311 ; 170  |        unsigned int m_bNone     :1;
                             1312 ; 171  |        unsigned int m_bMessage  :1;
                             1313 ; 172  |        unsigned int m_bTimer    :1;
                             1314 ; 173  |        unsigned int m_bButton   :1;
                             1315 ; 174  |    } B;
                             1316 ; 175  |    int I;
                             1317 ; 176  |} ;
                             1318 ; 177  |
                             1319 ; 178  |
                             1320 ; 179  |struct Button {
                             1321 ; 180  |        WORD wButtonEvent;
                             1322 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1323 ; 182  |};
                             1324 ; 183  |
                             1325 ; 184  |struct Message {
                             1326 ; 185  |        WORD wMsgLength;
                             1327 ; 186  |        WORD wMsgCommand;
                             1328 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1329 ; 188  |};
                             1330 ; 189  |
                             1331 ; 190  |union EventTypes {
                             1332 ; 191  |        struct CMessage msg;
                             1333 ; 192  |        struct Button Button ;
                             1334 ; 193  |        struct Message Message;
                             1335 ; 194  |};
                             1336 ; 195  |
                             1337 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1338 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1339 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1340 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1341 ; 200  |
                             1342 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1343 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1344 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1345 ; 204  |
                             1346 ; 205  |#if DEBUG
                             1347 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1348 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1349 ; 208  |#else 
                             1350 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             1351 ; 210  |#define DebugBuildAssert(x)    
                             1352 ; 211  |#endif
                             1353 ; 212  |
                             1354 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1355 ; 214  |//  #pragma asm
                             1356 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1357 ; 216  |//  #pragma endasm
                             1358 ; 217  |
                             1359 ; 218  |
                             1360 ; 219  |#ifdef COLOR_262K
                             1361 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             1362 ; 221  |#elif defined(COLOR_65K)
                             1363 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             1364 ; 223  |#else
                             1365 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             1366 ; 225  |#endif
                             1367 ; 226  |    
                             1368 ; 227  |#endif // #ifndef _TYPES_H
                             1369 
                             1371 
                             1372 ; 542  |extern volatile WORD g_wActivityState;
                             1373 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             1374 ; 544  |
                             1375 ; 545  |void _reentrant Init5VSense(void);
                             1376 ; 546  |void _reentrant ServiceDCDC(void);
                             1377 ; 547  |
                             1378 ; 548  |////////////////////////////////////////////////////////////////////////////
                             1379 ; 549  |//// JPEG Thumbnail Mode Setting
                             1380 ; 550  |//// number of column in thumbnail mode
                             1381 ; 551  |#define THUMBNAIL_X 2           
                             1382 ; 552  |//// number of row in  thumbnail mode
                             1383 ; 553  |#define THUMBNAIL_Y 2           
                             1384 ; 554  |//// thumbnail boundary offset x
                             1385 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             1386 ; 556  |//// thumbnail boundary offset y
                             1387 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             1388 ; 558  |
                             1389 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             1390 ; 560  |
                             1391 
                             1393 
                             1394 ; 15   |
                             1395 ; 16   |#ifndef _USB_MEM
                             1396 ; 17   |//if not overwridden, default to the compiler default memory space
                             1397 ; 18   |#define _USB_MEM
                             1398 ; 19   |#endif
                             1399 ; 20   |
                             1400 ; 21   |#define USB_LANGUAGE_ENGLISH 0x0409
                             1401 ; 22   |#define USB_LANGUAGE_CHINESE_PRC 0x0804
                             1402 ; 23   |#define USB_LANGUAGE_CHINESE_TAIWAN 0x0404
                             1403 ; 24   |#define USB_LANGUAGE_JAPANESE 0x0411
                             1404 ; 25   |
                             1405 ; 26   |#define MAX_STRING 30
                             1406 ; 27   |
                             1407 ; 28   |#define  USB_SPEED_FULL                      (0)
                             1408 ; 29   |#define  USB_SPEED_LOW                       (1)
                             1409 ; 30   |#define  USB_SPEED_HIGH                      (2)
                             1410 ; 31   |
                             1411 ; 32   |#define EP_FS_MAX_PACKET_SIZE               (64)    
                             1412 ; 33   |
                             1413 ; 34   |#define EP_HS_MAX_PACKET_SIZE               (512)   
                             1414 ; 35   |
                             1415 ; 36   |// Data transferred to devices based on Sigmatel 3500 chip may sometimes be 
                             1416 ; 37   |// corrupted. The corruption occurs when device is connected in USB High Speed 
                             1417 ; 38   |// mode, and size of the transfer in bytes is divisible by 128, but not 
                             1418 ; 39   |// divisible by the packet size. The workaround is implemented in Microsoft MTP 
                             1419 ; 40   |// driver to allow support for those devices.
                             1420 ; 41   |
                             1421 ; 42   |// the bug can corrupt the end of data buffer. It occurs when host sends out a 
                             1422 ; 43   |// short packet that is multiple of 128 bytes. During this scenario the USB core
                             1423 ; 44   |// does writes that are voided (byte enable == all zero), which was an undefined 
                             1424 ; 45   |// capability and thus the gasket did not apply a proper response. This should 
                             1425 ; 46   |// not affect Mass Storage applications because data transfers are 512 bytes and 
                             1426 ; 47   |// scsi commands are < 16 bytes. Other applications with their own driver will
                             1427 ; 48   |// need to pad the packets if they fall into the error case. "What this basically 
                             1428 ; 49   |// boils down to is that any time the host sends a short packet of 128, 256 or
                             1429 ; 50   |// 384 bytes to a high-speed connected player a number of bytes will be corrupted.
                             1430 ; 51   |// This is easiest to reproduce in SendObject commands but can strike any of the 
                             1431 ; 52   |// commands that take an arbitrary amount of data.
                             1432 ; 53   |#define ARC_HS_128_MODULO_BUG               (128)
                             1433 ; 54   |
                             1434 ; 55   |
                             1435 ; 56   |/* Error codes */
                             1436 ; 57   |#define USB_OK                              (0x00)
                             1437 ; 58   |#define USBERR_REGISTER_SERVICE             (0x01)  // Failed to register a service
                             1438 ; 59   |#define USBERR_NO_SERVICE                   (0x02)  // No registered service found 
                             1439 ; 60   |#define USBERR_TX_FAILED                    (0x03)  // Fail to prepare XD descriptor
                             1440 ; 61   |#define USBERR_SIZE_TOO_LARGE               (0x04)  // Number of bytes to transfer is too large
                             1441 ; 62   |#define USBERR_EP_INIT_FAILED               (0x05)  // Endpoint init fail
                             1442 ; 63   |#define USBERR_CONFIG_FAILED                (0x06)  // Error reported by the application
                             1443 ; 64   |                                                    // if the new config failed or not supported
                             1444 ; 65   |#define USBERR_DEVICE_NOT_CONFIGURED        (0x07)  // Error reported by the transfer function
                             1445 ; 66   |                                                    // if attempting to transfer while the device
                             1446 ; 67   |                                                    // is not configured
                             1447 ; 68   |#define USBERR_INIT_FAILED                  (0x08)  // Fail to initialize the USB API
                             1448 ; 69   |
                             1449 ; 70   |
                             1450 ; 71   |/* Endpoint types */
                             1451 ; 72   |#define  USB_CONTROL_ENDPOINT             (0)
                             1452 ; 73   |#define  USB_ISOCHRONOUS_ENDPOINT         (1)
                             1453 ; 74   |#define  USB_BULK_ENDPOINT                (2)
                             1454 ; 75   |#define  USB_INTERRUPT_ENDPOINT           (3)
                             1455 ; 76   |
                             1456 ; 77   |/* End point direction */
                             1457 ; 78   |#define  USB_OUT                         (0)
                             1458 ; 79   |#define  USB_IN                          (1)
                             1459 ; 80   |
                             1460 ; 81   |/* End point packed size */
                             1461 ; 82   |#define  USB_FS_MAX_PACKET_SIZE           (64)
                             1462 ; 83   |#define  USB_HS_BULK_OUT_MAX_PACKET_SIZE  (256)
                             1463 ; 84   |#define  USB_HS_BULK_IN_MAX_PACKET_SIZE   (128)
                             1464 ; 85   |
                             1465 ; 86   |
                             1466 ; 87   |#define  USB_TEST_MODE_TEST_J             (0x01)
                             1467 ; 88   |#define  USB_TEST_MODE_TEST_K             (0x02)
                             1468 ; 89   |#define  USB_TEST_MODE_TEST_SE0_NAK       (0x03)
                             1469 ; 90   |#define  USB_TEST_MODE_TEST_PACKET        (0x04)
                             1470 ; 91   |
                             1471 ; 92   |/* Available service types */
                             1472 ; 93   |/* Services 0 through 15 are reserved for endpoints */
                             1473 ; 94   |#define  USB_SERVICE_EP0                  (0x00)
                             1474 ; 95   |#define  USB_SERVICE_EP1                  (0x01)
                             1475 ; 96   |#define  USB_SERVICE_EP2                  (0x02)
                             1476 ; 97   |#define  USB_SERVICE_EP3                  (0x03)
                             1477 ; 98   |#define  USB_SERVICE_EP4                  (0x04)
                             1478 ; 99   |#define  USB_SERVICE_EP5                  (0x05)
                             1479 ; 100  |#define  USB_SERVICE_EP6                  (0x06)
                             1480 ; 101  |#define  USB_SERVICE_EP7                  (0x07)
                             1481 ; 102  |#define  USB_SERVICE_EP8                  (0x08)
                             1482 ; 103  |#define  USB_SERVICE_EP9                  (0x09)
                             1483 ; 104  |#define  USB_SERVICE_EP10                 (0x0a)
                             1484 ; 105  |#define  USB_SERVICE_EP11                 (0x0b)
                             1485 ; 106  |#define  USB_SERVICE_EP12                 (0x0c)
                             1486 ; 107  |#define  USB_SERVICE_EP13                 (0x0d)
                             1487 ; 108  |#define  USB_SERVICE_EP14                 (0x0e)
                             1488 ; 109  |#define  USB_SERVICE_EP15                 (0x0f)
                             1489 ; 110  |#define  USB_SERVICE_BUS_RESET            (0x10)
                             1490 ; 111  |#define  USB_SERVICE_SUSPEND              (0x11)
                             1491 ; 112  |#define  USB_SERVICE_SOF                  (0x12)
                             1492 ; 113  |#define  USB_SERVICE_RESUME               (0x13)
                             1493 ; 114  |#define  USB_SERVICE_SLEEP                (0x14)
                             1494 ; 115  |#define  USB_SERVICE_SPEED_DETECTION      (0x15)
                             1495 ; 116  |#define  USB_SERVICE_TEST                 (0x16)
                             1496 ; 117  |#define  USB_SERVICE_CHANGE_CONFIG        (0x17)
                             1497 ; 118  |#define  USB_SERVICE_CHANGE_IFACE         (0x18)   
                             1498 ; 119  |#define  NON_EP_SERVICES                  (USB_SERVICE_SPEED_DETECTION - USB_SERVICE_EP15)
                             1499 ; 120  |
                             1500 ; 121  |// This is the maximum service structures allocated 
                             1501 ; 122  |// One for each End point + the common services (non endpoint services) 
                             1502 ; 123  |#define MAX_NUMBER_SERVICES               (MAX_NUM_EP + NON_EP_SERVICES)  
                             1503 ; 124  |
                             1504 ; 125  |#define NUMBER_BYTES_IN_SETUP               (8)
                             1505 ; 126  |
                             1506 ; 127  |// possible values of btStatus on the xd_struct
                             1507 ; 128  |#define  USB_STATUS_TRANSFER_IDLE           (0)
                             1508 ; 129  |#define  USB_STATUS_TRANSFER_SUCCESS        (1)            
                             1509 ; 130  |#define  USB_STATUS_TRANSFER_ACCEPTED       (2)
                             1510 ; 131  |#define  USB_STATUS_TRANSFER_IN_PROGRESS    (3)
                             1511 ; 132  |#define  USB_STATUS_TRANSFER_ERROR          (4)
                             1512 ; 133  |
                             1513 ; 134  |// types of status set/returned by set_status() and get_status()
                             1514 ; 135  |#define  USB_STATUS_DEVICE_STATE          (0x01)
                             1515 ; 136  |#define  USB_STATUS_INTERFACE             (0x02)
                             1516 ; 137  |#define  USB_STATUS_ADDRESS               (0x03)
                             1517 ; 138  |#define  USB_STATUS_CURRENT_CONFIG        (0x04)
                             1518 ; 139  |#define  USB_STATUS_SOF_COUNT             (0x05)
                             1519 ; 140  |#define  USB_STATUS                       (0x06)
                             1520 ; 141  |#define  USB_STATUS_TEST_MODE             (0x07)
                             1521 ; 142  |#define  USB_STATUS_DEVICE_SPEED          (0x08)  
                             1522 ; 143  |#define  USB_STATUS_DEVICE_TEST           (0x09)  
                             1523 ; 144  |#define  USB_STATUS_CURRENT_IFACE         (0x0a)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   7

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1524 ; 145  |#define  USB_STATUS_CONNECTION            (0x0b)  
                             1525 ; 146  |// For status endpoint, the endpoint number is coded in the less significant nibble
                             1526 ; 147  |#define  USB_STATUS_ENDPOINT              (0x10)
                             1527 ; 148  |#define  USB_STATUS_ENDPOINT_NUMBER_MASK  (0x0F)
                             1528 ; 149  |
                             1529 ; 150  |#define USB_MAX_SIZE_PER_TRANSFER       (0x4000)    // This is the maximum size that
                             1530 ; 151  |                                                    // we allow per transfer
                             1531 ; 152  |
                             1532 ; 153  |//Possible states the device can be in
                             1533 ; 154  |#define  USB_STATE_UNKNOWN                   (0xff)
                             1534 ; 155  |#define  USB_STATE_UNPLUGGED                 (0x05) // USB Cable unplugged
                             1535 ; 156  |#define  USB_STATE_PLUGGED                   (0x04) // USB Cable inserted
                             1536 ; 157  |#define  USB_STATE_POWERED                   (0x03)
                             1537 ; 158  |#define  USB_STATE_DEFAULT                   (0x02)
                             1538 ; 159  |#define  USB_STATE_ADDRESSED                 (0x01)
                             1539 ; 160  |#define  USB_STATE_CONFIGURED                (0x00)
                             1540 ; 161  |#define  USB_STATE_SUSPENDED                 (0x80)
                             1541 ; 162  |
                             1542 ; 163  |// Possible states the connection can be in
                             1543 ; 164  |//#define USB_STATE_UNKNOWN                 (0xff)
                             1544 ; 165  |#define USB_CONNECTED                       (0x00)
                             1545 ; 166  |#define USB_DISCONNECTED                    (0x01)
                             1546 ; 167  |
                             1547 ; 168  |
                             1548 ; 169  |
                             1549 ; 170  |typedef union
                             1550 ; 171  |{
                             1551 ; 172  |    struct
                             1552 ; 173  |    {
                             1553 ; 174  |        int Recipient               : 5;
                             1554 ; 175  |        int Type                    : 2;
                             1555 ; 176  |        int DataTransferDirection   : 1;
                             1556 ; 177  |        int Request                 : 8;
                             1557 ; 178  |        int                         : 8;
                             1558 ; 179  |    } B;
                             1559 ; 180  |    
                             1560 ; 181  |    int I;
                             1561 ; 182  |} USBRequestType ;
                             1562 
                             1576 
                             1577 ; 183  |
                             1578 ; 184  |typedef struct {
                             1579 ; 185  |   BYTE     bValid;
                             1580 ; 186  |   USBRequestType RequestType;
                             1581 ; 187  |   BYTE     btRequest;
                             1582 ; 188  |   WORD     wValue;
                             1583 ; 189  |   WORD     wIndex;
                             1584 ; 190  |   WORD     wLength;
                             1585 ; 191  |    } USB_SetupData;
                             1586 ; 192  |
                             1587 ; 193  |// Descriptor sizes in bytes
                             1588 ; 194  |#define SIZE_DEVICE_DESCRIPTOR_IN_BYTES     (18)
                             1589 ; 195  |#define SIZE_DEVICE_DESCRIPTOR_IN_WORDS     (6)
                             1590 ; 196  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES   (10)
                             1591 ; 197  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_WORDS   (4)
                             1592 ; 198  |#define SIZE_CONFIG_DESCRIPTOR_IN_BYTES     (9)
                             1593 ; 199  |#define SIZE_CONFIG_DESCRIPTOR_IN_WORDS     (3)
                             1594 ; 200  |#define SIZE_INTERFACE_DESCRIPTOR_IN_BYTES  (9)
                             1595 ; 201  |#define SIZE_INTERFACE_DESCRIPTOR_IN_WORDS  (3)
                             1596 ; 202  |#define SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES   (7)
                             1597 ; 203  |
                             1598 ; 204  |
                             1599 ; 205  |// Descriptor types
                             1600 ; 206  |#define DESCRIPTOR_TYPE_DEVICE              (0x01)
                             1601 ; 207  |#define DESCRIPTOR_TYPE_CONFIG              (0x02)
                             1602 ; 208  |#define DESCRIPTOR_TYPE_STRING              (0x03)
                             1603 ; 209  |#define DESCRIPTOR_TYPE_INTERFACE           (0x04)
                             1604 ; 210  |#define DESCRIPTOR_TYPE_ENDPOINT            (0x05)
                             1605 ; 211  |#define DESCRIPTOR_TYPE_DEVICE_QUALIFIER    (0x06)
                             1606 ; 212  |#define DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG  (0x07)
                             1607 ; 213  |#define DESCRIPTOR_TYPE_INTERFACE_POWER     (0x08)
                             1608 ; 214  |
                             1609 ; 215  |
                             1610 ; 216  |#define USB_REQUEST_DIRECTION_HOST_TO_DEVICE    ((WORD)0x000000)
                             1611 ; 217  |#define USB_REQUEST_DIRECTION_DEVICE_TO_HOST    ((WORD)0x000001)
                             1612 ; 218  |
                             1613 ; 219  |#define USB_REQUEST_TYPE_STANDARD               ((WORD)0x000000)
                             1614 ; 220  |#define USB_REQUEST_TYPE_CLASS                  ((WORD)0x000001)
                             1615 ; 221  |#define USB_REQUEST_TYPE_VENDOR                 ((WORD)0x000002)
                             1616 ; 222  |#define USB_REQUEST_TYPE_RESERVED               ((WORD)0x000003)
                             1617 ; 223  |
                             1618 ; 224  |#define USB_REQUEST_RECIPIENT_DEVICE            ((WORD)0x000000)
                             1619 ; 225  |#define USB_REQUEST_RECIPIENT_INTERFACE         ((WORD)0x000001)
                             1620 ; 226  |#define USB_REQUEST_RECIPIENT_ENDPOINT          ((WORD)0x000002)
                             1621 ; 227  |#define USB_REQUEST_RECIPIENT_OTHER             ((WORD)0x000003)
                             1622 ; 228  |
                             1623 ; 229  |#define USB_REQUEST_STANDARD_GET_STATUS         ((WORD)0x000000)
                             1624 ; 230  |#define USB_REQUEST_STANDARD_CLEAR_FEATURE      ((WORD)0x000001)
                             1625 ; 231  |#define USB_REQUEST_STANDARD_RESERVED_1         ((WORD)0x000002)
                             1626 ; 232  |#define USB_REQUEST_STANDARD_SET_FEATURE        ((WORD)0x000003)
                             1627 ; 233  |#define USB_REQUEST_STANDARD_RESERVED_2         ((WORD)0x000004)
                             1628 ; 234  |#define USB_REQUEST_STANDARD_SET_ADDRESS        ((WORD)0x000005)
                             1629 ; 235  |#define USB_REQUEST_STANDARD_GET_DESCRIPTOR     ((WORD)0x000006)
                             1630 ; 236  |#define USB_REQUEST_STANDARD_SET_DESCRIPTOR     ((WORD)0x000007)
                             1631 ; 237  |#define USB_REQUEST_STANDARD_GET_CONFIGURATION  ((WORD)0x000008)
                             1632 ; 238  |#define USB_REQUEST_STANDARD_SET_CONFIGURATION  ((WORD)0x000009)
                             1633 ; 239  |#define USB_REQUEST_STANDARD_GET_INTERFACE      ((WORD)0x00000A)
                             1634 ; 240  |#define USB_REQUEST_STANDARD_SET_INTERFACE      ((WORD)0x00000B)
                             1635 ; 241  |#define USB_REQUEST_STANDARD_SYNCH_FRAME        ((WORD)0x00000C)
                             1636 ; 242  |
                             1637 ; 243  |#define USB_CLEAR_FEATURE_ENDPOINT_HALT         (0)
                             1638 ; 244  |#define USB_CLEAR_FEATURE_REMOTE_WAKEUP         (1)
                             1639 ; 245  |
                             1640 ; 246  |
                             1641 ; 247  |// Struct Device Descriptor
                             1642 ; 248  |typedef struct {
                             1643 ; 249  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (18)
                             1644 ; 250  |    BYTE    btDescriptorType;       // (1) Device descriptor type (1)
                             1645 ; 251  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2.00 0x00)
                             1646 ; 252  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2.00 0x02)     
                             1647 ; 253  |    BYTE    btDeviceClass;          // (4) Class code
                             1648 ; 254  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             1649 ; 255  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             1650 ; 256  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 (8, 16, 32 or 64)
                             1651 ; 257  |    BYTE    btIdVendorLsb;          // (8) Vendor Id
                             1652 ; 258  |    BYTE    btIdVendorMsb;          // (9)
                             1653 ; 259  |    BYTE    btIdProductLsb;         // (10) Product Id
                             1654 ; 260  |    BYTE    btIdProductMsb;         // (11)
                             1655 ; 261  |    BYTE    btBcdReleaseLsb;        // (12) Device release number in BCD
                             1656 ; 262  |    BYTE    btBcdReleaseMsb;        // (13)
                             1657 ; 263  |    BYTE    btIndexManufacturer;    // (14) Index of string descriptor describing Manufacturer
                             1658 ; 264  |    BYTE    btIndexProduct;         // (15) Index of string descriptor describing Product
                             1659 ; 265  |    BYTE    btIndexSerialNumber;    // (16) Index of string descriptor describing Device Serial Number
                             1660 ; 266  |    BYTE    btNumConfigurations;    // (17) Number of possible configurations
                             1661 ; 267  |} Struct_Standard_Dev_Desc;
                             1662 ; 268  |
                             1663 ; 269  |// Struct Device Qualifier Descriptor
                             1664 ; 270  |typedef struct {
                             1665 ; 271  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (10)
                             1666 ; 272  |    BYTE    btDescriptorType;       // (1) Device descriptor type (6)
                             1667 ; 273  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2.00 0x00)
                             1668 ; 274  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2.00 0x02)     
                             1669 ; 275  |    BYTE    btDeviceClass;          // (4) Class code
                             1670 ; 276  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             1671 ; 277  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             1672 ; 278  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 other speed (8, 16, 32 or 64)
                             1673 ; 279  |    BYTE    btNumConfigurations;    // (8) Number of other-speed possible configurations
                             1674 ; 280  |    BYTE    btReserved;             // (9) Reserved for future use, must be 0
                             1675 ; 281  |} Struct_Dev_Qualifier_Desc;
                             1676 ; 282  |
                             1677 ; 283  |// Struct Configuration Descriptor
                             1678 ; 284  |typedef struct {
                             1679 ; 285  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             1680 ; 286  |    BYTE    btDescriptorType;       // (1) Device descriptor type (2 or 7)
                             1681 ; 287  |    BYTE    btTotalLengthLsb;       // (2) Total length of data returned for this config.
                             1682 ; 288  |    BYTE    btTotalLengthMsb;       // (3)                                  
                             1683 ; 289  |    BYTE    btNumInterfaces;        // (4) Number of Interfaces supported by this configuration
                             1684 ; 290  |    BYTE    btConfigurationValue;   // (5) Value to use as an argument to the SetConfiguration() request
                             1685 ; 291  |    BYTE    btIndexConfiguration;   // (6) Index of string descriptor describing this configuration
                             1686 ; 292  |    BYTE    btBitMapAttributes;     // (7) Configuration Characteristics
                             1687 ; 293  |                                    //     D7:      Reserved (set to one)
                             1688 ; 294  |                                    //     D6:      Self-powered
                             1689 ; 295  |                                    //     D5:      Remote Wakeup
                             1690 ; 296  |                                    //     D4..0:   Reserved (reset to zero)        
                             1691 ; 297  |    BYTE    btMaxPower;             // (8) Maximum power consumption expressed in 2mA units.
                             1692 ; 298  |} Struct_Standard_Config_Desc, Struct_Other_Speed_Config_Desc;
                             1693 ; 299  |
                             1694 ; 300  |// Struct Interface Descriptor
                             1695 ; 301  |typedef struct {
                             1696 ; 302  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             1697 ; 303  |    BYTE    btDescriptorType;       // (1) Device descriptor type (4)
                             1698 ; 304  |    BYTE    btInterfaceNum;         // (2) Number of this interface. Zero-based value.
                             1699 ; 305  |    BYTE    btAlternateSetting;     // (3)                                  
                             1700 ; 306  |    BYTE    btNumEndpoints;         // (4) Number of endpointsused by this interface (excluding endpoint 0).
                             1701 ; 307  |    BYTE    btInterfaceClass;       // (5) Class code
                             1702 ; 308  |    BYTE    btInterfaceSubClass;    // (6) Sub Class code
                             1703 ; 309  |    BYTE    btInterfaceProtocol;    // (7) Protocol Code
                             1704 ; 310  |    BYTE    btIndexInterface;       // (8) Index of string descriptor describing this interface
                             1705 ; 311  |} Struct_Standard_Interface_Desc;
                             1706 ; 312  |
                             1707 ; 313  |// Struct Endpoint Descriptor
                             1708 ; 314  |typedef struct {
                             1709 ; 315  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (7)
                             1710 ; 316  |    BYTE    btDescriptorType;       // (1) Device descriptor type (5)
                             1711 ; 317  |    BYTE    btEndpointAddress;      // (2) Address of the endpoint on the USB device described by this descriptor
                             1712 ; 318  |                                    //      Bit 3..0: Endpoint number
                             1713 ; 319  |                                    //      Bit 6..4: Reserved, reset to zero
                             1714 ; 320  |                                    //      Bit 7:    Direction. Ignored for control endpoints (0 OUT, 1 IN)
                             1715 ; 321  |    BYTE    btBitMapAttributes;     // (3) Endpoint attributes
                             1716 ; 322  |                                    //      bits 1..0: Transfer Type (00 Control, 01 Iso, 10 Bulk, 11 Int)
                             1717 ; 323  |                                    //      bits 5..2: If not an iso endpoints, they are reserved and must be reset to zero.
                             1718 ; 324  |                                    //      bits 7..6: Reserved bits, must be reset to zero.                                    
                             1719 ; 325  |    BYTE    btMaxPacketSizeLsb;     // (4) Maximum packet size. Refer to standard for bits specification
                             1720 ; 326  |    BYTE    btMaxPacketSizeMsb;     // (5)
                             1721 ; 327  |    BYTE    btInterval;             // (6) Interval for polling endpoint for data transfers (refer to standard)
                             1722 ; 328  |} Struct_Standard_Endpoint_Desc;
                             1723 ; 329  |
                             1724 ; 330  |typedef struct {
                             1725 ; 331  |    BYTE    btLength;                   // (0) Size of this descriptor in bytes (2*MAX_USB_LANG + 2)
                             1726 ; 332  |    BYTE    btDescriptorType;           // (1) String descriptor type (3)
                             1727 ; 333  |    BYTE    btString[MAX_STRING*2];       
                             1728 ; 334  |} Struct_String_Desc;
                             1729 ; 335  |
                             1730 ; 336  |//
                             1731 ; 337  |// Externals
                             1732 ; 338  |//
                             1733 ; 339  |extern void _reentrant usb_dci_chip_enable (void);
                             1734 ; 340  |extern void _reentrant usb_dci_shutdown(void);
                             1735 ; 341  |
                             1736 ; 342  |BYTE _reentrant usb_device_init(void);
                             1737 ; 343  |void _inline usb_device_shutdown(void)
                             1738 ; 344  |{
                             1739 ; 345  |    usb_dci_shutdown();
                             1740 ; 346  |}
                             1741 ; 347  |
                             1742 ; 348  |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData)); 
                             1743 ; 349  |//Remove unused function usb_device_get_service() to reclain _P memroy.
                             1744 ; 350  |//BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength)); 
                             1745 ; 351  |
                             1746 ; 352  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btDirection, BYTE btType, BOOL bFlag);
                             1747 ; 353  |
                             1748 ; 354  |extern USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             1749 
                             1758 
                             1759 ; 355  |#define usb_device_read_setup_data(btEndpoint) usb_dci_get_setup_data(btEndpoint)
                             1760 ; 356  |
                             1761 ; 357  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus);
                             1762 ; 358  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus);
                             1763 ; 359  |BYTE _reentrant usb_device_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             1764 ; 360  |
                             1765 ; 361  |extern void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             1766 ; 362  |#define usb_device_stall_endpoint(btEndpoint, btDirection) usb_dci_stall_endpoint((btEndpoint), (btDirection))
                             1767 ; 363  |
                             1768 ; 364  |extern void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             1769 ; 365  |#define usb_device_unstall_endpoint(btEndpoint, btDirection) usb_dci_unstall_endpoint((btEndpoint), (btDirection))
                             1770 ; 366  |
                             1771 ; 367  |extern void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             1772 ; 368  |#define usb_device_finish_transaction(btEndpoint) usb_dci_finish_transaction(btEndpoint);
                             1773 ; 369  |
                             1774 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             1775 ; 371  |//
                             1776 ; 372  |//>  Name:          usb_device_enable
                             1777 ; 373  |//
                             1778 ; 374  |//   Type:          Function
                             1779 ; 375  |//
                             1780 ; 376  |//   Description:   Enables the USB device for transfers
                             1781 ; 377  |//
                             1782 ; 378  |//   Inputs:        none
                             1783 ; 379  |//
                             1784 ; 380  |//   Outputs:       USB_OK or error code
                             1785 ; 381  |//
                             1786 ; 382  |//   Notes:         none
                             1787 ; 383  |//<
                             1788 ; 384  |////////////////////////////////////////////////////////////////////////////////
                             1789 ; 385  |void _inline usb_device_enable(void)
                             1790 ; 386  |{
                             1791 ; 387  |    usb_dci_chip_enable();
                             1792 ; 388  |}
                             1793 ; 389  |
                             1794 ; 390  |void _reentrant usb_device_release(void);
                             1795 ; 391  |void _reentrant usb_device_hold(void);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   8

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1796 ; 392  |BYTE _reentrant usb_device_is_hold(void);
                             1797 ; 393  |void _reentrant usb_device_data_phase_required(void);
                             1798 ; 394  |
                             1799 ; 395  |BOOL _reentrant usb_device_is_first_init(void);
                             1800 ; 396  |void _reentrant usb_device_set_first_init(void);
                             1801 ; 397  |void _reentrant usb_device_clear_first_init(void);
                             1802 ; 398  |
                             1803 ; 399  |WORD _reentrant usb_get_current_limit(void);
                             1804 ; 400  |RETCODE _reentrant usb_set_current_limit(WORD);
                             1805 ; 401  |
                             1806 ; 402  |////////////////////////////////////////////////////////////////////
                             1807 ; 403  |extern BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             1808 ; 404  |#define usb_device_get_endpoint_status(btEndpoint) usb_dci_get_endpoint_status(btEndpoint)
                             1809 ; 405  |
                             1810 ; 406  |#define USB_ENDPOINT_STATUS_OK                          0
                             1811 ; 407  |#define USB_ENDPOINT_STATUS_STALLED                     1
                             1812 ; 408  |#define USB_ENDPOINT_STATUS_RECIEVED_UNSTALL_REQUEST    2
                             1813 ; 409  |// WHQL
                             1814 ; 410  |#define USB_ENDPOINT_STATUS_HOST_STALLED                3
                             1815 ; 411  |////////////////////////////////////////////////////////////////////
                             1816 ; 412  |
                             1817 ; 413  |
                             1818 ; 414  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByteOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             1819 ; 415  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByteOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             1820 ; 416  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLength,WORD wPrivateData);
                             1821 ; 417  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             1822 ; 418  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateData, 
                             1823 ; 419  |                                         BOOL bIsDataPhase, WORD wDirection);
                             1824 ; 420  |
                             1825 ; 421  |#ifndef CUSTOMIZE_UNICODE
                             1826 ; 422  |extern const BYTE g_Manufacturer[];
                             1827 ; 423  |extern const BYTE g_ProductName[];
                             1828 ; 424  |extern const BYTE g_ConfigString[];
                             1829 ; 425  |extern const BYTE g_Interface0String[];
                             1830 ; 426  |extern const BYTE g_Interface1String[];
                             1831 ; 427  |extern const BYTE g_MSOSDescriptorString[];
                             1832 ; 428  |#else   // CUSTOMIZE_UNICODE
                             1833 ; 429  |extern const WORD g_Manufacturer[];
                             1834 ; 430  |extern const WORD g_ProductName[];
                             1835 ; 431  |extern const WORD g_ConfigString[];
                             1836 ; 432  |extern const WORD g_Interface0String[];
                             1837 ; 433  |extern const WORD g_Interface1String[];
                             1838 ; 434  |extern const WORD g_MSOSDescriptorString[];
                             1839 ; 435  |#endif
                             1840 ; 436  |extern WORD g_LanguageList[];
                             1841 ; 437  |
                             1842 ; 438  |extern const BYTE g_SCSIVendorID[];
                             1843 ; 439  |extern const BYTE g_SCSIProductID[];
                             1844 ; 440  |extern void *g_pStrings[];
                             1845 ; 441  |
                             1846 ; 442  |extern WORD g_wUSBVendorID;
                             1847 ; 443  |extern WORD g_wUSBProductID;
                             1848 ; 444  |extern WORD g_wUSBReleaseID;
                             1849 ; 445  |
                             1850 ; 446  |#endif
                             1851 ; 447  |/* EOF */
                             1852 ; 448  |
                             1853 
                             1855 
                             1856 ; 18   |#include "..\usb_internal.h"
                             1857 
                             1859 
                             1860 ; 1    |#ifndef _USB_INTERNAL_H
                             1861 ; 2    |#define _USB_INTERNAL_H
                             1862 ; 3    |
                             1863 ; 4    |#include "project.h"
                             1864 
                             1866 
                             1867 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             1868 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                             1869 ; 3    |//  Filename: project.inc
                             1870 ; 4    |//  Description: 
                             1871 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             1872 ; 6    |
                             1873 ; 7    |#if (!defined(_PROJECT_INC))
                             1874 ; 8    |#define _PROJECT_INC 1
                             1875 ; 9    |
                             1876 ; 10   |#if defined(STMP_BUILD_PLAYER)
                             1877 ; 11   |#include "hwequ.h"
                             1878 ; 12   |#else 
                             1879 ; 13   |//include "regscodec.inc"
                             1880 ; 14   |#endif
                             1881 ; 15   |
                             1882 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                             1883 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults ON) & 
                             1884 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm. STMP00012148
                             1885 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal). 
                             1886 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's specs can 
                             1887 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player mode.  
                             1888 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                             1889 ; 23   |
                             1890 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                             1891 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                             1892 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                             1893 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define below by defining
                             1894 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                             1895 ; 29   |#define ATTEMPT_FAST_BOOT 1
                             1896 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                             1897 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot config above- 
                             1898 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down threshholds by maybe 50mV.
                             1899 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed.
                             1900 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                             1901 ; 35   |
                             1902 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                             1903 ; 37   |// MEDIA DEFINITIONS
                             1904 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                             1905 ; 39   |
                             1906 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                             1907 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                             1908 ; 42   |#if defined(NAND1)
                             1909 ; 43   |#define SM_INTERNAL_CHIPS 1
                             1910 ; 44   |#else 
                             1911 ; 45   |#if defined(NAND2)
                             1912 ; 46   |#define SM_INTERNAL_CHIPS 2
                             1913 ; 47   |#else 
                             1914 ; 48   |#if defined(NAND3)
                             1915 ; 49   |#define SM_INTERNAL_CHIPS 3
                             1916 ; 50   |#else 
                             1917 ; 51   |#if defined(NAND4)
                             1918 ; 52   |#define SM_INTERNAL_CHIPS 4
                             1919 ; 53   |#else 
                             1920 ; 54   |#define SM_INTERNAL_CHIPS 1
                             1921 ; 55   |#endif
                             1922 ; 56   |#endif
                             1923 ; 57   |#endif
                             1924 ; 58   |#endif
                             1925 ; 59   |
                             1926 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                             1927 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                             1928 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it reads 0.  
                             1929 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                             1930 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it reads 1.
                             1931 ; 65   |//*** comment out if active high ****
                             1932 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                             1933 ; 67   |
                             1934 ; 68   |#if defined(SMEDIA)
                             1935 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                             1936 ; 70   |#define NUM_SM_EXTERNAL 1
                             1937 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             1938 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                             1939 ; 73   |#else 
                             1940 ; 74   |#if defined(MMC)
                             1941 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                             1942 ; 76   |#define NUM_SM_EXTERNAL 0
                             1943 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                             1944 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                             1945 ; 79   |#else 
                             1946 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                             1947 ; 81   |#define NUM_SM_EXTERNAL 0
                             1948 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             1949 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                             1950 ; 84   |#endif
                             1951 ; 85   |#endif
                             1952 ; 86   |
                             1953 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                             1954 ; 88   |// Mass Storage Class definitions
                             1955 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                             1956 ; 90   |// Set to 0 if Composite Device build is desired.    
                             1957 ; 91   |#define MULTI_LUN_BUILD 1   
                             1958 ; 92   |
                             1959 ; 93   |////////////////////////////////////////////////////////////////////////////////
                             1960 ; 94   |//  SCSI
                             1961 ; 95   |#if (MULTI_LUN_BUILD==0)
                             1962 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                             1963 ; 97   |    #define SCSI_NUM_TARGETS                        2
                             1964 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             1965 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                             1966 ; 100  |  #else
                             1967 ; 101  |    #define SCSI_NUM_TARGETS                        1
                             1968 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             1969 ; 103  |  #endif
                             1970 ; 104  |#else
                             1971 ; 105  |    #define SCSI_NUM_TARGETS                        1
                             1972 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                             1973 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                             1974 ; 108  |  #else
                             1975 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                             1976 ; 110  |  #endif
                             1977 ; 111  |#endif
                             1978 ; 112  |
                             1979 ; 113  |
                             1980 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                             1981 ; 115  |
                             1982 ; 116  |
                             1983 ; 117  |////////////////////////////////////////////////////////////////////////////////
                             1984 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                             1985 ; 119  |////////////////////////////////////////////////////////////////////////////////
                             1986 ; 120  |#ifdef MMC
                             1987 ; 121  |#ifdef MTP_BUILD
                             1988 ; 122  |// --------------------
                             1989 ; 123  |// MTP and MMC
                             1990 ; 124  |// --------------------
                             1991 ; 125  |#define NUM_LOGICAL_MEDIA       2
                             1992 ; 126  |#define NUM_LOGICAL_DRIVES      8
                             1993 ; 127  |#else  // ifndef MTP_BUILD
                             1994 ; 128  |#ifdef STMP_BUILD_PLAYER
                             1995 ; 129  |// --------------------
                             1996 ; 130  |// Player and MMC
                             1997 ; 131  |// --------------------
                             1998 ; 132  |#else
                             1999 ; 133  |// --------------------
                             2000 ; 134  |// USBMSC and MMC
                             2001 ; 135  |// --------------------
                             2002 ; 136  |#define NUM_LOGICAL_MEDIA       3
                             2003 ; 137  |#define NUM_LOGICAL_DRIVES      8
                             2004 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                             2005 ; 139  |#endif // ifdef MTP_BUILD
                             2006 ; 140  |#else  // ifndef MMC
                             2007 ; 141  |#ifdef MTP_BUILD
                             2008 ; 142  |// --------------------
                             2009 ; 143  |// MTP and NAND only
                             2010 ; 144  |// --------------------
                             2011 ; 145  |#define NUM_LOGICAL_MEDIA       1
                             2012 ; 146  |#define NUM_LOGICAL_DRIVES      7
                             2013 ; 147  |#else  // ifndef MTP_BUILD
                             2014 ; 148  |#ifdef STMP_BUILD_PLAYER
                             2015 ; 149  |// --------------------
                             2016 ; 150  |// Player and NAND only
                             2017 ; 151  |// --------------------
                             2018 ; 152  |#else
                             2019 ; 153  |// --------------------
                             2020 ; 154  |// USBMSC and NAND only
                             2021 ; 155  |// --------------------
                             2022 ; 156  |#define NUM_LOGICAL_MEDIA       2
                             2023 ; 157  |#define NUM_LOGICAL_DRIVES      7
                             2024 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                             2025 ; 159  |#endif // ifdef MTP_BUILD
                             2026 ; 160  |#endif // ifdef MMC 
                             2027 ; 161  |
                             2028 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                             2029 ; 163  |#if (defined(MTP_BUILD))
                             2030 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                             2031 ; 165  |
                             2032 ; 166  |////!
                             2033 ; 167  |////! This varible holds the watchdog count for the store flush.
                             2034 ; 168  |////!
                             2035 ; 169  |///
                             2036 ; 170  |#include <types.h>
                             2037 ; 171  |extern volatile INT g_StoreWatchDogCount;
                             2038 ; 172  |extern const INT g_StoreWatchDogTimeout;
                             2039 ; 173  |#endif
                             2040 ; 174  |
                             2041 ; 175  |////////////////////////////////////////////////////////////////////////////////
                             2042 ; 176  |// These are needed here for Mass Storage Class
                             2043 ; 177  |// Needs to be cleaned up
                             2044 ; 178  |////////////////////////////////////////////////////////////////////////////////
                             2045 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                             2046 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                             2047 ; 181  |#define SCRATCH_USER_X_SIZE 512
                             2048 ; 182  |
                             2049 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   9

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2050 ; 184  |
                             2051 ; 185  |#endif
                             2052 ; 186  |
                             2053 ; 187  |
                             2054 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                             2055 ; 189  |// SmartMedia/NAND defs
                             2056 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             2057 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                             2058 ; 192  |
                             2059 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                             2060 ; 194  |// Sysloadresources defs
                             2061 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             2062 ; 196  |
                             2063 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                             2064 ; 198  |// MMC defs
                             2065 ; 199  |#define MMC_MAX_PARTITIONS 1
                             2066 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                             2067 ; 201  |
                             2068 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                             2069 ; 203  |// SPI defs
                             2070 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                             2071 ; 205  |
                             2072 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                             2073 ; 207  |// Global media defs
                             2074 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                             2075 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                             2076 ; 210  |
                             2077 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                             2078 ; 212  |// DO NOT CHANGE THESE!!!
                             2079 ; 213  |#define SM_MAX_PARTITIONS 4
                             2080 ; 214  |#define MAX_HANDLES 2
                             2081 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                             2082 ; 216  |
                             2083 ; 217  |
                             2084 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                             2085 ; 219  |// Battery LRADC Values 
                             2086 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                             2087 ; 221  |// brownout trip point in mV (moved by RS)
                             2088 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                             2089 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                             2090 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                             2091 ; 225  |//     audio recording to media.
                             2092 ; 226  |#define BATT_SAFETY_MARGIN 10
                             2093 ; 227  |
                             2094 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                             2095 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline voltage to do a refresh.
                             2096 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                             2097 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                             2098 ; 232  |
                             2099 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc presence.
                             2100 ; 234  |
                             2101 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                             2102 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat check.
                             2103 ; 237  |#if (!defined(CLCD))
                             2104 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                             2105 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                             2106 ; 240  |#else 
                             2107 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                             2108 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                             2109 ; 243  |#endif
                             2110 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                             2111 ; 245  |
                             2112 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                             2113 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIon.
                             2114 ; 248  |// See mp3 encoder overlay.
                             2115 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                             2116 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                             2117 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                             2118 ; 252  |
                             2119 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                             2120 ; 254  |// Voice recording filenames
                             2121 ; 255  |// number of digits in filename Vxxx.wav
                             2122 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                             2123 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                             2124 ; 258  |
                             2125 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                             2126 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                             2127 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                             2128 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                             2129 ; 263  |#if defined(DEVICE_3500)
                             2130 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                             2131 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                             2132 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                             2133 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, & demo player)
                             2134 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             2135 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                             2136 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                             2137 ; 271  |
                             2138 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn when bias not yet ready.
                             2139 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                             2140 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevention if you use rec button from outside voice menu.
                             2141 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latency in the record-from-music-menu use-case.
                             2142 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                             2143 ; 277  |
                             2144 ; 278  |#else 
                             2145 ; 279  |// STMP3410
                             2146 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                             2147 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             2148 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                             2149 ; 283  |#endif
                             2150 ; 284  |
                             2151 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                             2152 ; 286  |// Number of available soft timers
                             2153 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                             2154 ; 288  |#if defined(SYNC_LYRICS)
                             2155 ; 289  |#define SOFT_TIMERS 10
                             2156 ; 290  |#else 
                             2157 ; 291  |#if defined(JPEG_DECODER)
                             2158 ; 292  |#define SOFT_TIMERS 10
                             2159 ; 293  |#else 
                             2160 ; 294  |#define SOFT_TIMERS 9
                             2161 ; 295  |#endif
                             2162 ; 296  |#endif
                             2163 ; 297  |
                             2164 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                             2165 ; 299  |//  sizes
                             2166 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                             2167 ; 301  |#if defined(MMC)
                             2168 ; 302  |#if defined(USE_PLAYLIST5)
                             2169 ; 303  |#define MENU_STACK_SIZE 1500
                             2170 ; 304  |#else 
                             2171 ; 305  |#define MENU_STACK_SIZE 1250
                             2172 ; 306  |#endif //if @def('USE_PLAYLIST5')
                             2173 ; 307  |#else 
                             2174 ; 308  |#if defined(USE_PLAYLIST5)
                             2175 ; 309  |#define MENU_STACK_SIZE 1500
                             2176 ; 310  |#else 
                             2177 ; 311  |#define MENU_STACK_SIZE 1250
                             2178 ; 312  |#endif //if @def('USE_PLAYLIST5')
                             2179 ; 313  |#endif //if @def('MMC')
                             2180 ; 314  |
                             2181 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 750 else 550 for other builds? TOVERIFY. MYALLOC
                             2182 ; 316  |// 
                             2183 ; 317  |#define STACK_L1_SIZE 750
                             2184 ; 318  |#define STACK_L2_SIZE 100
                             2185 ; 319  |#define STACK_L3_SIZE 160
                             2186 ; 320  |
                             2187 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                             2188 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                             2189 ; 323  |// is ok with switching code.
                             2190 ; 324  |#if defined(MTP_BUILD)
                             2191 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                             2192 ; 326  |#endif
                             2193 ; 327  |
                             2194 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                             2195 ; 329  |// maximum number of nested funclets 
                             2196 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                             2197 ; 331  |#define MAX_NESTED_FUNCLET 6 
                             2198 ; 332  |
                             2199 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                             2200 ; 334  |//    LCD DEFINITIONS
                             2201 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                             2202 ; 336  |
                             2203 ; 337  |#define SPACE_CHAR 0x000020          
                             2204 ; 338  |#define ZERO_CHAR 0x000030
                             2205 ; 339  |#define COLON_CHAR 0x00003A
                             2206 ; 340  |#define PERIOD_CHAR 0x00002E
                             2207 ; 341  |
                             2208 ; 342  |#if (defined(S6B33B0A_LCD))
                             2209 ; 343  |#define LCD_X_SIZE 128
                             2210 ; 344  |#define LCD_Y_SIZE 159
                             2211 ; 345  |#endif
                             2212 ; 346  |
                             2213 ; 347  |#if (defined(SED15XX_LCD))
                             2214 ; 348  |#define LCD_X_SIZE 128
                             2215 ; 349  |#define LCD_Y_SIZE 64
                             2216 ; 350  |#endif
                             2217 ; 351  |
                             2218 ; 352  |
                             2219 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                             2220 ; 354  |//   Details on Customizing Contrast
                             2221 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                             2222 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                             2223 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                             2224 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                             2225 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                             2226 ; 360  |//   unless the ezact sequence is remembered.
                             2227 ; 361  |//   To find out what range your player supports: 
                             2228 ; 362  |//   change these equs to full range or comment out (full range is default)
                             2229 ; 363  |//;;;;;;
                             2230 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                             2231 ; 365  |// recommended calibration using player -- uncomment 
                             2232 ; 366  |//;;;;;;
                             2233 ; 367  |//CONTRAST_CALIBRATION    equ  1
                             2234 ; 368  |////////////////////////////
                             2235 ; 369  |#if (defined(DEMO_HW))
                             2236 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi LCD (June6'05)
                             2237 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                             2238 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                             2239 ; 373  |#else 
                             2240 ; 374  |
                             2241 ; 375  |#if (defined(S6B33B0A_LCD))
                             2242 ; 376  |#define LCD_MAX_CONTRAST 210
                             2243 ; 377  |#define LCD_MIN_CONTRAST 160    
                             2244 ; 378  |#endif
                             2245 ; 379  |
                             2246 ; 380  |#if (defined(SED15XX_LCD))
                             2247 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                             2248 ; 382  |// Engineering board regs support range [17-37].
                             2249 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                             2250 ; 384  |//   One default contrast range [24-42] works for both.
                             2251 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                             2252 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                             2253 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                             2254 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                             2255 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                             2256 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                             2257 ; 391  |
                             2258 ; 392  |#if (defined(NEWSHINGYIH))
                             2259 ; 393  |#define LCD_MAX_CONTRAST 250
                             2260 ; 394  |#define LCD_MIN_CONTRAST 0
                             2261 ; 395  |#else 
                             2262 ; 396  |//-----
                             2263 ; 397  |// Near optimal for OLD LCD with NEW file. 
                             2264 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for both LCDs.
                             2265 ; 399  |#define LCD_MAX_CONTRAST 250
                             2266 ; 400  |#define LCD_MIN_CONTRAST 0
                             2267 ; 401  |
                             2268 ; 402  |//=====
                             2269 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                             2270 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this historic ver.
                             2271 ; 405  |//LCD_MAX_CONTRAST equ 42
                             2272 ; 406  |//LCD_MIN_CONTRAST equ 24 
                             2273 ; 407  |
                             2274 ; 408  |#endif
                             2275 ; 409  |#endif
                             2276 ; 410  |
                             2277 ; 411  |#endif
                             2278 ; 412  |
                             2279 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                             2280 ; 414  |// The default value of the lcd contrast in % of range
                             2281 ; 415  |//   the default value is used when no settings.dat is available
                             2282 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                             2283 ; 417  |
                             2284 ; 418  |#if (defined(S6B33B0A_LCD))
                             2285 ; 419  |// 60% of range is default value
                             2286 ; 420  |#define DEFAULT_CONTRAST 50 
                             2287 ; 421  |#endif
                             2288 ; 422  |
                             2289 ; 423  |#if (defined(SED15XX_LCD))
                             2290 ; 424  |// % of range is default value (was 60%)
                             2291 ; 425  |#define DEFAULT_CONTRAST 50 
                             2292 ; 426  |#endif
                             2293 ; 427  |
                             2294 ; 428  |
                             2295 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                             2296 ; 430  |// make lower when doing calibration
                             2297 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                             2298 ; 432  |
                             2299 ; 433  |
                             2300 ; 434  |/////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  10

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2301 ; 435  |// For FFWD and RWND
                             2302 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                             2303 ; 437  |#define SECONDS_TO_SKIP 1
                             2304 ; 438  |#define SECONDS_TO_SKIP1 3
                             2305 ; 439  |#define SECONDS_TO_SKIP2 6
                             2306 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                             2307 ; 441  |#define PREV_SONG_THRESHOLD 5  
                             2308 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2309 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                             2310 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2311 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                             2312 ; 446  |
                             2313 ; 447  |// For audible FFW/RWD
                             2314 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                             2315 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                             2316 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                             2317 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                             2318 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2319 ; 453  |#define LEVEL1_BOUNDARY 17 
                             2320 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2321 ; 455  |#define LEVEL2_BOUNDARY 33 
                             2322 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2323 ; 457  |#define LEVEL3_BOUNDARY 50 
                             2324 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                             2325 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                             2326 ; 460  |// Short Song Time, songs too short to play.
                             2327 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                             2328 ; 462  |
                             2329 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             2330 ; 464  |// MP3 Sync Values
                             2331 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                             2332 ; 466  |// # bytes to look for sync before marking it bad
                             2333 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                             2334 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                             2335 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                             2336 ; 470  |// once we have sync'd, the isr should be called this frequently
                             2337 ; 471  |#define MP3_DECODERISR_FAST 7500  
                             2338 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                             2339 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                             2340 ; 474  |
                             2341 ; 475  |
                             2342 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                             2343 ; 477  |//// Multi-Stage Volume Control Definitions
                             2344 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                             2345 ; 479  |//// Use Multi-Stage Volume
                             2346 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                             2347 ; 481  |
                             2348 ; 482  |//// Master Volume definitions
                             2349 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                             2350 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                             2351 ; 485  |
                             2352 ; 486  |//// DAC-Mode definitions
                             2353 ; 487  |//// Adjusts 0dB point
                             2354 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                             2355 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                             2356 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines above.
                             2357 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                             2358 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provides 1.5 dB gain on Stmp34x0; 
                             2359 ; 493  |//                                               Max gain possible: 8 step diff would provide +12dB gain.   
                             2360 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                             2361 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                             2362 ; 496  |
                             2363 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                             2364 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                             2365 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                             2366 ; 500  |
                             2367 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not the default
                             2368 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoint.
                             2369 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                             2370 ; 504  |
                             2371 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the default
                             2372 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                             2373 ; 507  |
                             2374 ; 508  |
                             2375 ; 509  |//// Line In definitions (used for Line-In 1)
                             2376 ; 510  |//// 0dB point of the Line In
                             2377 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                             2378 ; 512  |//// Minimum volume of Line In
                             2379 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                             2380 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                             2381 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                             2382 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                             2383 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                             2384 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS+1)
                             2385 ; 519  |
                             2386 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                             2387 ; 521  |//// 0dB point of the Line In
                             2388 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                             2389 ; 523  |//// Minimum volume of Line In
                             2390 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                             2391 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                             2392 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                             2393 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                             2394 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                             2395 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                             2396 ; 530  |
                             2397 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                             2398 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid deadlock states & recovers. 
                             2399 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                             2400 ; 534  |#define FM_WATCHDOG_ENABLE 1
                             2401 ; 535  |
                             2402 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                             2403 ; 537  |////
                             2404 ; 538  |////! This varible holds the lcd display state for the mtp project.
                             2405 ; 539  |////
                             2406 ; 540  |///
                             2407 ; 541  |#include <types.h>
                             2408 ; 542  |extern volatile WORD g_wActivityState;
                             2409 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             2410 ; 544  |
                             2411 ; 545  |void _reentrant Init5VSense(void);
                             2412 ; 546  |void _reentrant ServiceDCDC(void);
                             2413 ; 547  |
                             2414 ; 548  |////////////////////////////////////////////////////////////////////////////
                             2415 ; 549  |//// JPEG Thumbnail Mode Setting
                             2416 ; 550  |//// number of column in thumbnail mode
                             2417 ; 551  |#define THUMBNAIL_X 2           
                             2418 ; 552  |//// number of row in  thumbnail mode
                             2419 ; 553  |#define THUMBNAIL_Y 2           
                             2420 ; 554  |//// thumbnail boundary offset x
                             2421 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             2422 ; 556  |//// thumbnail boundary offset y
                             2423 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             2424 ; 558  |
                             2425 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             2426 ; 560  |
                             2427 
                             2429 
                             2430 ; 5    |
                             2431 ; 6    |#ifndef MAX_USB_STRINGS
                             2432 ; 7    |#define MAX_USB_STRINGS 9
                             2433 ; 8    |#endif
                             2434 ; 9    |
                             2435 ; 10   |
                             2436 ; 11   |#define  USB_SELF_POWERED                    (0x01)
                             2437 ; 12   |#define  USB_REMOTE_WAKEUP                   (0x02)
                             2438 ; 13   |
                             2439 ; 14   |#define MAX_DESC_SIZE       86      // (255/3)+1
                             2440 ; 15   |
                             2441 ; 16   |#define MS_OS_STRING_DESCRIPTOR_INDEX 0xEE
                             2442 ; 17   |#define MS_OS_STRING_DESCRIPTOR_INDEX_IN_ARRAY 7
                             2443 ; 18   |
                             2444 ; 19   |/* The USB Device State Structure */
                             2445 ; 20   |typedef struct {
                             2446 ; 21   |   BYTE         btSpeed;                // Speed of device when connected
                             2447 ; 22   |                                        // High Speed or Full Speed
                             2448 ; 23   |   BYTE         btCurConfig;            // Current configuration number (0 means not configured yet)
                             2449 ; 24   |                                        // or default interface
                             2450 ; 25   |   BYTE         btCurInterface;         // Current Alternate Interface (0 means not configured yet)                                                         
                             2451 ; 26   |   BYTE         btAddress;              // USB device address
                             2452 ; 27   |   USHORT       usUsbState;             // State USB (UNKNOWN, POWERED, DEFAULT, ADDRESSED, CONFIGURED, SUSPENDED)
                             2453 ; 28   |   USHORT       usUsbStatePriorSusp;    // Ste USB prior a SUSPEND. This state needs to be restore
                             2454 ; 29   |                                        // once the USB resumes
                             2455 ; 30   |   USHORT       usUsbDeviceState;       // State of the device (SelfPowered, Remote Wakeup)
                             2456 ; 31   |   USHORT       usSofCount;
                             2457 ; 32   |   BYTE         btBusResetting;         // Set during a reset phase
                             2458 ; 33   |   BYTE         btServicesRegistered;   // Number of services registered
                             2459 ; 34   |   WORD         wError;                 // Increments each time a USB Error Interrupt occurs
                             2460 ; 35   |   BOOL         bEnterTestMode;         // Set when entered in test mode. To clear the device
                             2461 ; 36   |                                        // must be powered down
                             2462 ; 37   |   USHORT       usConnectionState;      // State of the USB connection (CONNECTED, DISCONNECTED, UNKNOWN)                                         
                             2463 ; 38   |} Dev_State_Struct;
                             2464 ; 39   |
                             2465 ; 40   |typedef struct xd_struct_type{
                             2466 ; 41   |   BYTE         btEndpointNum;          // Endpoint number 
                             2467 ; 42   |   BYTE         btDirection;            // Direction : Send/Receive
                             2468 ; 43   |   BYTE         btEndpointType;         // Type of the endpoint: Ctrl, Isoch, Bulk,Int 
                             2469 ; 44   |   BYTE         btStatus;               // Current transfer status 
                             2470 ; 45   |   WORD _X *    pbtStartAddressWord;    // Address of first byte (DSP Word address in STMP space)
                             2471 ; 46   |   BYTE         btStartOffsetByte;      // Address of first byte (Word Byte offset in STMP space)
                             2472 ; 47   |   USHORT       usTotalLength;          // Number of bytes to send/recv 
                             2473 ; 48   |   USHORT       usMaxPacketSize;        // Max Packet size 
                             2474 ; 49   |   BYTE         btDontZeroTerminate;
                             2475 ; 50   |   BOOL         bIsDataPhase;           // Set to TRUE if the transfer is data phase
                             2476 ; 51   |                                        // of a setup transfer
                             2477 ; 52   |   struct xd_struct_type _USB_MEM*pNext;     // pointer to the next xd_struct
                             2478 ; 53   |   WORD         wPrivateData;           //data to be passed to the service handler
                             2479 ; 54   |   USHORT       usBytesCopied;          //number of bytes copied so far
                             2480 ; 55   |   WORD         wCurrentOffsetByte;
                             2481 ; 56   |   WORD _X*    pbtCurrentAddressWord;
                             2482 ; 57   |} xd_struct;
                             2483 ; 58   |
                             2484 ; 59   |// If MAX_NUM_EP is not defined, default to 4
                             2485 ; 60   |// *** NOTE: if you change this definition, change the equate for MAX_NUM_EP in usb20ddmem.asm as well.
                             2486 ; 61   |// The two definitions must be equivalent for proper operation.
                             2487 ; 62   |#define MAX_NUM_EP  4
                             2488 
                             2504 
                             2505 ; 63   |
                             2506 ; 64   |extern Dev_State_Struct _USB_MEM stDeviceState;
                             2507 
                             2529 
                             2530 ; 65   |
                             2531 ; 66   |extern xd_struct _USB_MEM * g_dXD_Queues[MAX_NUM_EP][2];
                             2532 ; 67   |
                             2533 ; 68   |BYTE _reentrant usb_device_call_service(BYTE btType, BOOL bSetup, BYTE btDirection, WORD _X*ptbBuffer, WORD wLength, WORD wPrivateData);
                             2534 ; 69   |xd_struct _USB_MEM * GetEmptyXd(void);
                             2535 ; 70   |void FreeXd(xd_struct _USB_MEM * pTemp);
                             2536 ; 71   |void AddXdToQueue(xd_struct _USB_MEM *pHead,xd_struct _USB_MEM *pElement);
                             2537 ; 72   |void InitXdPool(void);
                             2538 ; 73   |_reentrant void usb_PackDescriptor(void* pDescriptor,void _X * pDestination, WORD startIndex);
                             2539 ; 74   |_reentrant void parse_strings(void);
                             2540 ; 75   |
                             2541 ; 76   |
                             2542 ; 77   |    // Service structures.
                             2543 ; 78   |    // Those are the structures storing the function handler for a specific
                             2544 ; 79   |    // USB service.
                             2545 ; 80   |    // There is a service per Endpoint + Reset + Suspend + Start Of Frame
                             2546 ; 81   |    //                                 + Resume + Sleep + Speed Detection  
                             2547 ; 82   |    // The service structs are setup by the USB application using the device driver
                             2548 ; 83   |typedef struct {
                             2549 ; 84   |   BYTE             btType;     // Which service type
                             2550 ; 85   |                                // Pointer to the service function
                             2551 ; 86   |   void (* Service)(BOOL bSetup, BYTE btDirection, WORD _X* pbtBuffer, WORD wLength, WORD wPrivateData);
                             2552 ; 87   |} Service_Struct;
                             2553 ; 88   |
                             2554 ; 89   |
                             2555 ; 90   |#endif
                             2556 
                             2558 
                             2559 ; 19   |#include "..\..\usb_dci.h"
                             2560 
                             2562 
                             2563 ; 1    |#ifndef _USB_DCI_H
                             2564 ; 2    |#define _USB_DCI_H
                             2565 ; 3    |
                             2566 ; 4    |#include "types.h"
                             2567 
                             2569 
                             2570 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2571 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             2572 ; 3    |//
                             2573 ; 4    |// Filename: types.h
                             2574 ; 5    |// Description: Standard data types
                             2575 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             2576 ; 7    |
                             2577 ; 8    |#ifndef _TYPES_H
                             2578 ; 9    |#define _TYPES_H
                             2579 ; 10   |
                             2580 ; 11   |// TODO:  move this outta here!
                             2581 ; 12   |#if !defined(NOERROR)
                             2582 ; 13   |#define NOERROR 0
                             2583 ; 14   |#define SUCCESS 0
                             2584 ; 15   |#endif 
                             2585 ; 16   |#if !defined(SUCCESS)
                             2586 ; 17   |#define SUCCESS  0
                             2587 ; 18   |#endif
                             2588 ; 19   |#if !defined(ERROR)
                             2589 ; 20   |#define ERROR   -1
                             2590 ; 21   |#endif
                             2591 ; 22   |#if !defined(FALSE)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  11

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2592 ; 23   |#define FALSE 0
                             2593 ; 24   |#endif
                             2594 ; 25   |#if !defined(TRUE)
                             2595 ; 26   |#define TRUE  1
                             2596 ; 27   |#endif
                             2597 ; 28   |
                             2598 ; 29   |#if !defined(NULL)
                             2599 ; 30   |#define NULL 0
                             2600 ; 31   |#endif
                             2601 ; 32   |
                             2602 ; 33   |#define MAX_INT     0x7FFFFF
                             2603 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             2604 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             2605 ; 36   |#define MAX_ULONG   (-1) 
                             2606 ; 37   |
                             2607 ; 38   |#define WORD_SIZE   24              // word size in bits
                             2608 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             2609 ; 40   |
                             2610 ; 41   |
                             2611 ; 42   |#define BYTE    unsigned char       // btVarName
                             2612 ; 43   |#define CHAR    signed char         // cVarName
                             2613 ; 44   |#define USHORT  unsigned short      // usVarName
                             2614 ; 45   |#define SHORT   unsigned short      // sVarName
                             2615 ; 46   |#define WORD    unsigned int        // wVarName
                             2616 ; 47   |#define INT     signed int          // iVarName
                             2617 ; 48   |#define DWORD   unsigned long       // dwVarName
                             2618 ; 49   |#define LONG    signed long         // lVarName
                             2619 ; 50   |#define BOOL    unsigned int        // bVarName
                             2620 ; 51   |#define FRACT   _fract              // frVarName
                             2621 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             2622 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             2623 ; 54   |#define FLOAT   float               // fVarName
                             2624 ; 55   |#define DBL     double              // dVarName
                             2625 ; 56   |#define ENUM    enum                // eVarName
                             2626 ; 57   |#define CMX     _complex            // cmxVarName
                             2627 ; 58   |typedef WORD UCS3;                   // 
                             2628 ; 59   |
                             2629 ; 60   |#define UINT16  unsigned short
                             2630 ; 61   |#define UINT8   unsigned char   
                             2631 ; 62   |#define UINT32  unsigned long
                             2632 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             2633 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             2634 ; 65   |#define WCHAR   UINT16
                             2635 ; 66   |
                             2636 ; 67   |//UINT128 is 16 bytes or 6 words
                             2637 ; 68   |typedef struct UINT128_3500 {   
                             2638 ; 69   |    int val[6];     
                             2639 ; 70   |} UINT128_3500;
                             2640 ; 71   |
                             2641 ; 72   |#define UINT128   UINT128_3500
                             2642 ; 73   |
                             2643 ; 74   |// Little endian word packed byte strings:   
                             2644 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2645 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2646 ; 77   |// Little endian word packed byte strings:   
                             2647 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2648 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2649 ; 80   |
                             2650 ; 81   |// Declare Memory Spaces To Use When Coding
                             2651 ; 82   |// A. Sector Buffers
                             2652 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             2653 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             2654 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             2655 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             2656 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             2657 ; 88   |// B. Media DDI Memory
                             2658 ; 89   |#define MEDIA_DDI_MEM _Y
                             2659 ; 90   |
                             2660 ; 91   |
                             2661 ; 92   |
                             2662 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             2663 ; 94   |// Examples of circular pointers:
                             2664 ; 95   |//    INT CIRC cpiVarName
                             2665 ; 96   |//    DWORD CIRC cpdwVarName
                             2666 ; 97   |
                             2667 ; 98   |#define RETCODE INT                 // rcVarName
                             2668 ; 99   |
                             2669 ; 100  |// generic bitfield structure
                             2670 ; 101  |struct Bitfield {
                             2671 ; 102  |    unsigned int B0  :1;
                             2672 ; 103  |    unsigned int B1  :1;
                             2673 ; 104  |    unsigned int B2  :1;
                             2674 ; 105  |    unsigned int B3  :1;
                             2675 ; 106  |    unsigned int B4  :1;
                             2676 ; 107  |    unsigned int B5  :1;
                             2677 ; 108  |    unsigned int B6  :1;
                             2678 ; 109  |    unsigned int B7  :1;
                             2679 ; 110  |    unsigned int B8  :1;
                             2680 ; 111  |    unsigned int B9  :1;
                             2681 ; 112  |    unsigned int B10 :1;
                             2682 ; 113  |    unsigned int B11 :1;
                             2683 ; 114  |    unsigned int B12 :1;
                             2684 ; 115  |    unsigned int B13 :1;
                             2685 ; 116  |    unsigned int B14 :1;
                             2686 ; 117  |    unsigned int B15 :1;
                             2687 ; 118  |    unsigned int B16 :1;
                             2688 ; 119  |    unsigned int B17 :1;
                             2689 ; 120  |    unsigned int B18 :1;
                             2690 ; 121  |    unsigned int B19 :1;
                             2691 ; 122  |    unsigned int B20 :1;
                             2692 ; 123  |    unsigned int B21 :1;
                             2693 ; 124  |    unsigned int B22 :1;
                             2694 ; 125  |    unsigned int B23 :1;
                             2695 ; 126  |};
                             2696 ; 127  |
                             2697 ; 128  |union BitInt {
                             2698 ; 129  |        struct Bitfield B;
                             2699 ; 130  |        int        I;
                             2700 ; 131  |};
                             2701 ; 132  |
                             2702 ; 133  |#define MAX_MSG_LENGTH 10
                             2703 ; 134  |struct CMessage
                             2704 ; 135  |{
                             2705 ; 136  |        unsigned int m_uLength;
                             2706 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             2707 ; 138  |};
                             2708 ; 139  |
                             2709 ; 140  |typedef struct {
                             2710 ; 141  |    WORD m_wLength;
                             2711 ; 142  |    WORD m_wMessage;
                             2712 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             2713 ; 144  |} Message;
                             2714 ; 145  |
                             2715 ; 146  |struct MessageQueueDescriptor
                             2716 ; 147  |{
                             2717 ; 148  |        int *m_pBase;
                             2718 ; 149  |        int m_iModulo;
                             2719 ; 150  |        int m_iSize;
                             2720 ; 151  |        int *m_pHead;
                             2721 ; 152  |        int *m_pTail;
                             2722 ; 153  |};
                             2723 ; 154  |
                             2724 ; 155  |struct ModuleEntry
                             2725 ; 156  |{
                             2726 ; 157  |    int m_iSignaledEventMask;
                             2727 ; 158  |    int m_iWaitEventMask;
                             2728 ; 159  |    int m_iResourceOfCode;
                             2729 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             2730 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             2731 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             2732 ; 163  |    int m_uTimeOutHigh;
                             2733 ; 164  |    int m_uTimeOutLow;
                             2734 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             2735 ; 166  |};
                             2736 ; 167  |
                             2737 ; 168  |union WaitMask{
                             2738 ; 169  |    struct B{
                             2739 ; 170  |        unsigned int m_bNone     :1;
                             2740 ; 171  |        unsigned int m_bMessage  :1;
                             2741 ; 172  |        unsigned int m_bTimer    :1;
                             2742 ; 173  |        unsigned int m_bButton   :1;
                             2743 ; 174  |    } B;
                             2744 ; 175  |    int I;
                             2745 ; 176  |} ;
                             2746 ; 177  |
                             2747 ; 178  |
                             2748 ; 179  |struct Button {
                             2749 ; 180  |        WORD wButtonEvent;
                             2750 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             2751 ; 182  |};
                             2752 ; 183  |
                             2753 ; 184  |struct Message {
                             2754 ; 185  |        WORD wMsgLength;
                             2755 ; 186  |        WORD wMsgCommand;
                             2756 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             2757 ; 188  |};
                             2758 ; 189  |
                             2759 ; 190  |union EventTypes {
                             2760 ; 191  |        struct CMessage msg;
                             2761 ; 192  |        struct Button Button ;
                             2762 ; 193  |        struct Message Message;
                             2763 ; 194  |};
                             2764 ; 195  |
                             2765 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             2766 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             2767 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             2768 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             2769 ; 200  |
                             2770 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             2771 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             2772 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             2773 ; 204  |
                             2774 ; 205  |#if DEBUG
                             2775 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             2776 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             2777 ; 208  |#else 
                             2778 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             2779 ; 210  |#define DebugBuildAssert(x)    
                             2780 ; 211  |#endif
                             2781 ; 212  |
                             2782 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             2783 ; 214  |//  #pragma asm
                             2784 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             2785 ; 216  |//  #pragma endasm
                             2786 ; 217  |
                             2787 ; 218  |
                             2788 ; 219  |#ifdef COLOR_262K
                             2789 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             2790 ; 221  |#elif defined(COLOR_65K)
                             2791 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             2792 ; 223  |#else
                             2793 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             2794 ; 225  |#endif
                             2795 ; 226  |    
                             2796 ; 227  |#endif // #ifndef _TYPES_H
                             2797 
                             2799 
                             2800 ; 5    |#include "usb_internal.h"
                             2801 
                             2803 
                             2804 ; 1    |#ifndef _USB_INTERNAL_H
                             2805 ; 2    |#define _USB_INTERNAL_H
                             2806 ; 3    |
                             2807 ; 4    |#include "project.h"
                             2808 ; 5    |
                             2809 ; 6    |#ifndef MAX_USB_STRINGS
                             2810 ; 7    |#define MAX_USB_STRINGS 9
                             2811 ; 8    |#endif
                             2812 ; 9    |
                             2813 ; 10   |
                             2814 ; 11   |#define  USB_SELF_POWERED                    (0x01)
                             2815 ; 12   |#define  USB_REMOTE_WAKEUP                   (0x02)
                             2816 ; 13   |
                             2817 ; 14   |#define MAX_DESC_SIZE       86      // (255/3)+1
                             2818 ; 15   |
                             2819 ; 16   |#define MS_OS_STRING_DESCRIPTOR_INDEX 0xEE
                             2820 ; 17   |#define MS_OS_STRING_DESCRIPTOR_INDEX_IN_ARRAY 7
                             2821 ; 18   |
                             2822 ; 19   |/* The USB Device State Structure */
                             2823 ; 20   |typedef struct {
                             2824 ; 21   |   BYTE         btSpeed;                // Speed of device when connected
                             2825 ; 22   |                                        // High Speed or Full Speed
                             2826 ; 23   |   BYTE         btCurConfig;            // Current configuration number (0 means not configured yet)
                             2827 ; 24   |                                        // or default interface
                             2828 ; 25   |   BYTE         btCurInterface;         // Current Alternate Interface (0 means not configured yet)                                                         
                             2829 ; 26   |   BYTE         btAddress;              // USB device address
                             2830 ; 27   |   USHORT       usUsbState;             // State USB (UNKNOWN, POWERED, DEFAULT, ADDRESSED, CONFIGURED, SUSPENDED)
                             2831 ; 28   |   USHORT       usUsbStatePriorSusp;    // Ste USB prior a SUSPEND. This state needs to be restore
                             2832 ; 29   |                                        // once the USB resumes
                             2833 ; 30   |   USHORT       usUsbDeviceState;       // State of the device (SelfPowered, Remote Wakeup)
                             2834 ; 31   |   USHORT       usSofCount;
                             2835 ; 32   |   BYTE         btBusResetting;         // Set during a reset phase
                             2836 ; 33   |   BYTE         btServicesRegistered;   // Number of services registered
                             2837 ; 34   |   WORD         wError;                 // Increments each time a USB Error Interrupt occurs
                             2838 ; 35   |   BOOL         bEnterTestMode;         // Set when entered in test mode. To clear the device
                             2839 ; 36   |                                        // must be powered down
                             2840 ; 37   |   USHORT       usConnectionState;      // State of the USB connection (CONNECTED, DISCONNECTED, UNKNOWN)                                         
                             2841 ; 38   |} Dev_State_Struct;
                             2842 ; 39   |
                             2843 ; 40   |typedef struct xd_struct_type{
                             2844 ; 41   |   BYTE         btEndpointNum;          // Endpoint number 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  12

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2845 ; 42   |   BYTE         btDirection;            // Direction : Send/Receive
                             2846 ; 43   |   BYTE         btEndpointType;         // Type of the endpoint: Ctrl, Isoch, Bulk,Int 
                             2847 ; 44   |   BYTE         btStatus;               // Current transfer status 
                             2848 ; 45   |   WORD _X *    pbtStartAddressWord;    // Address of first byte (DSP Word address in STMP space)
                             2849 ; 46   |   BYTE         btStartOffsetByte;      // Address of first byte (Word Byte offset in STMP space)
                             2850 ; 47   |   USHORT       usTotalLength;          // Number of bytes to send/recv 
                             2851 ; 48   |   USHORT       usMaxPacketSize;        // Max Packet size 
                             2852 ; 49   |   BYTE         btDontZeroTerminate;
                             2853 ; 50   |   BOOL         bIsDataPhase;           // Set to TRUE if the transfer is data phase
                             2854 ; 51   |                                        // of a setup transfer
                             2855 ; 52   |   struct xd_struct_type _USB_MEM*pNext;     // pointer to the next xd_struct
                             2856 ; 53   |   WORD         wPrivateData;           //data to be passed to the service handler
                             2857 ; 54   |   USHORT       usBytesCopied;          //number of bytes copied so far
                             2858 ; 55   |   WORD         wCurrentOffsetByte;
                             2859 ; 56   |   WORD _X*    pbtCurrentAddressWord;
                             2860 ; 57   |} xd_struct;
                             2861 ; 58   |
                             2862 ; 59   |// If MAX_NUM_EP is not defined, default to 4
                             2863 ; 60   |// *** NOTE: if you change this definition, change the equate for MAX_NUM_EP in usb20ddmem.asm as well.
                             2864 ; 61   |// The two definitions must be equivalent for proper operation.
                             2865 ; 62   |#define MAX_NUM_EP  4
                             2866 ; 63   |
                             2867 ; 64   |extern Dev_State_Struct _USB_MEM stDeviceState;
                             2868 ; 65   |
                             2869 ; 66   |extern xd_struct _USB_MEM * g_dXD_Queues[MAX_NUM_EP][2];
                             2870 ; 67   |
                             2871 ; 68   |BYTE _reentrant usb_device_call_service(BYTE btType, BOOL bSetup, BYTE btDirection, WORD _X*ptbBuffer, WORD wLength, WORD wPrivateData);
                             2872 ; 69   |xd_struct _USB_MEM * GetEmptyXd(void);
                             2873 ; 70   |void FreeXd(xd_struct _USB_MEM * pTemp);
                             2874 ; 71   |void AddXdToQueue(xd_struct _USB_MEM *pHead,xd_struct _USB_MEM *pElement);
                             2875 ; 72   |void InitXdPool(void);
                             2876 ; 73   |_reentrant void usb_PackDescriptor(void* pDescriptor,void _X * pDestination, WORD startIndex);
                             2877 ; 74   |_reentrant void parse_strings(void);
                             2878 ; 75   |
                             2879 ; 76   |
                             2880 ; 77   |    // Service structures.
                             2881 ; 78   |    // Those are the structures storing the function handler for a specific
                             2882 ; 79   |    // USB service.
                             2883 ; 80   |    // There is a service per Endpoint + Reset + Suspend + Start Of Frame
                             2884 ; 81   |    //                                 + Resume + Sleep + Speed Detection  
                             2885 ; 82   |    // The service structs are setup by the USB application using the device driver
                             2886 ; 83   |typedef struct {
                             2887 ; 84   |   BYTE             btType;     // Which service type
                             2888 ; 85   |                                // Pointer to the service function
                             2889 ; 86   |   void (* Service)(BOOL bSetup, BYTE btDirection, WORD _X* pbtBuffer, WORD wLength, WORD wPrivateData);
                             2890 ; 87   |} Service_Struct;
                             2891 ; 88   |
                             2892 ; 89   |
                             2893 ; 90   |#endif
                             2894 
                             2896 
                             2897 ; 6    |#include "usb_api.h"
                             2898 
                             2900 
                             2901 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2902 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                             2903 ; 3    |//
                             2904 ; 4    |// File : USB_API.H
                             2905 ; 5    |// Description : USB_API.H defines and structures definition for USB device
                             2906 ; 6    |//               driver API.
                             2907 ; 7    |//               This 
                             2908 ; 8    |////////////////////////////////////////////////////////////////////////////////
                             2909 ; 9    |
                             2910 ; 10   |#ifndef __usb_api_h__
                             2911 ; 11   |#define __usb_api_h__ 1
                             2912 ; 12   |
                             2913 ; 13   |#include "types.h"
                             2914 ; 14   |#include "project.h"
                             2915 ; 15   |
                             2916 ; 16   |#ifndef _USB_MEM
                             2917 ; 17   |//if not overwridden, default to the compiler default memory space
                             2918 ; 18   |#define _USB_MEM
                             2919 ; 19   |#endif
                             2920 ; 20   |
                             2921 ; 21   |#define USB_LANGUAGE_ENGLISH 0x0409
                             2922 ; 22   |#define USB_LANGUAGE_CHINESE_PRC 0x0804
                             2923 ; 23   |#define USB_LANGUAGE_CHINESE_TAIWAN 0x0404
                             2924 ; 24   |#define USB_LANGUAGE_JAPANESE 0x0411
                             2925 ; 25   |
                             2926 ; 26   |#define MAX_STRING 30
                             2927 ; 27   |
                             2928 ; 28   |#define  USB_SPEED_FULL                      (0)
                             2929 ; 29   |#define  USB_SPEED_LOW                       (1)
                             2930 ; 30   |#define  USB_SPEED_HIGH                      (2)
                             2931 ; 31   |
                             2932 ; 32   |#define EP_FS_MAX_PACKET_SIZE               (64)    
                             2933 ; 33   |
                             2934 ; 34   |#define EP_HS_MAX_PACKET_SIZE               (512)   
                             2935 ; 35   |
                             2936 ; 36   |// Data transferred to devices based on Sigmatel 3500 chip may sometimes be 
                             2937 ; 37   |// corrupted. The corruption occurs when device is connected in USB High Speed 
                             2938 ; 38   |// mode, and size of the transfer in bytes is divisible by 128, but not 
                             2939 ; 39   |// divisible by the packet size. The workaround is implemented in Microsoft MTP 
                             2940 ; 40   |// driver to allow support for those devices.
                             2941 ; 41   |
                             2942 ; 42   |// the bug can corrupt the end of data buffer. It occurs when host sends out a 
                             2943 ; 43   |// short packet that is multiple of 128 bytes. During this scenario the USB core
                             2944 ; 44   |// does writes that are voided (byte enable == all zero), which was an undefined 
                             2945 ; 45   |// capability and thus the gasket did not apply a proper response. This should 
                             2946 ; 46   |// not affect Mass Storage applications because data transfers are 512 bytes and 
                             2947 ; 47   |// scsi commands are < 16 bytes. Other applications with their own driver will
                             2948 ; 48   |// need to pad the packets if they fall into the error case. "What this basically 
                             2949 ; 49   |// boils down to is that any time the host sends a short packet of 128, 256 or
                             2950 ; 50   |// 384 bytes to a high-speed connected player a number of bytes will be corrupted.
                             2951 ; 51   |// This is easiest to reproduce in SendObject commands but can strike any of the 
                             2952 ; 52   |// commands that take an arbitrary amount of data.
                             2953 ; 53   |#define ARC_HS_128_MODULO_BUG               (128)
                             2954 ; 54   |
                             2955 ; 55   |
                             2956 ; 56   |/* Error codes */
                             2957 ; 57   |#define USB_OK                              (0x00)
                             2958 ; 58   |#define USBERR_REGISTER_SERVICE             (0x01)  // Failed to register a service
                             2959 ; 59   |#define USBERR_NO_SERVICE                   (0x02)  // No registered service found 
                             2960 ; 60   |#define USBERR_TX_FAILED                    (0x03)  // Fail to prepare XD descriptor
                             2961 ; 61   |#define USBERR_SIZE_TOO_LARGE               (0x04)  // Number of bytes to transfer is too large
                             2962 ; 62   |#define USBERR_EP_INIT_FAILED               (0x05)  // Endpoint init fail
                             2963 ; 63   |#define USBERR_CONFIG_FAILED                (0x06)  // Error reported by the application
                             2964 ; 64   |                                                    // if the new config failed or not supported
                             2965 ; 65   |#define USBERR_DEVICE_NOT_CONFIGURED        (0x07)  // Error reported by the transfer function
                             2966 ; 66   |                                                    // if attempting to transfer while the device
                             2967 ; 67   |                                                    // is not configured
                             2968 ; 68   |#define USBERR_INIT_FAILED                  (0x08)  // Fail to initialize the USB API
                             2969 ; 69   |
                             2970 ; 70   |
                             2971 ; 71   |/* Endpoint types */
                             2972 ; 72   |#define  USB_CONTROL_ENDPOINT             (0)
                             2973 ; 73   |#define  USB_ISOCHRONOUS_ENDPOINT         (1)
                             2974 ; 74   |#define  USB_BULK_ENDPOINT                (2)
                             2975 ; 75   |#define  USB_INTERRUPT_ENDPOINT           (3)
                             2976 ; 76   |
                             2977 ; 77   |/* End point direction */
                             2978 ; 78   |#define  USB_OUT                         (0)
                             2979 ; 79   |#define  USB_IN                          (1)
                             2980 ; 80   |
                             2981 ; 81   |/* End point packed size */
                             2982 ; 82   |#define  USB_FS_MAX_PACKET_SIZE           (64)
                             2983 ; 83   |#define  USB_HS_BULK_OUT_MAX_PACKET_SIZE  (256)
                             2984 ; 84   |#define  USB_HS_BULK_IN_MAX_PACKET_SIZE   (128)
                             2985 ; 85   |
                             2986 ; 86   |
                             2987 ; 87   |#define  USB_TEST_MODE_TEST_J             (0x01)
                             2988 ; 88   |#define  USB_TEST_MODE_TEST_K             (0x02)
                             2989 ; 89   |#define  USB_TEST_MODE_TEST_SE0_NAK       (0x03)
                             2990 ; 90   |#define  USB_TEST_MODE_TEST_PACKET        (0x04)
                             2991 ; 91   |
                             2992 ; 92   |/* Available service types */
                             2993 ; 93   |/* Services 0 through 15 are reserved for endpoints */
                             2994 ; 94   |#define  USB_SERVICE_EP0                  (0x00)
                             2995 ; 95   |#define  USB_SERVICE_EP1                  (0x01)
                             2996 ; 96   |#define  USB_SERVICE_EP2                  (0x02)
                             2997 ; 97   |#define  USB_SERVICE_EP3                  (0x03)
                             2998 ; 98   |#define  USB_SERVICE_EP4                  (0x04)
                             2999 ; 99   |#define  USB_SERVICE_EP5                  (0x05)
                             3000 ; 100  |#define  USB_SERVICE_EP6                  (0x06)
                             3001 ; 101  |#define  USB_SERVICE_EP7                  (0x07)
                             3002 ; 102  |#define  USB_SERVICE_EP8                  (0x08)
                             3003 ; 103  |#define  USB_SERVICE_EP9                  (0x09)
                             3004 ; 104  |#define  USB_SERVICE_EP10                 (0x0a)
                             3005 ; 105  |#define  USB_SERVICE_EP11                 (0x0b)
                             3006 ; 106  |#define  USB_SERVICE_EP12                 (0x0c)
                             3007 ; 107  |#define  USB_SERVICE_EP13                 (0x0d)
                             3008 ; 108  |#define  USB_SERVICE_EP14                 (0x0e)
                             3009 ; 109  |#define  USB_SERVICE_EP15                 (0x0f)
                             3010 ; 110  |#define  USB_SERVICE_BUS_RESET            (0x10)
                             3011 ; 111  |#define  USB_SERVICE_SUSPEND              (0x11)
                             3012 ; 112  |#define  USB_SERVICE_SOF                  (0x12)
                             3013 ; 113  |#define  USB_SERVICE_RESUME               (0x13)
                             3014 ; 114  |#define  USB_SERVICE_SLEEP                (0x14)
                             3015 ; 115  |#define  USB_SERVICE_SPEED_DETECTION      (0x15)
                             3016 ; 116  |#define  USB_SERVICE_TEST                 (0x16)
                             3017 ; 117  |#define  USB_SERVICE_CHANGE_CONFIG        (0x17)
                             3018 ; 118  |#define  USB_SERVICE_CHANGE_IFACE         (0x18)   
                             3019 ; 119  |#define  NON_EP_SERVICES                  (USB_SERVICE_SPEED_DETECTION - USB_SERVICE_EP15)
                             3020 ; 120  |
                             3021 ; 121  |// This is the maximum service structures allocated 
                             3022 ; 122  |// One for each End point + the common services (non endpoint services) 
                             3023 ; 123  |#define MAX_NUMBER_SERVICES               (MAX_NUM_EP + NON_EP_SERVICES)  
                             3024 ; 124  |
                             3025 ; 125  |#define NUMBER_BYTES_IN_SETUP               (8)
                             3026 ; 126  |
                             3027 ; 127  |// possible values of btStatus on the xd_struct
                             3028 ; 128  |#define  USB_STATUS_TRANSFER_IDLE           (0)
                             3029 ; 129  |#define  USB_STATUS_TRANSFER_SUCCESS        (1)            
                             3030 ; 130  |#define  USB_STATUS_TRANSFER_ACCEPTED       (2)
                             3031 ; 131  |#define  USB_STATUS_TRANSFER_IN_PROGRESS    (3)
                             3032 ; 132  |#define  USB_STATUS_TRANSFER_ERROR          (4)
                             3033 ; 133  |
                             3034 ; 134  |// types of status set/returned by set_status() and get_status()
                             3035 ; 135  |#define  USB_STATUS_DEVICE_STATE          (0x01)
                             3036 ; 136  |#define  USB_STATUS_INTERFACE             (0x02)
                             3037 ; 137  |#define  USB_STATUS_ADDRESS               (0x03)
                             3038 ; 138  |#define  USB_STATUS_CURRENT_CONFIG        (0x04)
                             3039 ; 139  |#define  USB_STATUS_SOF_COUNT             (0x05)
                             3040 ; 140  |#define  USB_STATUS                       (0x06)
                             3041 ; 141  |#define  USB_STATUS_TEST_MODE             (0x07)
                             3042 ; 142  |#define  USB_STATUS_DEVICE_SPEED          (0x08)  
                             3043 ; 143  |#define  USB_STATUS_DEVICE_TEST           (0x09)  
                             3044 ; 144  |#define  USB_STATUS_CURRENT_IFACE         (0x0a)
                             3045 ; 145  |#define  USB_STATUS_CONNECTION            (0x0b)  
                             3046 ; 146  |// For status endpoint, the endpoint number is coded in the less significant nibble
                             3047 ; 147  |#define  USB_STATUS_ENDPOINT              (0x10)
                             3048 ; 148  |#define  USB_STATUS_ENDPOINT_NUMBER_MASK  (0x0F)
                             3049 ; 149  |
                             3050 ; 150  |#define USB_MAX_SIZE_PER_TRANSFER       (0x4000)    // This is the maximum size that
                             3051 ; 151  |                                                    // we allow per transfer
                             3052 ; 152  |
                             3053 ; 153  |//Possible states the device can be in
                             3054 ; 154  |#define  USB_STATE_UNKNOWN                   (0xff)
                             3055 ; 155  |#define  USB_STATE_UNPLUGGED                 (0x05) // USB Cable unplugged
                             3056 ; 156  |#define  USB_STATE_PLUGGED                   (0x04) // USB Cable inserted
                             3057 ; 157  |#define  USB_STATE_POWERED                   (0x03)
                             3058 ; 158  |#define  USB_STATE_DEFAULT                   (0x02)
                             3059 ; 159  |#define  USB_STATE_ADDRESSED                 (0x01)
                             3060 ; 160  |#define  USB_STATE_CONFIGURED                (0x00)
                             3061 ; 161  |#define  USB_STATE_SUSPENDED                 (0x80)
                             3062 ; 162  |
                             3063 ; 163  |// Possible states the connection can be in
                             3064 ; 164  |//#define USB_STATE_UNKNOWN                 (0xff)
                             3065 ; 165  |#define USB_CONNECTED                       (0x00)
                             3066 ; 166  |#define USB_DISCONNECTED                    (0x01)
                             3067 ; 167  |
                             3068 ; 168  |
                             3069 ; 169  |
                             3070 ; 170  |typedef union
                             3071 ; 171  |{
                             3072 ; 172  |    struct
                             3073 ; 173  |    {
                             3074 ; 174  |        int Recipient               : 5;
                             3075 ; 175  |        int Type                    : 2;
                             3076 ; 176  |        int DataTransferDirection   : 1;
                             3077 ; 177  |        int Request                 : 8;
                             3078 ; 178  |        int                         : 8;
                             3079 ; 179  |    } B;
                             3080 ; 180  |    
                             3081 ; 181  |    int I;
                             3082 ; 182  |} USBRequestType ;
                             3083 ; 183  |
                             3084 ; 184  |typedef struct {
                             3085 ; 185  |   BYTE     bValid;
                             3086 ; 186  |   USBRequestType RequestType;
                             3087 ; 187  |   BYTE     btRequest;
                             3088 ; 188  |   WORD     wValue;
                             3089 ; 189  |   WORD     wIndex;
                             3090 ; 190  |   WORD     wLength;
                             3091 ; 191  |    } USB_SetupData;
                             3092 ; 192  |
                             3093 ; 193  |// Descriptor sizes in bytes
                             3094 ; 194  |#define SIZE_DEVICE_DESCRIPTOR_IN_BYTES     (18)
                             3095 ; 195  |#define SIZE_DEVICE_DESCRIPTOR_IN_WORDS     (6)
                             3096 ; 196  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES   (10)
                             3097 ; 197  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_WORDS   (4)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  13

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3098 ; 198  |#define SIZE_CONFIG_DESCRIPTOR_IN_BYTES     (9)
                             3099 ; 199  |#define SIZE_CONFIG_DESCRIPTOR_IN_WORDS     (3)
                             3100 ; 200  |#define SIZE_INTERFACE_DESCRIPTOR_IN_BYTES  (9)
                             3101 ; 201  |#define SIZE_INTERFACE_DESCRIPTOR_IN_WORDS  (3)
                             3102 ; 202  |#define SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES   (7)
                             3103 ; 203  |
                             3104 ; 204  |
                             3105 ; 205  |// Descriptor types
                             3106 ; 206  |#define DESCRIPTOR_TYPE_DEVICE              (0x01)
                             3107 ; 207  |#define DESCRIPTOR_TYPE_CONFIG              (0x02)
                             3108 ; 208  |#define DESCRIPTOR_TYPE_STRING              (0x03)
                             3109 ; 209  |#define DESCRIPTOR_TYPE_INTERFACE           (0x04)
                             3110 ; 210  |#define DESCRIPTOR_TYPE_ENDPOINT            (0x05)
                             3111 ; 211  |#define DESCRIPTOR_TYPE_DEVICE_QUALIFIER    (0x06)
                             3112 ; 212  |#define DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG  (0x07)
                             3113 ; 213  |#define DESCRIPTOR_TYPE_INTERFACE_POWER     (0x08)
                             3114 ; 214  |
                             3115 ; 215  |
                             3116 ; 216  |#define USB_REQUEST_DIRECTION_HOST_TO_DEVICE    ((WORD)0x000000)
                             3117 ; 217  |#define USB_REQUEST_DIRECTION_DEVICE_TO_HOST    ((WORD)0x000001)
                             3118 ; 218  |
                             3119 ; 219  |#define USB_REQUEST_TYPE_STANDARD               ((WORD)0x000000)
                             3120 ; 220  |#define USB_REQUEST_TYPE_CLASS                  ((WORD)0x000001)
                             3121 ; 221  |#define USB_REQUEST_TYPE_VENDOR                 ((WORD)0x000002)
                             3122 ; 222  |#define USB_REQUEST_TYPE_RESERVED               ((WORD)0x000003)
                             3123 ; 223  |
                             3124 ; 224  |#define USB_REQUEST_RECIPIENT_DEVICE            ((WORD)0x000000)
                             3125 ; 225  |#define USB_REQUEST_RECIPIENT_INTERFACE         ((WORD)0x000001)
                             3126 ; 226  |#define USB_REQUEST_RECIPIENT_ENDPOINT          ((WORD)0x000002)
                             3127 ; 227  |#define USB_REQUEST_RECIPIENT_OTHER             ((WORD)0x000003)
                             3128 ; 228  |
                             3129 ; 229  |#define USB_REQUEST_STANDARD_GET_STATUS         ((WORD)0x000000)
                             3130 ; 230  |#define USB_REQUEST_STANDARD_CLEAR_FEATURE      ((WORD)0x000001)
                             3131 ; 231  |#define USB_REQUEST_STANDARD_RESERVED_1         ((WORD)0x000002)
                             3132 ; 232  |#define USB_REQUEST_STANDARD_SET_FEATURE        ((WORD)0x000003)
                             3133 ; 233  |#define USB_REQUEST_STANDARD_RESERVED_2         ((WORD)0x000004)
                             3134 ; 234  |#define USB_REQUEST_STANDARD_SET_ADDRESS        ((WORD)0x000005)
                             3135 ; 235  |#define USB_REQUEST_STANDARD_GET_DESCRIPTOR     ((WORD)0x000006)
                             3136 ; 236  |#define USB_REQUEST_STANDARD_SET_DESCRIPTOR     ((WORD)0x000007)
                             3137 ; 237  |#define USB_REQUEST_STANDARD_GET_CONFIGURATION  ((WORD)0x000008)
                             3138 ; 238  |#define USB_REQUEST_STANDARD_SET_CONFIGURATION  ((WORD)0x000009)
                             3139 ; 239  |#define USB_REQUEST_STANDARD_GET_INTERFACE      ((WORD)0x00000A)
                             3140 ; 240  |#define USB_REQUEST_STANDARD_SET_INTERFACE      ((WORD)0x00000B)
                             3141 ; 241  |#define USB_REQUEST_STANDARD_SYNCH_FRAME        ((WORD)0x00000C)
                             3142 ; 242  |
                             3143 ; 243  |#define USB_CLEAR_FEATURE_ENDPOINT_HALT         (0)
                             3144 ; 244  |#define USB_CLEAR_FEATURE_REMOTE_WAKEUP         (1)
                             3145 ; 245  |
                             3146 ; 246  |
                             3147 ; 247  |// Struct Device Descriptor
                             3148 ; 248  |typedef struct {
                             3149 ; 249  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (18)
                             3150 ; 250  |    BYTE    btDescriptorType;       // (1) Device descriptor type (1)
                             3151 ; 251  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2.00 0x00)
                             3152 ; 252  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2.00 0x02)     
                             3153 ; 253  |    BYTE    btDeviceClass;          // (4) Class code
                             3154 ; 254  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             3155 ; 255  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             3156 ; 256  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 (8, 16, 32 or 64)
                             3157 ; 257  |    BYTE    btIdVendorLsb;          // (8) Vendor Id
                             3158 ; 258  |    BYTE    btIdVendorMsb;          // (9)
                             3159 ; 259  |    BYTE    btIdProductLsb;         // (10) Product Id
                             3160 ; 260  |    BYTE    btIdProductMsb;         // (11)
                             3161 ; 261  |    BYTE    btBcdReleaseLsb;        // (12) Device release number in BCD
                             3162 ; 262  |    BYTE    btBcdReleaseMsb;        // (13)
                             3163 ; 263  |    BYTE    btIndexManufacturer;    // (14) Index of string descriptor describing Manufacturer
                             3164 ; 264  |    BYTE    btIndexProduct;         // (15) Index of string descriptor describing Product
                             3165 ; 265  |    BYTE    btIndexSerialNumber;    // (16) Index of string descriptor describing Device Serial Number
                             3166 ; 266  |    BYTE    btNumConfigurations;    // (17) Number of possible configurations
                             3167 ; 267  |} Struct_Standard_Dev_Desc;
                             3168 ; 268  |
                             3169 ; 269  |// Struct Device Qualifier Descriptor
                             3170 ; 270  |typedef struct {
                             3171 ; 271  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (10)
                             3172 ; 272  |    BYTE    btDescriptorType;       // (1) Device descriptor type (6)
                             3173 ; 273  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2.00 0x00)
                             3174 ; 274  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2.00 0x02)     
                             3175 ; 275  |    BYTE    btDeviceClass;          // (4) Class code
                             3176 ; 276  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             3177 ; 277  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             3178 ; 278  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 other speed (8, 16, 32 or 64)
                             3179 ; 279  |    BYTE    btNumConfigurations;    // (8) Number of other-speed possible configurations
                             3180 ; 280  |    BYTE    btReserved;             // (9) Reserved for future use, must be 0
                             3181 ; 281  |} Struct_Dev_Qualifier_Desc;
                             3182 ; 282  |
                             3183 ; 283  |// Struct Configuration Descriptor
                             3184 ; 284  |typedef struct {
                             3185 ; 285  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             3186 ; 286  |    BYTE    btDescriptorType;       // (1) Device descriptor type (2 or 7)
                             3187 ; 287  |    BYTE    btTotalLengthLsb;       // (2) Total length of data returned for this config.
                             3188 ; 288  |    BYTE    btTotalLengthMsb;       // (3)                                  
                             3189 ; 289  |    BYTE    btNumInterfaces;        // (4) Number of Interfaces supported by this configuration
                             3190 ; 290  |    BYTE    btConfigurationValue;   // (5) Value to use as an argument to the SetConfiguration() request
                             3191 ; 291  |    BYTE    btIndexConfiguration;   // (6) Index of string descriptor describing this configuration
                             3192 ; 292  |    BYTE    btBitMapAttributes;     // (7) Configuration Characteristics
                             3193 ; 293  |                                    //     D7:      Reserved (set to one)
                             3194 ; 294  |                                    //     D6:      Self-powered
                             3195 ; 295  |                                    //     D5:      Remote Wakeup
                             3196 ; 296  |                                    //     D4..0:   Reserved (reset to zero)        
                             3197 ; 297  |    BYTE    btMaxPower;             // (8) Maximum power consumption expressed in 2mA units.
                             3198 ; 298  |} Struct_Standard_Config_Desc, Struct_Other_Speed_Config_Desc;
                             3199 ; 299  |
                             3200 ; 300  |// Struct Interface Descriptor
                             3201 ; 301  |typedef struct {
                             3202 ; 302  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             3203 ; 303  |    BYTE    btDescriptorType;       // (1) Device descriptor type (4)
                             3204 ; 304  |    BYTE    btInterfaceNum;         // (2) Number of this interface. Zero-based value.
                             3205 ; 305  |    BYTE    btAlternateSetting;     // (3)                                  
                             3206 ; 306  |    BYTE    btNumEndpoints;         // (4) Number of endpointsused by this interface (excluding endpoint 0).
                             3207 ; 307  |    BYTE    btInterfaceClass;       // (5) Class code
                             3208 ; 308  |    BYTE    btInterfaceSubClass;    // (6) Sub Class code
                             3209 ; 309  |    BYTE    btInterfaceProtocol;    // (7) Protocol Code
                             3210 ; 310  |    BYTE    btIndexInterface;       // (8) Index of string descriptor describing this interface
                             3211 ; 311  |} Struct_Standard_Interface_Desc;
                             3212 ; 312  |
                             3213 ; 313  |// Struct Endpoint Descriptor
                             3214 ; 314  |typedef struct {
                             3215 ; 315  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (7)
                             3216 ; 316  |    BYTE    btDescriptorType;       // (1) Device descriptor type (5)
                             3217 ; 317  |    BYTE    btEndpointAddress;      // (2) Address of the endpoint on the USB device described by this descriptor
                             3218 ; 318  |                                    //      Bit 3..0: Endpoint number
                             3219 ; 319  |                                    //      Bit 6..4: Reserved, reset to zero
                             3220 ; 320  |                                    //      Bit 7:    Direction. Ignored for control endpoints (0 OUT, 1 IN)
                             3221 ; 321  |    BYTE    btBitMapAttributes;     // (3) Endpoint attributes
                             3222 ; 322  |                                    //      bits 1..0: Transfer Type (00 Control, 01 Iso, 10 Bulk, 11 Int)
                             3223 ; 323  |                                    //      bits 5..2: If not an iso endpoints, they are reserved and must be reset to zero.
                             3224 ; 324  |                                    //      bits 7..6: Reserved bits, must be reset to zero.                                    
                             3225 ; 325  |    BYTE    btMaxPacketSizeLsb;     // (4) Maximum packet size. Refer to standard for bits specification
                             3226 ; 326  |    BYTE    btMaxPacketSizeMsb;     // (5)
                             3227 ; 327  |    BYTE    btInterval;             // (6) Interval for polling endpoint for data transfers (refer to standard)
                             3228 ; 328  |} Struct_Standard_Endpoint_Desc;
                             3229 ; 329  |
                             3230 ; 330  |typedef struct {
                             3231 ; 331  |    BYTE    btLength;                   // (0) Size of this descriptor in bytes (2*MAX_USB_LANG + 2)
                             3232 ; 332  |    BYTE    btDescriptorType;           // (1) String descriptor type (3)
                             3233 ; 333  |    BYTE    btString[MAX_STRING*2];       
                             3234 ; 334  |} Struct_String_Desc;
                             3235 ; 335  |
                             3236 ; 336  |//
                             3237 ; 337  |// Externals
                             3238 ; 338  |//
                             3239 ; 339  |extern void _reentrant usb_dci_chip_enable (void);
                             3240 ; 340  |extern void _reentrant usb_dci_shutdown(void);
                             3241 ; 341  |
                             3242 ; 342  |BYTE _reentrant usb_device_init(void);
                             3243 ; 343  |void _inline usb_device_shutdown(void)
                             3244 ; 344  |{
                             3245 ; 345  |    usb_dci_shutdown();
                             3246 ; 346  |}
                             3247 ; 347  |
                             3248 ; 348  |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData)); 
                             3249 ; 349  |//Remove unused function usb_device_get_service() to reclain _P memroy.
                             3250 ; 350  |//BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength)); 
                             3251 ; 351  |
                             3252 ; 352  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btDirection, BYTE btType, BOOL bFlag);
                             3253 ; 353  |
                             3254 ; 354  |extern USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             3255 ; 355  |#define usb_device_read_setup_data(btEndpoint) usb_dci_get_setup_data(btEndpoint)
                             3256 ; 356  |
                             3257 ; 357  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus);
                             3258 ; 358  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus);
                             3259 ; 359  |BYTE _reentrant usb_device_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             3260 ; 360  |
                             3261 ; 361  |extern void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3262 ; 362  |#define usb_device_stall_endpoint(btEndpoint, btDirection) usb_dci_stall_endpoint((btEndpoint), (btDirection))
                             3263 ; 363  |
                             3264 ; 364  |extern void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3265 ; 365  |#define usb_device_unstall_endpoint(btEndpoint, btDirection) usb_dci_unstall_endpoint((btEndpoint), (btDirection))
                             3266 ; 366  |
                             3267 ; 367  |extern void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             3268 ; 368  |#define usb_device_finish_transaction(btEndpoint) usb_dci_finish_transaction(btEndpoint);
                             3269 ; 369  |
                             3270 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             3271 ; 371  |//
                             3272 ; 372  |//>  Name:          usb_device_enable
                             3273 ; 373  |//
                             3274 ; 374  |//   Type:          Function
                             3275 ; 375  |//
                             3276 ; 376  |//   Description:   Enables the USB device for transfers
                             3277 ; 377  |//
                             3278 ; 378  |//   Inputs:        none
                             3279 ; 379  |//
                             3280 ; 380  |//   Outputs:       USB_OK or error code
                             3281 ; 381  |//
                             3282 ; 382  |//   Notes:         none
                             3283 ; 383  |//<
                             3284 ; 384  |////////////////////////////////////////////////////////////////////////////////
                             3285 ; 385  |void _inline usb_device_enable(void)
                             3286 ; 386  |{
                             3287 ; 387  |    usb_dci_chip_enable();
                             3288 ; 388  |}
                             3289 ; 389  |
                             3290 ; 390  |void _reentrant usb_device_release(void);
                             3291 ; 391  |void _reentrant usb_device_hold(void);
                             3292 ; 392  |BYTE _reentrant usb_device_is_hold(void);
                             3293 ; 393  |void _reentrant usb_device_data_phase_required(void);
                             3294 ; 394  |
                             3295 ; 395  |BOOL _reentrant usb_device_is_first_init(void);
                             3296 ; 396  |void _reentrant usb_device_set_first_init(void);
                             3297 ; 397  |void _reentrant usb_device_clear_first_init(void);
                             3298 ; 398  |
                             3299 ; 399  |WORD _reentrant usb_get_current_limit(void);
                             3300 ; 400  |RETCODE _reentrant usb_set_current_limit(WORD);
                             3301 ; 401  |
                             3302 ; 402  |////////////////////////////////////////////////////////////////////
                             3303 ; 403  |extern BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             3304 ; 404  |#define usb_device_get_endpoint_status(btEndpoint) usb_dci_get_endpoint_status(btEndpoint)
                             3305 ; 405  |
                             3306 ; 406  |#define USB_ENDPOINT_STATUS_OK                          0
                             3307 ; 407  |#define USB_ENDPOINT_STATUS_STALLED                     1
                             3308 ; 408  |#define USB_ENDPOINT_STATUS_RECIEVED_UNSTALL_REQUEST    2
                             3309 ; 409  |// WHQL
                             3310 ; 410  |#define USB_ENDPOINT_STATUS_HOST_STALLED                3
                             3311 ; 411  |////////////////////////////////////////////////////////////////////
                             3312 ; 412  |
                             3313 ; 413  |
                             3314 ; 414  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByteOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             3315 ; 415  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByteOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             3316 ; 416  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLength,WORD wPrivateData);
                             3317 ; 417  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             3318 ; 418  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateData, 
                             3319 ; 419  |                                         BOOL bIsDataPhase, WORD wDirection);
                             3320 ; 420  |
                             3321 ; 421  |#ifndef CUSTOMIZE_UNICODE
                             3322 ; 422  |extern const BYTE g_Manufacturer[];
                             3323 ; 423  |extern const BYTE g_ProductName[];
                             3324 ; 424  |extern const BYTE g_ConfigString[];
                             3325 ; 425  |extern const BYTE g_Interface0String[];
                             3326 ; 426  |extern const BYTE g_Interface1String[];
                             3327 ; 427  |extern const BYTE g_MSOSDescriptorString[];
                             3328 ; 428  |#else   // CUSTOMIZE_UNICODE
                             3329 ; 429  |extern const WORD g_Manufacturer[];
                             3330 ; 430  |extern const WORD g_ProductName[];
                             3331 ; 431  |extern const WORD g_ConfigString[];
                             3332 ; 432  |extern const WORD g_Interface0String[];
                             3333 ; 433  |extern const WORD g_Interface1String[];
                             3334 ; 434  |extern const WORD g_MSOSDescriptorString[];
                             3335 ; 435  |#endif
                             3336 ; 436  |extern WORD g_LanguageList[];
                             3337 ; 437  |
                             3338 ; 438  |extern const BYTE g_SCSIVendorID[];
                             3339 ; 439  |extern const BYTE g_SCSIProductID[];
                             3340 ; 440  |extern void *g_pStrings[];
                             3341 ; 441  |
                             3342 ; 442  |extern WORD g_wUSBVendorID;
                             3343 ; 443  |extern WORD g_wUSBProductID;
                             3344 ; 444  |extern WORD g_wUSBReleaseID;
                             3345 ; 445  |
                             3346 ; 446  |#endif
                             3347 ; 447  |/* EOF */
                             3348 ; 448  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  14

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3349 
                             3351 
                             3352 ; 7    |
                             3353 ; 8    |
                             3354 ; 9    |BYTE _reentrant usb_dci_init                (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3355 ; 10   |#define usb_dci_chip_init(pStDeviceState) /* Do Nothing */
                             3356 ; 11   |void _reentrant usb_dci_process_reset       (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3357 ; 12   |void _reentrant usb_dci_process_tr_complete (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3358 ; 13   |void _reentrant usb_dci_process_suspend     (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3359 ; 14   |void _reentrant usb_dci_process_port_change (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3360 ; 15   |BYTE _reentrant usb_dci_init_endpoint       (xd_struct _USB_MEM * pStXD);
                             3361 ; 16   |USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             3362 ; 17   |BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             3363 ; 18   |void _reentrant usb_dci_set_endpoint_status(BYTE btEndpoint, USHORT usStatus);
                             3364 ; 19   |void _reentrant usb_dci_set_address(BYTE btAddress);
                             3365 ; 20   |BYTE _reentrant usb_dci_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             3366 ; 21   |void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3367 ; 22   |void _reentrant usb_dci_host_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3368 ; 23   |void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3369 ; 24   |void _reentrant usb_dci_init_data_toggle_endpoint(BYTE btEndpoint);
                             3370 ; 25   |BYTE _reentrant usb_dci_transfer_data(xd_struct _USB_MEM * pStXd);
                             3371 ; 26   |void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             3372 ; 27   |void _reentrant usb_dci_update_connection_status(void);
                             3373 ; 28   |void _reentrant usb_dci_shutdown(void);
                             3374 ; 29   |void _reentrant usb_dci_set_test_mode(USHORT usTest); 
                             3375 ; 30   |
                             3376 ; 31   |void _reentrant usb_dci_chip_enable (void);
                             3377 ; 32   |#endif
                             3378 
                             3380 
                             3381 ; 20   |#include "..\usb20ddprv.h"
                             3382 
                             3384 
                             3385 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3386 ; 2    |// Copyright(C) SigmaTel, Inc. 2002-2003
                             3387 ; 3    |//
                             3388 ; 4    |// File        : usb20ddprv.h
                             3389 ; 5    |// Description : This file contains the private defines, externs and
                             3390 ; 6    |//           data structure definitions required by the USB2.0 Device Driver
                             3391 ; 7    |////////////////////////////////////////////////////////////////////////////////
                             3392 ; 8    |
                             3393 ; 9    |#ifndef __usb20ddprv_h__
                             3394 ; 10   |#define __usb20ddprv_h__ 1
                             3395 ; 11   |
                             3396 ; 12   |#include "types.h"
                             3397 
                             3399 
                             3400 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3401 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             3402 ; 3    |//
                             3403 ; 4    |// Filename: types.h
                             3404 ; 5    |// Description: Standard data types
                             3405 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3406 ; 7    |
                             3407 ; 8    |#ifndef _TYPES_H
                             3408 ; 9    |#define _TYPES_H
                             3409 ; 10   |
                             3410 ; 11   |// TODO:  move this outta here!
                             3411 ; 12   |#if !defined(NOERROR)
                             3412 ; 13   |#define NOERROR 0
                             3413 ; 14   |#define SUCCESS 0
                             3414 ; 15   |#endif 
                             3415 ; 16   |#if !defined(SUCCESS)
                             3416 ; 17   |#define SUCCESS  0
                             3417 ; 18   |#endif
                             3418 ; 19   |#if !defined(ERROR)
                             3419 ; 20   |#define ERROR   -1
                             3420 ; 21   |#endif
                             3421 ; 22   |#if !defined(FALSE)
                             3422 ; 23   |#define FALSE 0
                             3423 ; 24   |#endif
                             3424 ; 25   |#if !defined(TRUE)
                             3425 ; 26   |#define TRUE  1
                             3426 ; 27   |#endif
                             3427 ; 28   |
                             3428 ; 29   |#if !defined(NULL)
                             3429 ; 30   |#define NULL 0
                             3430 ; 31   |#endif
                             3431 ; 32   |
                             3432 ; 33   |#define MAX_INT     0x7FFFFF
                             3433 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             3434 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             3435 ; 36   |#define MAX_ULONG   (-1) 
                             3436 ; 37   |
                             3437 ; 38   |#define WORD_SIZE   24              // word size in bits
                             3438 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             3439 ; 40   |
                             3440 ; 41   |
                             3441 ; 42   |#define BYTE    unsigned char       // btVarName
                             3442 ; 43   |#define CHAR    signed char         // cVarName
                             3443 ; 44   |#define USHORT  unsigned short      // usVarName
                             3444 ; 45   |#define SHORT   unsigned short      // sVarName
                             3445 ; 46   |#define WORD    unsigned int        // wVarName
                             3446 ; 47   |#define INT     signed int          // iVarName
                             3447 ; 48   |#define DWORD   unsigned long       // dwVarName
                             3448 ; 49   |#define LONG    signed long         // lVarName
                             3449 ; 50   |#define BOOL    unsigned int        // bVarName
                             3450 ; 51   |#define FRACT   _fract              // frVarName
                             3451 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             3452 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             3453 ; 54   |#define FLOAT   float               // fVarName
                             3454 ; 55   |#define DBL     double              // dVarName
                             3455 ; 56   |#define ENUM    enum                // eVarName
                             3456 ; 57   |#define CMX     _complex            // cmxVarName
                             3457 ; 58   |typedef WORD UCS3;                   // 
                             3458 ; 59   |
                             3459 ; 60   |#define UINT16  unsigned short
                             3460 ; 61   |#define UINT8   unsigned char   
                             3461 ; 62   |#define UINT32  unsigned long
                             3462 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             3463 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             3464 ; 65   |#define WCHAR   UINT16
                             3465 ; 66   |
                             3466 ; 67   |//UINT128 is 16 bytes or 6 words
                             3467 ; 68   |typedef struct UINT128_3500 {   
                             3468 ; 69   |    int val[6];     
                             3469 ; 70   |} UINT128_3500;
                             3470 ; 71   |
                             3471 ; 72   |#define UINT128   UINT128_3500
                             3472 ; 73   |
                             3473 ; 74   |// Little endian word packed byte strings:   
                             3474 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3475 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3476 ; 77   |// Little endian word packed byte strings:   
                             3477 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3478 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3479 ; 80   |
                             3480 ; 81   |// Declare Memory Spaces To Use When Coding
                             3481 ; 82   |// A. Sector Buffers
                             3482 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             3483 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             3484 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             3485 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             3486 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             3487 ; 88   |// B. Media DDI Memory
                             3488 ; 89   |#define MEDIA_DDI_MEM _Y
                             3489 ; 90   |
                             3490 ; 91   |
                             3491 ; 92   |
                             3492 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             3493 ; 94   |// Examples of circular pointers:
                             3494 ; 95   |//    INT CIRC cpiVarName
                             3495 ; 96   |//    DWORD CIRC cpdwVarName
                             3496 ; 97   |
                             3497 ; 98   |#define RETCODE INT                 // rcVarName
                             3498 ; 99   |
                             3499 ; 100  |// generic bitfield structure
                             3500 ; 101  |struct Bitfield {
                             3501 ; 102  |    unsigned int B0  :1;
                             3502 ; 103  |    unsigned int B1  :1;
                             3503 ; 104  |    unsigned int B2  :1;
                             3504 ; 105  |    unsigned int B3  :1;
                             3505 ; 106  |    unsigned int B4  :1;
                             3506 ; 107  |    unsigned int B5  :1;
                             3507 ; 108  |    unsigned int B6  :1;
                             3508 ; 109  |    unsigned int B7  :1;
                             3509 ; 110  |    unsigned int B8  :1;
                             3510 ; 111  |    unsigned int B9  :1;
                             3511 ; 112  |    unsigned int B10 :1;
                             3512 ; 113  |    unsigned int B11 :1;
                             3513 ; 114  |    unsigned int B12 :1;
                             3514 ; 115  |    unsigned int B13 :1;
                             3515 ; 116  |    unsigned int B14 :1;
                             3516 ; 117  |    unsigned int B15 :1;
                             3517 ; 118  |    unsigned int B16 :1;
                             3518 ; 119  |    unsigned int B17 :1;
                             3519 ; 120  |    unsigned int B18 :1;
                             3520 ; 121  |    unsigned int B19 :1;
                             3521 ; 122  |    unsigned int B20 :1;
                             3522 ; 123  |    unsigned int B21 :1;
                             3523 ; 124  |    unsigned int B22 :1;
                             3524 ; 125  |    unsigned int B23 :1;
                             3525 ; 126  |};
                             3526 ; 127  |
                             3527 ; 128  |union BitInt {
                             3528 ; 129  |        struct Bitfield B;
                             3529 ; 130  |        int        I;
                             3530 ; 131  |};
                             3531 ; 132  |
                             3532 ; 133  |#define MAX_MSG_LENGTH 10
                             3533 ; 134  |struct CMessage
                             3534 ; 135  |{
                             3535 ; 136  |        unsigned int m_uLength;
                             3536 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             3537 ; 138  |};
                             3538 ; 139  |
                             3539 ; 140  |typedef struct {
                             3540 ; 141  |    WORD m_wLength;
                             3541 ; 142  |    WORD m_wMessage;
                             3542 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             3543 ; 144  |} Message;
                             3544 ; 145  |
                             3545 ; 146  |struct MessageQueueDescriptor
                             3546 ; 147  |{
                             3547 ; 148  |        int *m_pBase;
                             3548 ; 149  |        int m_iModulo;
                             3549 ; 150  |        int m_iSize;
                             3550 ; 151  |        int *m_pHead;
                             3551 ; 152  |        int *m_pTail;
                             3552 ; 153  |};
                             3553 ; 154  |
                             3554 ; 155  |struct ModuleEntry
                             3555 ; 156  |{
                             3556 ; 157  |    int m_iSignaledEventMask;
                             3557 ; 158  |    int m_iWaitEventMask;
                             3558 ; 159  |    int m_iResourceOfCode;
                             3559 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             3560 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             3561 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             3562 ; 163  |    int m_uTimeOutHigh;
                             3563 ; 164  |    int m_uTimeOutLow;
                             3564 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             3565 ; 166  |};
                             3566 ; 167  |
                             3567 ; 168  |union WaitMask{
                             3568 ; 169  |    struct B{
                             3569 ; 170  |        unsigned int m_bNone     :1;
                             3570 ; 171  |        unsigned int m_bMessage  :1;
                             3571 ; 172  |        unsigned int m_bTimer    :1;
                             3572 ; 173  |        unsigned int m_bButton   :1;
                             3573 ; 174  |    } B;
                             3574 ; 175  |    int I;
                             3575 ; 176  |} ;
                             3576 ; 177  |
                             3577 ; 178  |
                             3578 ; 179  |struct Button {
                             3579 ; 180  |        WORD wButtonEvent;
                             3580 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             3581 ; 182  |};
                             3582 ; 183  |
                             3583 ; 184  |struct Message {
                             3584 ; 185  |        WORD wMsgLength;
                             3585 ; 186  |        WORD wMsgCommand;
                             3586 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             3587 ; 188  |};
                             3588 ; 189  |
                             3589 ; 190  |union EventTypes {
                             3590 ; 191  |        struct CMessage msg;
                             3591 ; 192  |        struct Button Button ;
                             3592 ; 193  |        struct Message Message;
                             3593 ; 194  |};
                             3594 ; 195  |
                             3595 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             3596 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             3597 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             3598 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             3599 ; 200  |
                             3600 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             3601 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             3602 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             3603 ; 204  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  15

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3604 ; 205  |#if DEBUG
                             3605 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             3606 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             3607 ; 208  |#else 
                             3608 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             3609 ; 210  |#define DebugBuildAssert(x)    
                             3610 ; 211  |#endif
                             3611 ; 212  |
                             3612 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             3613 ; 214  |//  #pragma asm
                             3614 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             3615 ; 216  |//  #pragma endasm
                             3616 ; 217  |
                             3617 ; 218  |
                             3618 ; 219  |#ifdef COLOR_262K
                             3619 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             3620 ; 221  |#elif defined(COLOR_65K)
                             3621 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             3622 ; 223  |#else
                             3623 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             3624 ; 225  |#endif
                             3625 ; 226  |    
                             3626 ; 227  |#endif // #ifndef _TYPES_H
                             3627 
                             3629 
                             3630 ; 13   |#include "regsusb20.h"
                             3631 
                             3633 
                             3634 ; 1    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             3635 ; 2    |//;  Copyright(C) SigmaTel, Inc. 2002-2003
                             3636 ; 3    |//;  File        : regsusb20ip.inc
                             3637 ; 4    |//;  Description : USB20 IP Register definition
                             3638 ; 5    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             3639 ; 6    |
                             3640 ; 7    |// The following naming conventions are followed in this file.
                             3641 ; 8    |// All registers are named using the format...
                             3642 ; 9    |//     HW_<module>_<regname>
                             3643 ; 10   |// where <module> is the module name which can be any of the following...
                             3644 ; 11   |//     USB20
                             3645 ; 12   |// (Note that when there is more than one copy of a particular module, the
                             3646 ; 13   |// module name includes a number starting from 0 for the first instance of
                             3647 ; 14   |// that module)
                             3648 ; 15   |// <regname> is the specific register within that module
                             3649 ; 16   |// We also define the following...
                             3650 ; 17   |//     HW_<module>_<regname>_BITPOS
                             3651 ; 18   |// which defines the starting bit (i.e. LSB) of a multi bit field
                             3652 ; 19   |//     HW_<module>_<regname>_SETMASK
                             3653 ; 20   |// which does something else, and
                             3654 ; 21   |//     HW_<module>_<regname>_CLRMASK
                             3655 ; 22   |// which does something else.
                             3656 ; 23   |// Other rules
                             3657 ; 24   |//     All caps
                             3658 ; 25   |//     Numeric identifiers start at 0
                             3659 ; 26   |
                             3660 ; 27   |#if !(defined(regsusb20inc))
                             3661 ; 28   |#define regsusb20inc 1
                             3662 ; 29   |
                             3663 ; 30   |#include "types.h"
                             3664 
                             3666 
                             3667 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3668 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             3669 ; 3    |//
                             3670 ; 4    |// Filename: types.h
                             3671 ; 5    |// Description: Standard data types
                             3672 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3673 ; 7    |
                             3674 ; 8    |#ifndef _TYPES_H
                             3675 ; 9    |#define _TYPES_H
                             3676 ; 10   |
                             3677 ; 11   |// TODO:  move this outta here!
                             3678 ; 12   |#if !defined(NOERROR)
                             3679 ; 13   |#define NOERROR 0
                             3680 ; 14   |#define SUCCESS 0
                             3681 ; 15   |#endif 
                             3682 ; 16   |#if !defined(SUCCESS)
                             3683 ; 17   |#define SUCCESS  0
                             3684 ; 18   |#endif
                             3685 ; 19   |#if !defined(ERROR)
                             3686 ; 20   |#define ERROR   -1
                             3687 ; 21   |#endif
                             3688 ; 22   |#if !defined(FALSE)
                             3689 ; 23   |#define FALSE 0
                             3690 ; 24   |#endif
                             3691 ; 25   |#if !defined(TRUE)
                             3692 ; 26   |#define TRUE  1
                             3693 ; 27   |#endif
                             3694 ; 28   |
                             3695 ; 29   |#if !defined(NULL)
                             3696 ; 30   |#define NULL 0
                             3697 ; 31   |#endif
                             3698 ; 32   |
                             3699 ; 33   |#define MAX_INT     0x7FFFFF
                             3700 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             3701 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             3702 ; 36   |#define MAX_ULONG   (-1) 
                             3703 ; 37   |
                             3704 ; 38   |#define WORD_SIZE   24              // word size in bits
                             3705 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             3706 ; 40   |
                             3707 ; 41   |
                             3708 ; 42   |#define BYTE    unsigned char       // btVarName
                             3709 ; 43   |#define CHAR    signed char         // cVarName
                             3710 ; 44   |#define USHORT  unsigned short      // usVarName
                             3711 ; 45   |#define SHORT   unsigned short      // sVarName
                             3712 ; 46   |#define WORD    unsigned int        // wVarName
                             3713 ; 47   |#define INT     signed int          // iVarName
                             3714 ; 48   |#define DWORD   unsigned long       // dwVarName
                             3715 ; 49   |#define LONG    signed long         // lVarName
                             3716 ; 50   |#define BOOL    unsigned int        // bVarName
                             3717 ; 51   |#define FRACT   _fract              // frVarName
                             3718 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             3719 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             3720 ; 54   |#define FLOAT   float               // fVarName
                             3721 ; 55   |#define DBL     double              // dVarName
                             3722 ; 56   |#define ENUM    enum                // eVarName
                             3723 ; 57   |#define CMX     _complex            // cmxVarName
                             3724 ; 58   |typedef WORD UCS3;                   // 
                             3725 ; 59   |
                             3726 ; 60   |#define UINT16  unsigned short
                             3727 ; 61   |#define UINT8   unsigned char   
                             3728 ; 62   |#define UINT32  unsigned long
                             3729 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             3730 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             3731 ; 65   |#define WCHAR   UINT16
                             3732 ; 66   |
                             3733 ; 67   |//UINT128 is 16 bytes or 6 words
                             3734 ; 68   |typedef struct UINT128_3500 {   
                             3735 ; 69   |    int val[6];     
                             3736 ; 70   |} UINT128_3500;
                             3737 ; 71   |
                             3738 ; 72   |#define UINT128   UINT128_3500
                             3739 ; 73   |
                             3740 ; 74   |// Little endian word packed byte strings:   
                             3741 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3742 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3743 ; 77   |// Little endian word packed byte strings:   
                             3744 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3745 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3746 ; 80   |
                             3747 ; 81   |// Declare Memory Spaces To Use When Coding
                             3748 ; 82   |// A. Sector Buffers
                             3749 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             3750 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             3751 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             3752 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             3753 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             3754 ; 88   |// B. Media DDI Memory
                             3755 ; 89   |#define MEDIA_DDI_MEM _Y
                             3756 ; 90   |
                             3757 ; 91   |
                             3758 ; 92   |
                             3759 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             3760 ; 94   |// Examples of circular pointers:
                             3761 ; 95   |//    INT CIRC cpiVarName
                             3762 ; 96   |//    DWORD CIRC cpdwVarName
                             3763 ; 97   |
                             3764 ; 98   |#define RETCODE INT                 // rcVarName
                             3765 ; 99   |
                             3766 ; 100  |// generic bitfield structure
                             3767 ; 101  |struct Bitfield {
                             3768 ; 102  |    unsigned int B0  :1;
                             3769 ; 103  |    unsigned int B1  :1;
                             3770 ; 104  |    unsigned int B2  :1;
                             3771 ; 105  |    unsigned int B3  :1;
                             3772 ; 106  |    unsigned int B4  :1;
                             3773 ; 107  |    unsigned int B5  :1;
                             3774 ; 108  |    unsigned int B6  :1;
                             3775 ; 109  |    unsigned int B7  :1;
                             3776 ; 110  |    unsigned int B8  :1;
                             3777 ; 111  |    unsigned int B9  :1;
                             3778 ; 112  |    unsigned int B10 :1;
                             3779 ; 113  |    unsigned int B11 :1;
                             3780 ; 114  |    unsigned int B12 :1;
                             3781 ; 115  |    unsigned int B13 :1;
                             3782 ; 116  |    unsigned int B14 :1;
                             3783 ; 117  |    unsigned int B15 :1;
                             3784 ; 118  |    unsigned int B16 :1;
                             3785 ; 119  |    unsigned int B17 :1;
                             3786 ; 120  |    unsigned int B18 :1;
                             3787 ; 121  |    unsigned int B19 :1;
                             3788 ; 122  |    unsigned int B20 :1;
                             3789 ; 123  |    unsigned int B21 :1;
                             3790 ; 124  |    unsigned int B22 :1;
                             3791 ; 125  |    unsigned int B23 :1;
                             3792 ; 126  |};
                             3793 ; 127  |
                             3794 ; 128  |union BitInt {
                             3795 ; 129  |        struct Bitfield B;
                             3796 ; 130  |        int        I;
                             3797 ; 131  |};
                             3798 ; 132  |
                             3799 ; 133  |#define MAX_MSG_LENGTH 10
                             3800 ; 134  |struct CMessage
                             3801 ; 135  |{
                             3802 ; 136  |        unsigned int m_uLength;
                             3803 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             3804 ; 138  |};
                             3805 ; 139  |
                             3806 ; 140  |typedef struct {
                             3807 ; 141  |    WORD m_wLength;
                             3808 ; 142  |    WORD m_wMessage;
                             3809 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             3810 ; 144  |} Message;
                             3811 ; 145  |
                             3812 ; 146  |struct MessageQueueDescriptor
                             3813 ; 147  |{
                             3814 ; 148  |        int *m_pBase;
                             3815 ; 149  |        int m_iModulo;
                             3816 ; 150  |        int m_iSize;
                             3817 ; 151  |        int *m_pHead;
                             3818 ; 152  |        int *m_pTail;
                             3819 ; 153  |};
                             3820 ; 154  |
                             3821 ; 155  |struct ModuleEntry
                             3822 ; 156  |{
                             3823 ; 157  |    int m_iSignaledEventMask;
                             3824 ; 158  |    int m_iWaitEventMask;
                             3825 ; 159  |    int m_iResourceOfCode;
                             3826 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             3827 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             3828 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             3829 ; 163  |    int m_uTimeOutHigh;
                             3830 ; 164  |    int m_uTimeOutLow;
                             3831 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             3832 ; 166  |};
                             3833 ; 167  |
                             3834 ; 168  |union WaitMask{
                             3835 ; 169  |    struct B{
                             3836 ; 170  |        unsigned int m_bNone     :1;
                             3837 ; 171  |        unsigned int m_bMessage  :1;
                             3838 ; 172  |        unsigned int m_bTimer    :1;
                             3839 ; 173  |        unsigned int m_bButton   :1;
                             3840 ; 174  |    } B;
                             3841 ; 175  |    int I;
                             3842 ; 176  |} ;
                             3843 ; 177  |
                             3844 ; 178  |
                             3845 ; 179  |struct Button {
                             3846 ; 180  |        WORD wButtonEvent;
                             3847 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             3848 ; 182  |};
                             3849 ; 183  |
                             3850 ; 184  |struct Message {
                             3851 ; 185  |        WORD wMsgLength;
                             3852 ; 186  |        WORD wMsgCommand;
                             3853 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             3854 ; 188  |};
                             3855 ; 189  |
                             3856 ; 190  |union EventTypes {
                             3857 ; 191  |        struct CMessage msg;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  16

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3858 ; 192  |        struct Button Button ;
                             3859 ; 193  |        struct Message Message;
                             3860 ; 194  |};
                             3861 ; 195  |
                             3862 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             3863 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             3864 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             3865 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             3866 ; 200  |
                             3867 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             3868 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             3869 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             3870 ; 204  |
                             3871 ; 205  |#if DEBUG
                             3872 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             3873 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             3874 ; 208  |#else 
                             3875 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             3876 ; 210  |#define DebugBuildAssert(x)    
                             3877 ; 211  |#endif
                             3878 ; 212  |
                             3879 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             3880 ; 214  |//  #pragma asm
                             3881 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             3882 ; 216  |//  #pragma endasm
                             3883 ; 217  |
                             3884 ; 218  |
                             3885 ; 219  |#ifdef COLOR_262K
                             3886 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             3887 ; 221  |#elif defined(COLOR_65K)
                             3888 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             3889 ; 223  |#else
                             3890 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             3891 ; 225  |#endif
                             3892 ; 226  |    
                             3893 ; 227  |#endif // #ifndef _TYPES_H
                             3894 
                             3896 
                             3897 ; 31   |
                             3898 ; 32   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             3899 ; 33   |//   USB2.0 STMP Registers 
                             3900 ; 34   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             3901 ; 35   |#define HW_USB_BASEADDR (0xF200)
                             3902 ; 36   |
                             3903 ; 37   |
                             3904 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                             3905 ; 39   |//  USB Control Status Register (HW_USBCSR) Bit Definitions
                             3906 ; 40   |#define HW_USBCSR_USBEN_BITPOS (0)
                             3907 ; 41   |#define HW_USBCSR_WAKEUPIRQ_BITPOS (1)
                             3908 ; 42   |#define HW_USBCSR_WAKEUPIE_BITPOS (2)
                             3909 ; 43   |#define HW_USBCSR_VBUSCXIRQ_BITPOS (3)
                             3910 ; 44   |#define HW_USBCSR_VBUSCXIE_BITPOS (4)
                             3911 ; 45   |#define HW_USBCSR_VBUSDISCXIRQ_BITPOS (5)
                             3912 ; 46   |#define HW_USBCSR_VBUSDISCXIE_BITPOS (6)
                             3913 ; 47   |#define HW_USBCSR_CLKOFF_BITPOS (7)
                             3914 ; 48   |#define HW_USBCSR_SUSP_BITPOS (8)
                             3915 ; 49   |#define HW_USBCSR_SUSPF_BITPOS (9)
                             3916 ; 50   |#define HW_USBCSR_UTMITST_BITPOS (10)
                             3917 ; 51   |#define HW_USBCSR_UTMI_EXT_BITPOS (11)
                             3918 ; 52   |#define HW_USBCSR_PLUGGEDIN_EN_BITPOS (12)
                             3919 ; 53   |#define HW_USBCSR_PLUGGEDIN_BITPOS (13)
                             3920 ; 54   |#define HW_USBCSR_HOSTDISCONNECT_BITPOS (22)
                             3921 ; 55   |#define HW_USBCSR_VBUSSENSE_BITPOS (23)
                             3922 ; 56   |
                             3923 ; 57   |#define HW_USBCSR_USBEN_SETMASK (1<<HW_USBCSR_USBEN_BITPOS)        
                             3924 ; 58   |#define HW_USBCSR_WAKEUPIRQ_SETMASK (1<<HW_USBCSR_WAKEUPIRQ_BITPOS) 
                             3925 ; 59   |#define HW_USBCSR_WAKEUPIE_SETMASK (1<<HW_USBCSR_WAKEUPIE_BITPOS)  
                             3926 ; 60   |#define HW_USBCSR_VBUSCXIRQ_SETMASK (1<<HW_USBCSR_VBUSCXIRQ_BITPOS)
                             3927 ; 61   |#define HW_USBCSR_VBUSCXIE_SETMASK (1<<HW_USBCSR_VBUSCXIE_BITPOS)
                             3928 ; 62   |#define HW_USBCSR_VBUSDISCXIRQ_SETMASK (1<<HW_USBCSR_VBUSDISCXIRQ_BITPOS)
                             3929 ; 63   |#define HW_USBCSR_VBUSDISCXIE_SETMASK (1<<HW_USBCSR_VBUSDISCXIE_BITPOS)
                             3930 ; 64   |#define HW_USBCSR_CLKOFF_SETMASK (1<<HW_USBCSR_CLKOFF_BITPOS)    
                             3931 ; 65   |#define HW_USBCSR_SUSP_SETMASK (1<<HW_USBCSR_SUSP_BITPOS)      
                             3932 ; 66   |#define HW_USBCSR_SUSPF_SETMASK (1<<HW_USBCSR_SUSPF_BITPOS)     
                             3933 ; 67   |#define HW_USBCSR_UTMITST_SETMASK (1<<HW_USBCSR_UTMITST_BITPOS)   
                             3934 ; 68   |#define HW_USBCSR_UTMI_EXT_SETMASK (1<<HW_USBCSR_UTMI_EXT_BITPOS)
                             3935 ; 69   |#define HW_USBCSR_VBUSSENSE_SETMASK (1<<HW_USBCSR_VBUSSENSE_BITPOS)
                             3936 ; 70   |
                             3937 ; 71   |
                             3938 ; 72   |#define HW_USBCSR_USBEN_CLRMASK (~(WORD)HW_USBCSR_USBEN_SETMASK)     
                             3939 ; 73   |#define HW_USBCSR_WAKEUPIRQ_CLRMASK (~(WORD)HW_USBCSR_WAKEUPIRQ_SETMASK) 
                             3940 ; 74   |#define HW_USBCSR_WAKEUPIE_CLRMASK (~(WORD)HW_USBCSR_WAKEUPIE_SETMASK)  
                             3941 ; 75   |#define HW_USBCSR_VBUSCXIRQ_CLRMASK (~(WORD)HW_USBCSR_VBUSCXIRQ_SETMASK)
                             3942 ; 76   |#define HW_USBCSR_VBUSCXIE_CLRMASK (~(WORD)HW_USBCSR_VBUSCXIE_SETMASK)
                             3943 ; 77   |#define HW_USBCSR_VBUSDISCXIRQ_CLRMASK (~(WORD)HW_USBCSR_VBUSDISCXIRQ_SETMASK)
                             3944 ; 78   |#define HW_USBCSR_VBUSDISCXIE_CLRMASK (~(WORD)HW_USBCSR_VBUSDISCXIE_SETMASK) 
                             3945 ; 79   |#define HW_USBCSR_CLKOFF_CLRMASK (~(WORD)HW_USBCSR_CLKOFF_SETMASK)    
                             3946 ; 80   |#define HW_USBCSR_SUSP_CLRMASK (~(WORD)HW_USBCSR_SUSP_SETMASK)      
                             3947 ; 81   |#define HW_USBCSR_SUSPF_CLRMASK (~(WORD)HW_USBCSR_SUSPF_SETMASK)     
                             3948 ; 82   |#define HW_USBCSR_UTMITST_CLRMASK (~(WORD)HW_USBCSR_UTMITST_SETMASK)   
                             3949 ; 83   |#define HW_USBCSR_UTMI_EXT_CLRMASK (~(WORD)HW_USBCSR_UTMI_EXT_SETMASK) 
                             3950 ; 84   |#define HW_USBCSR_VBUSSENSE_CLRMASK (~(WORD)HW_USBCSR_VBUSSENSE_SETMASK) 
                             3951 ; 85   |
                             3952 ; 86   |typedef union               
                             3953 ; 87   |{
                             3954 ; 88   |    struct {
                             3955 ; 89   |        int USBEN          :1;
                             3956 ; 90   |        int WAKEUPIRQ      :1;
                             3957 ; 91   |        int WAKEUPIE       :1;
                             3958 ; 92   |        int VBUSCXIRQ      :1;
                             3959 ; 93   |        int VBUSCXIE       :1;
                             3960 ; 94   |        int VBUSDISCXIRQ   :1;
                             3961 ; 95   |        int VBUSDISCXIE    :1;
                             3962 ; 96   |        int CLKOFF         :1;
                             3963 ; 97   |        int SUSP           :1;
                             3964 ; 98   |        int SUSPF          :1;
                             3965 ; 99   |        int UTMITST        :1;
                             3966 ; 100  |        int ARCCONNECT     :1;
                             3967 ; 101  |        int PLUGGEDIN_EN   :1;
                             3968 ; 102  |        int PLUGGEDIN      :1;
                             3969 ; 103  |        int                :8;
                             3970 ; 104  |        int HOSTDISCONNECT :1;
                             3971 ; 105  |        int VBUSSENSE      :1;
                             3972 ; 106  |    } B;
                             3973 ; 107  |    int I;
                             3974 ; 108  |} usbcsr_type;
                             3975 ; 109  |#define HW_USBCSR      (*(volatile usbcsr_type _X*) (HW_USB_BASEADDR))    /* USB Control / Status Register */
                             3976 ; 110  |
                             3977 ; 111  |/////////////////////////////////////////////////////////////////////////////////
                             3978 ; 112  |//  USB DMA OFFSET register (HW_USBDMAOFF) Bit Definitions
                             3979 ; 113  |#define HW_USBDMAOFF_MEM_BITPOS (16)
                             3980 ; 114  |
                             3981 ; 115  |#define HW_USBDMAOFF_ADD_SETMASK (0x00FFFF)
                             3982 ; 116  |#define HW_USBDMAOFF_MEM_SETMASK (3<<HW_USBDMAOFF_MEM_BITPOS)
                             3983 ; 117  |
                             3984 ; 118  |#define HW_USBDMAOFF_ADD_CLRMASK (~(WORD)HW_USBDMAOFF_ADD_SETMASK)
                             3985 ; 119  |#define HW_USBDMAOFF_MEM_CLRMASK (~(WORD)HW_USBDMAOFF_MEM_SETMASK)
                             3986 ; 120  |
                             3987 ; 121  |typedef union               
                             3988 ; 122  |{
                             3989 ; 123  |    struct {
                             3990 ; 124  |        int ADD            :16;
                             3991 ; 125  |        int MEM            :2;
                             3992 ; 126  |        int                :6;
                             3993 ; 127  |    } B;
                             3994 ; 128  |    int I;
                             3995 ; 129  |} usbdmaoff_type;
                             3996 ; 130  |#define HW_USBDMAOFF      (*(volatile usbdmaoff_type _X*) (HW_USB_BASEADDR+1))    
                             3997 ; 131  |
                             3998 ; 132  |/////////////////////////////////////////////////////////////////////////////////
                             3999 ; 133  |//  USB ARC ACCESS register (HW_USBARCACCESS) Bit Definitions
                             4000 ; 134  |#define HW_USBARCACCESS_RWB_BITPOS (16)
                             4001 ; 135  |#define HW_USBARCACCESS_KICK_BITPOS (23)
                             4002 ; 136  |
                             4003 ; 137  |#define HW_USBARCACCESS_ADD_SETMASK (0x0001FF)
                             4004 ; 138  |#define HW_USBARCACCESS_RWB_SETMASK (1<<HW_USBARCACCESS_RWB_BITPOS)
                             4005 ; 139  |#define HW_USBARCACCESS_KICK_SETMASK (23<<HW_USBDMAOFF_MEM_BITPOS)
                             4006 ; 140  |
                             4007 ; 141  |#define HW_USBARCACCESS_ADD_CLRMASK (~(WORD)HW_USBARCACCESS_ADD_SETMASK)
                             4008 ; 142  |#define HW_USBARCACCESS_RWB_CLRMASK (~(WORD)HW_USBARCACCESS_RWB_SETMASK) 
                             4009 ; 143  |#define HW_USBARCACCESS_KICK_CLRMASK (~(WORD)HW_USBARCACCESS_KICK_SETMASK)
                             4010 ; 144  |
                             4011 ; 145  |typedef union               
                             4012 ; 146  |{
                             4013 ; 147  |    struct {
                             4014 ; 148  |        int ADD            :9;
                             4015 ; 149  |        int                :7;
                             4016 ; 150  |        int RWB            :1;
                             4017 ; 151  |        int                :14;
                             4018 ; 152  |        int KICK           :1;
                             4019 ; 153  |    } B;
                             4020 ; 154  |    int I;
                             4021 ; 155  |} usbarcaccess_type;
                             4022 ; 156  |#define HW_USBARCACCESS      (*(volatile usbarcaccess_type _X*) (HW_USB_BASEADDR+2))    
                             4023 ; 157  |
                             4024 ; 158  |/////////////////////////////////////////////////////////////////////////////////
                             4025 ; 159  |//  USB ARC DATA LOW register (HW_USBARCDATALOW) Bit Definitions
                             4026 ; 160  |#define HW_USBARCDATALOW_DATA_SETMASK (0x00FFFF)
                             4027 ; 161  |
                             4028 ; 162  |#define HW_USBARCDATALOW_ADD_CLRMASK (~(WORD)HW_USBARCDATALOW_DATA_SETMASK)
                             4029 ; 163  |
                             4030 ; 164  |typedef union               
                             4031 ; 165  |{
                             4032 ; 166  |    struct {
                             4033 ; 167  |        int DATA           :16;
                             4034 ; 168  |        int                :8;
                             4035 ; 169  |    } B;
                             4036 ; 170  |    int I;
                             4037 ; 171  |} usbarcdatalow_type;
                             4038 ; 172  |#define HW_USBARCDATALOW      (*(volatile usbarcdatalow_type _X*) (HW_USB_BASEADDR+3))    
                             4039 ; 173  |
                             4040 ; 174  |/////////////////////////////////////////////////////////////////////////////////
                             4041 ; 175  |//  USB ARC DATA HIGH register (HW_USBARCDATAHIGH) Bit Definitions
                             4042 ; 176  |#define HW_USBARCDATAHIGH_DATA_SETMASK (0x00FFFF)
                             4043 ; 177  |
                             4044 ; 178  |#define HW_USBARCDATAHIGH_ADD_CLRMASK (~(WORD)HW_USBARCDATAHIGH_DATA_SETMASK)
                             4045 ; 179  |
                             4046 ; 180  |typedef union               
                             4047 ; 181  |{
                             4048 ; 182  |    struct {
                             4049 ; 183  |        int DATA           :16;
                             4050 ; 184  |        int                :8;
                             4051 ; 185  |    } B;
                             4052 ; 186  |    int I;
                             4053 ; 187  |} usbarcdatahigh_type;
                             4054 ; 188  |#define HW_USBARCDATAHIGH     (*(volatile usbarcdatahigh_type _X*) (HW_USB_BASEADDR+4))    
                             4055 ; 189  |
                             4056 ; 190  |
                             4057 ; 191  |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             4058 ; 192  |//   USB2.0 ARC Registers 
                             4059 ; 193  |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             4060 ; 194  |#define HW_ARC_BASE_ADDR (0x0000)
                             4061 ; 195  |
                             4062 ; 196  |#define HW_ARC_HCSPARAMS (HW_ARC_BASE_ADDR+0x104)
                             4063 ; 197  |#define HW_ARC_USBCMD (HW_ARC_BASE_ADDR+0x140)
                             4064 ; 198  |#define HW_ARC_USBSTS (HW_ARC_BASE_ADDR+0x144)
                             4065 ; 199  |#define HW_ARC_USBINTR (HW_ARC_BASE_ADDR+0x148)
                             4066 ; 200  |#define HW_ARC_DEVADDR (HW_ARC_BASE_ADDR+0x154)
                             4067 ; 201  |#define HW_ARC_ENDPTLISTADDR (HW_ARC_BASE_ADDR+0x158)
                             4068 ; 202  |#define HW_ARC_PORTSC1 (HW_ARC_BASE_ADDR+0x184)
                             4069 ; 203  |#define HW_ARC_USBMODE (HW_ARC_BASE_ADDR+0x1a8)
                             4070 ; 204  |#define HW_ARC_ENDPTSETUPSTAT (HW_ARC_BASE_ADDR+0x1ac)
                             4071 ; 205  |#define HW_ARC_ENDPTPRIME (HW_ARC_BASE_ADDR+0x1b0)
                             4072 ; 206  |#define HW_ARC_ENDPTFLUSH (HW_ARC_BASE_ADDR+0x1b4)
                             4073 ; 207  |#define HW_ARC_ENDPTSTATUS (HW_ARC_BASE_ADDR+0x1b8)
                             4074 ; 208  |#define HW_ARC_ENDPTCOMPLETE (HW_ARC_BASE_ADDR+0x1bc)
                             4075 ; 209  |#define HW_ARC_ENDPTCTRL0 (HW_ARC_BASE_ADDR+0x1c0)
                             4076 ; 210  |#define HW_ARC_ENDPTCTRL1 (HW_ARC_BASE_ADDR+0x1c4)
                             4077 ; 211  |#define HW_ARC_ENDPTCTRL2 (HW_ARC_BASE_ADDR+0x1c8)
                             4078 ; 212  |#define HW_ARC_ENDPTCTRL3 (HW_ARC_BASE_ADDR+0x1cc)
                             4079 ; 213  |#define HW_ARC_ENDPTCTRL4 (HW_ARC_BASE_ADDR+0x1d0)
                             4080 ; 214  |#define HW_ARC_ENDPTCTRL5 (HW_ARC_BASE_ADDR+0x1d4)
                             4081 ; 215  |#define HW_ARC_ENDPTCTRL6 (HW_ARC_BASE_ADDR+0x1d8)
                             4082 ; 216  |#define HW_ARC_ENDPTCTRL7 (HW_ARC_BASE_ADDR+0x1dc)
                             4083 ; 217  |#define HW_ARC_ENDPTCTRL8 (HW_ARC_BASE_ADDR+0x1e0)
                             4084 ; 218  |#define HW_ARC_ENDPTCTRL9 (HW_ARC_BASE_ADDR+0x1e4)
                             4085 ; 219  |#define HW_ARC_ENDPTCTRL10 (HW_ARC_BASE_ADDR+0x1e8)
                             4086 ; 220  |#define HW_ARC_ENDPTCTRL11 (HW_ARC_BASE_ADDR+0x1ec)
                             4087 ; 221  |#define HW_ARC_ENDPTCTRL12 (HW_ARC_BASE_ADDR+0x1f0)
                             4088 ; 222  |#define HW_ARC_ENDPTCTRL13 (HW_ARC_BASE_ADDR+0x1f4)
                             4089 ; 223  |#define HW_ARC_ENDPTCTRL14 (HW_ARC_BASE_ADDR+0x1f8)
                             4090 ; 224  |#define HW_ARC_ENDPTCTRL15 (HW_ARC_BASE_ADDR+0x1fc)
                             4091 ; 225  |
                             4092 ; 226  |#define HW_ARC_ENDPTCTRL(n) (HW_ARC_ENDPTCTRL0+((n)*4))    
                             4093 ; 227  |/////////////////////////////////////////////////////////////////////////////////
                             4094 ; 228  |//  USB ARC Register Host Control Structural Parameters (HW_ARC_HCSPARAMS)
                             4095 ; 229  |
                             4096 ; 230  |#define HW_ARC_HCSPARAMS_NPORTS_BITPOS (0)
                             4097 ; 231  |#define HW_ARC_HCSPARAMS_PPC_BITPOS (4)
                             4098 ; 232  |#define HW_ARC_HCSPARAMS_NPCC_BITPOS (8)
                             4099 ; 233  |#define HW_ARC_HCSPARAMS_NCC_BITPOS (12)
                             4100 ; 234  |#define HW_ARC_HCSPARAMS_PI_BITPOS (16)
                             4101 ; 235  |#define HW_ARC_HCSPARAMS_NPTT_BITPOS (20)
                             4102 ; 236  |#define HW_ARC_HCSPARAMS_NTT_BITPOS (24)
                             4103 ; 237  |
                             4104 ; 238  |#define HW_ARC_HCSPARAMS_NPORTS_SETMASK (15<<HW_ARC_HCSPARAMS_NPORTS_BITPOS)
                             4105 ; 239  |#define HW_ARC_HCSPARAMS_PPC_SETMASK (1<<HW_ARC_HCSPARAMS_PPC_BITPOS)        
                             4106 ; 240  |#define HW_ARC_HCSPARAMS_NPCC_SETMASK (15<<HW_ARC_HCSPARAMS_NPCC_BITPOS)  
                             4107 ; 241  |#define HW_ARC_HCSPARAMS_NCC_SETMASK (15<<HW_ARC_HCSPARAMS_NCC_BITPOS)       
                             4108 ; 242  |#define HW_ARC_HCSPARAMS_PI_SETMASK (1<<HW_ARC_HCSPARAMS_PI_BITPOS)     
                             4109 ; 243  |#define HW_ARC_HCSPARAMS_NPTT_SETMASK (15<<HW_ARC_HCSPARAMS_NPTT_BITPOS)  
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  17

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4110 ; 244  |#define HW_ARC_HCSPARAMS_NTT_SETMASK (15<<HW_ARC_HCSPARAMS_NTT_BITPOS)       
                             4111 ; 245  |
                             4112 ; 246  |#define HW_ARC_HCSPARAMS_NPORTS_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NPORTS_SETMASK)
                             4113 ; 247  |#define HW_ARC_HCSPARAMS_PPC_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_PPC_SETMASK)
                             4114 ; 248  |#define HW_ARC_HCSPARAMS_NPCC_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NPCC_SETMASK)
                             4115 ; 249  |#define HW_ARC_HCSPARAMS_NCC_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NCC_SETMASK)
                             4116 ; 250  |#define HW_ARC_HCSPARAMS_PI_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_PI_SETMASK)  
                             4117 ; 251  |#define HW_ARC_HCSPARAMS_NPTT_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NPTT_SETMASK)
                             4118 ; 252  |#define HW_ARC_HCSPARAMS_NTT_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NTT_SETMASK)
                             4119 ; 253  |
                             4120 ; 254  |typedef union               
                             4121 ; 255  |{
                             4122 ; 256  |    struct {
                             4123 ; 257  |        int N_PORTS         :4;
                             4124 ; 258  |        int PPC             :1;
                             4125 ; 259  |        int                 :3;
                             4126 ; 260  |        int N_PCC           :4;
                             4127 ; 261  |        int N_CC            :4;
                             4128 ; 262  |        int PI              :1;
                             4129 ; 263  |        int                 :3;
                             4130 ; 264  |        int N_PTT           :4;
                             4131 ; 265  |        int N_TT            :4;
                             4132 ; 266  |        int                 :20;
                             4133 ; 267  |    } B;
                             4134 ; 268  |    DWORD I;
                             4135 ; 269  |} hcsparams_type;
                             4136 ; 270  |// #define HW_ARC_HCSPARAMS (*(volatile hcsparams_type _X*) (HW_ARC_BASEADDR))    
                             4137 ; 271  |
                             4138 ; 272  |/////////////////////////////////////////////////////////////////////////////////
                             4139 ; 273  |//  USB ARC Register USB Command (HW_ARC_USBCMD)
                             4140 ; 274  |
                             4141 ; 275  |#define HW_ARC_USBCMD_RS_BITPOS (0)
                             4142 ; 276  |#define HW_ARC_USBCMD_RST_BITPOS (1)
                             4143 ; 277  |#define HW_ARC_USBCMD_FS0_BITPOS (2)
                             4144 ; 278  |#define HW_ARC_USBCMD_FS1_BITPOS (3)
                             4145 ; 279  |#define HW_ARC_USBCMD_PSE_BITPOS (4)
                             4146 ; 280  |#define HW_ARC_USBCMD_ASE_BITPOS (5)
                             4147 ; 281  |#define HW_ARC_USBCMD_IAA_BITPOS (6)
                             4148 ; 282  |#define HW_ARC_USBCMD_LR_BITPOS (7)
                             4149 ; 283  |#define HW_ARC_USBCMD_ASP0_BITPOS (8)
                             4150 ; 284  |#define HW_ARC_USBCMD_ASP1_BITPOS (9)
                             4151 ; 285  |#define HW_ARC_USBCMD_ASPE_BITPOS (11)
                             4152 ; 286  |#define HW_ARC_USBCMD_FS2_BITPOS (15)
                             4153 ; 287  |#define HW_ARC_USBCMD_ITC_BITPOS (16)
                             4154 ; 288  |
                             4155 ; 289  |#define HW_ARC_USBCMD_RS_SETMASK (1<<HW_ARC_USBCMD_RS_BITPOS)                
                             4156 ; 290  |#define HW_ARC_USBCMD_RST_SETMASK (1<<HW_ARC_USBCMD_RST_BITPOS)   
                             4157 ; 291  |#define HW_ARC_USBCMD_FS0_SETMASK (1<<HW_ARC_USBCMD_FS0_BITPOS)   
                             4158 ; 292  |#define HW_ARC_USBCMD_FS1_SETMASK (1<<HW_ARC_USBCMD_FS1_BITPOS)   
                             4159 ; 293  |#define HW_ARC_USBCMD_PSE_SETMASK (1<<HW_ARC_USBCMD_PSE_BITPOS)   
                             4160 ; 294  |#define HW_ARC_USBCMD_ASE_SETMASK (1<<HW_ARC_USBCMD_ASE_BITPOS)   
                             4161 ; 295  |#define HW_ARC_USBCMD_IAA_SETMASK (1<<HW_ARC_USBCMD_IAA_BITPOS)   
                             4162 ; 296  |#define HW_ARC_USBCMD_LR_SETMASK (1<<HW_ARC_USBCMD_LR_BITPOS)        
                             4163 ; 297  |#define HW_ARC_USBCMD_ASP0_SETMASK (1<<HW_ARC_USBCMD_ASP0_BITPOS)
                             4164 ; 298  |#define HW_ARC_USBCMD_ASP1_SETMASK (1<<HW_ARC_USBCMD_ASP1_BITPOS)
                             4165 ; 299  |#define HW_ARC_USBCMD_ASPE_SETMASK (1<<HW_ARC_USBCMD_ASPE_BITPOS)
                             4166 ; 300  |#define HW_ARC_USBCMD_FS2_SETMASK (1<<HW_ARC_USBCMD_FS2_BITPOS)    
                             4167 ; 301  |#define HW_ARC_USBCMD_ITC_SETMASK (255<<HW_ARC_USBCMD_ITC_BITPOS)
                             4168 ; 302  |
                             4169 ; 303  |#define HW_ARC_USBCMD_RS_CLRMASK (~(WORD)HW_ARC_USBCMD_RS_SETMASK)     
                             4170 ; 304  |#define HW_ARC_USBCMD_RST_CLRMASK (~(WORD)HW_ARC_USBCMD_RST_SETMASK)    
                             4171 ; 305  |#define HW_ARC_USBCMD_FS0_CLRMASK (~(WORD)HW_ARC_USBCMD_FS0_SETMASK)    
                             4172 ; 306  |#define HW_ARC_USBCMD_FS1_CLRMASK (~(WORD)HW_ARC_USBCMD_FS1_SETMASK)    
                             4173 ; 307  |#define HW_ARC_USBCMD_PSE_CLRMASK (~(WORD)HW_ARC_USBCMD_PSE_SETMASK)    
                             4174 ; 308  |#define HW_ARC_USBCMD_ASE_CLRMASK (~(WORD)HW_ARC_USBCMD_ASE_SETMASK)    
                             4175 ; 309  |#define HW_ARC_USBCMD_IAA_CLRMASK (~(WORD)HW_ARC_USBCMD_IAA_SETMASK)    
                             4176 ; 310  |#define HW_ARC_USBCMD_LR_CLRMASK (~(WORD)HW_ARC_USBCMD_LR_SETMASK) 
                             4177 ; 311  |#define HW_ARC_USBCMD_ASP0_CLRMASK (~(WORD)HW_ARC_USBCMD_ASP0_SETMASK)
                             4178 ; 312  |#define HW_ARC_USBCMD_ASP1_CLRMASK (~(WORD)HW_ARC_USBCMD_ASP1_SETMASK)
                             4179 ; 313  |#define HW_ARC_USBCMD_ASPE_CLRMASK (~(WORD)HW_ARC_USBCMD_ASPE_SETMASK)
                             4180 ; 314  |#define HW_ARC_USBCMD_FS2_CLRMASK (~(WORD)HW_ARC_USBCMD_FS2_SETMASK)    
                             4181 ; 315  |#define HW_ARC_USBCMD_ITC_CLRMASK (~(WORD)HW_ARC_USBCMD_ITC_SETMASK)    
                             4182 ; 316  |
                             4183 ; 317  |typedef union               
                             4184 ; 318  |{
                             4185 ; 319  |    struct {
                             4186 ; 320  |        int RS              :1;
                             4187 ; 321  |        int RST             :1;
                             4188 ; 322  |        int FS0             :1;
                             4189 ; 323  |        int FS1             :1;
                             4190 ; 324  |        int PSE             :1;
                             4191 ; 325  |        int ASE             :1;
                             4192 ; 326  |        int IAA             :1;
                             4193 ; 327  |        int LR              :1;
                             4194 ; 328  |        int ASP0            :1;
                             4195 ; 329  |        int ASP1            :1;
                             4196 ; 330  |        int                 :1;
                             4197 ; 331  |        int ASPE            :1;
                             4198 ; 332  |        int                 :3;
                             4199 ; 333  |        int FS2             :1;
                             4200 ; 334  |        int ITC             :8;
                             4201 ; 335  |        int                 :24;
                             4202 ; 336  |    } B;
                             4203 ; 337  |    DWORD I;
                             4204 ; 338  |} usbcmd_type;
                             4205 ; 339  |//#define HW_ARC_USBCMD ((volatile usbcmd_type _X*) (HW_ARC_BASEADDR+0x140))    
                             4206 ; 340  |
                             4207 ; 341  |/////////////////////////////////////////////////////////////////////////////////
                             4208 ; 342  |//  USB ARC Register USB Status (HW_ARC_USBSTS)
                             4209 ; 343  |
                             4210 ; 344  |#define HW_ARC_USBSTS_UI_BITPOS (0)
                             4211 ; 345  |#define HW_ARC_USBSTS_UEI_BITPOS (1)
                             4212 ; 346  |#define HW_ARC_USBSTS_PCI_BITPOS (2)
                             4213 ; 347  |#define HW_ARC_USBSTS_FRI_BITPOS (3)
                             4214 ; 348  |#define HW_ARC_USBSTS_SEI_BITPOS (4)
                             4215 ; 349  |#define HW_ARC_USBSTS_AAI_BITPOS (5)
                             4216 ; 350  |#define HW_ARC_USBSTS_URI_BITPOS (6)
                             4217 ; 351  |#define HW_ARC_USBSTS_SRI_BITPOS (7)
                             4218 ; 352  |#define HW_ARC_USBSTS_SLI_BITPOS (8)
                             4219 ; 353  |#define HW_ARC_USBSTS_HCH_BITPOS (12)
                             4220 ; 354  |#define HW_ARC_USBSTS_RCL_BITPOS (13)
                             4221 ; 355  |#define HW_ARC_USBSTS_PS_BITPOS (14)
                             4222 ; 356  |#define HW_ARC_USBSTS_AS_BITPOS (15)
                             4223 ; 357  |
                             4224 ; 358  |#define HW_ARC_USBSTS_UI_SETMASK (1<<HW_ARC_USBSTS_UI_BITPOS)    
                             4225 ; 359  |#define HW_ARC_USBSTS_UEI_SETMASK (1<<HW_ARC_USBSTS_UEI_BITPOS)
                             4226 ; 360  |#define HW_ARC_USBSTS_PCI_SETMASK (1<<HW_ARC_USBSTS_PCI_BITPOS)
                             4227 ; 361  |#define HW_ARC_USBSTS_FRI_SETMASK (1<<HW_ARC_USBSTS_FRI_BITPOS)
                             4228 ; 362  |#define HW_ARC_USBSTS_SEI_SETMASK (1<<HW_ARC_USBSTS_SEI_BITPOS)
                             4229 ; 363  |#define HW_ARC_USBSTS_AAI_SETMASK (1<<HW_ARC_USBSTS_AAI_BITPOS)
                             4230 ; 364  |#define HW_ARC_USBSTS_URI_SETMASK (1<<HW_ARC_USBSTS_URI_BITPOS)
                             4231 ; 365  |#define HW_ARC_USBSTS_SRI_SETMASK (1<<HW_ARC_USBSTS_SRI_BITPOS)
                             4232 ; 366  |#define HW_ARC_USBSTS_SLI_SETMASK (1<<HW_ARC_USBSTS_SLI_BITPOS)
                             4233 ; 367  |#define HW_ARC_USBSTS_HCH_SETMASK (1<<HW_ARC_USBSTS_HCH_BITPOS)
                             4234 ; 368  |#define HW_ARC_USBSTS_RCL_SETMASK (1<<HW_ARC_USBSTS_RCL_BITPOS)
                             4235 ; 369  |#define HW_ARC_USBSTS_PS_SETMASK (1<<HW_ARC_USBSTS_PS_BITPOS)    
                             4236 ; 370  |#define HW_ARC_USBSTS_AS_SETMASK (1<<HW_ARC_USBSTS_AS_BITPOS)    
                             4237 ; 371  |
                             4238 ; 372  |#define HW_ARC_USBSTS_UI_CLRMASK (~(WORD)HW_ARC_USBSTS_UI_SETMASK)
                             4239 ; 373  |#define HW_ARC_USBSTS_UEI_CLRMASK (~(WORD)HW_ARC_USBSTS_UEI_SETMASK)
                             4240 ; 374  |#define HW_ARC_USBSTS_PCI_CLRMASK (~(WORD)HW_ARC_USBSTS_PCI_SETMASK)
                             4241 ; 375  |#define HW_ARC_USBSTS_FRI_CLRMASK (~(WORD)HW_ARC_USBSTS_FRI_SETMASK)
                             4242 ; 376  |#define HW_ARC_USBSTS_SEI_CLRMASK (~(WORD)HW_ARC_USBSTS_SEI_SETMASK)
                             4243 ; 377  |#define HW_ARC_USBSTS_AAI_CLRMASK (~(WORD)HW_ARC_USBSTS_AAI_SETMASK)
                             4244 ; 378  |#define HW_ARC_USBSTS_URI_CLRMASK (~(WORD)HW_ARC_USBSTS_URI_SETMASK)
                             4245 ; 379  |#define HW_ARC_USBSTS_SRI_CLRMASK (~(WORD)HW_ARC_USBSTS_SRI_SETMASK)
                             4246 ; 380  |#define HW_ARC_USBSTS_SLI_CLRMASK (~(WORD)HW_ARC_USBSTS_SLI_SETMASK)
                             4247 ; 381  |#define HW_ARC_USBSTS_HCH_CLRMASK (~(WORD)HW_ARC_USBSTS_HCH_SETMASK)
                             4248 ; 382  |#define HW_ARC_USBSTS_RCL_CLRMASK (~(WORD)HW_ARC_USBSTS_RCL_SETMASK)
                             4249 ; 383  |#define HW_ARC_USBSTS_PS_CLRMASK (~(WORD)HW_ARC_USBSTS_PS_SETMASK)
                             4250 ; 384  |#define HW_ARC_USBSTS_AS_CLRMASK (~(WORD)HW_ARC_USBSTS_AS_SETMASK)
                             4251 ; 385  |
                             4252 ; 386  |
                             4253 ; 387  |typedef union               
                             4254 ; 388  |{
                             4255 ; 389  |    struct {
                             4256 ; 390  |        int UI              :1;
                             4257 ; 391  |        int UEI             :1;
                             4258 ; 392  |        int PCI             :1;
                             4259 ; 393  |        int FRI             :1;
                             4260 ; 394  |        int SEI             :1;
                             4261 ; 395  |        int AAI             :1;
                             4262 ; 396  |        int URI             :1;
                             4263 ; 397  |        int STI             :1;
                             4264 ; 398  |        int SLI             :1;
                             4265 ; 399  |        int                 :3;
                             4266 ; 400  |        int HCH             :1;
                             4267 ; 401  |        int RCL             :1;
                             4268 ; 402  |        int PS              :1;
                             4269 ; 403  |        int AS              :1;
                             4270 ; 404  |        int                 :24;
                             4271 ; 405  |    } B;
                             4272 ; 406  |    DWORD I;
                             4273 ; 407  |} usbsts_type;
                             4274 ; 408  |//#define HW_ARC_USBSTS (*(volatile usbsts_type _X*) (HW_ARC_BASEADDR+0x144))    
                             4275 ; 409  |
                             4276 ; 410  |/////////////////////////////////////////////////////////////////////////////////
                             4277 ; 411  |//  USB ARC Register USB Interrupt Enable (HW_ARC_USBINTR)
                             4278 ; 412  |
                             4279 ; 413  |#define HW_ARC_USBINTR_UE_BITPOS (0)
                             4280 ; 414  |#define HW_ARC_USBINTR_UEE_BITPOS (1)
                             4281 ; 415  |#define HW_ARC_USBINTR_PCE_BITPOS (2)
                             4282 ; 416  |#define HW_ARC_USBINTR_FRE_BITPOS (3)
                             4283 ; 417  |#define HW_ARC_USBINTR_SEE_BITPOS (4)
                             4284 ; 418  |#define HW_ARC_USBINTR_AAE_BITPOS (5)
                             4285 ; 419  |#define HW_ARC_USBINTR_URE_BITPOS (6)
                             4286 ; 420  |#define HW_ARC_USBINTR_SRE_BITPOS (7)
                             4287 ; 421  |#define HW_ARC_USBINTR_SLE_BITPOS (8)
                             4288 ; 422  |
                             4289 ; 423  |#define HW_ARC_USBINTR_UE_SETMASK (1<<HW_ARC_USBINTR_UE_BITPOS)   
                             4290 ; 424  |#define HW_ARC_USBINTR_UEE_SETMASK (1<<HW_ARC_USBINTR_UEE_BITPOS)
                             4291 ; 425  |#define HW_ARC_USBINTR_PCE_SETMASK (1<<HW_ARC_USBINTR_PCE_BITPOS)
                             4292 ; 426  |#define HW_ARC_USBINTR_FRE_SETMASK (1<<HW_ARC_USBINTR_FRE_BITPOS)
                             4293 ; 427  |#define HW_ARC_USBINTR_SEE_SETMASK (1<<HW_ARC_USBINTR_SEE_BITPOS)
                             4294 ; 428  |#define HW_ARC_USBINTR_AAE_SETMASK (1<<HW_ARC_USBINTR_AAE_BITPOS)
                             4295 ; 429  |#define HW_ARC_USBINTR_URE_SETMASK (1<<HW_ARC_USBINTR_URE_BITPOS)
                             4296 ; 430  |#define HW_ARC_USBINTR_SRE_SETMASK (1<<HW_ARC_USBINTR_SRE_BITPOS)
                             4297 ; 431  |#define HW_ARC_USBINTR_SLE_SETMASK (1<<HW_ARC_USBINTR_SLE_BITPOS)
                             4298 ; 432  |
                             4299 ; 433  |#define HW_ARC_USBINTR_UE_CLRMASK (~(WORD)HW_ARC_USBINTR_UE_SETMASK)
                             4300 ; 434  |#define HW_ARC_USBINTR_UEE_CLRMASK (~(WORD)HW_ARC_USBINTR_UEE_SETMASK)
                             4301 ; 435  |#define HW_ARC_USBINTR_PCE_CLRMASK (~(WORD)HW_ARC_USBINTR_PCE_SETMASK)
                             4302 ; 436  |#define HW_ARC_USBINTR_FRE_CLRMASK (~(WORD)HW_ARC_USBINTR_FRE_SETMASK)
                             4303 ; 437  |#define HW_ARC_USBINTR_SEE_CLRMASK (~(WORD)HW_ARC_USBINTR_SEE_SETMASK)
                             4304 ; 438  |#define HW_ARC_USBINTR_AAE_CLRMASK (~(WORD)HW_ARC_USBINTR_AAE_SETMASK)
                             4305 ; 439  |#define HW_ARC_USBINTR_URE_CLRMASK (~(WORD)HW_ARC_USBINTR_URE_SETMASK)
                             4306 ; 440  |#define HW_ARC_USBINTR_SRE_CLRMASK (~(WORD)HW_ARC_USBINTR_SRE_SETMASK)
                             4307 ; 441  |#define HW_ARC_USBINTR_SLE_CLRMASK (~(WORD)HW_ARC_USBINTR_SLE_SETMASK)
                             4308 ; 442  |
                             4309 ; 443  |
                             4310 ; 444  |typedef union               
                             4311 ; 445  |{
                             4312 ; 446  |    struct {
                             4313 ; 447  |        int UE              :1;
                             4314 ; 448  |        int UEE             :1;
                             4315 ; 449  |        int PCE             :1;
                             4316 ; 450  |        int FRE             :1;
                             4317 ; 451  |        int SEE             :1;
                             4318 ; 452  |        int AAE             :1;
                             4319 ; 453  |        int URE             :1;
                             4320 ; 454  |        int STE             :1;
                             4321 ; 455  |        int SLE             :1;
                             4322 ; 456  |        int                 :39;
                             4323 ; 457  |    } B;
                             4324 ; 458  |    DWORD I;
                             4325 ; 459  |} usbintr_type;
                             4326 ; 460  |//#define HW_ARC_USBINTR (*(volatile usbintr_type _X*) (HW_ARC_BASEADDR+0x148))    
                             4327 ; 461  |
                             4328 ; 462  |
                             4329 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             4330 ; 464  |//  USB ARC Register USB Device Controller Device Address (HW_ARC_DEVADDR)
                             4331 ; 465  |
                             4332 ; 466  |#define HW_ARC_DEVADDR_ADD_BITPOS (25)
                             4333 ; 467  |
                             4334 ; 468  |#define HW_ARC_DEVADDR_ADD_SETMASK (127<<HW_ARC_DEVADDR_ADD_BITPOS)    
                             4335 ; 469  |
                             4336 ; 470  |#define HW_ARC_DEVEADDR_ADD_CLRMASK (~(WORD)HW_ARC_DEVADDR_ADD_SETMASK)   
                             4337 ; 471  |
                             4338 ; 472  |typedef union               
                             4339 ; 473  |{
                             4340 ; 474  |    struct {
                             4341 ; 475  |        int                 :25;
                             4342 ; 476  |        int ADD             :7;
                             4343 ; 477  |        int                 :16;
                             4344 ; 478  |    } B;
                             4345 ; 479  |    DWORD I;
                             4346 ; 480  |} devaddr_type;
                             4347 ; 481  |//#define HW_ARC_DEVADDR (*(volatile devaddr_type _X*) (HW_ARC_BASEADDR+0x154))    
                             4348 ; 482  |
                             4349 ; 483  |
                             4350 ; 484  |/////////////////////////////////////////////////////////////////////////////////
                             4351 ; 485  |//  USB ARC Register USB Device Controller Endpoint List Address (HW_ARC_ENDPTLISTADDR)
                             4352 ; 486  |
                             4353 ; 487  |#define HW_ARC_ENDPTLISTADDR_ADD_BITPOS (11)
                             4354 ; 488  |
                             4355 ; 489  |#define HW_ARC_ENDPTLISTADDR_ADD_SETMASK (0x400000<<HW_ARC_ENDPTLISTADDR_ADD_BITPOS) 
                             4356 ; 490  |
                             4357 ; 491  |#define HW_ARC_ENDPTLISTADDR_ADD_CLRMASK (~(WORD)HW_ARC_ENDPTLISTADDR_ADD_SETMASK) 
                             4358 ; 492  |
                             4359 ; 493  |typedef union               
                             4360 ; 494  |{
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  18

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4361 ; 495  |    struct {
                             4362 ; 496  |        int                 :10;
                             4363 ; 497  |        int ADD             :22;
                             4364 ; 498  |        int                 :16;
                             4365 ; 499  |    } B;
                             4366 ; 500  |    DWORD I;
                             4367 ; 501  |} endptlistaddr_type;
                             4368 ; 502  |//#define HW_ARC_ENDPTLISTADDR (*(volatile endptlistaddr_type _X*) (HW_ARC_BASEADDR+0x158))    
                             4369 ; 503  |
                             4370 ; 504  |
                             4371 ; 505  |/////////////////////////////////////////////////////////////////////////////////
                             4372 ; 506  |//  USB ARC Register USB Port Status Control 1 (HW_ARC_PORTSC1)
                             4373 ; 507  |
                             4374 ; 508  |#define HW_ARC_PORTSC1_CCS_BITPOS (0)
                             4375 ; 509  |#define HW_ARC_PORTSC1_CSC_BITPOS (1)
                             4376 ; 510  |#define HW_ARC_PORTSC1_PE_BITPOS (2)
                             4377 ; 511  |#define HW_ARC_PORTSC1_PEC_BITPOS (3)
                             4378 ; 512  |#define HW_ARC_PORTSC1_OCA_BITPOS (4)
                             4379 ; 513  |#define HW_ARC_PORTSC1_OCC_BITPOS (5)
                             4380 ; 514  |#define HW_ARC_PORTSC1_FPR_BITPOS (6)
                             4381 ; 515  |#define HW_ARC_PORTSC1_SUSP_BITPOS (7)
                             4382 ; 516  |#define HW_ARC_PORTSC1_PR_BITPOS (8)
                             4383 ; 517  |#define HW_ARC_PORTSC1_HSP_BITPOS (9)
                             4384 ; 518  |#define HW_ARC_PORTSC1_LS_BITPOS (10)
                             4385 ; 519  |#define HW_ARC_PORTSC1_PP_BITPOS (12)
                             4386 ; 520  |#define HW_ARC_PORTSC1_PO_BITPOS (13)
                             4387 ; 521  |#define HW_ARC_PORTSC1_PIC_BITPOS (14)
                             4388 ; 522  |#define HW_ARC_PORTSC1_PTC_BITPOS (16)
                             4389 ; 523  |#define HW_ARC_PORTSC1_WKCN_BITPOS (20)
                             4390 ; 524  |#define HW_ARC_PORTSC1_WKDS_BITPOS (21)
                             4391 ; 525  |#define HW_ARC_PORTSC1_WKOC_BITPOS (22)
                             4392 ; 526  |#define HW_ARC_PORTSC1_PHCD_BITPOS (23)
                             4393 ; 527  |#define HW_ARC_PORTSC1_PFSC_BITPOS (24)
                             4394 ; 528  |#define HW_ARC_PORTSC1_PSPD_BITPOS (26)
                             4395 ; 529  |#define HW_ARC_PORTSC1_PTW_BITPOS (29)
                             4396 ; 530  |#define HW_ARC_PORTSC1_STS_BITPOS (30)
                             4397 ; 531  |#define HW_ARC_PORTSC1_PTS_BITPOS (31)
                             4398 ; 532  |
                             4399 ; 533  |#define HW_ARC_PORTSC1_CCS_SETMASK (1<<HW_ARC_PORTSC1_CCS_BITPOS)  
                             4400 ; 534  |#define HW_ARC_PORTSC1_CSC_SETMASK (1<<HW_ARC_PORTSC1_CSC_BITPOS)  
                             4401 ; 535  |#define HW_ARC_PORTSC1_PE_SETMASK (1<<HW_ARC_PORTSC1_PE_BITPOS)   
                             4402 ; 536  |#define HW_ARC_PORTSC1_PEC_SETMASK (1<<HW_ARC_PORTSC1_PEC_BITPOS)  
                             4403 ; 537  |#define HW_ARC_PORTSC1_OCA_SETMASK (1<<HW_ARC_PORTSC1_OCA_BITPOS)  
                             4404 ; 538  |#define HW_ARC_PORTSC1_OCC_SETMASK (1<<HW_ARC_PORTSC1_OCC_BITPOS)  
                             4405 ; 539  |#define HW_ARC_PORTSC1_FPR_SETMASK (1<<HW_ARC_PORTSC1_FPR_BITPOS)  
                             4406 ; 540  |#define HW_ARC_PORTSC1_SUSP_SETMASK (1<<HW_ARC_PORTSC1_SUSP_BITPOS)
                             4407 ; 541  |#define HW_ARC_PORTSC1_PR_SETMASK (1<<HW_ARC_PORTSC1_PR_BITPOS)   
                             4408 ; 542  |#define HW_ARC_PORTSC1_HSP_SETMASK (1<<HW_ARC_PORTSC1_HSP_BITPOS)  
                             4409 ; 543  |#define HW_ARC_PORTSC1_LS_SETMASK (3<<HW_ARC_PORTSC1_LS_BITPOS)   
                             4410 ; 544  |#define HW_ARC_PORTSC1_PP_SETMASK (1<<HW_ARC_PORTSC1_PP_BITPOS)   
                             4411 ; 545  |#define HW_ARC_PORTSC1_PO_SETMASK (1<<HW_ARC_PORTSC1_PO_BITPOS)   
                             4412 ; 546  |#define HW_ARC_PORTSC1_PIC_SETMASK (3<<HW_ARC_PORTSC1_PIC_BITPOS)  
                             4413 ; 547  |#define HW_ARC_PORTSC1_PTC_SETMASK (15<<HW_ARC_PORTSC1_PTC_BITPOS) 
                             4414 ; 548  |#define HW_ARC_PORTSC1_WKCN_SETMASK (1<<HW_ARC_PORTSC1_WKCN_BITPOS)
                             4415 ; 549  |#define HW_ARC_PORTSC1_WKDS_SETMASK (1<<HW_ARC_PORTSC1_WKDS_BITPOS)
                             4416 ; 550  |#define HW_ARC_PORTSC1_WKOC_SETMASK (1<<HW_ARC_PORTSC1_WKOC_BITPOS)
                             4417 ; 551  |#define HW_ARC_PORTSC1_PHCD_SETMASK (1<<HW_ARC_PORTSC1_PHCD_BITPOS)
                             4418 ; 552  |
                             4419 ; 553  |// We need to equate the following label like this due to a sign extension problem
                             4420 ; 554  |// if equated like so (1<<HW_ARC_PORTSC1_PFSC_SETMASK)
                             4421 ; 555  |#define HW_ARC_PORTSC1_PFSC_SETMASK (0x01000000)
                             4422 ; 556  |
                             4423 ; 557  |#define HW_ARC_PORTSC1_PSPD_SETMASK (3<<HW_ARC_PORTSC1_PSPD_BITPOS)
                             4424 ; 558  |#define HW_ARC_PORTSC1_PTW_SETMASK (1<<HW_ARC_PORTSC1_PTW_BITPOS)  
                             4425 ; 559  |#define HW_ARC_PORTSC1_STS_SETMASK (1<<HW_ARC_PORTSC1_STS_BITPOS)  
                             4426 ; 560  |#define HW_ARC_PORTSC1_PTS_SETMASK (1<<HW_ARC_PORTSC1_PTS_BITPOS)  
                             4427 ; 561  |
                             4428 ; 562  |#define HW_ARC_PORTSC1_CCS_CLRMASK (~(WORD)HW_ARC_PORTSC1_CCS_SETMASK)   
                             4429 ; 563  |#define HW_ARC_PORTSC1_CSC_CLRMASK (~(WORD)HW_ARC_PORTSC1_CSC_SETMASK)   
                             4430 ; 564  |#define HW_ARC_PORTSC1_PE_CLRMASK (~(WORD)HW_ARC_PORTSC1_PE_SETMASK)    
                             4431 ; 565  |#define HW_ARC_PORTSC1_PEC_CLRMASK (~(WORD)HW_ARC_PORTSC1_PEC_SETMASK)   
                             4432 ; 566  |#define HW_ARC_PORTSC1_OCA_CLRMASK (~(WORD)HW_ARC_PORTSC1_OCA_SETMASK)   
                             4433 ; 567  |#define HW_ARC_PORTSC1_OCC_CLRMASK (~(WORD)HW_ARC_PORTSC1_OCC_SETMASK)   
                             4434 ; 568  |#define HW_ARC_PORTSC1_FPR_CLRMASK (~(WORD)HW_ARC_PORTSC1_FPR_SETMASK)   
                             4435 ; 569  |#define HW_ARC_PORTSC1_SUSP_CLRMASK (~(WORD)HW_ARC_PORTSC1_SUSP_SETMASK)
                             4436 ; 570  |#define HW_ARC_PORTSC1_PR_CLRMASK (~(WORD)HW_ARC_PORTSC1_PR_SETMASK)    
                             4437 ; 571  |#define HW_ARC_PORTSC1_HSP_CLRMASK (~(WORD)HW_ARC_PORTSC1_HSP_SETMASK)   
                             4438 ; 572  |#define HW_ARC_PORTSC1_LS_CLRMASK (~(WORD)HW_ARC_PORTSC1_LS_SETMASK)    
                             4439 ; 573  |#define HW_ARC_PORTSC1_PP_CLRMASK (~(WORD)HW_ARC_PORTSC1_PP_SETMASK)    
                             4440 ; 574  |#define HW_ARC_PORTSC1_PO_CLRMASK (~(WORD)HW_ARC_PORTSC1_PO_SETMASK)    
                             4441 ; 575  |#define HW_ARC_PORTSC1_PIC_CLRMASK (~(WORD)HW_ARC_PORTSC1_PIC_SETMASK)   
                             4442 ; 576  |#define HW_ARC_PORTSC1_PTC_CLRMASK (~(WORD)HW_ARC_PORTSC1_PTC_SETMASK)   
                             4443 ; 577  |#define HW_ARC_PORTSC1_WKCN_CLRMASK (~(WORD)HW_ARC_PORTSC1_WKCN_SETMASK)
                             4444 ; 578  |#define HW_ARC_PORTSC1_WKDS_CLRMASK (~(WORD)HW_ARC_PORTSC1_WKDS_SETMASK)
                             4445 ; 579  |#define HW_ARC_PORTSC1_WKOC_CLRMASK (~(WORD)HW_ARC_PORTSC1_WKOC_SETMASK)
                             4446 ; 580  |#define HW_ARC_PORTSC1_PHCD_CLRMASK (~(WORD)HW_ARC_PORTSC1_PHCD_SETMASK)
                             4447 ; 581  |#define HW_ARC_PORTSC1_PFSC_CLRMASK (~(WORD)HW_ARC_PORTSC1_PFSC_SETMASK)
                             4448 ; 582  |#define HW_ARC_PORTSC1_PSPD_CLRMASK (~(WORD)HW_ARC_PORTSC1_PSPD_SETMASK)
                             4449 ; 583  |#define HW_ARC_PORTSC1_PTW_CLRMASK (~(WORD)HW_ARC_PORTSC1_PTW_SETMASK)   
                             4450 ; 584  |#define HW_ARC_PORTSC1_STS_CLRMASK (~(WORD)HW_ARC_PORTSC1_STS_SETMASK)   
                             4451 ; 585  |#define HW_ARC_PORTSC1_PTS_CLRMASK (~(WORD)HW_ARC_PORTSC1_PTS_SETMASK)   
                             4452 ; 586  |
                             4453 ; 587  |typedef union               
                             4454 ; 588  |{
                             4455 ; 589  |    struct {
                             4456 ; 590  |        int CCS             :1;
                             4457 ; 591  |        int CSC             :1;
                             4458 ; 592  |        int PE              :1;
                             4459 ; 593  |        int PEC             :1;
                             4460 ; 594  |        int OCA             :1;
                             4461 ; 595  |        int OCC             :1;
                             4462 ; 596  |        int FPR             :1;
                             4463 ; 597  |        int SUSP            :1;
                             4464 ; 598  |        int PR              :1;
                             4465 ; 599  |        int HSP             :1;
                             4466 ; 600  |        int LS              :2;
                             4467 ; 601  |        int PP              :1;
                             4468 ; 602  |        int PO              :1;
                             4469 ; 603  |        int PIC             :2;
                             4470 ; 604  |        int PTC             :4;
                             4471 ; 605  |        int WKCN            :1;
                             4472 ; 606  |        int WKDS            :1;
                             4473 ; 607  |        int WKOC            :1;
                             4474 ; 608  |        int PHCD            :1;
                             4475 ; 609  |        int PFSC            :1;
                             4476 ; 610  |        int                 :1;
                             4477 ; 611  |        int PSPD            :2;
                             4478 ; 612  |        int                 :1;
                             4479 ; 613  |        int PTW             :1;
                             4480 ; 614  |        int STS             :1;
                             4481 ; 615  |        int PTS             :1;
                             4482 ; 616  |        int                 :16;
                             4483 ; 617  |    } B;
                             4484 ; 618  |    DWORD I;
                             4485 ; 619  |} portsc1_type;
                             4486 ; 620  |//#define HW_ARC_PORTSC1 (*(volatile portsc1_type _X*) (HW_ARC_BASEADDR+0x184))    
                             4487 ; 621  |
                             4488 ; 622  |
                             4489 ; 623  |/////////////////////////////////////////////////////////////////////////////////
                             4490 ; 624  |//  USB ARC Register USB Device Mode (HW_ARC_USBMODE)
                             4491 ; 625  |
                             4492 ; 626  |#define HW_ARC_USBMODE_CM_BITPOS (0)
                             4493 ; 627  |#define HW_ARC_USBMODE_ES_BITPOS (2)
                             4494 ; 628  |
                             4495 ; 629  |#define HW_ARC_USBMODE_CM_SETMASK (3<<HW_ARC_USBMODE_CM_BITPOS)   
                             4496 ; 630  |#define HW_ARC_USBMODE_ES_SETMASK (1<<HW_ARC_USBMODE_ES_BITPOS)   
                             4497 ; 631  |
                             4498 ; 632  |#define HW_ARC_USBMODE_CM_CLRMASK (~(WORD)HW_ARC_USBMODE_CM_SETMASK) 
                             4499 ; 633  |#define HW_ARC_USBMODE_ES_CLRMASK (~(WORD)HW_ARC_USBMODE_ES_SETMASK)    
                             4500 ; 634  |
                             4501 ; 635  |typedef union               
                             4502 ; 636  |{
                             4503 ; 637  |    struct {
                             4504 ; 638  |        int CM              :2;
                             4505 ; 639  |        int ES              :1;
                             4506 ; 640  |        int                 :46;
                             4507 ; 641  |    } B;
                             4508 ; 642  |    DWORD I;
                             4509 ; 643  |} usbmode_type;
                             4510 ; 644  |//#define HW_ARC_USBMODE (*(volatile usbmode_type _X*) (HW_ARC_BASEADDR+0x1a8))    
                             4511 ; 645  |
                             4512 ; 646  |
                             4513 ; 647  |/////////////////////////////////////////////////////////////////////////////////
                             4514 ; 648  |//  The following endpoint equates are common for the following registers
                             4515 ; 649  |
                             4516 ; 650  |#define ENDPOINT0_BITPOS (0)
                             4517 ; 651  |#define ENDPOINT1_BITPOS (1)
                             4518 ; 652  |#define ENDPOINT2_BITPOS (2)
                             4519 ; 653  |#define ENDPOINT3_BITPOS (3)
                             4520 ; 654  |#define ENDPOINT4_BITPOS (4)
                             4521 ; 655  |#define ENDPOINT5_BITPOS (5)
                             4522 ; 656  |#define ENDPOINT6_BITPOS (6)
                             4523 ; 657  |#define ENDPOINT7_BITPOS (7)
                             4524 ; 658  |#define ENDPOINT8_BITPOS (8)
                             4525 ; 659  |#define ENDPOINT9_BITPOS (9)
                             4526 ; 660  |#define ENDPOINT10_BITPOS (10)
                             4527 ; 661  |#define ENDPOINT11_BITPOS (11)
                             4528 ; 662  |#define ENDPOINT12_BITPOS (12)
                             4529 ; 663  |#define ENDPOINT13_BITPOS (13)
                             4530 ; 664  |#define ENDPOINT14_BITPOS (14)
                             4531 ; 665  |#define ENDPOINT15_BITPOS (15)
                             4532 ; 666  |
                             4533 ; 667  |#define ENDPOINT0_SETMASK (1<<ENDPOINT0_BITPOS)
                             4534 ; 668  |#define ENDPOINT1_SETMASK (1<<ENDPOINT1_BITPOS)
                             4535 ; 669  |#define ENDPOINT2_SETMASK (1<<ENDPOINT2_BITPOS)
                             4536 ; 670  |#define ENDPOINT3_SETMASK (1<<ENDPOINT3_BITPOS)
                             4537 ; 671  |#define ENDPOINT4_SETMASK (1<<ENDPOINT4_BITPOS)
                             4538 ; 672  |#define ENDPOINT5_SETMASK (1<<ENDPOINT5_BITPOS)
                             4539 ; 673  |#define ENDPOINT6_SETMASK (1<<ENDPOINT6_BITPOS)
                             4540 ; 674  |#define ENDPOINT7_SETMASK (1<<ENDPOINT7_BITPOS)
                             4541 ; 675  |#define ENDPOINT8_SETMASK (1<<ENDPOINT8_BITPOS)
                             4542 ; 676  |#define ENDPOINT9_SETMASK (1<<ENDPOINT9_BITPOS)
                             4543 ; 677  |#define ENDPOINT10_SETMASK (1<<ENDPOINT10_BITPOS)
                             4544 ; 678  |#define ENDPOINT11_SETMASK (1<<ENDPOINT11_BITPOS)
                             4545 ; 679  |#define ENDPOINT12_SETMASK (1<<ENDPOINT12_BITPOS)
                             4546 ; 680  |#define ENDPOINT13_SETMASK (1<<ENDPOINT13_BITPOS)
                             4547 ; 681  |#define ENDPOINT14_SETMASK (1<<ENDPOINT14_BITPOS)
                             4548 ; 682  |#define ENDPOINT15_SETMASK (1<<ENDPOINT15_BITPOS)
                             4549 ; 683  |
                             4550 ; 684  |#define ENDPOINT0_CLRMASK (~(WORD)ENDPOINT0_SETMASK)    
                             4551 ; 685  |#define ENDPOINT1_CLRMASK (~(WORD)ENDPOINT1_SETMASK)    
                             4552 ; 686  |#define ENDPOINT2_CLRMASK (~(WORD)ENDPOINT2_SETMASK)    
                             4553 ; 687  |#define ENDPOINT3_CLRMASK (~(WORD)ENDPOINT3_SETMASK)    
                             4554 ; 688  |#define ENDPOINT4_CLRMASK (~(WORD)ENDPOINT4_SETMASK)    
                             4555 ; 689  |#define ENDPOINT5_CLRMASK (~(WORD)ENDPOINT5_SETMASK)    
                             4556 ; 690  |#define ENDPOINT6_CLRMASK (~(WORD)ENDPOINT6_SETMASK)    
                             4557 ; 691  |#define ENDPOINT7_CLRMASK (~(WORD)ENDPOINT7_SETMASK)    
                             4558 ; 692  |#define ENDPOINT8_CLRMASK (~(WORD)ENDPOINT8_SETMASK)    
                             4559 ; 693  |#define ENDPOINT9_CLRMASK (~(WORD)ENDPOINT9_SETMASK)    
                             4560 ; 694  |#define ENDPOINT10_CLRMASK (~(WORD)ENDPOINT10_SETMASK)
                             4561 ; 695  |#define ENDPOINT11_CLRMASK (~(WORD)ENDPOINT11_SETMASK)
                             4562 ; 696  |#define ENDPOINT12_CLRMASK (~(WORD)ENDPOINT12_SETMASK)
                             4563 ; 697  |#define ENDPOINT13_CLRMASK (~(WORD)ENDPOINT13_SETMASK)
                             4564 ; 698  |#define ENDPOINT14_CLRMASK (~(WORD)ENDPOINT14_SETMASK)
                             4565 ; 699  |#define ENDPOINT15_CLRMASK (~(WORD)ENDPOINT15_SETMASK)
                             4566 ; 700  |
                             4567 ; 701  |typedef union               
                             4568 ; 702  |{
                             4569 ; 703  |    struct {
                             4570 ; 704  |        int EP0              :1;
                             4571 ; 705  |        int EP1              :1;
                             4572 ; 706  |        int EP2              :1;
                             4573 ; 707  |        int EP3              :1;
                             4574 ; 708  |        int EP4              :1;
                             4575 ; 709  |        int EP5              :1;
                             4576 ; 710  |        int EP6              :1;
                             4577 ; 711  |        int EP7              :1;
                             4578 ; 712  |        int EP8              :1;
                             4579 ; 713  |        int EP9              :1;
                             4580 ; 714  |        int EP10             :1;
                             4581 ; 715  |        int EP11             :1;
                             4582 ; 716  |        int EP12             :1;
                             4583 ; 717  |        int EP13             :1;
                             4584 ; 718  |        int EP14             :1;
                             4585 ; 719  |        int EP15             :1;
                             4586 ; 720  |        int                  :32;
                             4587 ; 721  |    } B;
                             4588 ; 722  |    DWORD I;
                             4589 ; 723  |} endpsetupstat_type;
                             4590 ; 724  |
                             4591 ; 725  |//#define HW_ARC_ENDPTSETUPSTAT (*(volatile endpsetupstat_type _X*) (HW_ARC_BASEADDR+0x1ac))    
                             4592 ; 726  |
                             4593 ; 727  |typedef union               
                             4594 ; 728  |{
                             4595 ; 729  |    struct {
                             4596 ; 730  |        int EP0              :1;
                             4597 ; 731  |        int EP1              :1;
                             4598 ; 732  |        int EP2              :1;
                             4599 ; 733  |        int EP3              :1;
                             4600 ; 734  |        int EP4              :1;
                             4601 ; 735  |        int EP5              :1;
                             4602 ; 736  |        int EP6              :1;
                             4603 ; 737  |        int EP7              :1;
                             4604 ; 738  |        int EP8              :1;
                             4605 ; 739  |        int EP9              :1;
                             4606 ; 740  |        int EP10             :1;
                             4607 ; 741  |        int EP11             :1;
                             4608 ; 742  |        int EP12             :1;
                             4609 ; 743  |        int EP13             :1;
                             4610 ; 744  |        int EP14             :1;
                             4611 ; 745  |        int EP15             :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  19

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4612 ; 746  |        int                  :8;
                             4613 ; 747  |    } B;
                             4614 ; 748  |    WORD I;
                             4615 ; 749  |} endpt_type;
                             4616 
                             4654 
                             4655 ; 750  |
                             4656 ; 751  |typedef union
                             4657 ; 752  |{
                             4658 ; 753  |   struct {
                             4659 ; 754  |       endpt_type  RX;
                             4660 ; 755  |       endpt_type  TX;
                             4661 ; 756  |   } W;
                             4662 ; 757  |   DWORD DW;
                             4663 ; 758  |} endptrxtx_type;
                             4664 ; 759  |
                             4665 ; 760  |//#define HW_ARC_ENDPTPRIME    (*(volatile endptrxtx_type _X*) (HW_ARC_BASEADDR+0x1b0))    
                             4666 ; 761  |//#define HW_ARC_ENDPTFLUSH    (*(volatile endptrxtx_type _X*) (HW_ARC_BASEADDR+0x1b4))    
                             4667 ; 762  |//#define HW_ARC_ENDPTSTAT     (*(volatile endptrxtx_type _X*) (HW_ARC_BASEADDR+0x1b8))    
                             4668 ; 763  |//#define HW_ARC_ENDPTCOMPLETE (*(volatile endptrxtx_type _X*) (HW_ARC_BASEADDR+0x1bc))    
                             4669 ; 764  |
                             4670 ; 765  |
                             4671 ; 766  |
                             4672 ; 767  |/////////////////////////////////////////////////////////////////////////////////
                             4673 ; 768  |//  USB ARC Register Endpoint control (HW_ARC_ENDPTCTRL)
                             4674 ; 769  |
                             4675 ; 770  |#define HW_ARC_ENDPTCTRL_RXS_BITPOS (0)
                             4676 ; 771  |#define HW_ARC_ENDPTCTRL_RXD_BITPOS (1)
                             4677 ; 772  |#define HW_ARC_ENDPTCTRL_RXT_BITPOS (2)
                             4678 ; 773  |#define HW_ARC_ENDPTCTRL_RXI_BITPOS (5)
                             4679 ; 774  |#define HW_ARC_ENDPTCTRL_RXR_BITPOS (6)
                             4680 ; 775  |#define HW_ARC_ENDPTCTRL_RXE_BITPOS (7)
                             4681 ; 776  |#define HW_ARC_ENDPTCTRL_TXS_BITPOS (16)
                             4682 ; 777  |#define HW_ARC_ENDPTCTRL_TXD_BITPOS (17)
                             4683 ; 778  |#define HW_ARC_ENDPTCTRL_TXT_BITPOS (18)
                             4684 ; 779  |#define HW_ARC_ENDPTCTRL_TXI_BITPOS (21)
                             4685 ; 780  |#define HW_ARC_ENDPTCTRL_TXR_BITPOS (22)
                             4686 ; 781  |#define HW_ARC_ENDPTCTRL_TXE_BITPOS (23)
                             4687 ; 782  |
                             4688 ; 783  |#define HW_ARC_ENDPTCTRL_RXS_SETMASK (1<<HW_ARC_ENDPTCTRL_RXS_BITPOS)
                             4689 ; 784  |#define HW_ARC_ENDPTCTRL_RXD_SETMASK (1<<HW_ARC_ENDPTCTRL_RXD_BITPOS)
                             4690 ; 785  |#define HW_ARC_ENDPTCTRL_RXT_SETMASK (3<<HW_ARC_ENDPTCTRL_RXT_BITPOS)
                             4691 ; 786  |#define HW_ARC_ENDPTCTRL_RXI_SETMASK (1<<HW_ARC_ENDPTCTRL_RXI_BITPOS)
                             4692 ; 787  |#define HW_ARC_ENDPTCTRL_RXR_SETMASK (1<<HW_ARC_ENDPTCTRL_RXR_BITPOS)
                             4693 ; 788  |#define HW_ARC_ENDPTCTRL_RXE_SETMASK (1<<HW_ARC_ENDPTCTRL_RXE_BITPOS)
                             4694 ; 789  |#define HW_ARC_ENDPTCTRL_TXS_SETMASK (1<<HW_ARC_ENDPTCTRL_TXS_BITPOS)
                             4695 ; 790  |#define HW_ARC_ENDPTCTRL_TXD_SETMASK (1<<HW_ARC_ENDPTCTRL_TXD_BITPOS)
                             4696 ; 791  |#define HW_ARC_ENDPTCTRL_TXT_SETMASK (3<<HW_ARC_ENDPTCTRL_TXT_BITPOS)
                             4697 ; 792  |#define HW_ARC_ENDPTCTRL_TXI_SETMASK (1<<HW_ARC_ENDPTCTRL_TXI_BITPOS)
                             4698 ; 793  |#define HW_ARC_ENDPTCTRL_TXR_SETMASK (1<<HW_ARC_ENDPTCTRL_TXR_BITPOS)
                             4699 ; 794  |
                             4700 ; 795  |// We need to equate the following label like this due to a sign extension problem
                             4701 ; 796  |// if equated like so (1<<HW_ARC_ENDPTCTRL_TXE_BITPOS)
                             4702 ; 797  |#define HW_ARC_ENDPTCTRL_TXE_SETMASK (0x00800000)
                             4703 ; 798  |//HW_ARC_ENDPTCTRL_TXE_SETMASK    equ     (1<<HW_ARC_ENDPTCTRL_TXE_BITPOS)
                             4704 ; 799  |
                             4705 ; 800  |#define HW_ARC_ENDPTCTRL_RXS_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXS_SETMASK)
                             4706 ; 801  |#define HW_ARC_ENDPTCTRL_RXD_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXD_SETMASK)
                             4707 ; 802  |#define HW_ARC_ENDPTCTRL_RXT_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXT_SETMASK)
                             4708 ; 803  |#define HW_ARC_ENDPTCTRL_RXI_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXI_SETMASK)
                             4709 ; 804  |#define HW_ARC_ENDPTCTRL_RXR_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXR_SETMASK)
                             4710 ; 805  |#define HW_ARC_ENDPTCTRL_RXE_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXE_SETMASK)
                             4711 ; 806  |#define HW_ARC_ENDPTCTRL_TXS_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXS_SETMASK)
                             4712 ; 807  |#define HW_ARC_ENDPTCTRL_TXD_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXD_SETMASK)
                             4713 ; 808  |#define HW_ARC_ENDPTCTRL_TXT_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXT_SETMASK)
                             4714 ; 809  |#define HW_ARC_ENDPTCTRL_TXI_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXI_SETMASK)
                             4715 ; 810  |#define HW_ARC_ENDPTCTRL_TXR_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXR_SETMASK)
                             4716 ; 811  |#define HW_ARC_ENDPTCTRL_TXE_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXE_SETMASK)
                             4717 ; 812  |
                             4718 ; 813  |
                             4719 ; 814  |typedef union               
                             4720 ; 815  |{
                             4721 ; 816  |    struct {
                             4722 ; 817  |        int RXS             :1;
                             4723 ; 818  |        int RXD             :1;
                             4724 ; 819  |        int RXT             :2;
                             4725 ; 820  |        int                 :1;
                             4726 ; 821  |        int RXI             :1;
                             4727 ; 822  |        int RXR             :1;
                             4728 ; 823  |        int RXE             :1;
                             4729 ; 824  |        int                 :8;
                             4730 ; 825  |        int TXS             :1;
                             4731 ; 826  |        int TXD             :1;
                             4732 ; 827  |        int TXT             :2;
                             4733 ; 828  |        int                 :1;
                             4734 ; 829  |        int TXI             :1;
                             4735 ; 830  |        int TXR             :1;
                             4736 ; 831  |        int TXE             :1;
                             4737 ; 832  |        int                 :24;
                             4738 ; 833  |    } B;
                             4739 ; 834  |    DWORD I;
                             4740 ; 835  |} endptctrl_type;
                             4741 ; 836  |//#define HW_ARC_ENDPTCTRL[n] (*(volatile usbintr_type _X*) (HW_ARC_BASEADDR+0x1c0+((n)*4)))    
                             4742 ; 837  |
                             4743 ; 838  |#endif
                             4744 ; 839  |
                             4745 ; 840  |
                             4746 
                             4748 
                             4749 ; 14   |#include "regsusb20phy.h"
                             4750 
                             4752 
                             4753 ; 1    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             4754 ; 2    |//;  Copyright(C) SigmaTel, Inc. 2002-2005
                             4755 ; 3    |//;  File        : regsusbphy.inc
                             4756 ; 4    |//;  Description : USB20 PHY Register definition
                             4757 ; 5    |//;  Updated 2.23.2003 By M. Henson
                             4758 ; 6    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             4759 ; 7    |
                             4760 ; 8    |// The following naming conventions are followed in this file.
                             4761 ; 9    |// All registers are named using the format...
                             4762 ; 10   |//     HW_<module>_<regname>
                             4763 ; 11   |// where <module> is the module name which can be any of the following...
                             4764 ; 12   |//     USB20
                             4765 ; 13   |// (Note that when there is more than one copy of a particular module, the
                             4766 ; 14   |// module name includes a number starting from 0 for the first instance of
                             4767 ; 15   |// that module)
                             4768 ; 16   |// <regname> is the specific register within that module
                             4769 ; 17   |// We also define the following...
                             4770 ; 18   |//     HW_<module>_<regname>_BITPOS
                             4771 ; 19   |// which defines the starting bit (i.e. LSB) of a multi bit field
                             4772 ; 20   |//     HW_<module>_<regname>_SETMASK
                             4773 ; 21   |// which does something else, and
                             4774 ; 22   |//     HW_<module>_<regname>_CLRMASK
                             4775 ; 23   |// which does something else.
                             4776 ; 24   |// Other rules
                             4777 ; 25   |//     All caps
                             4778 ; 26   |//     Numeric identifiers start at 0
                             4779 ; 27   |
                             4780 ; 28   |#if !(defined(regsusbphyinc))
                             4781 ; 29   |#define regsusbphyinc 1
                             4782 ; 30   |
                             4783 ; 31   |#include "types.h"
                             4784 
                             4786 
                             4787 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             4788 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             4789 ; 3    |//
                             4790 ; 4    |// Filename: types.h
                             4791 ; 5    |// Description: Standard data types
                             4792 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             4793 ; 7    |
                             4794 ; 8    |#ifndef _TYPES_H
                             4795 ; 9    |#define _TYPES_H
                             4796 ; 10   |
                             4797 ; 11   |// TODO:  move this outta here!
                             4798 ; 12   |#if !defined(NOERROR)
                             4799 ; 13   |#define NOERROR 0
                             4800 ; 14   |#define SUCCESS 0
                             4801 ; 15   |#endif 
                             4802 ; 16   |#if !defined(SUCCESS)
                             4803 ; 17   |#define SUCCESS  0
                             4804 ; 18   |#endif
                             4805 ; 19   |#if !defined(ERROR)
                             4806 ; 20   |#define ERROR   -1
                             4807 ; 21   |#endif
                             4808 ; 22   |#if !defined(FALSE)
                             4809 ; 23   |#define FALSE 0
                             4810 ; 24   |#endif
                             4811 ; 25   |#if !defined(TRUE)
                             4812 ; 26   |#define TRUE  1
                             4813 ; 27   |#endif
                             4814 ; 28   |
                             4815 ; 29   |#if !defined(NULL)
                             4816 ; 30   |#define NULL 0
                             4817 ; 31   |#endif
                             4818 ; 32   |
                             4819 ; 33   |#define MAX_INT     0x7FFFFF
                             4820 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             4821 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             4822 ; 36   |#define MAX_ULONG   (-1) 
                             4823 ; 37   |
                             4824 ; 38   |#define WORD_SIZE   24              // word size in bits
                             4825 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             4826 ; 40   |
                             4827 ; 41   |
                             4828 ; 42   |#define BYTE    unsigned char       // btVarName
                             4829 ; 43   |#define CHAR    signed char         // cVarName
                             4830 ; 44   |#define USHORT  unsigned short      // usVarName
                             4831 ; 45   |#define SHORT   unsigned short      // sVarName
                             4832 ; 46   |#define WORD    unsigned int        // wVarName
                             4833 ; 47   |#define INT     signed int          // iVarName
                             4834 ; 48   |#define DWORD   unsigned long       // dwVarName
                             4835 ; 49   |#define LONG    signed long         // lVarName
                             4836 ; 50   |#define BOOL    unsigned int        // bVarName
                             4837 ; 51   |#define FRACT   _fract              // frVarName
                             4838 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             4839 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             4840 ; 54   |#define FLOAT   float               // fVarName
                             4841 ; 55   |#define DBL     double              // dVarName
                             4842 ; 56   |#define ENUM    enum                // eVarName
                             4843 ; 57   |#define CMX     _complex            // cmxVarName
                             4844 ; 58   |typedef WORD UCS3;                   // 
                             4845 ; 59   |
                             4846 ; 60   |#define UINT16  unsigned short
                             4847 ; 61   |#define UINT8   unsigned char   
                             4848 ; 62   |#define UINT32  unsigned long
                             4849 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             4850 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             4851 ; 65   |#define WCHAR   UINT16
                             4852 ; 66   |
                             4853 ; 67   |//UINT128 is 16 bytes or 6 words
                             4854 ; 68   |typedef struct UINT128_3500 {   
                             4855 ; 69   |    int val[6];     
                             4856 ; 70   |} UINT128_3500;
                             4857 ; 71   |
                             4858 ; 72   |#define UINT128   UINT128_3500
                             4859 ; 73   |
                             4860 ; 74   |// Little endian word packed byte strings:   
                             4861 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             4862 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             4863 ; 77   |// Little endian word packed byte strings:   
                             4864 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             4865 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             4866 ; 80   |
                             4867 ; 81   |// Declare Memory Spaces To Use When Coding
                             4868 ; 82   |// A. Sector Buffers
                             4869 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             4870 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             4871 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             4872 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             4873 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             4874 ; 88   |// B. Media DDI Memory
                             4875 ; 89   |#define MEDIA_DDI_MEM _Y
                             4876 ; 90   |
                             4877 ; 91   |
                             4878 ; 92   |
                             4879 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             4880 ; 94   |// Examples of circular pointers:
                             4881 ; 95   |//    INT CIRC cpiVarName
                             4882 ; 96   |//    DWORD CIRC cpdwVarName
                             4883 ; 97   |
                             4884 ; 98   |#define RETCODE INT                 // rcVarName
                             4885 ; 99   |
                             4886 ; 100  |// generic bitfield structure
                             4887 ; 101  |struct Bitfield {
                             4888 ; 102  |    unsigned int B0  :1;
                             4889 ; 103  |    unsigned int B1  :1;
                             4890 ; 104  |    unsigned int B2  :1;
                             4891 ; 105  |    unsigned int B3  :1;
                             4892 ; 106  |    unsigned int B4  :1;
                             4893 ; 107  |    unsigned int B5  :1;
                             4894 ; 108  |    unsigned int B6  :1;
                             4895 ; 109  |    unsigned int B7  :1;
                             4896 ; 110  |    unsigned int B8  :1;
                             4897 ; 111  |    unsigned int B9  :1;
                             4898 ; 112  |    unsigned int B10 :1;
                             4899 ; 113  |    unsigned int B11 :1;
                             4900 ; 114  |    unsigned int B12 :1;
                             4901 ; 115  |    unsigned int B13 :1;
                             4902 ; 116  |    unsigned int B14 :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  20

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4903 ; 117  |    unsigned int B15 :1;
                             4904 ; 118  |    unsigned int B16 :1;
                             4905 ; 119  |    unsigned int B17 :1;
                             4906 ; 120  |    unsigned int B18 :1;
                             4907 ; 121  |    unsigned int B19 :1;
                             4908 ; 122  |    unsigned int B20 :1;
                             4909 ; 123  |    unsigned int B21 :1;
                             4910 ; 124  |    unsigned int B22 :1;
                             4911 ; 125  |    unsigned int B23 :1;
                             4912 ; 126  |};
                             4913 ; 127  |
                             4914 ; 128  |union BitInt {
                             4915 ; 129  |        struct Bitfield B;
                             4916 ; 130  |        int        I;
                             4917 ; 131  |};
                             4918 ; 132  |
                             4919 ; 133  |#define MAX_MSG_LENGTH 10
                             4920 ; 134  |struct CMessage
                             4921 ; 135  |{
                             4922 ; 136  |        unsigned int m_uLength;
                             4923 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             4924 ; 138  |};
                             4925 ; 139  |
                             4926 ; 140  |typedef struct {
                             4927 ; 141  |    WORD m_wLength;
                             4928 ; 142  |    WORD m_wMessage;
                             4929 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             4930 ; 144  |} Message;
                             4931 ; 145  |
                             4932 ; 146  |struct MessageQueueDescriptor
                             4933 ; 147  |{
                             4934 ; 148  |        int *m_pBase;
                             4935 ; 149  |        int m_iModulo;
                             4936 ; 150  |        int m_iSize;
                             4937 ; 151  |        int *m_pHead;
                             4938 ; 152  |        int *m_pTail;
                             4939 ; 153  |};
                             4940 ; 154  |
                             4941 ; 155  |struct ModuleEntry
                             4942 ; 156  |{
                             4943 ; 157  |    int m_iSignaledEventMask;
                             4944 ; 158  |    int m_iWaitEventMask;
                             4945 ; 159  |    int m_iResourceOfCode;
                             4946 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             4947 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             4948 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             4949 ; 163  |    int m_uTimeOutHigh;
                             4950 ; 164  |    int m_uTimeOutLow;
                             4951 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             4952 ; 166  |};
                             4953 ; 167  |
                             4954 ; 168  |union WaitMask{
                             4955 ; 169  |    struct B{
                             4956 ; 170  |        unsigned int m_bNone     :1;
                             4957 ; 171  |        unsigned int m_bMessage  :1;
                             4958 ; 172  |        unsigned int m_bTimer    :1;
                             4959 ; 173  |        unsigned int m_bButton   :1;
                             4960 ; 174  |    } B;
                             4961 ; 175  |    int I;
                             4962 ; 176  |} ;
                             4963 ; 177  |
                             4964 ; 178  |
                             4965 ; 179  |struct Button {
                             4966 ; 180  |        WORD wButtonEvent;
                             4967 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             4968 ; 182  |};
                             4969 ; 183  |
                             4970 ; 184  |struct Message {
                             4971 ; 185  |        WORD wMsgLength;
                             4972 ; 186  |        WORD wMsgCommand;
                             4973 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             4974 ; 188  |};
                             4975 ; 189  |
                             4976 ; 190  |union EventTypes {
                             4977 ; 191  |        struct CMessage msg;
                             4978 ; 192  |        struct Button Button ;
                             4979 ; 193  |        struct Message Message;
                             4980 ; 194  |};
                             4981 ; 195  |
                             4982 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             4983 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             4984 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             4985 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             4986 ; 200  |
                             4987 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             4988 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             4989 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             4990 ; 204  |
                             4991 ; 205  |#if DEBUG
                             4992 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             4993 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             4994 ; 208  |#else 
                             4995 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             4996 ; 210  |#define DebugBuildAssert(x)    
                             4997 ; 211  |#endif
                             4998 ; 212  |
                             4999 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             5000 ; 214  |//  #pragma asm
                             5001 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             5002 ; 216  |//  #pragma endasm
                             5003 ; 217  |
                             5004 ; 218  |
                             5005 ; 219  |#ifdef COLOR_262K
                             5006 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             5007 ; 221  |#elif defined(COLOR_65K)
                             5008 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             5009 ; 223  |#else
                             5010 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             5011 ; 225  |#endif
                             5012 ; 226  |    
                             5013 ; 227  |#endif // #ifndef _TYPES_H
                             5014 
                             5016 
                             5017 ; 32   |
                             5018 ; 33   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             5019 ; 34   |//   USB2.0 PHY STMP Registers 
                             5020 ; 35   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             5021 ; 36   |#define HW_USBPHY_BASEADDR (0xF210)
                             5022 ; 37   |
                             5023 ; 38   |
                             5024 ; 39   |/////////////////////////////////////////////////////////////////////////////////
                             5025 ; 40   |//  USB PHY Powerdown Register (HW_USBPHYPWD) Bit Definitions
                             5026 ; 41   |
                             5027 ; 42   |#define HW_USBPHYPWD_TXDISCON1500_BITPOS (5)
                             5028 ; 43   |#define HW_USBPHYPWD_PLLVCOPWD_BITPOS (6)
                             5029 ; 44   |#define HW_USBPHYPWD_PLLVCPPWD_BITPOS (7)
                             5030 ; 45   |#define HW_USBPHYPWD_TXPWDFS_BITPOS (10)
                             5031 ; 46   |#define HW_USBPHYPWD_TXPWDIBIAS_BITPOS (11)
                             5032 ; 47   |#define HW_USBPHYPWD_TXPWDV2I_BITPOS (12)
                             5033 ; 48   |#define HW_USBPHYPWD_TXPWDVBG_BITPOS (13)
                             5034 ; 49   |#define HW_USBPHYPWD_TXPWDCOMP_BITPOS (14)
                             5035 ; 50   |#define HW_USBPHYPWD_RXPWDDISCONDET_BITPOS (16)
                             5036 ; 51   |#define HW_USBPHYPWD_RXPWDENV_BITPOS (17)
                             5037 ; 52   |#define HW_USBPHYPWD_RXPWD1PT1_BITPOS (18)
                             5038 ; 53   |#define HW_USBPHYPWD_RXPWDDIFF_BITPOS (19)
                             5039 ; 54   |#define HW_USBPHYPWD_RXPWDRX_BITPOS (20)
                             5040 ; 55   |#define HW_USBPHYPWD_PWDIBIAS_BITPOS (22)
                             5041 ; 56   |#define HW_USBPHYPWD_REGRESET_BITPOS (23)
                             5042 ; 57   |
                             5043 ; 58   |#define HW_USBPHYPWD_TXDISCON1500_SETMASK (1<<HW_USBPHYPWD_TXDISCON1500_BITPOS)
                             5044 ; 59   |#define HW_USBPHYPWD_PLLVCOPWD_SETMASK (1<<HW_USBPHYPWD_PLLVCOPWD_BITPOS)
                             5045 ; 60   |#define HW_USBPHYPWD_PLLVCPPWD_SETMASK (1<<HW_USBPHYPWD_PLLVCPPWD_BITPOS)
                             5046 ; 61   |#define HW_USBPHYPWD_TXPWDFS_SETMASK (1<<HW_USBPHYPWD_TXPWDFS_BITPOS)
                             5047 ; 62   |#define HW_USBPHYPWD_TXPWDIBIAS_SETMASK (1<<HW_USBPHYPWD_TXPWDIBIAS_BITPOS)
                             5048 ; 63   |#define HW_USBPHYPWD_TXPWDV2I_SETMASK (1<<HW_USBPHYPWD_TXPWDV2I_BITPOS)
                             5049 ; 64   |#define HW_USBPHYPWD_TXPWDVBG_SETMASK (1<<HW_USBPHYPWD_TXPWDVBG_BITPOS)
                             5050 ; 65   |#define HW_USBPHYPWD_TXPWDCOMP_SETMASK (1<<HW_USBPHYPWD_TXPWDCOMP_BITPOS)
                             5051 ; 66   |#define HW_USBPHYPWD_RXPWDDISCONDET_SETMASK (1<<HW_USBPHYPWD_RXPWDDISCONDET_BITPOS)
                             5052 ; 67   |#define HW_USBPHYPWD_RXPWDENV_SETMASK (1<<HW_USBPHYPWD_RXPWDENV_BITPOS)
                             5053 ; 68   |#define HW_USBPHYPWD_RXPWD1PT1_SETMASK (1<<HW_USBPHYPWD_RXPWD1PT1_BITPOS)
                             5054 ; 69   |#define HW_USBPHYPWD_RXPWDDIFF_SETMASK (1<<HW_USBPHYPWD_RXPWDDIFF_BITPOS)
                             5055 ; 70   |#define HW_USBPHYPWD_RXPWDRX_SETMASK (1<<HW_USBPHYPWD_RXPWDRX_BITPOS)
                             5056 ; 71   |#define HW_USBPHYPWD_PWDIBIAS_SETMASK (1<<HW_USBPHYPWD_PWDIBIAS_BITPOS)
                             5057 ; 72   |#define HW_USBPHYPWD_REGRESET_SETMASK (1<<HW_USBPHYPWD_REGRESET_BITPOS)
                             5058 ; 73   |
                             5059 ; 74   |#define HW_USBPHYPWD_TXDISCON1500_CLRMASK (~(WORD)HW_USBPHYPWD_TXDISCON1500_SETMASK)
                             5060 ; 75   |#define HW_USBPHYPWD_PLLVCOPWD_CLRMASK (~(WORD)HW_USBPHYPWD_PLLVCOPWD_SETMASK)
                             5061 ; 76   |#define HW_USBPHYPWD_PLLVCPPWD_CLRMASK (~(WORD)HW_USBPHYPWD_PLLVCPPWD_SETMASK)
                             5062 ; 77   |#define HW_USBPHYPWD_TXPWDFS_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDFS_SETMASK)
                             5063 ; 78   |#define HW_USBPHYPWD_TXPWDIBIAS_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDIBIAS_SETMASK)
                             5064 ; 79   |#define HW_USBPHYPWD_TXPWDV2I_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDV2I_SETMASK)
                             5065 ; 80   |#define HW_USBPHYPWD_TXPWDVBG_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDVBG_SETMASK)
                             5066 ; 81   |#define HW_USBPHYPWD_TXPWDCOMP_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDCOMP_SETMASK)
                             5067 ; 82   |#define HW_USBPHYPWD_RXPWDDISCONDET_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWDDISCONDET_SETMASK)
                             5068 ; 83   |#define HW_USBPHYPWD_RXPWDENV_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWDENV_SETMASK)
                             5069 ; 84   |#define HW_USBPHYPWD_RXPWD1PT1_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWD1PT1_SETMASK)
                             5070 ; 85   |#define HW_USBPHYPWD_RXPWDDIFF_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWDDIFF_SETMASK)
                             5071 ; 86   |#define HW_USBPHYPWD_RXPWDRX_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWDRX_SETMASK)
                             5072 ; 87   |#define HW_USBPHYPWD_PWDIBIAS_CLRMASK (~(WORD)HW_USBPHYPWD_PWDIBIAS_SETMASK)
                             5073 ; 88   |#define HW_USBPHYPWD_REGRESET_CLRMASK (~(WORD)HW_USBPHYPWD_REGRESET_SETMASK)
                             5074 ; 89   |
                             5075 ; 90   |typedef union               
                             5076 ; 91   |{
                             5077 ; 92   |    struct {
                             5078 ; 93   |        int RSVD0          :5;
                             5079 ; 94   |        int TXDISCON1500   :1;
                             5080 ; 95   |        int PLLVCOPWD      :1;
                             5081 ; 96   |        int PLLVCPPWD      :1;
                             5082 ; 97   |        int RSVD1          :2;
                             5083 ; 98   |        int TXPWDFS        :1;
                             5084 ; 99   |        int TXPWDIBIAS     :1;
                             5085 ; 100  |        int TXPWDV2I       :1;
                             5086 ; 101  |        int TXPWDVBG       :1;
                             5087 ; 102  |        int TXPWDCOMP      :1;
                             5088 ; 103  |        int RSVD2          :1;
                             5089 ; 104  |        int RXPWDDISCONDET :1;
                             5090 ; 105  |        int RXPWDENV       :1;
                             5091 ; 106  |        int RXPWD1PT1      :1;
                             5092 ; 107  |        int RXPWDDIFF      :1;
                             5093 ; 108  |        int RXPWDRX        :1;
                             5094 ; 109  |        int RSVD3          :1;
                             5095 ; 110  |        int PWDIBIAS       :1;
                             5096 ; 111  |        int REGRESET       :1;
                             5097 ; 112  |    } B;
                             5098 ; 113  |    int I;
                             5099 ; 114  |} usbphypwd_type;
                             5100 ; 115  |#define HW_USBPHYPWD      (*(volatile usbphypwd_type _X*) (HW_USBPHY_BASEADDR))    /* USB PHY Powerdown Register */
                             5101 ; 116  |
                             5102 ; 117  |/////////////////////////////////////////////////////////////////////////////////
                             5103 ; 118  |//  USB PHY Transmit register (HW_USBPHYTX) Bit Definitions
                             5104 ; 119  |#define HW_USBPHYTX_TXCAL1500_BITPOS (0)
                             5105 ; 120  |#define HW_USBPHYTX_TXENCAL1500_BITPOS (5)
                             5106 ; 121  |#define HW_USBPHYTX_TXHSXCVR_BITPOS (6)
                             5107 ; 122  |#define HW_USBPHYTX_TXCALIBRATE_BITPOS (7)
                             5108 ; 123  |#define HW_USBPHYTX_TXCAL45DN_BITPOS (8)
                             5109 ; 124  |#define HW_USBPHYTX_TXENCAL45DN_BITPOS (13)
                             5110 ; 125  |#define HW_USBPHYTX_TXHSTERM_BITPOS (14)
                             5111 ; 126  |#define HW_USBPHYTX_TXSKEW_BITPOS (15)
                             5112 ; 127  |#define HW_USBPHYTX_TXCAL45DP_BITPOS (16)
                             5113 ; 128  |#define HW_USBPHYTX_TXENCAL45DP_BITPOS (21)
                             5114 ; 129  |#define HW_USBPHYTX_TXFSHIZ_BITPOS (22)
                             5115 ; 130  |#define HW_USBPHYTX_TXCOMPOUT_BITPOS (23)
                             5116 ; 131  |
                             5117 ; 132  |#define HW_USBPHYTX_TXCAL1500_WIDTH (4)
                             5118 ; 133  |#define HW_USBPHYTX_TXENCAL1500_WIDTH (1)
                             5119 ; 134  |#define HW_USBPHYTX_TXHSXCVR_WIDTH (1)
                             5120 ; 135  |#define HW_USBPHYTX_TXCALIBRATE_WIDTH (1)
                             5121 ; 136  |#define HW_USBPHYTX_TXCAL45DN_WIDTH (4)
                             5122 ; 137  |#define HW_USBPHYTX_TXENCAL45DN_WIDTH (1)
                             5123 ; 138  |#define HW_USBPHYTX_TXHSTERM_WIDTH (1)
                             5124 ; 139  |#define HW_USBPHYTX_TXSKEW_WIDTH (1)
                             5125 ; 140  |#define HW_USBPHYTX_TXCAL45DP_WIDTH (4)
                             5126 ; 141  |#define HW_USBPHYTX_TXENCAL45DP_WIDTH (1)
                             5127 ; 142  |#define HW_USBPHYTX_TXFSHIZ_WIDTH (1)
                             5128 ; 143  |#define HW_USBPHYTX_TXCOMPOUT_WIDTH (1)
                             5129 ; 144  |
                             5130 ; 145  |#define HW_USBPHYTX_TXCAL1500_SETMASK (((1<<HW_USBPHYTX_TXCAL1500_WIDTH)-1)<<HW_USBPHYTX_TXCAL1500_BITPOS)
                             5131 ; 146  |#define HW_USBPHYTX_TXENCAL1500_SETMASK (((1<<HW_USBPHYTX_TXENCAL1500_WIDTH)-1)<<HW_USBPHYTX_TXENCAL1500_BITPOS)
                             5132 ; 147  |#define HW_USBPHYTX_TXHSXCVR_SETMASK (((1<<HW_USBPHYTX_TXHSXCVR_WIDTH)-1)<<HW_USBPHYTX_TXHSXCVR_BITPOS)
                             5133 ; 148  |#define HW_USBPHYTX_TXCALIBRATE_SETMASK (((1<<HW_USBPHYTX_TXCALIBRATE_WIDTH)-1)<<HW_USBPHYTX_TXCALIBRATE_BITPOS)
                             5134 ; 149  |#define HW_USBPHYTX_TXCAL45DN_SETMASK (((1<<HW_USBPHYTX_TXCAL45DN_WIDTH)-1)<<HW_USBPHYTX_TXCAL45DN_BITPOS)
                             5135 ; 150  |#define HW_USBPHYTX_TXENCAL45DN_SETMASK (((1<<HW_USBPHYTX_TXENCAL45DN_WIDTH)-1)<<HW_USBPHYTX_TXENCAL45DN_BITPOS)
                             5136 ; 151  |#define HW_USBPHYTX_TXHSTERM_SETMASK (((1<<HW_USBPHYTX_TXHSTERM_WIDTH)-1)<<HW_USBPHYTX_TXHSTERM_BITPOS)
                             5137 ; 152  |#define HW_USBPHYTX_TXSKEW_SETMASK (((1<<HW_USBPHYTX_TXSKEW_WIDTH)-1)<<HW_USBPHYTX_TXSKEW_BITPOS)
                             5138 ; 153  |#define HW_USBPHYTX_TXCAL45DP_SETMASK (((1<<HW_USBPHYTX_TXCAL45DP_WIDTH)-1)<<HW_USBPHYTX_TXCAL45DP_BITPOS)
                             5139 ; 154  |#define HW_USBPHYTX_TXENCAL45DP_SETMASK (((1<<HW_USBPHYTX_TXENCAL45DP_WIDTH)-1)<<HW_USBPHYTX_TXENCAL45DP_BITPOS)
                             5140 ; 155  |#define HW_USBPHYTX_TXFSHIZ_SETMASK (((1<<HW_USBPHYTX_TXFSHIZ_WIDTH)-1)<<HW_USBPHYTX_TXFSHIZ_BITPOS)
                             5141 ; 156  |#define HW_USBPHYTX_TXCOMPOUT_SETMASK (((1<<HW_USBPHYTX_TXCOMPOUT_WIDTH)-1)<<HW_USBPHYTX_TXCOMPOUT_BITPOS)
                             5142 ; 157  |
                             5143 ; 158  |#define HW_USBPHYTX_TXCAL1500_CLRMASK (~(WORD)HW_USBPHYTX_TXCAL1500_SETMASK)
                             5144 ; 159  |#define HW_USBPHYTX_TXENCAL1500_CLRMASK (~(WORD)HW_USBPHYTX_TXENCAL1500_SETMASK)
                             5145 ; 160  |#define HW_USBPHYTX_TXHSXCVR_CLRMASK (~(WORD)HW_USBPHYTX_TXHSXCVR_SETMASK)
                             5146 ; 161  |#define HW_USBPHYTX_TXCALIBRATE_CLRMASK (~(WORD)HW_USBPHYTX_TXCALIBRATE_SETMASK)
                             5147 ; 162  |#define HW_USBPHYTX_TXCAL45DN_CLRMASK (~(WORD)HW_USBPHYTX_TXCAL45DN_SETMASK)
                             5148 ; 163  |#define HW_USBPHYTX_TXENCAL45DN_CLRMASK (~(WORD)HW_USBPHYTX_TXENCAL45DN_SETMASK)
                             5149 ; 164  |#define HW_USBPHYTX_TXHSTERM_CLRMASK (~(WORD)HW_USBPHYTX_TXHSTERM_SETMASK)
                             5150 ; 165  |#define HW_USBPHYTX_TXSKEW_CLRMASK (~(WORD)HW_USBPHYTX_TXSKEW_SETMASK)
                             5151 ; 166  |#define HW_USBPHYTX_TXCAL45DP_CLRMASK (~(WORD)HW_USBPHYTX_TXCAL45DP_SETMASK)
                             5152 ; 167  |#define HW_USBPHYTX_TXENCAL45DP_CLRMASK (~(WORD)HW_USBPHYTX_TXENCAL45DP_SETMASK)
                             5153 ; 168  |#define HW_USBPHYTX_TXFSHIZ_CLRMASK (~(WORD)HW_USBPHYTX_TXFSHIZ_SETMASK)
                             5154 ; 169  |#define HW_USBPHYTX_TXCOMPOUT_CLRMASK (~(WORD)HW_USBPHYTX_TXCOMPOUT_SETMASK)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  21

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5155 ; 170  |
                             5156 ; 171  |typedef union               
                             5157 ; 172  |{
                             5158 ; 173  |    struct {
                             5159 ; 174  |        int TXCAL1500          :4;
                             5160 ; 175  |        int RSVD0              :1;
                             5161 ; 176  |        int TXENCAL1500        :1;
                             5162 ; 177  |        int TXHSXCVR           :1;
                             5163 ; 178  |        int TXCALIBRATE        :1;
                             5164 ; 179  |        int TXCAL45DN          :4;
                             5165 ; 180  |        int RSVD1              :1;
                             5166 ; 181  |        int TXENCAL45DN        :1;
                             5167 ; 182  |        int TXHSTERM           :1;
                             5168 ; 183  |        int TXSKEW             :1;
                             5169 ; 184  |        int TXCAL45DP          :4;
                             5170 ; 185  |        int RSVD2              :1;
                             5171 ; 186  |        int TXENCAL45DP        :1;
                             5172 ; 187  |        int TXFSHIZ            :1;
                             5173 ; 188  |        int TXCOMPOUT          :1;
                             5174 ; 189  |    } B;
                             5175 ; 190  |    int I;
                             5176 ; 191  |} usbphytx_type;
                             5177 ; 192  |#define HW_USBPHYTX      (*(volatile usbphytx_type _X*) (HW_USBPHY_BASEADDR+1))    
                             5178 ; 193  |
                             5179 ; 194  |/////////////////////////////////////////////////////////////////////////////////
                             5180 ; 195  |//  USB PHY PLL register (HW_USBPHYPLL) Bit Definitions
                             5181 ; 196  |#define HW_USBPHYPLL_PLLV2ISEL_BITPOS (0)
                             5182 ; 197  |#define HW_USBPHYPLL_PLLCPDBLIP_BITPOS (5)
                             5183 ; 198  |#define HW_USBPHYPLL_PLLVCOCLK2_BITPOS (6)
                             5184 ; 199  |#define HW_USBPHYPLL_PLLVCOCLK24_BITPOS (7)
                             5185 ; 200  |#define HW_USBPHYPLL_PLLCPNSEL_BITPOS (8)
                             5186 ; 201  |#define HW_USBPHYPLL_PLLCLKDIVSEL_BITPOS (12)
                             5187 ; 202  |#define HW_USBPHYPLL_PLLPFDRST_BITPOS (20)
                             5188 ; 203  |#define HW_USBPHYPLL_PLLCPSHORTLFR_BITPOS (21)
                             5189 ; 204  |#define HW_USBPHYPLL_PLLVCOKSTART_BITPOS (22)
                             5190 ; 205  |#define HW_USBPHYPLL_PLLCLKDIVRSTZ_BITPOS (23)
                             5191 ; 206  |
                             5192 ; 207  |#define HW_USBPHYPLL_PLLV2ISEL_WIDTH (4)
                             5193 ; 208  |#define HW_USBPHYPLL_PLLCPDBLIP_WIDTH (1)
                             5194 ; 209  |#define HW_USBPHYPLL_PLLVCOCLK2_WIDTH (1)
                             5195 ; 210  |#define HW_USBPHYPLL_PLLVCOCLK24_WIDTH (1)
                             5196 ; 211  |#define HW_USBPHYPLL_PLLCPNSEL_WIDTH (4)
                             5197 ; 212  |#define HW_USBPHYPLL_PLLCLKDIVSEL_WIDTH (4)
                             5198 ; 213  |#define HW_USBPHYPLL_PLLPFDRST_WIDTH (1)
                             5199 ; 214  |#define HW_USBPHYPLL_PLLCPSHORTLFR_WIDTH (1)
                             5200 ; 215  |#define HW_USBPHYPLL_PLLVCOKSTART_WIDTH (1)
                             5201 ; 216  |#define HW_USBPHYPLL_PLLCLKDIVRSTZ_WIDTH (1)
                             5202 ; 217  |
                             5203 ; 218  |#define HW_USBPHYPLL_PLLV2ISEL_SETMASK (((1<<HW_USBPHYPLL_PLLV2ISEL_WIDTH)-1)<<HW_USBPHYPLL_PLLV2ISEL_BITPOS)
                             5204 ; 219  |#define HW_USBPHYPLL_PLLCPDBLIP_SETMASK (((1<<HW_USBPHYPLL_PLLCPDBLIP_WIDTH)-1)<<HW_USBPHYPLL_PLLCPDBLIP_BITPOS)
                             5205 ; 220  |#define HW_USBPHYPLL_PLLVCOCLK2_SETMASK (((1<<HW_USBPHYPLL_PLLVCOCLK2_WIDTH)-1)<<HW_USBPHYPLL_PLLVCOCLK2_BITPOS)
                             5206 ; 221  |#define HW_USBPHYPLL_PLLVCOCLK24_SETMASK (((1<<HW_USBPHYPLL_PLLVCOCLK24_WIDTH)-1)<<HW_USBPHYPLL_PLLVCOCLK24_BITPOS)
                             5207 ; 222  |#define HW_USBPHYPLL_PLLCPNSEL_SETMASK (((1<<HW_USBPHYPLL_PLLCPNSEL_WIDTH)-1)<<HW_USBPHYPLL_PLLCPNSEL_BITPOS)
                             5208 ; 223  |#define HW_USBPHYPLL_PLLCLKDIVSEL_SETMASK (((1<<HW_USBPHYPLL_PLLCLKDIVSEL_WIDTH)-1)<<HW_USBPHYPLL_PLLCLKDIVSEL_BITPOS)
                             5209 ; 224  |#define HW_USBPHYPLL_PLLPFDRST_SETMASK (((1<<HW_USBPHYPLL_PLLPFDRST_WIDTH)-1)<<HW_USBPHYPLL_PLLPFDRST_BITPOS)
                             5210 ; 225  |#define HW_USBPHYPLL_PLLCPSHORTLFR_SETMASK (((1<<HW_USBPHYPLL_PLLCPSHORTLFR_WIDTH)-1)<<HW_USBPHYPLL_PLLCPSHORTLFR_BITPOS)
                             5211 ; 226  |#define HW_USBPHYPLL_PLLVCOKSTART_SETMASK (((1<<HW_USBPHYPLL_PLLVCOKSTART_WIDTH)-1)<<HW_USBPHYPLL_PLLVCOKSTART_BITPOS)
                             5212 ; 227  |#define HW_USBPHYPLL_PLLCLKDIVRSTZ_SETMASK (((1<<HW_USBPHYPLL_PLLCLKDIVRSTZ_WIDTH)-1)<<HW_USBPHYPLL_PLLCLKDIVRSTZ_BITPOS)
                             5213 ; 228  |
                             5214 ; 229  |#define HW_USBPHYPLL_PLLV2ISEL_CLRMASK (~(WORD)HW_USBPHYPLL_PLLV2ISEL_SETMASK)
                             5215 ; 230  |#define HW_USBPHYPLL_PLLCPDBLIP_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCPDBLIP_SETMASK)
                             5216 ; 231  |#define HW_USBPHYPLL_PLLVCOCLK2_CLRMASK (~(WORD)HW_USBPHYPLL_PLLVCOCLK2_SETMASK)
                             5217 ; 232  |#define HW_USBPHYPLL_PLLVCOCLK24_CLRMASK (~(WORD)HW_USBPHYPLL_PLLVCOCLK24_SETMASK)
                             5218 ; 233  |#define HW_USBPHYPLL_PLLCPNSEL_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCPNSEL_SETMASK)
                             5219 ; 234  |#define HW_USBPHYPLL_PLLCLKDIVSEL_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCLKDIVSEL_SETMASK)
                             5220 ; 235  |#define HW_USBPHYPLL_PLLPFDRST_CLRMASK (~(WORD)HW_USBPHYPLL_PLLPFDRST_SETMASK)
                             5221 ; 236  |#define HW_USBPHYPLL_PLLCPSHORTLFR_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCPSHORTLFR_SETMASK)
                             5222 ; 237  |#define HW_USBPHYPLL_PLLVCOKSTART_CLRMASK (~(WORD)HW_USBPHYPLL_PLLVCOKSTART_SETMASK)
                             5223 ; 238  |#define HW_USBPHYPLL_PLLCLKDIVRSTZ_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCLKDIVRSTZ_SETMASK)
                             5224 ; 239  |
                             5225 ; 240  |typedef union               
                             5226 ; 241  |{
                             5227 ; 242  |    struct {
                             5228 ; 243  |        int PLLV2ISEL        :4;
                             5229 ; 244  |        int RSVD0            :1;
                             5230 ; 245  |        int PLLCPDBLIP       :1;
                             5231 ; 246  |        int PLLVCOCLK2       :1;
                             5232 ; 247  |        int PLLVCOCLK24      :1;
                             5233 ; 248  |        int PLLCPNSEL        :4;
                             5234 ; 249  |        int PLLCLKDIVSEL     :4;
                             5235 ; 250  |        int RSVD1            :4;
                             5236 ; 251  |        int PLLPFDRST        :1;
                             5237 ; 252  |        int PLLCPSHORTLFR    :1;
                             5238 ; 253  |        int PLLVCOKSTART     :1;
                             5239 ; 254  |        int PLLCLKDIVRSTZ    :1;
                             5240 ; 255  |    } B;
                             5241 ; 256  |    int I;
                             5242 ; 257  |} usbphypll_type;
                             5243 ; 258  |#define HW_USBPHYPLL      (*(volatile usbphypll_type _X*) (HW_USBPHY_BASEADDR+2))    
                             5244 ; 259  |
                             5245 ; 260  |/////////////////////////////////////////////////////////////////////////////////
                             5246 ; 261  |//  USB PHY PLL register (HW_USBPHYRX) Bit Definitions
                             5247 ; 262  |#define HW_USBRX_ENVADJ_BITPOS (0)
                             5248 ; 263  |#define HW_USBRX_DISCONADJ_BITPOS (4)
                             5249 ; 264  |#define HW_USBRX_DEBUGMODE_BITPOS (8)
                             5250 ; 265  |#define HW_USBRX_PLLLKTIMECTL_BITPOS (12)
                             5251 ; 266  |#define HW_USBRX_PLLCKDIVCTL_BITPOS (16)
                             5252 ; 267  |#define HW_USBRX_HOSTMODETEST_BITPOS (20)
                             5253 ; 268  |#define HW_USBRX_FSCKSOURCESEL_BITPOS (21)
                             5254 ; 269  |#define HW_USBRX_REGRXDBYPASS_BITPOS (22)
                             5255 ; 270  |#define HW_USBRX_PLLLOCKED_BITPOS (23)
                             5256 ; 271  |
                             5257 ; 272  |#define HW_USBRX_ENVADJ_WIDTH (4)
                             5258 ; 273  |#define HW_USBRX_DISCONADJ_WIDTH (4)
                             5259 ; 274  |#define HW_USBRX_DEBUGMODE_WIDTH (4)
                             5260 ; 275  |#define HW_USBRX_PLLLKTIMECTL_WIDTH (4)
                             5261 ; 276  |#define HW_USBRX_PLLCKDIVCTL_WIDTH (4)
                             5262 ; 277  |#define HW_USBRX_HOSTMODETEST_WIDTH (1)
                             5263 ; 278  |#define HW_USBRX_FSCKSOURCESEL_WIDTH (1)
                             5264 ; 279  |#define HW_USBRX_REGRXDBYPASS_WIDTH (1)
                             5265 ; 280  |#define HW_USBRX_PLLLOCKED_WIDTH (1)
                             5266 ; 281  |
                             5267 ; 282  |#define HW_USBRX_ENVADJ_SETMASK (((1<<HW_USBRX_ENVADJ_WIDTH)-1)<<HW_USBRX_ENVADJ_BITPOS)
                             5268 ; 283  |#define HW_USBRX_DISCONADJ_SETMASK (((1<<HW_USBRX_DISCONADJ_WIDTH)-1)<<HW_USBRX_DISCONADJ_BITPOS)
                             5269 ; 284  |#define HW_USBRX_DEBUGMODE_SETMASK (((1<<HW_USBRX_DEBUGMODE_WIDTH)-1)<<HW_USBRX_DEBUGMODE_BITPOS)
                             5270 ; 285  |#define HW_USBRX_PLLLKTIMECTL_SETMASK (((1<<HW_USBRX_PLLLKTIMECTL_WIDTH)-1)<<HW_USBRX_PLLLKTIMECTL_BITPOS)
                             5271 ; 286  |#define HW_USBRX_PLLCKDIVCTL_SETMASK (((1<<HW_USBRX_PLLCKDIVCTL_WIDTH)-1)<<HW_USBRX_PLLCKDIVCTL_BITPOS)
                             5272 ; 287  |// 480 MHz PLL is divided by named number here. Setmask divider field nibble of 7 gives actual divider of 8 and so on. (8 gives 9, 9 gives 10)
                             5273 ; 288  |//              480Mhz/7 =68.57Mhz
                             5274 ; 289  |#define HW_USBPHYRX_PLLDIV_BY_7 0x060000
                             5275 ; 290  |
                             5276 ; 291  |//              480Mhz/8 ~60Mhz
                             5277 ; 292  |#define HW_USBPHYRX_PLLDIV_BY_8 0x070000
                             5278 ; 293  |
                             5279 ; 294  |//              480Mhz/9 =53.3Mhz
                             5280 ; 295  |#define HW_USBPHYRX_PLLDIV_BY_9 0x080000
                             5281 ; 296  |
                             5282 ; 297  |//              480Mhz/10 =48Mhz
                             5283 ; 298  |#define HW_USBPHYRX_PLLDIV_BY_10 0x090000
                             5284 ; 299  |
                             5285 ; 300  |
                             5286 ; 301  |#define HW_USBRX_HOSTMODETEST_SETMASK (((1<<HW_USBRX_HOSTMODETEST_WIDTH)-1)<<HW_USBRX_HOSTMODETEST_BITPOS)
                             5287 ; 302  |#define HW_USBRX_FSCKSOURCESEL_SETMASK (((1<<HW_USBRX_FSCKSOURCESEL_WIDTH)-1)<<HW_USBRX_FSCKSOURCESEL_BITPOS)
                             5288 ; 303  |#define HW_USBRX_REGRXDBYPASS_SETMASK (((1<<HW_USBRX_REGRXDBYPASS_WIDTH)-1)<<HW_USBRX_REGRXDBYPASS_BITPOS)
                             5289 ; 304  |#define HW_USBRX_PLLLOCKED_SETMASK (((1<<HW_USBRX_PLLLOCKED_WIDTH)-1)<<HW_USBRX_PLLLOCKED_BITPOS)
                             5290 ; 305  |
                             5291 ; 306  |#define HW_USBRX_ENVADJ_CLRMASK (~(WORD)HW_USBRX_ENVADJ_SETMASK)
                             5292 ; 307  |#define HW_USBRX_DISCONADJ_CLRMASK (~(WORD)HW_USBRX_DISCONADJ_SETMASK)
                             5293 ; 308  |#define HW_USBRX_DEBUGMODE_CLRMASK (~(WORD)HW_USBRX_DEBUGMODE_SETMASK)
                             5294 ; 309  |#define HW_USBRX_PLLLKTIMECTL_CLRMASK (~(WORD)HW_USBRX_PLLLKTIMECTL_SETMASK)
                             5295 ; 310  |#define HW_USBRX_PLLCKDIVCTL_CLRMASK (~(WORD)HW_USBRX_PLLCKDIVCTL_SETMASK)
                             5296 ; 311  |#define HW_USBRX_HOSTMODETEST_CLRMASK (~(WORD)HW_USBRX_HOSTMODETEST_SETMASK)
                             5297 ; 312  |#define HW_USBRX_FSCKSOURCESEL_CLRMASK (~(WORD)HW_USBRX_FSCKSOURCESEL_SETMASK)
                             5298 ; 313  |#define HW_USBRX_REGRXDBYPASS_CLRMASK (~(WORD)HW_USBRX_REGRXDBYPASS_SETMASK)
                             5299 ; 314  |#define HW_USBRX_PLLLOCKED_CLRMASK (~(WORD)HW_USBRX_PLLLOCKED_SETMASK)
                             5300 ; 315  |
                             5301 ; 316  |typedef union               
                             5302 ; 317  |{
                             5303 ; 318  |    struct {
                             5304 ; 319  |     int ENVADJ               :4;
                             5305 ; 320  |     int DISCONADJ            :4;
                             5306 ; 321  |     int DEBUGMODE            :4;
                             5307 ; 322  |     int PLLLKTIMECTL         :4;
                             5308 ; 323  |     int PLLCKDIVCTL          :4;
                             5309 ; 324  |     int HOSTMODETEST         :1;
                             5310 ; 325  |     int FSCKSOURCESEL        :1;
                             5311 ; 326  |     int REGRXDBYPASS         :1;
                             5312 ; 327  |     int PLLLOCKED            :1;
                             5313 ; 328  |    } B;
                             5314 ; 329  |    int I;
                             5315 ; 330  |} usbphyrx_type;
                             5316 ; 331  |#define HW_USBPHYRX      (*(volatile usbphyrx_type _X*) (HW_USBPHY_BASEADDR+3))    
                             5317 ; 332  |
                             5318 ; 333  |#endif
                             5319 ; 334  |
                             5320 
                             5322 
                             5323 ; 15   |
                             5324 ; 16   |////////////////////////////////////////////////////////////////////////////////
                             5325 ; 17   |//  Macros
                             5326 ; 18   |////////////////////////////////////////////////////////////////////////////////
                             5327 ; 19   |
                             5328 ; 20   |
                             5329 ; 21   |     
                             5330 ; 22   |// This macro reads the ARC 32-bit register and returns in a 24-bit word
                             5331 ; 23   |// the LSW (16 bit)
                             5332 ; 24   |// This macro is usefull to test endpoint bits. Do not use this macro to
                             5333 ; 25   |// read-modify-write sequence since the upper 16 bits of the ARC register
                             5334 ; 26   |// are not saved 
                             5335 ; 27   |#define READ_USB_REG_LOW(Reg, Data)     
                             5336 ; 28   |/*
                             5337 ; 29   |    Reg &= HW_USBARCACCESS_ADD_SETMASK; \ 
                             5338 ; 30   |    HW_USBARCACCESS.B.ADD = Reg;        \ 
                             5339 ; 31   |    HW_USBARCACCESS.B.RWB = 1;          \ 
                             5340 ; 32   |    HW_USBARCACCESS.B.KICK = 1;         \ 
                             5341 ; 33   |    while(HW_USBARCACCESS.B.KICK);      \ 
                             5342 ; 34   |    Data = (WORD)(HW_USBARCDATALOW.B.DATA & HW_USBARCDATALOW_DATA_SETMASK); 
                             5343 ; 35   |*/
                             5344 ; 36   |
                             5345 ; 37   |// This macro reads the ARC 32-bit register and returns in a 24-bit word
                             5346 ; 38   |// the HSW (16 bit)
                             5347 ; 39   |// This macro is usefull to test endpoint bits. Do not use this macro to
                             5348 ; 40   |// read-modify-write sequence since the lower 16 bits of the ARC register
                             5349 ; 41   |// are not saved 
                             5350 ; 42   |#define READ_USB_REG_HIGH(Reg, Data)    
                             5351 ; 43   |/*
                             5352 ; 44   |    Reg &= HW_USBARCACCESS_ADD_SETMASK; \ 
                             5353 ; 45   |    HW_USBARCACCESS.B.ADD = Reg;        \ 
                             5354 ; 46   |    HW_USBARCACCESS.B.RWB = 1;          \ 
                             5355 ; 47   |    HW_USBARCACCESS.B.KICK = 1;         \ 
                             5356 ; 48   |    while(HW_USBARCACCESS.B.KICK);      \ 
                             5357 ; 49   |    Data = (WORD)(HW_USBARCDATAHIGH.B.DATA & HW_USBARCDATALOW_DATA_SETMASK); 
                             5358 ; 50   |*/
                             5359 ; 51   |
                             5360 ; 52   |
                             5361 ; 53   |#define  MAX_EP_TR_DESCRS                    MAX_NUM_EP
                             5362 ; 54   |#define  MAX_XDS_FOR_TR_CALLS                MAX_EP_TR_DESCRS
                             5363 ; 55   |#define  MAX_USB_DEVICES                     (1)
                             5364 ; 56   |
                             5365 ; 57   |#define  USB_MAX_CTRL_PAYLOAD                (64)
                             5366 ; 58   |
                             5367 ; 59   |/* Endpoint Queue Head Bit Masks */
                             5368 ; 60   |#define  USB_EP_QUEUE_HEAD_IOS              (0x8000)
                             5369 ; 61   |
                             5370 ; 62   |/* Endpoint Queue Head Bit Position */
                             5371 ; 63   |#define USB_EP_QUEUE_HEAD_MULT_POS                  (14)
                             5372 ; 64   |#define USB_EP_QUEUE_HEAD_DONT_ZERO_TERMINATE_POS   (13)
                             5373 ; 65   |
                             5374 ; 66   |// dTD Masks
                             5375 ; 67   |#define USB_EP_dTD_ACTIVE                   (0x0080)
                             5376 ; 68   |#define USB_EP_dTD_HALTED                   (0x0040)
                             5377 ; 69   |#define USB_EP_dTD_DATA_BUF_ERR             (0x0020)
                             5378 ; 70   |#define USB_EP_dTD_DATA_TRANSACT_ERR        (0x0008)
                             5379 ; 71   |#define USB_EP_dTD_NO_ERROR                 (0x00e8)
                             5380 ; 72   |#define USB_EP_dTD_IOC                      (0x8000)
                             5381 ; 73   |
                             5382 ; 74   |    // This structure is also defined in assembly. All dQH writes go thru this structure.
                             5383 ; 75   |    // To update the actual dQH, use the assembly function dQHPackCap()  
                             5384 ; 76   |    // The structure is allocated in assembly file address dQH_Scratch_Cap
                             5385 ; 77   |typedef struct {
                             5386 ; 78   |    USHORT  usIos;                  // Bit 15 is the Interrupt On Setup
                             5387 ; 79   |                                    // Bits 0 to 14 always set to 0
                             5388 ; 80   |    USHORT  usMaxPktLengthZltMult;  // Bits 0-10 = Maximum Packet Length
                             5389 ; 81   |                                    // Bits 11-12 - Always 0
                             5390 ; 82   |                                    // Bit 13 - Zero Length Termination Select Bit
                             5391 ; 83   |                                    // bits 14-15 - Number packets executed per transaction
                             5392 ; 84   |                                    //              always 00 for control and bulk endpoints
                             5393 ; 85   |    BYTE *  pbtNextdTDPointer;      // Pointer to the next dTD. We limit the address to 16 bits
                             5394 ; 86   |                                    // 64Kbytes in ARC space.
                             5395 ; 87   |    USHORT  usStatusIoc;            // Bits 0-7 - Status of transaction
                             5396 ; 88   |                                    // Bits 8-14 - Always 0
                             5397 ; 89   |                                    // Bit 15 - Interrupt On Completion (IOC)
                             5398 ; 90   |    USHORT  usTotalBytes;            // Total bytes transfered
                             5399 ; 91   |    } dQH_Struct_Cap;
                             5400 ; 92   |
                             5401 ; 93   |
                             5402 ; 94   |    // There is one structure of this type per endpoint. The structures are allocated in assembly
                             5403 ; 95   |    // at addresses dTD_SCRATCH_0 to dTD_SCRATCH_n where n is number of endpoints - 1
                             5404 ; 96   |typedef struct {
                             5405 ; 97   |    BYTE *  pbtNextdTDPointer;      // Pointer to the next dTD. We limit the address to 16 bits
                             5406 ; 98   |                                    // 64Kbytes in ARC space.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  22

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5407 ; 99   |    USHORT  usStatusIoc;            // Bits 0-7 - Status of transaction
                             5408 ; 100  |                                    // Bits 8-14 - Always 0
                             5409 ; 101  |                                    // Bit 15 - Interrupt On Completion (IOC)
                             5410 ; 102  |    USHORT  usTotalBytes;           // bits 0-13 total bytes to transfer
                             5411 ; 103  |                                    // bits 14-15 Always set to 0
                             5412 ; 104  |    USHORT  usCurrentOffset;        // Offset into the 4KBytes buffer where the packet is to begin
                             5413 ; 105  |                                    // limited to 12 bits
                             5414 ; 106  |    BYTE *  pbtBufPage0;            // Page 0 offset for the packet buffer
                             5415 ; 107  |    BYTE *  pbtBufPage1;            // Page 1 offset for the packet buffer
                             5416 ; 108  |    BYTE *  pbtBufPage2;            // Page 2 offset for the packet buffer
                             5417 ; 109  |    BYTE *  pbtBufPage3;            // Page 3 offset for the packet buffer
                             5418 ; 110  |    BYTE *  pbtBufPage4;            // Page 4 offset for the packet buffer
                             5419 ; 111  |    } dTD_Struct;
                             5420 ; 112  |
                             5421 ; 113  |
                             5422 ; 114  |typedef struct {
                             5423 ; 115  |   BYTE     btRequestType;
                             5424 ; 116  |   BYTE     btRequest;
                             5425 ; 117  |   BYTE     btValueLsb;
                             5426 ; 118  |   BYTE     btValueMsb;
                             5427 ; 119  |   BYTE     btIndexLsb;
                             5428 ; 120  |   BYTE     btIndexMsb;
                             5429 ; 121  |   BYTE     btLengthLsb;
                             5430 ; 122  |   BYTE     btLengthMsb;
                             5431 ; 123  |    } dQH_Struct_Setup;
                             5432 ; 124  |
                             5433 ; 125  |
                             5434 ; 126  |    // Use only for ARC simulation
                             5435 ; 127  |#ifdef  SIM_USB20
                             5436 ; 128  |
                             5437 ; 129  |typedef struct {
                             5438 ; 130  |    DWORD       SoftArcHcsParams;      
                             5439 ; 131  |    DWORD       SoftArcUsbCmd;         
                             5440 ; 132  |    DWORD       SoftArcUsbSts;         
                             5441 ; 133  |    DWORD       SoftArcUsbIntr;        
                             5442 ; 134  |    DWORD       SoftArcDevAddr;        
                             5443 ; 135  |    DWORD       SoftArcEndptListAddr;  
                             5444 ; 136  |    DWORD       SoftArcPortsc1;        
                             5445 ; 137  |    DWORD       SoftArcUsbMode;        
                             5446 ; 138  |    DWORD       SoftArcEndptSetupStat; 
                             5447 ; 139  |    DWORD       SoftArcEndptPrime;     
                             5448 ; 140  |    DWORD       SoftArcEndptFlush;     
                             5449 ; 141  |    DWORD       SoftArcEndptStatus;    
                             5450 ; 142  |    DWORD       SoftArcEndptComplete;  
                             5451 ; 143  |    DWORD       SoftArcEndptCtrl[MAX_NUM_EP];     
                             5452 ; 144  |} arc_reg_struct;
                             5453 ; 145  |
                             5454 ; 146  |#endif
                             5455 ; 147  |
                             5456 ; 148  |extern _asmfunc void FInitUsbStructures(void);
                             5457 ; 149  |extern _asmfunc void FdQHPackCap(USHORT usEndpointNumber, BYTE btDirection, BYTE btFlag);
                             5458 ; 150  |extern _asmfunc void FdQHUnpackSetup(USHORT usEndpointNumber, BYTE btDirection);
                             5459 ; 151  |extern _asmfunc void FdTDUnpack(USHORT usEndpointNumber, BYTE btDirection);
                             5460 ; 152  |extern _asmfunc void FdTDPack(USHORT usEndpointNumber, BYTE btDirection);
                             5461 ; 153  |void _reentrant ProcessEndptSetup(DWORD dwRegComplete, WORD wRegSetup);
                             5462 ; 154  |void _reentrant ProcessEndptComplete(DWORD dwRegComplete, WORD wRegSetup);
                             5463 ; 155  |
                             5464 ; 156  |#ifdef  SIM_USB20
                             5465 ; 157  |void _reentrant write_usb_reg(DWORD *dwSoftReg, DWORD dwData);         
                             5466 ; 158  |void _reentrant read_usb_reg(DWORD *dwSoftReg, DWORD * dwData);
                             5467 ; 159  |#else
                             5468 ; 160  |void _reentrant write_usb_reg(USHORT usRegAdd, DWORD dwData);         
                             5469 ; 161  |void _reentrant read_usb_reg(USHORT usRegAdd, DWORD * dwData);
                             5470 ; 162  |#endif
                             5471 ; 163  |
                             5472 ; 164  |void _long_interrupt(-1) usb_dci_isr(void);
                             5473 ; 165  |
                             5474 ; 166  |#ifndef BOOT_ROM
                             5475 ; 167  |void _reentrant usb_dci_set_test_mode(USHORT usTest);
                             5476 ; 168  |#endif
                             5477 ; 169  | 
                             5478 ; 170  |#endif
                             5479 
                             5481 
                             5482 ; 21   |#include "regsusb20.h"
                             5483 
                             5485 
                             5486 ; 1    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             5487 ; 2    |//;  Copyright(C) SigmaTel, Inc. 2002-2003
                             5488 ; 3    |//;  File        : regsusb20ip.inc
                             5489 ; 4    |//;  Description : USB20 IP Register definition
                             5490 ; 5    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             5491 ; 6    |
                             5492 ; 7    |// The following naming conventions are followed in this file.
                             5493 ; 8    |// All registers are named using the format...
                             5494 ; 9    |//     HW_<module>_<regname>
                             5495 ; 10   |// where <module> is the module name which can be any of the following...
                             5496 ; 11   |//     USB20
                             5497 ; 12   |// (Note that when there is more than one copy of a particular module, the
                             5498 ; 13   |// module name includes a number starting from 0 for the first instance of
                             5499 ; 14   |// that module)
                             5500 ; 15   |// <regname> is the specific register within that module
                             5501 ; 16   |// We also define the following...
                             5502 ; 17   |//     HW_<module>_<regname>_BITPOS
                             5503 ; 18   |// which defines the starting bit (i.e. LSB) of a multi bit field
                             5504 ; 19   |//     HW_<module>_<regname>_SETMASK
                             5505 ; 20   |// which does something else, and
                             5506 ; 21   |//     HW_<module>_<regname>_CLRMASK
                             5507 ; 22   |// which does something else.
                             5508 ; 23   |// Other rules
                             5509 ; 24   |//     All caps
                             5510 ; 25   |//     Numeric identifiers start at 0
                             5511 ; 26   |
                             5512 ; 27   |#if !(defined(regsusb20inc))
                             5513 ; 28   |#define regsusb20inc 1
                             5514 ; 29   |
                             5515 ; 30   |#include "types.h"
                             5516 ; 31   |
                             5517 ; 32   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             5518 ; 33   |//   USB2.0 STMP Registers 
                             5519 ; 34   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             5520 ; 35   |#define HW_USB_BASEADDR (0xF200)
                             5521 ; 36   |
                             5522 ; 37   |
                             5523 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                             5524 ; 39   |//  USB Control Status Register (HW_USBCSR) Bit Definitions
                             5525 ; 40   |#define HW_USBCSR_USBEN_BITPOS (0)
                             5526 ; 41   |#define HW_USBCSR_WAKEUPIRQ_BITPOS (1)
                             5527 ; 42   |#define HW_USBCSR_WAKEUPIE_BITPOS (2)
                             5528 ; 43   |#define HW_USBCSR_VBUSCXIRQ_BITPOS (3)
                             5529 ; 44   |#define HW_USBCSR_VBUSCXIE_BITPOS (4)
                             5530 ; 45   |#define HW_USBCSR_VBUSDISCXIRQ_BITPOS (5)
                             5531 ; 46   |#define HW_USBCSR_VBUSDISCXIE_BITPOS (6)
                             5532 ; 47   |#define HW_USBCSR_CLKOFF_BITPOS (7)
                             5533 ; 48   |#define HW_USBCSR_SUSP_BITPOS (8)
                             5534 ; 49   |#define HW_USBCSR_SUSPF_BITPOS (9)
                             5535 ; 50   |#define HW_USBCSR_UTMITST_BITPOS (10)
                             5536 ; 51   |#define HW_USBCSR_UTMI_EXT_BITPOS (11)
                             5537 ; 52   |#define HW_USBCSR_PLUGGEDIN_EN_BITPOS (12)
                             5538 ; 53   |#define HW_USBCSR_PLUGGEDIN_BITPOS (13)
                             5539 ; 54   |#define HW_USBCSR_HOSTDISCONNECT_BITPOS (22)
                             5540 ; 55   |#define HW_USBCSR_VBUSSENSE_BITPOS (23)
                             5541 ; 56   |
                             5542 ; 57   |#define HW_USBCSR_USBEN_SETMASK (1<<HW_USBCSR_USBEN_BITPOS)        
                             5543 ; 58   |#define HW_USBCSR_WAKEUPIRQ_SETMASK (1<<HW_USBCSR_WAKEUPIRQ_BITPOS) 
                             5544 ; 59   |#define HW_USBCSR_WAKEUPIE_SETMASK (1<<HW_USBCSR_WAKEUPIE_BITPOS)  
                             5545 ; 60   |#define HW_USBCSR_VBUSCXIRQ_SETMASK (1<<HW_USBCSR_VBUSCXIRQ_BITPOS)
                             5546 ; 61   |#define HW_USBCSR_VBUSCXIE_SETMASK (1<<HW_USBCSR_VBUSCXIE_BITPOS)
                             5547 ; 62   |#define HW_USBCSR_VBUSDISCXIRQ_SETMASK (1<<HW_USBCSR_VBUSDISCXIRQ_BITPOS)
                             5548 ; 63   |#define HW_USBCSR_VBUSDISCXIE_SETMASK (1<<HW_USBCSR_VBUSDISCXIE_BITPOS)
                             5549 ; 64   |#define HW_USBCSR_CLKOFF_SETMASK (1<<HW_USBCSR_CLKOFF_BITPOS)    
                             5550 ; 65   |#define HW_USBCSR_SUSP_SETMASK (1<<HW_USBCSR_SUSP_BITPOS)      
                             5551 ; 66   |#define HW_USBCSR_SUSPF_SETMASK (1<<HW_USBCSR_SUSPF_BITPOS)     
                             5552 ; 67   |#define HW_USBCSR_UTMITST_SETMASK (1<<HW_USBCSR_UTMITST_BITPOS)   
                             5553 ; 68   |#define HW_USBCSR_UTMI_EXT_SETMASK (1<<HW_USBCSR_UTMI_EXT_BITPOS)
                             5554 ; 69   |#define HW_USBCSR_VBUSSENSE_SETMASK (1<<HW_USBCSR_VBUSSENSE_BITPOS)
                             5555 ; 70   |
                             5556 ; 71   |
                             5557 ; 72   |#define HW_USBCSR_USBEN_CLRMASK (~(WORD)HW_USBCSR_USBEN_SETMASK)     
                             5558 ; 73   |#define HW_USBCSR_WAKEUPIRQ_CLRMASK (~(WORD)HW_USBCSR_WAKEUPIRQ_SETMASK) 
                             5559 ; 74   |#define HW_USBCSR_WAKEUPIE_CLRMASK (~(WORD)HW_USBCSR_WAKEUPIE_SETMASK)  
                             5560 ; 75   |#define HW_USBCSR_VBUSCXIRQ_CLRMASK (~(WORD)HW_USBCSR_VBUSCXIRQ_SETMASK)
                             5561 ; 76   |#define HW_USBCSR_VBUSCXIE_CLRMASK (~(WORD)HW_USBCSR_VBUSCXIE_SETMASK)
                             5562 ; 77   |#define HW_USBCSR_VBUSDISCXIRQ_CLRMASK (~(WORD)HW_USBCSR_VBUSDISCXIRQ_SETMASK)
                             5563 ; 78   |#define HW_USBCSR_VBUSDISCXIE_CLRMASK (~(WORD)HW_USBCSR_VBUSDISCXIE_SETMASK) 
                             5564 ; 79   |#define HW_USBCSR_CLKOFF_CLRMASK (~(WORD)HW_USBCSR_CLKOFF_SETMASK)    
                             5565 ; 80   |#define HW_USBCSR_SUSP_CLRMASK (~(WORD)HW_USBCSR_SUSP_SETMASK)      
                             5566 ; 81   |#define HW_USBCSR_SUSPF_CLRMASK (~(WORD)HW_USBCSR_SUSPF_SETMASK)     
                             5567 ; 82   |#define HW_USBCSR_UTMITST_CLRMASK (~(WORD)HW_USBCSR_UTMITST_SETMASK)   
                             5568 ; 83   |#define HW_USBCSR_UTMI_EXT_CLRMASK (~(WORD)HW_USBCSR_UTMI_EXT_SETMASK) 
                             5569 ; 84   |#define HW_USBCSR_VBUSSENSE_CLRMASK (~(WORD)HW_USBCSR_VBUSSENSE_SETMASK) 
                             5570 ; 85   |
                             5571 ; 86   |typedef union               
                             5572 ; 87   |{
                             5573 ; 88   |    struct {
                             5574 ; 89   |        int USBEN          :1;
                             5575 ; 90   |        int WAKEUPIRQ      :1;
                             5576 ; 91   |        int WAKEUPIE       :1;
                             5577 ; 92   |        int VBUSCXIRQ      :1;
                             5578 ; 93   |        int VBUSCXIE       :1;
                             5579 ; 94   |        int VBUSDISCXIRQ   :1;
                             5580 ; 95   |        int VBUSDISCXIE    :1;
                             5581 ; 96   |        int CLKOFF         :1;
                             5582 ; 97   |        int SUSP           :1;
                             5583 ; 98   |        int SUSPF          :1;
                             5584 ; 99   |        int UTMITST        :1;
                             5585 ; 100  |        int ARCCONNECT     :1;
                             5586 ; 101  |        int PLUGGEDIN_EN   :1;
                             5587 ; 102  |        int PLUGGEDIN      :1;
                             5588 ; 103  |        int                :8;
                             5589 ; 104  |        int HOSTDISCONNECT :1;
                             5590 ; 105  |        int VBUSSENSE      :1;
                             5591 ; 106  |    } B;
                             5592 ; 107  |    int I;
                             5593 ; 108  |} usbcsr_type;
                             5594 ; 109  |#define HW_USBCSR      (*(volatile usbcsr_type _X*) (HW_USB_BASEADDR))    /* USB Control / Status Register */
                             5595 ; 110  |
                             5596 ; 111  |/////////////////////////////////////////////////////////////////////////////////
                             5597 ; 112  |//  USB DMA OFFSET register (HW_USBDMAOFF) Bit Definitions
                             5598 ; 113  |#define HW_USBDMAOFF_MEM_BITPOS (16)
                             5599 ; 114  |
                             5600 ; 115  |#define HW_USBDMAOFF_ADD_SETMASK (0x00FFFF)
                             5601 ; 116  |#define HW_USBDMAOFF_MEM_SETMASK (3<<HW_USBDMAOFF_MEM_BITPOS)
                             5602 ; 117  |
                             5603 ; 118  |#define HW_USBDMAOFF_ADD_CLRMASK (~(WORD)HW_USBDMAOFF_ADD_SETMASK)
                             5604 ; 119  |#define HW_USBDMAOFF_MEM_CLRMASK (~(WORD)HW_USBDMAOFF_MEM_SETMASK)
                             5605 ; 120  |
                             5606 ; 121  |typedef union               
                             5607 ; 122  |{
                             5608 ; 123  |    struct {
                             5609 ; 124  |        int ADD            :16;
                             5610 ; 125  |        int MEM            :2;
                             5611 ; 126  |        int                :6;
                             5612 ; 127  |    } B;
                             5613 ; 128  |    int I;
                             5614 ; 129  |} usbdmaoff_type;
                             5615 ; 130  |#define HW_USBDMAOFF      (*(volatile usbdmaoff_type _X*) (HW_USB_BASEADDR+1))    
                             5616 ; 131  |
                             5617 ; 132  |/////////////////////////////////////////////////////////////////////////////////
                             5618 ; 133  |//  USB ARC ACCESS register (HW_USBARCACCESS) Bit Definitions
                             5619 ; 134  |#define HW_USBARCACCESS_RWB_BITPOS (16)
                             5620 ; 135  |#define HW_USBARCACCESS_KICK_BITPOS (23)
                             5621 ; 136  |
                             5622 ; 137  |#define HW_USBARCACCESS_ADD_SETMASK (0x0001FF)
                             5623 ; 138  |#define HW_USBARCACCESS_RWB_SETMASK (1<<HW_USBARCACCESS_RWB_BITPOS)
                             5624 ; 139  |#define HW_USBARCACCESS_KICK_SETMASK (23<<HW_USBDMAOFF_MEM_BITPOS)
                             5625 ; 140  |
                             5626 ; 141  |#define HW_USBARCACCESS_ADD_CLRMASK (~(WORD)HW_USBARCACCESS_ADD_SETMASK)
                             5627 ; 142  |#define HW_USBARCACCESS_RWB_CLRMASK (~(WORD)HW_USBARCACCESS_RWB_SETMASK) 
                             5628 ; 143  |#define HW_USBARCACCESS_KICK_CLRMASK (~(WORD)HW_USBARCACCESS_KICK_SETMASK)
                             5629 ; 144  |
                             5630 ; 145  |typedef union               
                             5631 ; 146  |{
                             5632 ; 147  |    struct {
                             5633 ; 148  |        int ADD            :9;
                             5634 ; 149  |        int                :7;
                             5635 ; 150  |        int RWB            :1;
                             5636 ; 151  |        int                :14;
                             5637 ; 152  |        int KICK           :1;
                             5638 ; 153  |    } B;
                             5639 ; 154  |    int I;
                             5640 ; 155  |} usbarcaccess_type;
                             5641 ; 156  |#define HW_USBARCACCESS      (*(volatile usbarcaccess_type _X*) (HW_USB_BASEADDR+2))    
                             5642 ; 157  |
                             5643 ; 158  |/////////////////////////////////////////////////////////////////////////////////
                             5644 ; 159  |//  USB ARC DATA LOW register (HW_USBARCDATALOW) Bit Definitions
                             5645 ; 160  |#define HW_USBARCDATALOW_DATA_SETMASK (0x00FFFF)
                             5646 ; 161  |
                             5647 ; 162  |#define HW_USBARCDATALOW_ADD_CLRMASK (~(WORD)HW_USBARCDATALOW_DATA_SETMASK)
                             5648 ; 163  |
                             5649 ; 164  |typedef union               
                             5650 ; 165  |{
                             5651 ; 166  |    struct {
                             5652 ; 167  |        int DATA           :16;
                             5653 ; 168  |        int                :8;
                             5654 ; 169  |    } B;
                             5655 ; 170  |    int I;
                             5656 ; 171  |} usbarcdatalow_type;
                             5657 ; 172  |#define HW_USBARCDATALOW      (*(volatile usbarcdatalow_type _X*) (HW_USB_BASEADDR+3))    
                             5658 ; 173  |
                             5659 ; 174  |/////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  23

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5660 ; 175  |//  USB ARC DATA HIGH register (HW_USBARCDATAHIGH) Bit Definitions
                             5661 ; 176  |#define HW_USBARCDATAHIGH_DATA_SETMASK (0x00FFFF)
                             5662 ; 177  |
                             5663 ; 178  |#define HW_USBARCDATAHIGH_ADD_CLRMASK (~(WORD)HW_USBARCDATAHIGH_DATA_SETMASK)
                             5664 ; 179  |
                             5665 ; 180  |typedef union               
                             5666 ; 181  |{
                             5667 ; 182  |    struct {
                             5668 ; 183  |        int DATA           :16;
                             5669 ; 184  |        int                :8;
                             5670 ; 185  |    } B;
                             5671 ; 186  |    int I;
                             5672 ; 187  |} usbarcdatahigh_type;
                             5673 ; 188  |#define HW_USBARCDATAHIGH     (*(volatile usbarcdatahigh_type _X*) (HW_USB_BASEADDR+4))    
                             5674 ; 189  |
                             5675 ; 190  |
                             5676 ; 191  |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             5677 ; 192  |//   USB2.0 ARC Registers 
                             5678 ; 193  |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             5679 ; 194  |#define HW_ARC_BASE_ADDR (0x0000)
                             5680 ; 195  |
                             5681 ; 196  |#define HW_ARC_HCSPARAMS (HW_ARC_BASE_ADDR+0x104)
                             5682 ; 197  |#define HW_ARC_USBCMD (HW_ARC_BASE_ADDR+0x140)
                             5683 ; 198  |#define HW_ARC_USBSTS (HW_ARC_BASE_ADDR+0x144)
                             5684 ; 199  |#define HW_ARC_USBINTR (HW_ARC_BASE_ADDR+0x148)
                             5685 ; 200  |#define HW_ARC_DEVADDR (HW_ARC_BASE_ADDR+0x154)
                             5686 ; 201  |#define HW_ARC_ENDPTLISTADDR (HW_ARC_BASE_ADDR+0x158)
                             5687 ; 202  |#define HW_ARC_PORTSC1 (HW_ARC_BASE_ADDR+0x184)
                             5688 ; 203  |#define HW_ARC_USBMODE (HW_ARC_BASE_ADDR+0x1a8)
                             5689 ; 204  |#define HW_ARC_ENDPTSETUPSTAT (HW_ARC_BASE_ADDR+0x1ac)
                             5690 ; 205  |#define HW_ARC_ENDPTPRIME (HW_ARC_BASE_ADDR+0x1b0)
                             5691 ; 206  |#define HW_ARC_ENDPTFLUSH (HW_ARC_BASE_ADDR+0x1b4)
                             5692 ; 207  |#define HW_ARC_ENDPTSTATUS (HW_ARC_BASE_ADDR+0x1b8)
                             5693 ; 208  |#define HW_ARC_ENDPTCOMPLETE (HW_ARC_BASE_ADDR+0x1bc)
                             5694 ; 209  |#define HW_ARC_ENDPTCTRL0 (HW_ARC_BASE_ADDR+0x1c0)
                             5695 ; 210  |#define HW_ARC_ENDPTCTRL1 (HW_ARC_BASE_ADDR+0x1c4)
                             5696 ; 211  |#define HW_ARC_ENDPTCTRL2 (HW_ARC_BASE_ADDR+0x1c8)
                             5697 ; 212  |#define HW_ARC_ENDPTCTRL3 (HW_ARC_BASE_ADDR+0x1cc)
                             5698 ; 213  |#define HW_ARC_ENDPTCTRL4 (HW_ARC_BASE_ADDR+0x1d0)
                             5699 ; 214  |#define HW_ARC_ENDPTCTRL5 (HW_ARC_BASE_ADDR+0x1d4)
                             5700 ; 215  |#define HW_ARC_ENDPTCTRL6 (HW_ARC_BASE_ADDR+0x1d8)
                             5701 ; 216  |#define HW_ARC_ENDPTCTRL7 (HW_ARC_BASE_ADDR+0x1dc)
                             5702 ; 217  |#define HW_ARC_ENDPTCTRL8 (HW_ARC_BASE_ADDR+0x1e0)
                             5703 ; 218  |#define HW_ARC_ENDPTCTRL9 (HW_ARC_BASE_ADDR+0x1e4)
                             5704 ; 219  |#define HW_ARC_ENDPTCTRL10 (HW_ARC_BASE_ADDR+0x1e8)
                             5705 ; 220  |#define HW_ARC_ENDPTCTRL11 (HW_ARC_BASE_ADDR+0x1ec)
                             5706 ; 221  |#define HW_ARC_ENDPTCTRL12 (HW_ARC_BASE_ADDR+0x1f0)
                             5707 ; 222  |#define HW_ARC_ENDPTCTRL13 (HW_ARC_BASE_ADDR+0x1f4)
                             5708 ; 223  |#define HW_ARC_ENDPTCTRL14 (HW_ARC_BASE_ADDR+0x1f8)
                             5709 ; 224  |#define HW_ARC_ENDPTCTRL15 (HW_ARC_BASE_ADDR+0x1fc)
                             5710 ; 225  |
                             5711 ; 226  |#define HW_ARC_ENDPTCTRL(n) (HW_ARC_ENDPTCTRL0+((n)*4))    
                             5712 ; 227  |/////////////////////////////////////////////////////////////////////////////////
                             5713 ; 228  |//  USB ARC Register Host Control Structural Parameters (HW_ARC_HCSPARAMS)
                             5714 ; 229  |
                             5715 ; 230  |#define HW_ARC_HCSPARAMS_NPORTS_BITPOS (0)
                             5716 ; 231  |#define HW_ARC_HCSPARAMS_PPC_BITPOS (4)
                             5717 ; 232  |#define HW_ARC_HCSPARAMS_NPCC_BITPOS (8)
                             5718 ; 233  |#define HW_ARC_HCSPARAMS_NCC_BITPOS (12)
                             5719 ; 234  |#define HW_ARC_HCSPARAMS_PI_BITPOS (16)
                             5720 ; 235  |#define HW_ARC_HCSPARAMS_NPTT_BITPOS (20)
                             5721 ; 236  |#define HW_ARC_HCSPARAMS_NTT_BITPOS (24)
                             5722 ; 237  |
                             5723 ; 238  |#define HW_ARC_HCSPARAMS_NPORTS_SETMASK (15<<HW_ARC_HCSPARAMS_NPORTS_BITPOS)
                             5724 ; 239  |#define HW_ARC_HCSPARAMS_PPC_SETMASK (1<<HW_ARC_HCSPARAMS_PPC_BITPOS)        
                             5725 ; 240  |#define HW_ARC_HCSPARAMS_NPCC_SETMASK (15<<HW_ARC_HCSPARAMS_NPCC_BITPOS)  
                             5726 ; 241  |#define HW_ARC_HCSPARAMS_NCC_SETMASK (15<<HW_ARC_HCSPARAMS_NCC_BITPOS)       
                             5727 ; 242  |#define HW_ARC_HCSPARAMS_PI_SETMASK (1<<HW_ARC_HCSPARAMS_PI_BITPOS)     
                             5728 ; 243  |#define HW_ARC_HCSPARAMS_NPTT_SETMASK (15<<HW_ARC_HCSPARAMS_NPTT_BITPOS)  
                             5729 ; 244  |#define HW_ARC_HCSPARAMS_NTT_SETMASK (15<<HW_ARC_HCSPARAMS_NTT_BITPOS)       
                             5730 ; 245  |
                             5731 ; 246  |#define HW_ARC_HCSPARAMS_NPORTS_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NPORTS_SETMASK)
                             5732 ; 247  |#define HW_ARC_HCSPARAMS_PPC_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_PPC_SETMASK)
                             5733 ; 248  |#define HW_ARC_HCSPARAMS_NPCC_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NPCC_SETMASK)
                             5734 ; 249  |#define HW_ARC_HCSPARAMS_NCC_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NCC_SETMASK)
                             5735 ; 250  |#define HW_ARC_HCSPARAMS_PI_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_PI_SETMASK)  
                             5736 ; 251  |#define HW_ARC_HCSPARAMS_NPTT_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NPTT_SETMASK)
                             5737 ; 252  |#define HW_ARC_HCSPARAMS_NTT_CLRMASK (~(WORD)HW_ARC_HCSPARAMS_NTT_SETMASK)
                             5738 ; 253  |
                             5739 ; 254  |typedef union               
                             5740 ; 255  |{
                             5741 ; 256  |    struct {
                             5742 ; 257  |        int N_PORTS         :4;
                             5743 ; 258  |        int PPC             :1;
                             5744 ; 259  |        int                 :3;
                             5745 ; 260  |        int N_PCC           :4;
                             5746 ; 261  |        int N_CC            :4;
                             5747 ; 262  |        int PI              :1;
                             5748 ; 263  |        int                 :3;
                             5749 ; 264  |        int N_PTT           :4;
                             5750 ; 265  |        int N_TT            :4;
                             5751 ; 266  |        int                 :20;
                             5752 ; 267  |    } B;
                             5753 ; 268  |    DWORD I;
                             5754 ; 269  |} hcsparams_type;
                             5755 ; 270  |// #define HW_ARC_HCSPARAMS (*(volatile hcsparams_type _X*) (HW_ARC_BASEADDR))    
                             5756 ; 271  |
                             5757 ; 272  |/////////////////////////////////////////////////////////////////////////////////
                             5758 ; 273  |//  USB ARC Register USB Command (HW_ARC_USBCMD)
                             5759 ; 274  |
                             5760 ; 275  |#define HW_ARC_USBCMD_RS_BITPOS (0)
                             5761 ; 276  |#define HW_ARC_USBCMD_RST_BITPOS (1)
                             5762 ; 277  |#define HW_ARC_USBCMD_FS0_BITPOS (2)
                             5763 ; 278  |#define HW_ARC_USBCMD_FS1_BITPOS (3)
                             5764 ; 279  |#define HW_ARC_USBCMD_PSE_BITPOS (4)
                             5765 ; 280  |#define HW_ARC_USBCMD_ASE_BITPOS (5)
                             5766 ; 281  |#define HW_ARC_USBCMD_IAA_BITPOS (6)
                             5767 ; 282  |#define HW_ARC_USBCMD_LR_BITPOS (7)
                             5768 ; 283  |#define HW_ARC_USBCMD_ASP0_BITPOS (8)
                             5769 ; 284  |#define HW_ARC_USBCMD_ASP1_BITPOS (9)
                             5770 ; 285  |#define HW_ARC_USBCMD_ASPE_BITPOS (11)
                             5771 ; 286  |#define HW_ARC_USBCMD_FS2_BITPOS (15)
                             5772 ; 287  |#define HW_ARC_USBCMD_ITC_BITPOS (16)
                             5773 ; 288  |
                             5774 ; 289  |#define HW_ARC_USBCMD_RS_SETMASK (1<<HW_ARC_USBCMD_RS_BITPOS)                
                             5775 ; 290  |#define HW_ARC_USBCMD_RST_SETMASK (1<<HW_ARC_USBCMD_RST_BITPOS)   
                             5776 ; 291  |#define HW_ARC_USBCMD_FS0_SETMASK (1<<HW_ARC_USBCMD_FS0_BITPOS)   
                             5777 ; 292  |#define HW_ARC_USBCMD_FS1_SETMASK (1<<HW_ARC_USBCMD_FS1_BITPOS)   
                             5778 ; 293  |#define HW_ARC_USBCMD_PSE_SETMASK (1<<HW_ARC_USBCMD_PSE_BITPOS)   
                             5779 ; 294  |#define HW_ARC_USBCMD_ASE_SETMASK (1<<HW_ARC_USBCMD_ASE_BITPOS)   
                             5780 ; 295  |#define HW_ARC_USBCMD_IAA_SETMASK (1<<HW_ARC_USBCMD_IAA_BITPOS)   
                             5781 ; 296  |#define HW_ARC_USBCMD_LR_SETMASK (1<<HW_ARC_USBCMD_LR_BITPOS)        
                             5782 ; 297  |#define HW_ARC_USBCMD_ASP0_SETMASK (1<<HW_ARC_USBCMD_ASP0_BITPOS)
                             5783 ; 298  |#define HW_ARC_USBCMD_ASP1_SETMASK (1<<HW_ARC_USBCMD_ASP1_BITPOS)
                             5784 ; 299  |#define HW_ARC_USBCMD_ASPE_SETMASK (1<<HW_ARC_USBCMD_ASPE_BITPOS)
                             5785 ; 300  |#define HW_ARC_USBCMD_FS2_SETMASK (1<<HW_ARC_USBCMD_FS2_BITPOS)    
                             5786 ; 301  |#define HW_ARC_USBCMD_ITC_SETMASK (255<<HW_ARC_USBCMD_ITC_BITPOS)
                             5787 ; 302  |
                             5788 ; 303  |#define HW_ARC_USBCMD_RS_CLRMASK (~(WORD)HW_ARC_USBCMD_RS_SETMASK)     
                             5789 ; 304  |#define HW_ARC_USBCMD_RST_CLRMASK (~(WORD)HW_ARC_USBCMD_RST_SETMASK)    
                             5790 ; 305  |#define HW_ARC_USBCMD_FS0_CLRMASK (~(WORD)HW_ARC_USBCMD_FS0_SETMASK)    
                             5791 ; 306  |#define HW_ARC_USBCMD_FS1_CLRMASK (~(WORD)HW_ARC_USBCMD_FS1_SETMASK)    
                             5792 ; 307  |#define HW_ARC_USBCMD_PSE_CLRMASK (~(WORD)HW_ARC_USBCMD_PSE_SETMASK)    
                             5793 ; 308  |#define HW_ARC_USBCMD_ASE_CLRMASK (~(WORD)HW_ARC_USBCMD_ASE_SETMASK)    
                             5794 ; 309  |#define HW_ARC_USBCMD_IAA_CLRMASK (~(WORD)HW_ARC_USBCMD_IAA_SETMASK)    
                             5795 ; 310  |#define HW_ARC_USBCMD_LR_CLRMASK (~(WORD)HW_ARC_USBCMD_LR_SETMASK) 
                             5796 ; 311  |#define HW_ARC_USBCMD_ASP0_CLRMASK (~(WORD)HW_ARC_USBCMD_ASP0_SETMASK)
                             5797 ; 312  |#define HW_ARC_USBCMD_ASP1_CLRMASK (~(WORD)HW_ARC_USBCMD_ASP1_SETMASK)
                             5798 ; 313  |#define HW_ARC_USBCMD_ASPE_CLRMASK (~(WORD)HW_ARC_USBCMD_ASPE_SETMASK)
                             5799 ; 314  |#define HW_ARC_USBCMD_FS2_CLRMASK (~(WORD)HW_ARC_USBCMD_FS2_SETMASK)    
                             5800 ; 315  |#define HW_ARC_USBCMD_ITC_CLRMASK (~(WORD)HW_ARC_USBCMD_ITC_SETMASK)    
                             5801 ; 316  |
                             5802 ; 317  |typedef union               
                             5803 ; 318  |{
                             5804 ; 319  |    struct {
                             5805 ; 320  |        int RS              :1;
                             5806 ; 321  |        int RST             :1;
                             5807 ; 322  |        int FS0             :1;
                             5808 ; 323  |        int FS1             :1;
                             5809 ; 324  |        int PSE             :1;
                             5810 ; 325  |        int ASE             :1;
                             5811 ; 326  |        int IAA             :1;
                             5812 ; 327  |        int LR              :1;
                             5813 ; 328  |        int ASP0            :1;
                             5814 ; 329  |        int ASP1            :1;
                             5815 ; 330  |        int                 :1;
                             5816 ; 331  |        int ASPE            :1;
                             5817 ; 332  |        int                 :3;
                             5818 ; 333  |        int FS2             :1;
                             5819 ; 334  |        int ITC             :8;
                             5820 ; 335  |        int                 :24;
                             5821 ; 336  |    } B;
                             5822 ; 337  |    DWORD I;
                             5823 ; 338  |} usbcmd_type;
                             5824 ; 339  |//#define HW_ARC_USBCMD ((volatile usbcmd_type _X*) (HW_ARC_BASEADDR+0x140))    
                             5825 ; 340  |
                             5826 ; 341  |/////////////////////////////////////////////////////////////////////////////////
                             5827 ; 342  |//  USB ARC Register USB Status (HW_ARC_USBSTS)
                             5828 ; 343  |
                             5829 ; 344  |#define HW_ARC_USBSTS_UI_BITPOS (0)
                             5830 ; 345  |#define HW_ARC_USBSTS_UEI_BITPOS (1)
                             5831 ; 346  |#define HW_ARC_USBSTS_PCI_BITPOS (2)
                             5832 ; 347  |#define HW_ARC_USBSTS_FRI_BITPOS (3)
                             5833 ; 348  |#define HW_ARC_USBSTS_SEI_BITPOS (4)
                             5834 ; 349  |#define HW_ARC_USBSTS_AAI_BITPOS (5)
                             5835 ; 350  |#define HW_ARC_USBSTS_URI_BITPOS (6)
                             5836 ; 351  |#define HW_ARC_USBSTS_SRI_BITPOS (7)
                             5837 ; 352  |#define HW_ARC_USBSTS_SLI_BITPOS (8)
                             5838 ; 353  |#define HW_ARC_USBSTS_HCH_BITPOS (12)
                             5839 ; 354  |#define HW_ARC_USBSTS_RCL_BITPOS (13)
                             5840 ; 355  |#define HW_ARC_USBSTS_PS_BITPOS (14)
                             5841 ; 356  |#define HW_ARC_USBSTS_AS_BITPOS (15)
                             5842 ; 357  |
                             5843 ; 358  |#define HW_ARC_USBSTS_UI_SETMASK (1<<HW_ARC_USBSTS_UI_BITPOS)    
                             5844 ; 359  |#define HW_ARC_USBSTS_UEI_SETMASK (1<<HW_ARC_USBSTS_UEI_BITPOS)
                             5845 ; 360  |#define HW_ARC_USBSTS_PCI_SETMASK (1<<HW_ARC_USBSTS_PCI_BITPOS)
                             5846 ; 361  |#define HW_ARC_USBSTS_FRI_SETMASK (1<<HW_ARC_USBSTS_FRI_BITPOS)
                             5847 ; 362  |#define HW_ARC_USBSTS_SEI_SETMASK (1<<HW_ARC_USBSTS_SEI_BITPOS)
                             5848 ; 363  |#define HW_ARC_USBSTS_AAI_SETMASK (1<<HW_ARC_USBSTS_AAI_BITPOS)
                             5849 ; 364  |#define HW_ARC_USBSTS_URI_SETMASK (1<<HW_ARC_USBSTS_URI_BITPOS)
                             5850 ; 365  |#define HW_ARC_USBSTS_SRI_SETMASK (1<<HW_ARC_USBSTS_SRI_BITPOS)
                             5851 ; 366  |#define HW_ARC_USBSTS_SLI_SETMASK (1<<HW_ARC_USBSTS_SLI_BITPOS)
                             5852 ; 367  |#define HW_ARC_USBSTS_HCH_SETMASK (1<<HW_ARC_USBSTS_HCH_BITPOS)
                             5853 ; 368  |#define HW_ARC_USBSTS_RCL_SETMASK (1<<HW_ARC_USBSTS_RCL_BITPOS)
                             5854 ; 369  |#define HW_ARC_USBSTS_PS_SETMASK (1<<HW_ARC_USBSTS_PS_BITPOS)    
                             5855 ; 370  |#define HW_ARC_USBSTS_AS_SETMASK (1<<HW_ARC_USBSTS_AS_BITPOS)    
                             5856 ; 371  |
                             5857 ; 372  |#define HW_ARC_USBSTS_UI_CLRMASK (~(WORD)HW_ARC_USBSTS_UI_SETMASK)
                             5858 ; 373  |#define HW_ARC_USBSTS_UEI_CLRMASK (~(WORD)HW_ARC_USBSTS_UEI_SETMASK)
                             5859 ; 374  |#define HW_ARC_USBSTS_PCI_CLRMASK (~(WORD)HW_ARC_USBSTS_PCI_SETMASK)
                             5860 ; 375  |#define HW_ARC_USBSTS_FRI_CLRMASK (~(WORD)HW_ARC_USBSTS_FRI_SETMASK)
                             5861 ; 376  |#define HW_ARC_USBSTS_SEI_CLRMASK (~(WORD)HW_ARC_USBSTS_SEI_SETMASK)
                             5862 ; 377  |#define HW_ARC_USBSTS_AAI_CLRMASK (~(WORD)HW_ARC_USBSTS_AAI_SETMASK)
                             5863 ; 378  |#define HW_ARC_USBSTS_URI_CLRMASK (~(WORD)HW_ARC_USBSTS_URI_SETMASK)
                             5864 ; 379  |#define HW_ARC_USBSTS_SRI_CLRMASK (~(WORD)HW_ARC_USBSTS_SRI_SETMASK)
                             5865 ; 380  |#define HW_ARC_USBSTS_SLI_CLRMASK (~(WORD)HW_ARC_USBSTS_SLI_SETMASK)
                             5866 ; 381  |#define HW_ARC_USBSTS_HCH_CLRMASK (~(WORD)HW_ARC_USBSTS_HCH_SETMASK)
                             5867 ; 382  |#define HW_ARC_USBSTS_RCL_CLRMASK (~(WORD)HW_ARC_USBSTS_RCL_SETMASK)
                             5868 ; 383  |#define HW_ARC_USBSTS_PS_CLRMASK (~(WORD)HW_ARC_USBSTS_PS_SETMASK)
                             5869 ; 384  |#define HW_ARC_USBSTS_AS_CLRMASK (~(WORD)HW_ARC_USBSTS_AS_SETMASK)
                             5870 ; 385  |
                             5871 ; 386  |
                             5872 ; 387  |typedef union               
                             5873 ; 388  |{
                             5874 ; 389  |    struct {
                             5875 ; 390  |        int UI              :1;
                             5876 ; 391  |        int UEI             :1;
                             5877 ; 392  |        int PCI             :1;
                             5878 ; 393  |        int FRI             :1;
                             5879 ; 394  |        int SEI             :1;
                             5880 ; 395  |        int AAI             :1;
                             5881 ; 396  |        int URI             :1;
                             5882 ; 397  |        int STI             :1;
                             5883 ; 398  |        int SLI             :1;
                             5884 ; 399  |        int                 :3;
                             5885 ; 400  |        int HCH             :1;
                             5886 ; 401  |        int RCL             :1;
                             5887 ; 402  |        int PS              :1;
                             5888 ; 403  |        int AS              :1;
                             5889 ; 404  |        int                 :24;
                             5890 ; 405  |    } B;
                             5891 ; 406  |    DWORD I;
                             5892 ; 407  |} usbsts_type;
                             5893 ; 408  |//#define HW_ARC_USBSTS (*(volatile usbsts_type _X*) (HW_ARC_BASEADDR+0x144))    
                             5894 ; 409  |
                             5895 ; 410  |/////////////////////////////////////////////////////////////////////////////////
                             5896 ; 411  |//  USB ARC Register USB Interrupt Enable (HW_ARC_USBINTR)
                             5897 ; 412  |
                             5898 ; 413  |#define HW_ARC_USBINTR_UE_BITPOS (0)
                             5899 ; 414  |#define HW_ARC_USBINTR_UEE_BITPOS (1)
                             5900 ; 415  |#define HW_ARC_USBINTR_PCE_BITPOS (2)
                             5901 ; 416  |#define HW_ARC_USBINTR_FRE_BITPOS (3)
                             5902 ; 417  |#define HW_ARC_USBINTR_SEE_BITPOS (4)
                             5903 ; 418  |#define HW_ARC_USBINTR_AAE_BITPOS (5)
                             5904 ; 419  |#define HW_ARC_USBINTR_URE_BITPOS (6)
                             5905 ; 420  |#define HW_ARC_USBINTR_SRE_BITPOS (7)
                             5906 ; 421  |#define HW_ARC_USBINTR_SLE_BITPOS (8)
                             5907 ; 422  |
                             5908 ; 423  |#define HW_ARC_USBINTR_UE_SETMASK (1<<HW_ARC_USBINTR_UE_BITPOS)   
                             5909 ; 424  |#define HW_ARC_USBINTR_UEE_SETMASK (1<<HW_ARC_USBINTR_UEE_BITPOS)
                             5910 ; 425  |#define HW_ARC_USBINTR_PCE_SETMASK (1<<HW_ARC_USBINTR_PCE_BITPOS)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  24

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5911 ; 426  |#define HW_ARC_USBINTR_FRE_SETMASK (1<<HW_ARC_USBINTR_FRE_BITPOS)
                             5912 ; 427  |#define HW_ARC_USBINTR_SEE_SETMASK (1<<HW_ARC_USBINTR_SEE_BITPOS)
                             5913 ; 428  |#define HW_ARC_USBINTR_AAE_SETMASK (1<<HW_ARC_USBINTR_AAE_BITPOS)
                             5914 ; 429  |#define HW_ARC_USBINTR_URE_SETMASK (1<<HW_ARC_USBINTR_URE_BITPOS)
                             5915 ; 430  |#define HW_ARC_USBINTR_SRE_SETMASK (1<<HW_ARC_USBINTR_SRE_BITPOS)
                             5916 ; 431  |#define HW_ARC_USBINTR_SLE_SETMASK (1<<HW_ARC_USBINTR_SLE_BITPOS)
                             5917 ; 432  |
                             5918 ; 433  |#define HW_ARC_USBINTR_UE_CLRMASK (~(WORD)HW_ARC_USBINTR_UE_SETMASK)
                             5919 ; 434  |#define HW_ARC_USBINTR_UEE_CLRMASK (~(WORD)HW_ARC_USBINTR_UEE_SETMASK)
                             5920 ; 435  |#define HW_ARC_USBINTR_PCE_CLRMASK (~(WORD)HW_ARC_USBINTR_PCE_SETMASK)
                             5921 ; 436  |#define HW_ARC_USBINTR_FRE_CLRMASK (~(WORD)HW_ARC_USBINTR_FRE_SETMASK)
                             5922 ; 437  |#define HW_ARC_USBINTR_SEE_CLRMASK (~(WORD)HW_ARC_USBINTR_SEE_SETMASK)
                             5923 ; 438  |#define HW_ARC_USBINTR_AAE_CLRMASK (~(WORD)HW_ARC_USBINTR_AAE_SETMASK)
                             5924 ; 439  |#define HW_ARC_USBINTR_URE_CLRMASK (~(WORD)HW_ARC_USBINTR_URE_SETMASK)
                             5925 ; 440  |#define HW_ARC_USBINTR_SRE_CLRMASK (~(WORD)HW_ARC_USBINTR_SRE_SETMASK)
                             5926 ; 441  |#define HW_ARC_USBINTR_SLE_CLRMASK (~(WORD)HW_ARC_USBINTR_SLE_SETMASK)
                             5927 ; 442  |
                             5928 ; 443  |
                             5929 ; 444  |typedef union               
                             5930 ; 445  |{
                             5931 ; 446  |    struct {
                             5932 ; 447  |        int UE              :1;
                             5933 ; 448  |        int UEE             :1;
                             5934 ; 449  |        int PCE             :1;
                             5935 ; 450  |        int FRE             :1;
                             5936 ; 451  |        int SEE             :1;
                             5937 ; 452  |        int AAE             :1;
                             5938 ; 453  |        int URE             :1;
                             5939 ; 454  |        int STE             :1;
                             5940 ; 455  |        int SLE             :1;
                             5941 ; 456  |        int                 :39;
                             5942 ; 457  |    } B;
                             5943 ; 458  |    DWORD I;
                             5944 ; 459  |} usbintr_type;
                             5945 ; 460  |//#define HW_ARC_USBINTR (*(volatile usbintr_type _X*) (HW_ARC_BASEADDR+0x148))    
                             5946 ; 461  |
                             5947 ; 462  |
                             5948 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             5949 ; 464  |//  USB ARC Register USB Device Controller Device Address (HW_ARC_DEVADDR)
                             5950 ; 465  |
                             5951 ; 466  |#define HW_ARC_DEVADDR_ADD_BITPOS (25)
                             5952 ; 467  |
                             5953 ; 468  |#define HW_ARC_DEVADDR_ADD_SETMASK (127<<HW_ARC_DEVADDR_ADD_BITPOS)    
                             5954 ; 469  |
                             5955 ; 470  |#define HW_ARC_DEVEADDR_ADD_CLRMASK (~(WORD)HW_ARC_DEVADDR_ADD_SETMASK)   
                             5956 ; 471  |
                             5957 ; 472  |typedef union               
                             5958 ; 473  |{
                             5959 ; 474  |    struct {
                             5960 ; 475  |        int                 :25;
                             5961 ; 476  |        int ADD             :7;
                             5962 ; 477  |        int                 :16;
                             5963 ; 478  |    } B;
                             5964 ; 479  |    DWORD I;
                             5965 ; 480  |} devaddr_type;
                             5966 ; 481  |//#define HW_ARC_DEVADDR (*(volatile devaddr_type _X*) (HW_ARC_BASEADDR+0x154))    
                             5967 ; 482  |
                             5968 ; 483  |
                             5969 ; 484  |/////////////////////////////////////////////////////////////////////////////////
                             5970 ; 485  |//  USB ARC Register USB Device Controller Endpoint List Address (HW_ARC_ENDPTLISTADDR)
                             5971 ; 486  |
                             5972 ; 487  |#define HW_ARC_ENDPTLISTADDR_ADD_BITPOS (11)
                             5973 ; 488  |
                             5974 ; 489  |#define HW_ARC_ENDPTLISTADDR_ADD_SETMASK (0x400000<<HW_ARC_ENDPTLISTADDR_ADD_BITPOS) 
                             5975 ; 490  |
                             5976 ; 491  |#define HW_ARC_ENDPTLISTADDR_ADD_CLRMASK (~(WORD)HW_ARC_ENDPTLISTADDR_ADD_SETMASK) 
                             5977 ; 492  |
                             5978 ; 493  |typedef union               
                             5979 ; 494  |{
                             5980 ; 495  |    struct {
                             5981 ; 496  |        int                 :10;
                             5982 ; 497  |        int ADD             :22;
                             5983 ; 498  |        int                 :16;
                             5984 ; 499  |    } B;
                             5985 ; 500  |    DWORD I;
                             5986 ; 501  |} endptlistaddr_type;
                             5987 ; 502  |//#define HW_ARC_ENDPTLISTADDR (*(volatile endptlistaddr_type _X*) (HW_ARC_BASEADDR+0x158))    
                             5988 ; 503  |
                             5989 ; 504  |
                             5990 ; 505  |/////////////////////////////////////////////////////////////////////////////////
                             5991 ; 506  |//  USB ARC Register USB Port Status Control 1 (HW_ARC_PORTSC1)
                             5992 ; 507  |
                             5993 ; 508  |#define HW_ARC_PORTSC1_CCS_BITPOS (0)
                             5994 ; 509  |#define HW_ARC_PORTSC1_CSC_BITPOS (1)
                             5995 ; 510  |#define HW_ARC_PORTSC1_PE_BITPOS (2)
                             5996 ; 511  |#define HW_ARC_PORTSC1_PEC_BITPOS (3)
                             5997 ; 512  |#define HW_ARC_PORTSC1_OCA_BITPOS (4)
                             5998 ; 513  |#define HW_ARC_PORTSC1_OCC_BITPOS (5)
                             5999 ; 514  |#define HW_ARC_PORTSC1_FPR_BITPOS (6)
                             6000 ; 515  |#define HW_ARC_PORTSC1_SUSP_BITPOS (7)
                             6001 ; 516  |#define HW_ARC_PORTSC1_PR_BITPOS (8)
                             6002 ; 517  |#define HW_ARC_PORTSC1_HSP_BITPOS (9)
                             6003 ; 518  |#define HW_ARC_PORTSC1_LS_BITPOS (10)
                             6004 ; 519  |#define HW_ARC_PORTSC1_PP_BITPOS (12)
                             6005 ; 520  |#define HW_ARC_PORTSC1_PO_BITPOS (13)
                             6006 ; 521  |#define HW_ARC_PORTSC1_PIC_BITPOS (14)
                             6007 ; 522  |#define HW_ARC_PORTSC1_PTC_BITPOS (16)
                             6008 ; 523  |#define HW_ARC_PORTSC1_WKCN_BITPOS (20)
                             6009 ; 524  |#define HW_ARC_PORTSC1_WKDS_BITPOS (21)
                             6010 ; 525  |#define HW_ARC_PORTSC1_WKOC_BITPOS (22)
                             6011 ; 526  |#define HW_ARC_PORTSC1_PHCD_BITPOS (23)
                             6012 ; 527  |#define HW_ARC_PORTSC1_PFSC_BITPOS (24)
                             6013 ; 528  |#define HW_ARC_PORTSC1_PSPD_BITPOS (26)
                             6014 ; 529  |#define HW_ARC_PORTSC1_PTW_BITPOS (29)
                             6015 ; 530  |#define HW_ARC_PORTSC1_STS_BITPOS (30)
                             6016 ; 531  |#define HW_ARC_PORTSC1_PTS_BITPOS (31)
                             6017 ; 532  |
                             6018 ; 533  |#define HW_ARC_PORTSC1_CCS_SETMASK (1<<HW_ARC_PORTSC1_CCS_BITPOS)  
                             6019 ; 534  |#define HW_ARC_PORTSC1_CSC_SETMASK (1<<HW_ARC_PORTSC1_CSC_BITPOS)  
                             6020 ; 535  |#define HW_ARC_PORTSC1_PE_SETMASK (1<<HW_ARC_PORTSC1_PE_BITPOS)   
                             6021 ; 536  |#define HW_ARC_PORTSC1_PEC_SETMASK (1<<HW_ARC_PORTSC1_PEC_BITPOS)  
                             6022 ; 537  |#define HW_ARC_PORTSC1_OCA_SETMASK (1<<HW_ARC_PORTSC1_OCA_BITPOS)  
                             6023 ; 538  |#define HW_ARC_PORTSC1_OCC_SETMASK (1<<HW_ARC_PORTSC1_OCC_BITPOS)  
                             6024 ; 539  |#define HW_ARC_PORTSC1_FPR_SETMASK (1<<HW_ARC_PORTSC1_FPR_BITPOS)  
                             6025 ; 540  |#define HW_ARC_PORTSC1_SUSP_SETMASK (1<<HW_ARC_PORTSC1_SUSP_BITPOS)
                             6026 ; 541  |#define HW_ARC_PORTSC1_PR_SETMASK (1<<HW_ARC_PORTSC1_PR_BITPOS)   
                             6027 ; 542  |#define HW_ARC_PORTSC1_HSP_SETMASK (1<<HW_ARC_PORTSC1_HSP_BITPOS)  
                             6028 ; 543  |#define HW_ARC_PORTSC1_LS_SETMASK (3<<HW_ARC_PORTSC1_LS_BITPOS)   
                             6029 ; 544  |#define HW_ARC_PORTSC1_PP_SETMASK (1<<HW_ARC_PORTSC1_PP_BITPOS)   
                             6030 ; 545  |#define HW_ARC_PORTSC1_PO_SETMASK (1<<HW_ARC_PORTSC1_PO_BITPOS)   
                             6031 ; 546  |#define HW_ARC_PORTSC1_PIC_SETMASK (3<<HW_ARC_PORTSC1_PIC_BITPOS)  
                             6032 ; 547  |#define HW_ARC_PORTSC1_PTC_SETMASK (15<<HW_ARC_PORTSC1_PTC_BITPOS) 
                             6033 ; 548  |#define HW_ARC_PORTSC1_WKCN_SETMASK (1<<HW_ARC_PORTSC1_WKCN_BITPOS)
                             6034 ; 549  |#define HW_ARC_PORTSC1_WKDS_SETMASK (1<<HW_ARC_PORTSC1_WKDS_BITPOS)
                             6035 ; 550  |#define HW_ARC_PORTSC1_WKOC_SETMASK (1<<HW_ARC_PORTSC1_WKOC_BITPOS)
                             6036 ; 551  |#define HW_ARC_PORTSC1_PHCD_SETMASK (1<<HW_ARC_PORTSC1_PHCD_BITPOS)
                             6037 ; 552  |
                             6038 ; 553  |// We need to equate the following label like this due to a sign extension problem
                             6039 ; 554  |// if equated like so (1<<HW_ARC_PORTSC1_PFSC_SETMASK)
                             6040 ; 555  |#define HW_ARC_PORTSC1_PFSC_SETMASK (0x01000000)
                             6041 ; 556  |
                             6042 ; 557  |#define HW_ARC_PORTSC1_PSPD_SETMASK (3<<HW_ARC_PORTSC1_PSPD_BITPOS)
                             6043 ; 558  |#define HW_ARC_PORTSC1_PTW_SETMASK (1<<HW_ARC_PORTSC1_PTW_BITPOS)  
                             6044 ; 559  |#define HW_ARC_PORTSC1_STS_SETMASK (1<<HW_ARC_PORTSC1_STS_BITPOS)  
                             6045 ; 560  |#define HW_ARC_PORTSC1_PTS_SETMASK (1<<HW_ARC_PORTSC1_PTS_BITPOS)  
                             6046 ; 561  |
                             6047 ; 562  |#define HW_ARC_PORTSC1_CCS_CLRMASK (~(WORD)HW_ARC_PORTSC1_CCS_SETMASK)   
                             6048 ; 563  |#define HW_ARC_PORTSC1_CSC_CLRMASK (~(WORD)HW_ARC_PORTSC1_CSC_SETMASK)   
                             6049 ; 564  |#define HW_ARC_PORTSC1_PE_CLRMASK (~(WORD)HW_ARC_PORTSC1_PE_SETMASK)    
                             6050 ; 565  |#define HW_ARC_PORTSC1_PEC_CLRMASK (~(WORD)HW_ARC_PORTSC1_PEC_SETMASK)   
                             6051 ; 566  |#define HW_ARC_PORTSC1_OCA_CLRMASK (~(WORD)HW_ARC_PORTSC1_OCA_SETMASK)   
                             6052 ; 567  |#define HW_ARC_PORTSC1_OCC_CLRMASK (~(WORD)HW_ARC_PORTSC1_OCC_SETMASK)   
                             6053 ; 568  |#define HW_ARC_PORTSC1_FPR_CLRMASK (~(WORD)HW_ARC_PORTSC1_FPR_SETMASK)   
                             6054 ; 569  |#define HW_ARC_PORTSC1_SUSP_CLRMASK (~(WORD)HW_ARC_PORTSC1_SUSP_SETMASK)
                             6055 ; 570  |#define HW_ARC_PORTSC1_PR_CLRMASK (~(WORD)HW_ARC_PORTSC1_PR_SETMASK)    
                             6056 ; 571  |#define HW_ARC_PORTSC1_HSP_CLRMASK (~(WORD)HW_ARC_PORTSC1_HSP_SETMASK)   
                             6057 ; 572  |#define HW_ARC_PORTSC1_LS_CLRMASK (~(WORD)HW_ARC_PORTSC1_LS_SETMASK)    
                             6058 ; 573  |#define HW_ARC_PORTSC1_PP_CLRMASK (~(WORD)HW_ARC_PORTSC1_PP_SETMASK)    
                             6059 ; 574  |#define HW_ARC_PORTSC1_PO_CLRMASK (~(WORD)HW_ARC_PORTSC1_PO_SETMASK)    
                             6060 ; 575  |#define HW_ARC_PORTSC1_PIC_CLRMASK (~(WORD)HW_ARC_PORTSC1_PIC_SETMASK)   
                             6061 ; 576  |#define HW_ARC_PORTSC1_PTC_CLRMASK (~(WORD)HW_ARC_PORTSC1_PTC_SETMASK)   
                             6062 ; 577  |#define HW_ARC_PORTSC1_WKCN_CLRMASK (~(WORD)HW_ARC_PORTSC1_WKCN_SETMASK)
                             6063 ; 578  |#define HW_ARC_PORTSC1_WKDS_CLRMASK (~(WORD)HW_ARC_PORTSC1_WKDS_SETMASK)
                             6064 ; 579  |#define HW_ARC_PORTSC1_WKOC_CLRMASK (~(WORD)HW_ARC_PORTSC1_WKOC_SETMASK)
                             6065 ; 580  |#define HW_ARC_PORTSC1_PHCD_CLRMASK (~(WORD)HW_ARC_PORTSC1_PHCD_SETMASK)
                             6066 ; 581  |#define HW_ARC_PORTSC1_PFSC_CLRMASK (~(WORD)HW_ARC_PORTSC1_PFSC_SETMASK)
                             6067 ; 582  |#define HW_ARC_PORTSC1_PSPD_CLRMASK (~(WORD)HW_ARC_PORTSC1_PSPD_SETMASK)
                             6068 ; 583  |#define HW_ARC_PORTSC1_PTW_CLRMASK (~(WORD)HW_ARC_PORTSC1_PTW_SETMASK)   
                             6069 ; 584  |#define HW_ARC_PORTSC1_STS_CLRMASK (~(WORD)HW_ARC_PORTSC1_STS_SETMASK)   
                             6070 ; 585  |#define HW_ARC_PORTSC1_PTS_CLRMASK (~(WORD)HW_ARC_PORTSC1_PTS_SETMASK)   
                             6071 ; 586  |
                             6072 ; 587  |typedef union               
                             6073 ; 588  |{
                             6074 ; 589  |    struct {
                             6075 ; 590  |        int CCS             :1;
                             6076 ; 591  |        int CSC             :1;
                             6077 ; 592  |        int PE              :1;
                             6078 ; 593  |        int PEC             :1;
                             6079 ; 594  |        int OCA             :1;
                             6080 ; 595  |        int OCC             :1;
                             6081 ; 596  |        int FPR             :1;
                             6082 ; 597  |        int SUSP            :1;
                             6083 ; 598  |        int PR              :1;
                             6084 ; 599  |        int HSP             :1;
                             6085 ; 600  |        int LS              :2;
                             6086 ; 601  |        int PP              :1;
                             6087 ; 602  |        int PO              :1;
                             6088 ; 603  |        int PIC             :2;
                             6089 ; 604  |        int PTC             :4;
                             6090 ; 605  |        int WKCN            :1;
                             6091 ; 606  |        int WKDS            :1;
                             6092 ; 607  |        int WKOC            :1;
                             6093 ; 608  |        int PHCD            :1;
                             6094 ; 609  |        int PFSC            :1;
                             6095 ; 610  |        int                 :1;
                             6096 ; 611  |        int PSPD            :2;
                             6097 ; 612  |        int                 :1;
                             6098 ; 613  |        int PTW             :1;
                             6099 ; 614  |        int STS             :1;
                             6100 ; 615  |        int PTS             :1;
                             6101 ; 616  |        int                 :16;
                             6102 ; 617  |    } B;
                             6103 ; 618  |    DWORD I;
                             6104 ; 619  |} portsc1_type;
                             6105 ; 620  |//#define HW_ARC_PORTSC1 (*(volatile portsc1_type _X*) (HW_ARC_BASEADDR+0x184))    
                             6106 ; 621  |
                             6107 ; 622  |
                             6108 ; 623  |/////////////////////////////////////////////////////////////////////////////////
                             6109 ; 624  |//  USB ARC Register USB Device Mode (HW_ARC_USBMODE)
                             6110 ; 625  |
                             6111 ; 626  |#define HW_ARC_USBMODE_CM_BITPOS (0)
                             6112 ; 627  |#define HW_ARC_USBMODE_ES_BITPOS (2)
                             6113 ; 628  |
                             6114 ; 629  |#define HW_ARC_USBMODE_CM_SETMASK (3<<HW_ARC_USBMODE_CM_BITPOS)   
                             6115 ; 630  |#define HW_ARC_USBMODE_ES_SETMASK (1<<HW_ARC_USBMODE_ES_BITPOS)   
                             6116 ; 631  |
                             6117 ; 632  |#define HW_ARC_USBMODE_CM_CLRMASK (~(WORD)HW_ARC_USBMODE_CM_SETMASK) 
                             6118 ; 633  |#define HW_ARC_USBMODE_ES_CLRMASK (~(WORD)HW_ARC_USBMODE_ES_SETMASK)    
                             6119 ; 634  |
                             6120 ; 635  |typedef union               
                             6121 ; 636  |{
                             6122 ; 637  |    struct {
                             6123 ; 638  |        int CM              :2;
                             6124 ; 639  |        int ES              :1;
                             6125 ; 640  |        int                 :46;
                             6126 ; 641  |    } B;
                             6127 ; 642  |    DWORD I;
                             6128 ; 643  |} usbmode_type;
                             6129 ; 644  |//#define HW_ARC_USBMODE (*(volatile usbmode_type _X*) (HW_ARC_BASEADDR+0x1a8))    
                             6130 ; 645  |
                             6131 ; 646  |
                             6132 ; 647  |/////////////////////////////////////////////////////////////////////////////////
                             6133 ; 648  |//  The following endpoint equates are common for the following registers
                             6134 ; 649  |
                             6135 ; 650  |#define ENDPOINT0_BITPOS (0)
                             6136 ; 651  |#define ENDPOINT1_BITPOS (1)
                             6137 ; 652  |#define ENDPOINT2_BITPOS (2)
                             6138 ; 653  |#define ENDPOINT3_BITPOS (3)
                             6139 ; 654  |#define ENDPOINT4_BITPOS (4)
                             6140 ; 655  |#define ENDPOINT5_BITPOS (5)
                             6141 ; 656  |#define ENDPOINT6_BITPOS (6)
                             6142 ; 657  |#define ENDPOINT7_BITPOS (7)
                             6143 ; 658  |#define ENDPOINT8_BITPOS (8)
                             6144 ; 659  |#define ENDPOINT9_BITPOS (9)
                             6145 ; 660  |#define ENDPOINT10_BITPOS (10)
                             6146 ; 661  |#define ENDPOINT11_BITPOS (11)
                             6147 ; 662  |#define ENDPOINT12_BITPOS (12)
                             6148 ; 663  |#define ENDPOINT13_BITPOS (13)
                             6149 ; 664  |#define ENDPOINT14_BITPOS (14)
                             6150 ; 665  |#define ENDPOINT15_BITPOS (15)
                             6151 ; 666  |
                             6152 ; 667  |#define ENDPOINT0_SETMASK (1<<ENDPOINT0_BITPOS)
                             6153 ; 668  |#define ENDPOINT1_SETMASK (1<<ENDPOINT1_BITPOS)
                             6154 ; 669  |#define ENDPOINT2_SETMASK (1<<ENDPOINT2_BITPOS)
                             6155 ; 670  |#define ENDPOINT3_SETMASK (1<<ENDPOINT3_BITPOS)
                             6156 ; 671  |#define ENDPOINT4_SETMASK (1<<ENDPOINT4_BITPOS)
                             6157 ; 672  |#define ENDPOINT5_SETMASK (1<<ENDPOINT5_BITPOS)
                             6158 ; 673  |#define ENDPOINT6_SETMASK (1<<ENDPOINT6_BITPOS)
                             6159 ; 674  |#define ENDPOINT7_SETMASK (1<<ENDPOINT7_BITPOS)
                             6160 ; 675  |#define ENDPOINT8_SETMASK (1<<ENDPOINT8_BITPOS)
                             6161 ; 676  |#define ENDPOINT9_SETMASK (1<<ENDPOINT9_BITPOS)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  25

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6162 ; 677  |#define ENDPOINT10_SETMASK (1<<ENDPOINT10_BITPOS)
                             6163 ; 678  |#define ENDPOINT11_SETMASK (1<<ENDPOINT11_BITPOS)
                             6164 ; 679  |#define ENDPOINT12_SETMASK (1<<ENDPOINT12_BITPOS)
                             6165 ; 680  |#define ENDPOINT13_SETMASK (1<<ENDPOINT13_BITPOS)
                             6166 ; 681  |#define ENDPOINT14_SETMASK (1<<ENDPOINT14_BITPOS)
                             6167 ; 682  |#define ENDPOINT15_SETMASK (1<<ENDPOINT15_BITPOS)
                             6168 ; 683  |
                             6169 ; 684  |#define ENDPOINT0_CLRMASK (~(WORD)ENDPOINT0_SETMASK)    
                             6170 ; 685  |#define ENDPOINT1_CLRMASK (~(WORD)ENDPOINT1_SETMASK)    
                             6171 ; 686  |#define ENDPOINT2_CLRMASK (~(WORD)ENDPOINT2_SETMASK)    
                             6172 ; 687  |#define ENDPOINT3_CLRMASK (~(WORD)ENDPOINT3_SETMASK)    
                             6173 ; 688  |#define ENDPOINT4_CLRMASK (~(WORD)ENDPOINT4_SETMASK)    
                             6174 ; 689  |#define ENDPOINT5_CLRMASK (~(WORD)ENDPOINT5_SETMASK)    
                             6175 ; 690  |#define ENDPOINT6_CLRMASK (~(WORD)ENDPOINT6_SETMASK)    
                             6176 ; 691  |#define ENDPOINT7_CLRMASK (~(WORD)ENDPOINT7_SETMASK)    
                             6177 ; 692  |#define ENDPOINT8_CLRMASK (~(WORD)ENDPOINT8_SETMASK)    
                             6178 ; 693  |#define ENDPOINT9_CLRMASK (~(WORD)ENDPOINT9_SETMASK)    
                             6179 ; 694  |#define ENDPOINT10_CLRMASK (~(WORD)ENDPOINT10_SETMASK)
                             6180 ; 695  |#define ENDPOINT11_CLRMASK (~(WORD)ENDPOINT11_SETMASK)
                             6181 ; 696  |#define ENDPOINT12_CLRMASK (~(WORD)ENDPOINT12_SETMASK)
                             6182 ; 697  |#define ENDPOINT13_CLRMASK (~(WORD)ENDPOINT13_SETMASK)
                             6183 ; 698  |#define ENDPOINT14_CLRMASK (~(WORD)ENDPOINT14_SETMASK)
                             6184 ; 699  |#define ENDPOINT15_CLRMASK (~(WORD)ENDPOINT15_SETMASK)
                             6185 ; 700  |
                             6186 ; 701  |typedef union               
                             6187 ; 702  |{
                             6188 ; 703  |    struct {
                             6189 ; 704  |        int EP0              :1;
                             6190 ; 705  |        int EP1              :1;
                             6191 ; 706  |        int EP2              :1;
                             6192 ; 707  |        int EP3              :1;
                             6193 ; 708  |        int EP4              :1;
                             6194 ; 709  |        int EP5              :1;
                             6195 ; 710  |        int EP6              :1;
                             6196 ; 711  |        int EP7              :1;
                             6197 ; 712  |        int EP8              :1;
                             6198 ; 713  |        int EP9              :1;
                             6199 ; 714  |        int EP10             :1;
                             6200 ; 715  |        int EP11             :1;
                             6201 ; 716  |        int EP12             :1;
                             6202 ; 717  |        int EP13             :1;
                             6203 ; 718  |        int EP14             :1;
                             6204 ; 719  |        int EP15             :1;
                             6205 ; 720  |        int                  :32;
                             6206 ; 721  |    } B;
                             6207 ; 722  |    DWORD I;
                             6208 ; 723  |} endpsetupstat_type;
                             6209 ; 724  |
                             6210 ; 725  |//#define HW_ARC_ENDPTSETUPSTAT (*(volatile endpsetupstat_type _X*) (HW_ARC_BASEADDR+0x1ac))    
                             6211 ; 726  |
                             6212 ; 727  |typedef union               
                             6213 ; 728  |{
                             6214 ; 729  |    struct {
                             6215 ; 730  |        int EP0              :1;
                             6216 ; 731  |        int EP1              :1;
                             6217 ; 732  |        int EP2              :1;
                             6218 ; 733  |        int EP3              :1;
                             6219 ; 734  |        int EP4              :1;
                             6220 ; 735  |        int EP5              :1;
                             6221 ; 736  |        int EP6              :1;
                             6222 ; 737  |        int EP7              :1;
                             6223 ; 738  |        int EP8              :1;
                             6224 ; 739  |        int EP9              :1;
                             6225 ; 740  |        int EP10             :1;
                             6226 ; 741  |        int EP11             :1;
                             6227 ; 742  |        int EP12             :1;
                             6228 ; 743  |        int EP13             :1;
                             6229 ; 744  |        int EP14             :1;
                             6230 ; 745  |        int EP15             :1;
                             6231 ; 746  |        int                  :8;
                             6232 ; 747  |    } B;
                             6233 ; 748  |    WORD I;
                             6234 ; 749  |} endpt_type;
                             6235 ; 750  |
                             6236 ; 751  |typedef union
                             6237 ; 752  |{
                             6238 ; 753  |   struct {
                             6239 ; 754  |       endpt_type  RX;
                             6240 ; 755  |       endpt_type  TX;
                             6241 ; 756  |   } W;
                             6242 ; 757  |   DWORD DW;
                             6243 ; 758  |} endptrxtx_type;
                             6244 ; 759  |
                             6245 ; 760  |//#define HW_ARC_ENDPTPRIME    (*(volatile endptrxtx_type _X*) (HW_ARC_BASEADDR+0x1b0))    
                             6246 ; 761  |//#define HW_ARC_ENDPTFLUSH    (*(volatile endptrxtx_type _X*) (HW_ARC_BASEADDR+0x1b4))    
                             6247 ; 762  |//#define HW_ARC_ENDPTSTAT     (*(volatile endptrxtx_type _X*) (HW_ARC_BASEADDR+0x1b8))    
                             6248 ; 763  |//#define HW_ARC_ENDPTCOMPLETE (*(volatile endptrxtx_type _X*) (HW_ARC_BASEADDR+0x1bc))    
                             6249 ; 764  |
                             6250 ; 765  |
                             6251 ; 766  |
                             6252 ; 767  |/////////////////////////////////////////////////////////////////////////////////
                             6253 ; 768  |//  USB ARC Register Endpoint control (HW_ARC_ENDPTCTRL)
                             6254 ; 769  |
                             6255 ; 770  |#define HW_ARC_ENDPTCTRL_RXS_BITPOS (0)
                             6256 ; 771  |#define HW_ARC_ENDPTCTRL_RXD_BITPOS (1)
                             6257 ; 772  |#define HW_ARC_ENDPTCTRL_RXT_BITPOS (2)
                             6258 ; 773  |#define HW_ARC_ENDPTCTRL_RXI_BITPOS (5)
                             6259 ; 774  |#define HW_ARC_ENDPTCTRL_RXR_BITPOS (6)
                             6260 ; 775  |#define HW_ARC_ENDPTCTRL_RXE_BITPOS (7)
                             6261 ; 776  |#define HW_ARC_ENDPTCTRL_TXS_BITPOS (16)
                             6262 ; 777  |#define HW_ARC_ENDPTCTRL_TXD_BITPOS (17)
                             6263 ; 778  |#define HW_ARC_ENDPTCTRL_TXT_BITPOS (18)
                             6264 ; 779  |#define HW_ARC_ENDPTCTRL_TXI_BITPOS (21)
                             6265 ; 780  |#define HW_ARC_ENDPTCTRL_TXR_BITPOS (22)
                             6266 ; 781  |#define HW_ARC_ENDPTCTRL_TXE_BITPOS (23)
                             6267 ; 782  |
                             6268 ; 783  |#define HW_ARC_ENDPTCTRL_RXS_SETMASK (1<<HW_ARC_ENDPTCTRL_RXS_BITPOS)
                             6269 ; 784  |#define HW_ARC_ENDPTCTRL_RXD_SETMASK (1<<HW_ARC_ENDPTCTRL_RXD_BITPOS)
                             6270 ; 785  |#define HW_ARC_ENDPTCTRL_RXT_SETMASK (3<<HW_ARC_ENDPTCTRL_RXT_BITPOS)
                             6271 ; 786  |#define HW_ARC_ENDPTCTRL_RXI_SETMASK (1<<HW_ARC_ENDPTCTRL_RXI_BITPOS)
                             6272 ; 787  |#define HW_ARC_ENDPTCTRL_RXR_SETMASK (1<<HW_ARC_ENDPTCTRL_RXR_BITPOS)
                             6273 ; 788  |#define HW_ARC_ENDPTCTRL_RXE_SETMASK (1<<HW_ARC_ENDPTCTRL_RXE_BITPOS)
                             6274 ; 789  |#define HW_ARC_ENDPTCTRL_TXS_SETMASK (1<<HW_ARC_ENDPTCTRL_TXS_BITPOS)
                             6275 ; 790  |#define HW_ARC_ENDPTCTRL_TXD_SETMASK (1<<HW_ARC_ENDPTCTRL_TXD_BITPOS)
                             6276 ; 791  |#define HW_ARC_ENDPTCTRL_TXT_SETMASK (3<<HW_ARC_ENDPTCTRL_TXT_BITPOS)
                             6277 ; 792  |#define HW_ARC_ENDPTCTRL_TXI_SETMASK (1<<HW_ARC_ENDPTCTRL_TXI_BITPOS)
                             6278 ; 793  |#define HW_ARC_ENDPTCTRL_TXR_SETMASK (1<<HW_ARC_ENDPTCTRL_TXR_BITPOS)
                             6279 ; 794  |
                             6280 ; 795  |// We need to equate the following label like this due to a sign extension problem
                             6281 ; 796  |// if equated like so (1<<HW_ARC_ENDPTCTRL_TXE_BITPOS)
                             6282 ; 797  |#define HW_ARC_ENDPTCTRL_TXE_SETMASK (0x00800000)
                             6283 ; 798  |//HW_ARC_ENDPTCTRL_TXE_SETMASK    equ     (1<<HW_ARC_ENDPTCTRL_TXE_BITPOS)
                             6284 ; 799  |
                             6285 ; 800  |#define HW_ARC_ENDPTCTRL_RXS_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXS_SETMASK)
                             6286 ; 801  |#define HW_ARC_ENDPTCTRL_RXD_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXD_SETMASK)
                             6287 ; 802  |#define HW_ARC_ENDPTCTRL_RXT_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXT_SETMASK)
                             6288 ; 803  |#define HW_ARC_ENDPTCTRL_RXI_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXI_SETMASK)
                             6289 ; 804  |#define HW_ARC_ENDPTCTRL_RXR_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXR_SETMASK)
                             6290 ; 805  |#define HW_ARC_ENDPTCTRL_RXE_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_RXE_SETMASK)
                             6291 ; 806  |#define HW_ARC_ENDPTCTRL_TXS_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXS_SETMASK)
                             6292 ; 807  |#define HW_ARC_ENDPTCTRL_TXD_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXD_SETMASK)
                             6293 ; 808  |#define HW_ARC_ENDPTCTRL_TXT_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXT_SETMASK)
                             6294 ; 809  |#define HW_ARC_ENDPTCTRL_TXI_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXI_SETMASK)
                             6295 ; 810  |#define HW_ARC_ENDPTCTRL_TXR_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXR_SETMASK)
                             6296 ; 811  |#define HW_ARC_ENDPTCTRL_TXE_CLRMASK (~(WORD)HW_ARC_ENDPTCTRL_TXE_SETMASK)
                             6297 ; 812  |
                             6298 ; 813  |
                             6299 ; 814  |typedef union               
                             6300 ; 815  |{
                             6301 ; 816  |    struct {
                             6302 ; 817  |        int RXS             :1;
                             6303 ; 818  |        int RXD             :1;
                             6304 ; 819  |        int RXT             :2;
                             6305 ; 820  |        int                 :1;
                             6306 ; 821  |        int RXI             :1;
                             6307 ; 822  |        int RXR             :1;
                             6308 ; 823  |        int RXE             :1;
                             6309 ; 824  |        int                 :8;
                             6310 ; 825  |        int TXS             :1;
                             6311 ; 826  |        int TXD             :1;
                             6312 ; 827  |        int TXT             :2;
                             6313 ; 828  |        int                 :1;
                             6314 ; 829  |        int TXI             :1;
                             6315 ; 830  |        int TXR             :1;
                             6316 ; 831  |        int TXE             :1;
                             6317 ; 832  |        int                 :24;
                             6318 ; 833  |    } B;
                             6319 ; 834  |    DWORD I;
                             6320 ; 835  |} endptctrl_type;
                             6321 ; 836  |//#define HW_ARC_ENDPTCTRL[n] (*(volatile usbintr_type _X*) (HW_ARC_BASEADDR+0x1c0+((n)*4)))    
                             6322 ; 837  |
                             6323 ; 838  |#endif
                             6324 ; 839  |
                             6325 ; 840  |
                             6326 
                             6328 
                             6329 ; 22   |#include "regsusb20phy.h"
                             6330 
                             6332 
                             6333 ; 1    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             6334 ; 2    |//;  Copyright(C) SigmaTel, Inc. 2002-2005
                             6335 ; 3    |//;  File        : regsusbphy.inc
                             6336 ; 4    |//;  Description : USB20 PHY Register definition
                             6337 ; 5    |//;  Updated 2.23.2003 By M. Henson
                             6338 ; 6    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             6339 ; 7    |
                             6340 ; 8    |// The following naming conventions are followed in this file.
                             6341 ; 9    |// All registers are named using the format...
                             6342 ; 10   |//     HW_<module>_<regname>
                             6343 ; 11   |// where <module> is the module name which can be any of the following...
                             6344 ; 12   |//     USB20
                             6345 ; 13   |// (Note that when there is more than one copy of a particular module, the
                             6346 ; 14   |// module name includes a number starting from 0 for the first instance of
                             6347 ; 15   |// that module)
                             6348 ; 16   |// <regname> is the specific register within that module
                             6349 ; 17   |// We also define the following...
                             6350 ; 18   |//     HW_<module>_<regname>_BITPOS
                             6351 ; 19   |// which defines the starting bit (i.e. LSB) of a multi bit field
                             6352 ; 20   |//     HW_<module>_<regname>_SETMASK
                             6353 ; 21   |// which does something else, and
                             6354 ; 22   |//     HW_<module>_<regname>_CLRMASK
                             6355 ; 23   |// which does something else.
                             6356 ; 24   |// Other rules
                             6357 ; 25   |//     All caps
                             6358 ; 26   |//     Numeric identifiers start at 0
                             6359 ; 27   |
                             6360 ; 28   |#if !(defined(regsusbphyinc))
                             6361 ; 29   |#define regsusbphyinc 1
                             6362 ; 30   |
                             6363 ; 31   |#include "types.h"
                             6364 ; 32   |
                             6365 ; 33   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             6366 ; 34   |//   USB2.0 PHY STMP Registers 
                             6367 ; 35   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             6368 ; 36   |#define HW_USBPHY_BASEADDR (0xF210)
                             6369 ; 37   |
                             6370 ; 38   |
                             6371 ; 39   |/////////////////////////////////////////////////////////////////////////////////
                             6372 ; 40   |//  USB PHY Powerdown Register (HW_USBPHYPWD) Bit Definitions
                             6373 ; 41   |
                             6374 ; 42   |#define HW_USBPHYPWD_TXDISCON1500_BITPOS (5)
                             6375 ; 43   |#define HW_USBPHYPWD_PLLVCOPWD_BITPOS (6)
                             6376 ; 44   |#define HW_USBPHYPWD_PLLVCPPWD_BITPOS (7)
                             6377 ; 45   |#define HW_USBPHYPWD_TXPWDFS_BITPOS (10)
                             6378 ; 46   |#define HW_USBPHYPWD_TXPWDIBIAS_BITPOS (11)
                             6379 ; 47   |#define HW_USBPHYPWD_TXPWDV2I_BITPOS (12)
                             6380 ; 48   |#define HW_USBPHYPWD_TXPWDVBG_BITPOS (13)
                             6381 ; 49   |#define HW_USBPHYPWD_TXPWDCOMP_BITPOS (14)
                             6382 ; 50   |#define HW_USBPHYPWD_RXPWDDISCONDET_BITPOS (16)
                             6383 ; 51   |#define HW_USBPHYPWD_RXPWDENV_BITPOS (17)
                             6384 ; 52   |#define HW_USBPHYPWD_RXPWD1PT1_BITPOS (18)
                             6385 ; 53   |#define HW_USBPHYPWD_RXPWDDIFF_BITPOS (19)
                             6386 ; 54   |#define HW_USBPHYPWD_RXPWDRX_BITPOS (20)
                             6387 ; 55   |#define HW_USBPHYPWD_PWDIBIAS_BITPOS (22)
                             6388 ; 56   |#define HW_USBPHYPWD_REGRESET_BITPOS (23)
                             6389 ; 57   |
                             6390 ; 58   |#define HW_USBPHYPWD_TXDISCON1500_SETMASK (1<<HW_USBPHYPWD_TXDISCON1500_BITPOS)
                             6391 ; 59   |#define HW_USBPHYPWD_PLLVCOPWD_SETMASK (1<<HW_USBPHYPWD_PLLVCOPWD_BITPOS)
                             6392 ; 60   |#define HW_USBPHYPWD_PLLVCPPWD_SETMASK (1<<HW_USBPHYPWD_PLLVCPPWD_BITPOS)
                             6393 ; 61   |#define HW_USBPHYPWD_TXPWDFS_SETMASK (1<<HW_USBPHYPWD_TXPWDFS_BITPOS)
                             6394 ; 62   |#define HW_USBPHYPWD_TXPWDIBIAS_SETMASK (1<<HW_USBPHYPWD_TXPWDIBIAS_BITPOS)
                             6395 ; 63   |#define HW_USBPHYPWD_TXPWDV2I_SETMASK (1<<HW_USBPHYPWD_TXPWDV2I_BITPOS)
                             6396 ; 64   |#define HW_USBPHYPWD_TXPWDVBG_SETMASK (1<<HW_USBPHYPWD_TXPWDVBG_BITPOS)
                             6397 ; 65   |#define HW_USBPHYPWD_TXPWDCOMP_SETMASK (1<<HW_USBPHYPWD_TXPWDCOMP_BITPOS)
                             6398 ; 66   |#define HW_USBPHYPWD_RXPWDDISCONDET_SETMASK (1<<HW_USBPHYPWD_RXPWDDISCONDET_BITPOS)
                             6399 ; 67   |#define HW_USBPHYPWD_RXPWDENV_SETMASK (1<<HW_USBPHYPWD_RXPWDENV_BITPOS)
                             6400 ; 68   |#define HW_USBPHYPWD_RXPWD1PT1_SETMASK (1<<HW_USBPHYPWD_RXPWD1PT1_BITPOS)
                             6401 ; 69   |#define HW_USBPHYPWD_RXPWDDIFF_SETMASK (1<<HW_USBPHYPWD_RXPWDDIFF_BITPOS)
                             6402 ; 70   |#define HW_USBPHYPWD_RXPWDRX_SETMASK (1<<HW_USBPHYPWD_RXPWDRX_BITPOS)
                             6403 ; 71   |#define HW_USBPHYPWD_PWDIBIAS_SETMASK (1<<HW_USBPHYPWD_PWDIBIAS_BITPOS)
                             6404 ; 72   |#define HW_USBPHYPWD_REGRESET_SETMASK (1<<HW_USBPHYPWD_REGRESET_BITPOS)
                             6405 ; 73   |
                             6406 ; 74   |#define HW_USBPHYPWD_TXDISCON1500_CLRMASK (~(WORD)HW_USBPHYPWD_TXDISCON1500_SETMASK)
                             6407 ; 75   |#define HW_USBPHYPWD_PLLVCOPWD_CLRMASK (~(WORD)HW_USBPHYPWD_PLLVCOPWD_SETMASK)
                             6408 ; 76   |#define HW_USBPHYPWD_PLLVCPPWD_CLRMASK (~(WORD)HW_USBPHYPWD_PLLVCPPWD_SETMASK)
                             6409 ; 77   |#define HW_USBPHYPWD_TXPWDFS_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDFS_SETMASK)
                             6410 ; 78   |#define HW_USBPHYPWD_TXPWDIBIAS_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDIBIAS_SETMASK)
                             6411 ; 79   |#define HW_USBPHYPWD_TXPWDV2I_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDV2I_SETMASK)
                             6412 ; 80   |#define HW_USBPHYPWD_TXPWDVBG_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDVBG_SETMASK)
                             6413 ; 81   |#define HW_USBPHYPWD_TXPWDCOMP_CLRMASK (~(WORD)HW_USBPHYPWD_TXPWDCOMP_SETMASK)
                             6414 ; 82   |#define HW_USBPHYPWD_RXPWDDISCONDET_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWDDISCONDET_SETMASK)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  26

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6415 ; 83   |#define HW_USBPHYPWD_RXPWDENV_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWDENV_SETMASK)
                             6416 ; 84   |#define HW_USBPHYPWD_RXPWD1PT1_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWD1PT1_SETMASK)
                             6417 ; 85   |#define HW_USBPHYPWD_RXPWDDIFF_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWDDIFF_SETMASK)
                             6418 ; 86   |#define HW_USBPHYPWD_RXPWDRX_CLRMASK (~(WORD)HW_USBPHYPWD_RXPWDRX_SETMASK)
                             6419 ; 87   |#define HW_USBPHYPWD_PWDIBIAS_CLRMASK (~(WORD)HW_USBPHYPWD_PWDIBIAS_SETMASK)
                             6420 ; 88   |#define HW_USBPHYPWD_REGRESET_CLRMASK (~(WORD)HW_USBPHYPWD_REGRESET_SETMASK)
                             6421 ; 89   |
                             6422 ; 90   |typedef union               
                             6423 ; 91   |{
                             6424 ; 92   |    struct {
                             6425 ; 93   |        int RSVD0          :5;
                             6426 ; 94   |        int TXDISCON1500   :1;
                             6427 ; 95   |        int PLLVCOPWD      :1;
                             6428 ; 96   |        int PLLVCPPWD      :1;
                             6429 ; 97   |        int RSVD1          :2;
                             6430 ; 98   |        int TXPWDFS        :1;
                             6431 ; 99   |        int TXPWDIBIAS     :1;
                             6432 ; 100  |        int TXPWDV2I       :1;
                             6433 ; 101  |        int TXPWDVBG       :1;
                             6434 ; 102  |        int TXPWDCOMP      :1;
                             6435 ; 103  |        int RSVD2          :1;
                             6436 ; 104  |        int RXPWDDISCONDET :1;
                             6437 ; 105  |        int RXPWDENV       :1;
                             6438 ; 106  |        int RXPWD1PT1      :1;
                             6439 ; 107  |        int RXPWDDIFF      :1;
                             6440 ; 108  |        int RXPWDRX        :1;
                             6441 ; 109  |        int RSVD3          :1;
                             6442 ; 110  |        int PWDIBIAS       :1;
                             6443 ; 111  |        int REGRESET       :1;
                             6444 ; 112  |    } B;
                             6445 ; 113  |    int I;
                             6446 ; 114  |} usbphypwd_type;
                             6447 ; 115  |#define HW_USBPHYPWD      (*(volatile usbphypwd_type _X*) (HW_USBPHY_BASEADDR))    /* USB PHY Powerdown Register */
                             6448 ; 116  |
                             6449 ; 117  |/////////////////////////////////////////////////////////////////////////////////
                             6450 ; 118  |//  USB PHY Transmit register (HW_USBPHYTX) Bit Definitions
                             6451 ; 119  |#define HW_USBPHYTX_TXCAL1500_BITPOS (0)
                             6452 ; 120  |#define HW_USBPHYTX_TXENCAL1500_BITPOS (5)
                             6453 ; 121  |#define HW_USBPHYTX_TXHSXCVR_BITPOS (6)
                             6454 ; 122  |#define HW_USBPHYTX_TXCALIBRATE_BITPOS (7)
                             6455 ; 123  |#define HW_USBPHYTX_TXCAL45DN_BITPOS (8)
                             6456 ; 124  |#define HW_USBPHYTX_TXENCAL45DN_BITPOS (13)
                             6457 ; 125  |#define HW_USBPHYTX_TXHSTERM_BITPOS (14)
                             6458 ; 126  |#define HW_USBPHYTX_TXSKEW_BITPOS (15)
                             6459 ; 127  |#define HW_USBPHYTX_TXCAL45DP_BITPOS (16)
                             6460 ; 128  |#define HW_USBPHYTX_TXENCAL45DP_BITPOS (21)
                             6461 ; 129  |#define HW_USBPHYTX_TXFSHIZ_BITPOS (22)
                             6462 ; 130  |#define HW_USBPHYTX_TXCOMPOUT_BITPOS (23)
                             6463 ; 131  |
                             6464 ; 132  |#define HW_USBPHYTX_TXCAL1500_WIDTH (4)
                             6465 ; 133  |#define HW_USBPHYTX_TXENCAL1500_WIDTH (1)
                             6466 ; 134  |#define HW_USBPHYTX_TXHSXCVR_WIDTH (1)
                             6467 ; 135  |#define HW_USBPHYTX_TXCALIBRATE_WIDTH (1)
                             6468 ; 136  |#define HW_USBPHYTX_TXCAL45DN_WIDTH (4)
                             6469 ; 137  |#define HW_USBPHYTX_TXENCAL45DN_WIDTH (1)
                             6470 ; 138  |#define HW_USBPHYTX_TXHSTERM_WIDTH (1)
                             6471 ; 139  |#define HW_USBPHYTX_TXSKEW_WIDTH (1)
                             6472 ; 140  |#define HW_USBPHYTX_TXCAL45DP_WIDTH (4)
                             6473 ; 141  |#define HW_USBPHYTX_TXENCAL45DP_WIDTH (1)
                             6474 ; 142  |#define HW_USBPHYTX_TXFSHIZ_WIDTH (1)
                             6475 ; 143  |#define HW_USBPHYTX_TXCOMPOUT_WIDTH (1)
                             6476 ; 144  |
                             6477 ; 145  |#define HW_USBPHYTX_TXCAL1500_SETMASK (((1<<HW_USBPHYTX_TXCAL1500_WIDTH)-1)<<HW_USBPHYTX_TXCAL1500_BITPOS)
                             6478 ; 146  |#define HW_USBPHYTX_TXENCAL1500_SETMASK (((1<<HW_USBPHYTX_TXENCAL1500_WIDTH)-1)<<HW_USBPHYTX_TXENCAL1500_BITPOS)
                             6479 ; 147  |#define HW_USBPHYTX_TXHSXCVR_SETMASK (((1<<HW_USBPHYTX_TXHSXCVR_WIDTH)-1)<<HW_USBPHYTX_TXHSXCVR_BITPOS)
                             6480 ; 148  |#define HW_USBPHYTX_TXCALIBRATE_SETMASK (((1<<HW_USBPHYTX_TXCALIBRATE_WIDTH)-1)<<HW_USBPHYTX_TXCALIBRATE_BITPOS)
                             6481 ; 149  |#define HW_USBPHYTX_TXCAL45DN_SETMASK (((1<<HW_USBPHYTX_TXCAL45DN_WIDTH)-1)<<HW_USBPHYTX_TXCAL45DN_BITPOS)
                             6482 ; 150  |#define HW_USBPHYTX_TXENCAL45DN_SETMASK (((1<<HW_USBPHYTX_TXENCAL45DN_WIDTH)-1)<<HW_USBPHYTX_TXENCAL45DN_BITPOS)
                             6483 ; 151  |#define HW_USBPHYTX_TXHSTERM_SETMASK (((1<<HW_USBPHYTX_TXHSTERM_WIDTH)-1)<<HW_USBPHYTX_TXHSTERM_BITPOS)
                             6484 ; 152  |#define HW_USBPHYTX_TXSKEW_SETMASK (((1<<HW_USBPHYTX_TXSKEW_WIDTH)-1)<<HW_USBPHYTX_TXSKEW_BITPOS)
                             6485 ; 153  |#define HW_USBPHYTX_TXCAL45DP_SETMASK (((1<<HW_USBPHYTX_TXCAL45DP_WIDTH)-1)<<HW_USBPHYTX_TXCAL45DP_BITPOS)
                             6486 ; 154  |#define HW_USBPHYTX_TXENCAL45DP_SETMASK (((1<<HW_USBPHYTX_TXENCAL45DP_WIDTH)-1)<<HW_USBPHYTX_TXENCAL45DP_BITPOS)
                             6487 ; 155  |#define HW_USBPHYTX_TXFSHIZ_SETMASK (((1<<HW_USBPHYTX_TXFSHIZ_WIDTH)-1)<<HW_USBPHYTX_TXFSHIZ_BITPOS)
                             6488 ; 156  |#define HW_USBPHYTX_TXCOMPOUT_SETMASK (((1<<HW_USBPHYTX_TXCOMPOUT_WIDTH)-1)<<HW_USBPHYTX_TXCOMPOUT_BITPOS)
                             6489 ; 157  |
                             6490 ; 158  |#define HW_USBPHYTX_TXCAL1500_CLRMASK (~(WORD)HW_USBPHYTX_TXCAL1500_SETMASK)
                             6491 ; 159  |#define HW_USBPHYTX_TXENCAL1500_CLRMASK (~(WORD)HW_USBPHYTX_TXENCAL1500_SETMASK)
                             6492 ; 160  |#define HW_USBPHYTX_TXHSXCVR_CLRMASK (~(WORD)HW_USBPHYTX_TXHSXCVR_SETMASK)
                             6493 ; 161  |#define HW_USBPHYTX_TXCALIBRATE_CLRMASK (~(WORD)HW_USBPHYTX_TXCALIBRATE_SETMASK)
                             6494 ; 162  |#define HW_USBPHYTX_TXCAL45DN_CLRMASK (~(WORD)HW_USBPHYTX_TXCAL45DN_SETMASK)
                             6495 ; 163  |#define HW_USBPHYTX_TXENCAL45DN_CLRMASK (~(WORD)HW_USBPHYTX_TXENCAL45DN_SETMASK)
                             6496 ; 164  |#define HW_USBPHYTX_TXHSTERM_CLRMASK (~(WORD)HW_USBPHYTX_TXHSTERM_SETMASK)
                             6497 ; 165  |#define HW_USBPHYTX_TXSKEW_CLRMASK (~(WORD)HW_USBPHYTX_TXSKEW_SETMASK)
                             6498 ; 166  |#define HW_USBPHYTX_TXCAL45DP_CLRMASK (~(WORD)HW_USBPHYTX_TXCAL45DP_SETMASK)
                             6499 ; 167  |#define HW_USBPHYTX_TXENCAL45DP_CLRMASK (~(WORD)HW_USBPHYTX_TXENCAL45DP_SETMASK)
                             6500 ; 168  |#define HW_USBPHYTX_TXFSHIZ_CLRMASK (~(WORD)HW_USBPHYTX_TXFSHIZ_SETMASK)
                             6501 ; 169  |#define HW_USBPHYTX_TXCOMPOUT_CLRMASK (~(WORD)HW_USBPHYTX_TXCOMPOUT_SETMASK)
                             6502 ; 170  |
                             6503 ; 171  |typedef union               
                             6504 ; 172  |{
                             6505 ; 173  |    struct {
                             6506 ; 174  |        int TXCAL1500          :4;
                             6507 ; 175  |        int RSVD0              :1;
                             6508 ; 176  |        int TXENCAL1500        :1;
                             6509 ; 177  |        int TXHSXCVR           :1;
                             6510 ; 178  |        int TXCALIBRATE        :1;
                             6511 ; 179  |        int TXCAL45DN          :4;
                             6512 ; 180  |        int RSVD1              :1;
                             6513 ; 181  |        int TXENCAL45DN        :1;
                             6514 ; 182  |        int TXHSTERM           :1;
                             6515 ; 183  |        int TXSKEW             :1;
                             6516 ; 184  |        int TXCAL45DP          :4;
                             6517 ; 185  |        int RSVD2              :1;
                             6518 ; 186  |        int TXENCAL45DP        :1;
                             6519 ; 187  |        int TXFSHIZ            :1;
                             6520 ; 188  |        int TXCOMPOUT          :1;
                             6521 ; 189  |    } B;
                             6522 ; 190  |    int I;
                             6523 ; 191  |} usbphytx_type;
                             6524 ; 192  |#define HW_USBPHYTX      (*(volatile usbphytx_type _X*) (HW_USBPHY_BASEADDR+1))    
                             6525 ; 193  |
                             6526 ; 194  |/////////////////////////////////////////////////////////////////////////////////
                             6527 ; 195  |//  USB PHY PLL register (HW_USBPHYPLL) Bit Definitions
                             6528 ; 196  |#define HW_USBPHYPLL_PLLV2ISEL_BITPOS (0)
                             6529 ; 197  |#define HW_USBPHYPLL_PLLCPDBLIP_BITPOS (5)
                             6530 ; 198  |#define HW_USBPHYPLL_PLLVCOCLK2_BITPOS (6)
                             6531 ; 199  |#define HW_USBPHYPLL_PLLVCOCLK24_BITPOS (7)
                             6532 ; 200  |#define HW_USBPHYPLL_PLLCPNSEL_BITPOS (8)
                             6533 ; 201  |#define HW_USBPHYPLL_PLLCLKDIVSEL_BITPOS (12)
                             6534 ; 202  |#define HW_USBPHYPLL_PLLPFDRST_BITPOS (20)
                             6535 ; 203  |#define HW_USBPHYPLL_PLLCPSHORTLFR_BITPOS (21)
                             6536 ; 204  |#define HW_USBPHYPLL_PLLVCOKSTART_BITPOS (22)
                             6537 ; 205  |#define HW_USBPHYPLL_PLLCLKDIVRSTZ_BITPOS (23)
                             6538 ; 206  |
                             6539 ; 207  |#define HW_USBPHYPLL_PLLV2ISEL_WIDTH (4)
                             6540 ; 208  |#define HW_USBPHYPLL_PLLCPDBLIP_WIDTH (1)
                             6541 ; 209  |#define HW_USBPHYPLL_PLLVCOCLK2_WIDTH (1)
                             6542 ; 210  |#define HW_USBPHYPLL_PLLVCOCLK24_WIDTH (1)
                             6543 ; 211  |#define HW_USBPHYPLL_PLLCPNSEL_WIDTH (4)
                             6544 ; 212  |#define HW_USBPHYPLL_PLLCLKDIVSEL_WIDTH (4)
                             6545 ; 213  |#define HW_USBPHYPLL_PLLPFDRST_WIDTH (1)
                             6546 ; 214  |#define HW_USBPHYPLL_PLLCPSHORTLFR_WIDTH (1)
                             6547 ; 215  |#define HW_USBPHYPLL_PLLVCOKSTART_WIDTH (1)
                             6548 ; 216  |#define HW_USBPHYPLL_PLLCLKDIVRSTZ_WIDTH (1)
                             6549 ; 217  |
                             6550 ; 218  |#define HW_USBPHYPLL_PLLV2ISEL_SETMASK (((1<<HW_USBPHYPLL_PLLV2ISEL_WIDTH)-1)<<HW_USBPHYPLL_PLLV2ISEL_BITPOS)
                             6551 ; 219  |#define HW_USBPHYPLL_PLLCPDBLIP_SETMASK (((1<<HW_USBPHYPLL_PLLCPDBLIP_WIDTH)-1)<<HW_USBPHYPLL_PLLCPDBLIP_BITPOS)
                             6552 ; 220  |#define HW_USBPHYPLL_PLLVCOCLK2_SETMASK (((1<<HW_USBPHYPLL_PLLVCOCLK2_WIDTH)-1)<<HW_USBPHYPLL_PLLVCOCLK2_BITPOS)
                             6553 ; 221  |#define HW_USBPHYPLL_PLLVCOCLK24_SETMASK (((1<<HW_USBPHYPLL_PLLVCOCLK24_WIDTH)-1)<<HW_USBPHYPLL_PLLVCOCLK24_BITPOS)
                             6554 ; 222  |#define HW_USBPHYPLL_PLLCPNSEL_SETMASK (((1<<HW_USBPHYPLL_PLLCPNSEL_WIDTH)-1)<<HW_USBPHYPLL_PLLCPNSEL_BITPOS)
                             6555 ; 223  |#define HW_USBPHYPLL_PLLCLKDIVSEL_SETMASK (((1<<HW_USBPHYPLL_PLLCLKDIVSEL_WIDTH)-1)<<HW_USBPHYPLL_PLLCLKDIVSEL_BITPOS)
                             6556 ; 224  |#define HW_USBPHYPLL_PLLPFDRST_SETMASK (((1<<HW_USBPHYPLL_PLLPFDRST_WIDTH)-1)<<HW_USBPHYPLL_PLLPFDRST_BITPOS)
                             6557 ; 225  |#define HW_USBPHYPLL_PLLCPSHORTLFR_SETMASK (((1<<HW_USBPHYPLL_PLLCPSHORTLFR_WIDTH)-1)<<HW_USBPHYPLL_PLLCPSHORTLFR_BITPOS)
                             6558 ; 226  |#define HW_USBPHYPLL_PLLVCOKSTART_SETMASK (((1<<HW_USBPHYPLL_PLLVCOKSTART_WIDTH)-1)<<HW_USBPHYPLL_PLLVCOKSTART_BITPOS)
                             6559 ; 227  |#define HW_USBPHYPLL_PLLCLKDIVRSTZ_SETMASK (((1<<HW_USBPHYPLL_PLLCLKDIVRSTZ_WIDTH)-1)<<HW_USBPHYPLL_PLLCLKDIVRSTZ_BITPOS)
                             6560 ; 228  |
                             6561 ; 229  |#define HW_USBPHYPLL_PLLV2ISEL_CLRMASK (~(WORD)HW_USBPHYPLL_PLLV2ISEL_SETMASK)
                             6562 ; 230  |#define HW_USBPHYPLL_PLLCPDBLIP_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCPDBLIP_SETMASK)
                             6563 ; 231  |#define HW_USBPHYPLL_PLLVCOCLK2_CLRMASK (~(WORD)HW_USBPHYPLL_PLLVCOCLK2_SETMASK)
                             6564 ; 232  |#define HW_USBPHYPLL_PLLVCOCLK24_CLRMASK (~(WORD)HW_USBPHYPLL_PLLVCOCLK24_SETMASK)
                             6565 ; 233  |#define HW_USBPHYPLL_PLLCPNSEL_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCPNSEL_SETMASK)
                             6566 ; 234  |#define HW_USBPHYPLL_PLLCLKDIVSEL_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCLKDIVSEL_SETMASK)
                             6567 ; 235  |#define HW_USBPHYPLL_PLLPFDRST_CLRMASK (~(WORD)HW_USBPHYPLL_PLLPFDRST_SETMASK)
                             6568 ; 236  |#define HW_USBPHYPLL_PLLCPSHORTLFR_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCPSHORTLFR_SETMASK)
                             6569 ; 237  |#define HW_USBPHYPLL_PLLVCOKSTART_CLRMASK (~(WORD)HW_USBPHYPLL_PLLVCOKSTART_SETMASK)
                             6570 ; 238  |#define HW_USBPHYPLL_PLLCLKDIVRSTZ_CLRMASK (~(WORD)HW_USBPHYPLL_PLLCLKDIVRSTZ_SETMASK)
                             6571 ; 239  |
                             6572 ; 240  |typedef union               
                             6573 ; 241  |{
                             6574 ; 242  |    struct {
                             6575 ; 243  |        int PLLV2ISEL        :4;
                             6576 ; 244  |        int RSVD0            :1;
                             6577 ; 245  |        int PLLCPDBLIP       :1;
                             6578 ; 246  |        int PLLVCOCLK2       :1;
                             6579 ; 247  |        int PLLVCOCLK24      :1;
                             6580 ; 248  |        int PLLCPNSEL        :4;
                             6581 ; 249  |        int PLLCLKDIVSEL     :4;
                             6582 ; 250  |        int RSVD1            :4;
                             6583 ; 251  |        int PLLPFDRST        :1;
                             6584 ; 252  |        int PLLCPSHORTLFR    :1;
                             6585 ; 253  |        int PLLVCOKSTART     :1;
                             6586 ; 254  |        int PLLCLKDIVRSTZ    :1;
                             6587 ; 255  |    } B;
                             6588 ; 256  |    int I;
                             6589 ; 257  |} usbphypll_type;
                             6590 ; 258  |#define HW_USBPHYPLL      (*(volatile usbphypll_type _X*) (HW_USBPHY_BASEADDR+2))    
                             6591 ; 259  |
                             6592 ; 260  |/////////////////////////////////////////////////////////////////////////////////
                             6593 ; 261  |//  USB PHY PLL register (HW_USBPHYRX) Bit Definitions
                             6594 ; 262  |#define HW_USBRX_ENVADJ_BITPOS (0)
                             6595 ; 263  |#define HW_USBRX_DISCONADJ_BITPOS (4)
                             6596 ; 264  |#define HW_USBRX_DEBUGMODE_BITPOS (8)
                             6597 ; 265  |#define HW_USBRX_PLLLKTIMECTL_BITPOS (12)
                             6598 ; 266  |#define HW_USBRX_PLLCKDIVCTL_BITPOS (16)
                             6599 ; 267  |#define HW_USBRX_HOSTMODETEST_BITPOS (20)
                             6600 ; 268  |#define HW_USBRX_FSCKSOURCESEL_BITPOS (21)
                             6601 ; 269  |#define HW_USBRX_REGRXDBYPASS_BITPOS (22)
                             6602 ; 270  |#define HW_USBRX_PLLLOCKED_BITPOS (23)
                             6603 ; 271  |
                             6604 ; 272  |#define HW_USBRX_ENVADJ_WIDTH (4)
                             6605 ; 273  |#define HW_USBRX_DISCONADJ_WIDTH (4)
                             6606 ; 274  |#define HW_USBRX_DEBUGMODE_WIDTH (4)
                             6607 ; 275  |#define HW_USBRX_PLLLKTIMECTL_WIDTH (4)
                             6608 ; 276  |#define HW_USBRX_PLLCKDIVCTL_WIDTH (4)
                             6609 ; 277  |#define HW_USBRX_HOSTMODETEST_WIDTH (1)
                             6610 ; 278  |#define HW_USBRX_FSCKSOURCESEL_WIDTH (1)
                             6611 ; 279  |#define HW_USBRX_REGRXDBYPASS_WIDTH (1)
                             6612 ; 280  |#define HW_USBRX_PLLLOCKED_WIDTH (1)
                             6613 ; 281  |
                             6614 ; 282  |#define HW_USBRX_ENVADJ_SETMASK (((1<<HW_USBRX_ENVADJ_WIDTH)-1)<<HW_USBRX_ENVADJ_BITPOS)
                             6615 ; 283  |#define HW_USBRX_DISCONADJ_SETMASK (((1<<HW_USBRX_DISCONADJ_WIDTH)-1)<<HW_USBRX_DISCONADJ_BITPOS)
                             6616 ; 284  |#define HW_USBRX_DEBUGMODE_SETMASK (((1<<HW_USBRX_DEBUGMODE_WIDTH)-1)<<HW_USBRX_DEBUGMODE_BITPOS)
                             6617 ; 285  |#define HW_USBRX_PLLLKTIMECTL_SETMASK (((1<<HW_USBRX_PLLLKTIMECTL_WIDTH)-1)<<HW_USBRX_PLLLKTIMECTL_BITPOS)
                             6618 ; 286  |#define HW_USBRX_PLLCKDIVCTL_SETMASK (((1<<HW_USBRX_PLLCKDIVCTL_WIDTH)-1)<<HW_USBRX_PLLCKDIVCTL_BITPOS)
                             6619 ; 287  |// 480 MHz PLL is divided by named number here. Setmask divider field nibble of 7 gives actual divider of 8 and so on. (8 gives 9, 9 gives 10)
                             6620 ; 288  |//              480Mhz/7 =68.57Mhz
                             6621 ; 289  |#define HW_USBPHYRX_PLLDIV_BY_7 0x060000
                             6622 ; 290  |
                             6623 ; 291  |//              480Mhz/8 ~60Mhz
                             6624 ; 292  |#define HW_USBPHYRX_PLLDIV_BY_8 0x070000
                             6625 ; 293  |
                             6626 ; 294  |//              480Mhz/9 =53.3Mhz
                             6627 ; 295  |#define HW_USBPHYRX_PLLDIV_BY_9 0x080000
                             6628 ; 296  |
                             6629 ; 297  |//              480Mhz/10 =48Mhz
                             6630 ; 298  |#define HW_USBPHYRX_PLLDIV_BY_10 0x090000
                             6631 ; 299  |
                             6632 ; 300  |
                             6633 ; 301  |#define HW_USBRX_HOSTMODETEST_SETMASK (((1<<HW_USBRX_HOSTMODETEST_WIDTH)-1)<<HW_USBRX_HOSTMODETEST_BITPOS)
                             6634 ; 302  |#define HW_USBRX_FSCKSOURCESEL_SETMASK (((1<<HW_USBRX_FSCKSOURCESEL_WIDTH)-1)<<HW_USBRX_FSCKSOURCESEL_BITPOS)
                             6635 ; 303  |#define HW_USBRX_REGRXDBYPASS_SETMASK (((1<<HW_USBRX_REGRXDBYPASS_WIDTH)-1)<<HW_USBRX_REGRXDBYPASS_BITPOS)
                             6636 ; 304  |#define HW_USBRX_PLLLOCKED_SETMASK (((1<<HW_USBRX_PLLLOCKED_WIDTH)-1)<<HW_USBRX_PLLLOCKED_BITPOS)
                             6637 ; 305  |
                             6638 ; 306  |#define HW_USBRX_ENVADJ_CLRMASK (~(WORD)HW_USBRX_ENVADJ_SETMASK)
                             6639 ; 307  |#define HW_USBRX_DISCONADJ_CLRMASK (~(WORD)HW_USBRX_DISCONADJ_SETMASK)
                             6640 ; 308  |#define HW_USBRX_DEBUGMODE_CLRMASK (~(WORD)HW_USBRX_DEBUGMODE_SETMASK)
                             6641 ; 309  |#define HW_USBRX_PLLLKTIMECTL_CLRMASK (~(WORD)HW_USBRX_PLLLKTIMECTL_SETMASK)
                             6642 ; 310  |#define HW_USBRX_PLLCKDIVCTL_CLRMASK (~(WORD)HW_USBRX_PLLCKDIVCTL_SETMASK)
                             6643 ; 311  |#define HW_USBRX_HOSTMODETEST_CLRMASK (~(WORD)HW_USBRX_HOSTMODETEST_SETMASK)
                             6644 ; 312  |#define HW_USBRX_FSCKSOURCESEL_CLRMASK (~(WORD)HW_USBRX_FSCKSOURCESEL_SETMASK)
                             6645 ; 313  |#define HW_USBRX_REGRXDBYPASS_CLRMASK (~(WORD)HW_USBRX_REGRXDBYPASS_SETMASK)
                             6646 ; 314  |#define HW_USBRX_PLLLOCKED_CLRMASK (~(WORD)HW_USBRX_PLLLOCKED_SETMASK)
                             6647 ; 315  |
                             6648 ; 316  |typedef union               
                             6649 ; 317  |{
                             6650 ; 318  |    struct {
                             6651 ; 319  |     int ENVADJ               :4;
                             6652 ; 320  |     int DISCONADJ            :4;
                             6653 ; 321  |     int DEBUGMODE            :4;
                             6654 ; 322  |     int PLLLKTIMECTL         :4;
                             6655 ; 323  |     int PLLCKDIVCTL          :4;
                             6656 ; 324  |     int HOSTMODETEST         :1;
                             6657 ; 325  |     int FSCKSOURCESEL        :1;
                             6658 ; 326  |     int REGRXDBYPASS         :1;
                             6659 ; 327  |     int PLLLOCKED            :1;
                             6660 ; 328  |    } B;
                             6661 ; 329  |    int I;
                             6662 ; 330  |} usbphyrx_type;
                             6663 ; 331  |#define HW_USBPHYRX      (*(volatile usbphyrx_type _X*) (HW_USBPHY_BASEADDR+3))    
                             6664 ; 332  |
                             6665 ; 333  |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  27

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6666 ; 334  |
                             6667 
                             6669 
                             6670 ; 23   |#include "regsdcdc.h"
                             6671 
                             6673 
                             6674 ; 1    |#if !(defined(regsdcdcinc))
                             6675 ; 2    |
                             6676 ; 3    |#define regssysteminc 1
                             6677 ; 4    |
                             6678 ; 5    |
                             6679 ; 6    |
                             6680 ; 7    |#include "types.h"
                             6681 
                             6683 
                             6684 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             6685 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             6686 ; 3    |//
                             6687 ; 4    |// Filename: types.h
                             6688 ; 5    |// Description: Standard data types
                             6689 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             6690 ; 7    |
                             6691 ; 8    |#ifndef _TYPES_H
                             6692 ; 9    |#define _TYPES_H
                             6693 ; 10   |
                             6694 ; 11   |// TODO:  move this outta here!
                             6695 ; 12   |#if !defined(NOERROR)
                             6696 ; 13   |#define NOERROR 0
                             6697 ; 14   |#define SUCCESS 0
                             6698 ; 15   |#endif 
                             6699 ; 16   |#if !defined(SUCCESS)
                             6700 ; 17   |#define SUCCESS  0
                             6701 ; 18   |#endif
                             6702 ; 19   |#if !defined(ERROR)
                             6703 ; 20   |#define ERROR   -1
                             6704 ; 21   |#endif
                             6705 ; 22   |#if !defined(FALSE)
                             6706 ; 23   |#define FALSE 0
                             6707 ; 24   |#endif
                             6708 ; 25   |#if !defined(TRUE)
                             6709 ; 26   |#define TRUE  1
                             6710 ; 27   |#endif
                             6711 ; 28   |
                             6712 ; 29   |#if !defined(NULL)
                             6713 ; 30   |#define NULL 0
                             6714 ; 31   |#endif
                             6715 ; 32   |
                             6716 ; 33   |#define MAX_INT     0x7FFFFF
                             6717 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             6718 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             6719 ; 36   |#define MAX_ULONG   (-1) 
                             6720 ; 37   |
                             6721 ; 38   |#define WORD_SIZE   24              // word size in bits
                             6722 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             6723 ; 40   |
                             6724 ; 41   |
                             6725 ; 42   |#define BYTE    unsigned char       // btVarName
                             6726 ; 43   |#define CHAR    signed char         // cVarName
                             6727 ; 44   |#define USHORT  unsigned short      // usVarName
                             6728 ; 45   |#define SHORT   unsigned short      // sVarName
                             6729 ; 46   |#define WORD    unsigned int        // wVarName
                             6730 ; 47   |#define INT     signed int          // iVarName
                             6731 ; 48   |#define DWORD   unsigned long       // dwVarName
                             6732 ; 49   |#define LONG    signed long         // lVarName
                             6733 ; 50   |#define BOOL    unsigned int        // bVarName
                             6734 ; 51   |#define FRACT   _fract              // frVarName
                             6735 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             6736 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             6737 ; 54   |#define FLOAT   float               // fVarName
                             6738 ; 55   |#define DBL     double              // dVarName
                             6739 ; 56   |#define ENUM    enum                // eVarName
                             6740 ; 57   |#define CMX     _complex            // cmxVarName
                             6741 ; 58   |typedef WORD UCS3;                   // 
                             6742 ; 59   |
                             6743 ; 60   |#define UINT16  unsigned short
                             6744 ; 61   |#define UINT8   unsigned char   
                             6745 ; 62   |#define UINT32  unsigned long
                             6746 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             6747 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             6748 ; 65   |#define WCHAR   UINT16
                             6749 ; 66   |
                             6750 ; 67   |//UINT128 is 16 bytes or 6 words
                             6751 ; 68   |typedef struct UINT128_3500 {   
                             6752 ; 69   |    int val[6];     
                             6753 ; 70   |} UINT128_3500;
                             6754 ; 71   |
                             6755 ; 72   |#define UINT128   UINT128_3500
                             6756 ; 73   |
                             6757 ; 74   |// Little endian word packed byte strings:   
                             6758 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             6759 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             6760 ; 77   |// Little endian word packed byte strings:   
                             6761 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             6762 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             6763 ; 80   |
                             6764 ; 81   |// Declare Memory Spaces To Use When Coding
                             6765 ; 82   |// A. Sector Buffers
                             6766 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             6767 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             6768 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             6769 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             6770 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             6771 ; 88   |// B. Media DDI Memory
                             6772 ; 89   |#define MEDIA_DDI_MEM _Y
                             6773 ; 90   |
                             6774 ; 91   |
                             6775 ; 92   |
                             6776 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             6777 ; 94   |// Examples of circular pointers:
                             6778 ; 95   |//    INT CIRC cpiVarName
                             6779 ; 96   |//    DWORD CIRC cpdwVarName
                             6780 ; 97   |
                             6781 ; 98   |#define RETCODE INT                 // rcVarName
                             6782 ; 99   |
                             6783 ; 100  |// generic bitfield structure
                             6784 ; 101  |struct Bitfield {
                             6785 ; 102  |    unsigned int B0  :1;
                             6786 ; 103  |    unsigned int B1  :1;
                             6787 ; 104  |    unsigned int B2  :1;
                             6788 ; 105  |    unsigned int B3  :1;
                             6789 ; 106  |    unsigned int B4  :1;
                             6790 ; 107  |    unsigned int B5  :1;
                             6791 ; 108  |    unsigned int B6  :1;
                             6792 ; 109  |    unsigned int B7  :1;
                             6793 ; 110  |    unsigned int B8  :1;
                             6794 ; 111  |    unsigned int B9  :1;
                             6795 ; 112  |    unsigned int B10 :1;
                             6796 ; 113  |    unsigned int B11 :1;
                             6797 ; 114  |    unsigned int B12 :1;
                             6798 ; 115  |    unsigned int B13 :1;
                             6799 ; 116  |    unsigned int B14 :1;
                             6800 ; 117  |    unsigned int B15 :1;
                             6801 ; 118  |    unsigned int B16 :1;
                             6802 ; 119  |    unsigned int B17 :1;
                             6803 ; 120  |    unsigned int B18 :1;
                             6804 ; 121  |    unsigned int B19 :1;
                             6805 ; 122  |    unsigned int B20 :1;
                             6806 ; 123  |    unsigned int B21 :1;
                             6807 ; 124  |    unsigned int B22 :1;
                             6808 ; 125  |    unsigned int B23 :1;
                             6809 ; 126  |};
                             6810 ; 127  |
                             6811 ; 128  |union BitInt {
                             6812 ; 129  |        struct Bitfield B;
                             6813 ; 130  |        int        I;
                             6814 ; 131  |};
                             6815 ; 132  |
                             6816 ; 133  |#define MAX_MSG_LENGTH 10
                             6817 ; 134  |struct CMessage
                             6818 ; 135  |{
                             6819 ; 136  |        unsigned int m_uLength;
                             6820 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             6821 ; 138  |};
                             6822 ; 139  |
                             6823 ; 140  |typedef struct {
                             6824 ; 141  |    WORD m_wLength;
                             6825 ; 142  |    WORD m_wMessage;
                             6826 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             6827 ; 144  |} Message;
                             6828 ; 145  |
                             6829 ; 146  |struct MessageQueueDescriptor
                             6830 ; 147  |{
                             6831 ; 148  |        int *m_pBase;
                             6832 ; 149  |        int m_iModulo;
                             6833 ; 150  |        int m_iSize;
                             6834 ; 151  |        int *m_pHead;
                             6835 ; 152  |        int *m_pTail;
                             6836 ; 153  |};
                             6837 ; 154  |
                             6838 ; 155  |struct ModuleEntry
                             6839 ; 156  |{
                             6840 ; 157  |    int m_iSignaledEventMask;
                             6841 ; 158  |    int m_iWaitEventMask;
                             6842 ; 159  |    int m_iResourceOfCode;
                             6843 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             6844 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             6845 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             6846 ; 163  |    int m_uTimeOutHigh;
                             6847 ; 164  |    int m_uTimeOutLow;
                             6848 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             6849 ; 166  |};
                             6850 ; 167  |
                             6851 ; 168  |union WaitMask{
                             6852 ; 169  |    struct B{
                             6853 ; 170  |        unsigned int m_bNone     :1;
                             6854 ; 171  |        unsigned int m_bMessage  :1;
                             6855 ; 172  |        unsigned int m_bTimer    :1;
                             6856 ; 173  |        unsigned int m_bButton   :1;
                             6857 ; 174  |    } B;
                             6858 ; 175  |    int I;
                             6859 ; 176  |} ;
                             6860 ; 177  |
                             6861 ; 178  |
                             6862 ; 179  |struct Button {
                             6863 ; 180  |        WORD wButtonEvent;
                             6864 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             6865 ; 182  |};
                             6866 ; 183  |
                             6867 ; 184  |struct Message {
                             6868 ; 185  |        WORD wMsgLength;
                             6869 ; 186  |        WORD wMsgCommand;
                             6870 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             6871 ; 188  |};
                             6872 ; 189  |
                             6873 ; 190  |union EventTypes {
                             6874 ; 191  |        struct CMessage msg;
                             6875 ; 192  |        struct Button Button ;
                             6876 ; 193  |        struct Message Message;
                             6877 ; 194  |};
                             6878 ; 195  |
                             6879 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             6880 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             6881 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             6882 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             6883 ; 200  |
                             6884 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             6885 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             6886 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             6887 ; 204  |
                             6888 ; 205  |#if DEBUG
                             6889 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             6890 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             6891 ; 208  |#else 
                             6892 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             6893 ; 210  |#define DebugBuildAssert(x)    
                             6894 ; 211  |#endif
                             6895 ; 212  |
                             6896 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             6897 ; 214  |//  #pragma asm
                             6898 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             6899 ; 216  |//  #pragma endasm
                             6900 ; 217  |
                             6901 ; 218  |
                             6902 ; 219  |#ifdef COLOR_262K
                             6903 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             6904 ; 221  |#elif defined(COLOR_65K)
                             6905 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             6906 ; 223  |#else
                             6907 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             6908 ; 225  |#endif
                             6909 ; 226  |    
                             6910 ; 227  |#endif // #ifndef _TYPES_H
                             6911 
                             6913 
                             6914 ; 8    |
                             6915 ; 9    |
                             6916 ; 10   |
                             6917 ; 11   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             6918 ; 12   |
                             6919 ; 13   |//   SYSTEM STMP Registers 
                             6920 ; 14   |//      Last Edited 2.19.2003 M. May
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  28

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6921 ; 15   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             6922 ; 16   |
                             6923 ; 17   |#define HW_DCDC_BASEADDR (0xFA0C)
                             6924 ; 18   |
                             6925 ; 19   |
                             6926 ; 20   |
                             6927 ; 21   |
                             6928 ; 22   |
                             6929 ; 23   |
                             6930 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                             6931 ; 25   |
                             6932 ; 26   |//  DcDc#1 Control Register (HW_DCDC1_CTRL0) Bit Definitions
                             6933 ; 27   |
                             6934 ; 28   |#define HW_DCDC1_CTRL0_PLEVBU_WIDTH (5)
                             6935 ; 29   |#define HW_DCDC1_CTRL0_RSVD0_WIDTH (3)
                             6936 ; 30   |#define HW_DCDC1_CTRL0_PLEVBO_WIDTH (5)
                             6937 ; 31   |#define HW_DCDC1_CTRL0_RSVD1_WIDTH (3)
                             6938 ; 32   |#define HW_DCDC1_CTRL0_NLEV_WIDTH (5)
                             6939 ; 33   |
                             6940 ; 34   |#define HW_DCDC1_CTRL0_RSVD2_WIDTH (3)
                             6941 ; 35   |
                             6942 ; 36   |
                             6943 ; 37   |
                             6944 ; 38   |#define HW_DCDC1_CTRL0_PLEVBU_BITPOS (0)
                             6945 ; 39   |#define HW_DCDC1_CTRL0_PLEVBO_BITPOS (8)
                             6946 ; 40   |#define HW_DCDC1_CTRL0_NLEV_BITPOS (16)
                             6947 ; 41   |
                             6948 ; 42   |
                             6949 ; 43   |
                             6950 ; 44   |#define HW_DCDC1_CTRL0_PLEVBU_SETMASK (((1<<HW_DCDC1_CTRL0_PLEVBU_WIDTH)-1)<<HW_DCDC1_CTRL0_PLEVBU_BITPOS)        
                             6951 ; 45   |#define HW_DCDC1_CTRL0_PLEVBO_SETMASK (((1<<HW_DCDC1_CTRL0_PLEVBO_WIDTH)-1)<<HW_DCDC1_CTRL0_PLEVBO_BITPOS) 
                             6952 ; 46   |#define HW_DCDC1_CTRL0_NLEV_SETMASK (((1<<HW_DCDC1_CTRL0_NLEV_WIDTH)-1)<<HW_DCDC1_CTRL0_NLEV_BITPOS)  
                             6953 ; 47   |
                             6954 ; 48   |
                             6955 ; 49   |
                             6956 ; 50   |#define HW_DCDC1_CTRL0_PLEVBU_CLRMASK (~(WORD)HW_DCDC1_CTRL0_PLEVBU_SETMASK)     
                             6957 ; 51   |#define HW_DCDC1_CTRL0_PLEVBO_CLRMASK (~(WORD)HW_DCDC1_CTRL0_PLEVBO_SETMASK) 
                             6958 ; 52   |#define HW_DCDC1_CTRL0_NLEV_CLRMASK (~(WORD)HW_DCDC1_CTRL0_NLEV_SETMASK)  
                             6959 ; 53   |
                             6960 ; 54   |
                             6961 ; 55   |
                             6962 ; 56   |
                             6963 ; 57   |
                             6964 ; 58   |typedef union               
                             6965 ; 59   |{
                             6966 ; 60   |    struct {
                             6967 ; 61   |        unsigned int PLEVBU           : HW_DCDC1_CTRL0_PLEVBU_WIDTH;
                             6968 ; 62   |        unsigned int RSVD0            : HW_DCDC1_CTRL0_RSVD0_WIDTH;
                             6969 ; 63   |        unsigned int PLEVBO           : HW_DCDC1_CTRL0_PLEVBO_WIDTH;
                             6970 ; 64   |        unsigned int RSVD1            : HW_DCDC1_CTRL0_RSVD1_WIDTH;
                             6971 ; 65   |        unsigned int NLEV             : HW_DCDC1_CTRL0_NLEV_WIDTH;
                             6972 ; 66   |        unsigned int RSVD2            : HW_DCDC1_CTRL0_RSVD2_WIDTH;
                             6973 ; 67   |    } B;
                             6974 ; 68   |    unsigned int I;
                             6975 ; 69   |} dcdc1_ctrl0_type;
                             6976 ; 70   |#define HW_DCDC1_CTRL0      (*(volatile dcdc1_ctrl0_type _X*) (HW_DCDC_BASEADDR))    /* DcDc#1 Limit Level Register */
                             6977 ; 71   |
                             6978 ; 72   |
                             6979 ; 73   |
                             6980 ; 74   |
                             6981 ; 75   |/////////////////////////////////////////////////////////////////////////////////
                             6982 ; 76   |
                             6983 ; 77   |//  DCDc#1 Control Register1 (HW_DCDC1_CTRL1) Bit Definitions
                             6984 ; 78   |
                             6985 ; 79   |#define HW_DCDC1_CTRL1_C_WIDTH (4)
                             6986 ; 80   |#define HW_DCDC1_CTRL1_R_WIDTH (4)
                             6987 ; 81   |#define HW_DCDC1_CTRL1_FFOR_WIDTH (3)
                             6988 ; 82   |#define HW_DCDC1_CTRL1_RSVD0_WIDTH (1)
                             6989 ; 83   |#define HW_DCDC1_CTRL1_PFMCTRL_WIDTH (12)
                             6990 ; 84   |
                             6991 ; 85   |
                             6992 ; 86   |
                             6993 ; 87   |#define HW_DCDC1_CTRL1_C_BITPOS (0)
                             6994 ; 88   |#define HW_DCDC1_CTRL1_R_BITPOS (4)
                             6995 ; 89   |#define HW_DCDC1_CTRL1_FFOR_BITPOS (8)
                             6996 ; 90   |#define HW_DCDC1_CTRL1_PFMCTRL_BITPOS (12) 
                             6997 ; 91   |
                             6998 ; 92   |#define HW_DCDC1_CTRL1_C_SETMASK (((1<<HW_DCDC1_CTRL1_C_WIDTH)-1)<<HW_DCDC1_CTRL1_C_BITPOS)        
                             6999 ; 93   |#define HW_DCDC1_CTRL1_R_SETMASK (((1<<HW_DCDC1_CTRL1_R_WIDTH)-1)<<HW_DCDC1_CTRL1_R_BITPOS) 
                             7000 ; 94   |#define HW_DCDC1_CTRL1_FFOR_SETMASK (((1<<HW_DCDC1_CTRL1_FFOR_WIDTH)-1)<<HW_DCDC1_CTRL1_FFOR_BITPOS)  
                             7001 ; 95   |#define HW_DCDC1_CTRL1_PFMCTRL_SETMASK (((1<<HW_DCDC1_CTRL1_PFMCTRL_WIDTH)-1)<<HW_DCDC1_CTRL1_PFMCTRL_BITPOS)   
                             7002 ; 96   |
                             7003 ; 97   |#define HW_DCDC1_CTRL1_C_CLRMASK (~(WORD)HW_DCDC1_CTRL1_C_SETMASK)     
                             7004 ; 98   |#define HW_DCDC1_CTRL1_R_CLRMASK (~(WORD)HW_DCDC1_CTRL1_R_SETMASK) 
                             7005 ; 99   |#define HW_DCDC1_CTRL1_FFOR_CLRMASK (~(WORD)HW_DCDC1_CTRL1_FFOR_SETMASK)  
                             7006 ; 100  |#define HW_DCDC1_CTRL1_PFMCTRL_CLRMASK (~(WORD)HW_DCDC1_CTRL1_PFMCTRL_SETMASK)  
                             7007 ; 101  |
                             7008 ; 102  |
                             7009 ; 103  |typedef union               
                             7010 ; 104  |{
                             7011 ; 105  |    struct {
                             7012 ; 106  |        unsigned int C       : HW_DCDC1_CTRL1_C_WIDTH;
                             7013 ; 107  |        unsigned int R                : HW_DCDC1_CTRL1_R_WIDTH;
                             7014 ; 108  |        unsigned int FFOR             : HW_DCDC1_CTRL1_FFOR_WIDTH;
                             7015 ; 109  |        unsigned int RSVD0            : HW_DCDC1_CTRL1_RSVD0_WIDTH;
                             7016 ; 110  |        unsigned int PFMCTRL          : HW_DCDC1_CTRL1_FFOR_WIDTH;
                             7017 ; 111  |    } B;
                             7018 ; 112  |    unsigned int I;
                             7019 ; 113  |} dcdc1_ctrl1_type;
                             7020 ; 114  |#define HW_DCDC1_CTRL1      (*(volatile dcdc1_ctrl1_type _X*) (HW_DCDC_BASEADDR+1))    /* DcDc#1 Ctrl #1 Register */
                             7021 ; 115  |
                             7022 ; 116  |
                             7023 ; 117  |
                             7024 ; 118  |
                             7025 ; 119  |/////////////////////////////////////////////////////////////////////////////////
                             7026 ; 120  |
                             7027 ; 121  |//  DcDc VDDIO Register (HW_DCDC_VDDIO) Bit Definitions
                             7028 ; 122  |
                             7029 ; 123  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_WIDTH (5)
                             7030 ; 124  |#define HW_DCDC_VDDIO_RSVD0_WIDTH (3)
                             7031 ; 125  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_WIDTH (5)
                             7032 ; 126  |#define HW_DCDC_VDDIO_RSVD1_WIDTH (3)
                             7033 ; 127  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_WIDTH (1)
                             7034 ; 128  |#define HW_DCDC_VDDIO_RSVD2_WIDTH (3)
                             7035 ; 129  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_WIDTH (1)
                             7036 ; 130  |#define HW_DCDC_VDDIO_OK_WIDTH (1)
                             7037 ; 131  |#define HW_DCDC_VDDIO_RSVD3_WIDTH (2)
                             7038 ; 132  |
                             7039 ; 133  |
                             7040 ; 134  |
                             7041 ; 135  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_BITPOS (0)
                             7042 ; 136  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_BITPOS (8)
                             7043 ; 137  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_BITPOS (16)
                             7044 ; 138  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_BITPOS (20)
                             7045 ; 139  |#define HW_DCDC_VDDIO_OK_BITPOS (21)
                             7046 ; 140  |
                             7047 ; 141  |
                             7048 ; 142  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_SETMASK (((1<<HW_DCDC_VDDIO_VOLTAGE_LEVEL_WIDTH)-1)<<HW_DCDC_VDDIO_VOLTAGE_LEVEL_BITPOS)        
                             7049 ; 143  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_SETMASK (((1<<HW_DCDC_VDDIO_BROWNOUT_LEVEL_WIDTH)-1)<<HW_DCDC_VDDIO_BROWNOUT_LEVEL_BITPOS) 
                             7050 ; 144  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_SETMASK (((1<<HW_DCDC_VDDIO_BROWNOUT_ENABLE_WIDTH)-1)<<HW_DCDC_VDDIO_BROWNOUT_ENABLE_BITPOS)  
                             7051 ; 145  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_SETMASK (((1<<HW_DCDC_VDDIO_BROWNOUT_STATUS_WIDTH)-1)<<HW_DCDC_VDDIO_BROWNOUT_STATUS_BITPOS)  
                             7052 ; 146  |
                             7053 ; 147  |
                             7054 ; 148  |
                             7055 ; 149  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDIO_VOLTAGE_LEVEL_SETMASK)     
                             7056 ; 150  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDIO_BROWNOUT_LEVEL_SETMASK) 
                             7057 ; 151  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_CLRMASK (~(WORD)HW_DCDC_VDDIO_BROWNOUT_ENABLE_SETMASK)  
                             7058 ; 152  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_CLRMASK (~(WORD)HW_DCDC_VDDIO_BROWNOUT_STATUS_SETMASK)  
                             7059 ; 153  |
                             7060 ; 154  |
                             7061 ; 155  |typedef union               
                             7062 ; 156  |{
                             7063 ; 157  |    struct {
                             7064 ; 158  |        unsigned int VOLTAGE_LEVEL    : HW_DCDC_VDDIO_VOLTAGE_LEVEL_WIDTH;
                             7065 ; 159  |        unsigned int RSVD0            : HW_DCDC_VDDIO_RSVD0_WIDTH;
                             7066 ; 160  |        unsigned int BROWNOUT_LEVEL   : HW_DCDC_VDDIO_BROWNOUT_LEVEL_WIDTH;
                             7067 ; 161  |        unsigned int RSVD1            : HW_DCDC_VDDIO_RSVD1_WIDTH;
                             7068 ; 162  |        unsigned int BROWNOUT_ENABLE  : HW_DCDC_VDDIO_BROWNOUT_ENABLE_WIDTH;
                             7069 ; 163  |        unsigned int RSVD2            : HW_DCDC_VDDIO_RSVD2_WIDTH;
                             7070 ; 164  |        unsigned int BROWNOUT_STATUS  : HW_DCDC_VDDIO_BROWNOUT_STATUS_WIDTH;
                             7071 ; 165  |                 unsigned int VDDIO_OK        : HW_DCDC_VDDIO_OK_WIDTH;
                             7072 ; 166  |        unsigned int RSVD3            : HW_DCDC_VDDIO_RSVD3_WIDTH;
                             7073 ; 167  |    } B;
                             7074 ; 168  |    unsigned int I;
                             7075 ; 169  |} dcdc_vddio_type;
                             7076 ; 170  |#define HW_DCDC_VDDIO      (*(volatile dcdc_vddio_type _X*) (HW_DCDC_BASEADDR+2))    /* DcDc VDDIO Register */
                             7077 ; 171  |
                             7078 ; 172  |
                             7079 ; 173  |
                             7080 ; 174  |/////////////////////////////////////////////////////////////////////////////////
                             7081 ; 175  |//  DcDc VDDD Register (HW_DCDC_VDDD) Bit Definitions
                             7082 ; 176  |
                             7083 ; 177  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_WIDTH (5)
                             7084 ; 178  |#define HW_DCDC_VDDD_RSVD0_WIDTH (3)
                             7085 ; 179  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_WIDTH (5)
                             7086 ; 180  |#define HW_DCDC_VDDD_RSVD1_WIDTH (3)
                             7087 ; 181  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_WIDTH (1)
                             7088 ; 182  |#define HW_DCDC_VDDD_RSVD2_WIDTH (3)
                             7089 ; 183  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_WIDTH (1)
                             7090 ; 184  |#define HW_DCDC_VDDD_OK_WIDTH (1)
                             7091 ; 185  |#define HW_DCDC_VDDD_RSVD3_WIDTH (2)
                             7092 ; 186  |
                             7093 ; 187  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_BITPOS (0)
                             7094 ; 188  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_BITPOS (8)
                             7095 ; 189  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_BITPOS (16)
                             7096 ; 190  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_BITPOS (20)
                             7097 ; 191  |#define HW_DCDC_VDDD_OK_BITPOS (21)
                             7098 ; 192  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_SETMASK (((1<<HW_DCDC_VDDD_VOLTAGE_LEVEL_WIDTH)-1)<<HW_DCDC_VDDD_VOLTAGE_LEVEL_BITPOS)        
                             7099 ; 193  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_SETMASK (((1<<HW_DCDC_VDDD_BROWNOUT_LEVEL_WIDTH)-1)<<HW_DCDC_VDDD_BROWNOUT_LEVEL_BITPOS) 
                             7100 ; 194  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_SETMASK (((1<<HW_DCDC_VDDD_BROWNOUT_ENABLE_WIDTH)-1)<<HW_DCDC_VDDD_BROWNOUT_ENABLE_BITPOS)  
                             7101 ; 195  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_SETMASK (((1<<HW_DCDC_VDDD_BROWNOUT_STATUS_WIDTH)-1)<<HW_DCDC_VDDD_BROWNOUT_STATUS_BITPOS)  
                             7102 ; 196  |
                             7103 ; 197  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDD_VOLTAGE_LEVEL_SETMASK)     
                             7104 ; 198  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDD_BROWNOUT_LEVEL_SETMASK) 
                             7105 ; 199  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_CLRMASK (~(WORD)HW_DCDC_VDDD_BROWNOUT_ENABLE_SETMASK)  
                             7106 ; 200  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_CLRMASK (~(WORD)HW_DCDC_VDDD_BROWNOUT_STATUS_SETMASK)  
                             7107 ; 201  |
                             7108 ; 202  |typedef union               
                             7109 ; 203  |{
                             7110 ; 204  |    struct {
                             7111 ; 205  |        unsigned int VOLTAGE_LEVEL    : HW_DCDC_VDDD_VOLTAGE_LEVEL_WIDTH;
                             7112 ; 206  |        unsigned int RSVD0            : HW_DCDC_VDDD_RSVD0_WIDTH;
                             7113 ; 207  |        unsigned int BROWNOUT_LEVEL   : HW_DCDC_VDDD_BROWNOUT_LEVEL_WIDTH;
                             7114 ; 208  |        unsigned int RSVD1            : HW_DCDC_VDDD_RSVD1_WIDTH;
                             7115 ; 209  |        unsigned int BROWNOUT_ENABLE  : HW_DCDC_VDDD_BROWNOUT_ENABLE_WIDTH;
                             7116 ; 210  |        unsigned int RSVD2            : HW_DCDC_VDDD_RSVD2_WIDTH;
                             7117 ; 211  |        unsigned int BROWNOUT_STATUS  : HW_DCDC_VDDD_BROWNOUT_STATUS_WIDTH;
                             7118 ; 212  |                 unsigned int VDD_OK           : HW_DCDC_VDDD_OK_WIDTH;
                             7119 ; 213  |        unsigned int RSVD3            : HW_DCDC_VDDD_RSVD3_WIDTH;
                             7120 ; 214  |    } B;
                             7121 ; 215  |   unsigned int I;
                             7122 ; 216  |        unsigned U;
                             7123 ; 217  |} dcdc_vddd_type;
                             7124 ; 218  |#define HW_DCDC_VDDD      (*(volatile dcdc_vddd_type _X*) (HW_DCDC_BASEADDR+3))    /* DcDc VDDD Register */
                             7125 ; 219  |
                             7126 ; 220  |
                             7127 ; 221  |
                             7128 ; 222  |
                             7129 ; 223  |/////////////////////////////////////////////////////////////////////////////////
                             7130 ; 224  |
                             7131 ; 225  |//  DcDc Vdda Register (HW_DCDC_VDDA) Bit Definitions
                             7132 ; 226  |
                             7133 ; 227  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_WIDTH (5)
                             7134 ; 228  |#define HW_DCDC_VDDA_RSVD0_WIDTH (3)
                             7135 ; 229  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_WIDTH (5)
                             7136 ; 230  |#define HW_DCDC_VDDA_RSVD1_WIDTH (3)
                             7137 ; 231  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_WIDTH (1)
                             7138 ; 232  |#define HW_DCDC_VDDA_RSVD2_WIDTH (3)
                             7139 ; 233  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_WIDTH (1)
                             7140 ; 234  |#define HW_DCDC_VDDA_OK_WIDTH (1)
                             7141 ; 235  |#define HW_DCDC_VDDA_RSVD3_WIDTH (2)
                             7142 ; 236  |
                             7143 ; 237  |
                             7144 ; 238  |
                             7145 ; 239  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_BITPOS (0)
                             7146 ; 240  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_BITPOS (8)
                             7147 ; 241  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_BITPOS (16)
                             7148 ; 242  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_BITPOS (20)
                             7149 ; 243  |#define HW_DCDC_VDDA_OK_BITPOS (21)
                             7150 ; 244  |
                             7151 ; 245  |
                             7152 ; 246  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_SETMASK (((1<<HW_DCDC_VDDA_VOLTAGE_LEVEL_WIDTH)-1)<<HW_DCDC_VDDA_VOLTAGE_LEVEL_BITPOS)        
                             7153 ; 247  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_SETMASK (((1<<HW_DCDC_VDDA_BROWNOUT_LEVEL_WIDTH)-1)<<HW_DCDC_VDDA_BROWNOUT_LEVEL_BITPOS) 
                             7154 ; 248  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_SETMASK (((1<<HW_DCDC_VDDA_BROWNOUT_ENABLE_WIDTH)-1)<<HW_DCDC_VDDA_BROWNOUT_ENABLE_BITPOS)  
                             7155 ; 249  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_SETMASK (((1<<HW_DCDC_VDDA_BROWNOUT_STATUS_WIDTH)-1)<<HW_DCDC_VDDA_BROWNOUT_STATUS_BITPOS)  
                             7156 ; 250  |
                             7157 ; 251  |
                             7158 ; 252  |
                             7159 ; 253  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDA_VOLTAGE_LEVEL_SETMASK)     
                             7160 ; 254  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDA_BROWNOUT_LEVEL_SETMASK) 
                             7161 ; 255  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_CLRMASK (~(WORD)HW_DCDC_VDDA_BROWNOUT_ENABLE_SETMASK)  
                             7162 ; 256  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_CLRMASK (~(WORD)HW_DCDC_VDDA_BROWNOUT_STATUS_SETMASK)  
                             7163 ; 257  |
                             7164 ; 258  |
                             7165 ; 259  |typedef union               
                             7166 ; 260  |{
                             7167 ; 261  |    struct {
                             7168 ; 262  |        unsigned int VOLTAGE_LEVEL    : HW_DCDC_VDDA_VOLTAGE_LEVEL_WIDTH;
                             7169 ; 263  |        unsigned int RSVD0            : HW_DCDC_VDDA_RSVD0_WIDTH;
                             7170 ; 264  |        unsigned int BROWNOUT_LEVEL   : HW_DCDC_VDDA_BROWNOUT_LEVEL_WIDTH;
                             7171 ; 265  |        unsigned int RSVD1            : HW_DCDC_VDDA_RSVD1_WIDTH;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  29

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7172 ; 266  |        unsigned int BROWNOUT_ENABLE  : HW_DCDC_VDDA_BROWNOUT_ENABLE_WIDTH;
                             7173 ; 267  |        unsigned int RSVD2            : HW_DCDC_VDDA_RSVD2_WIDTH;
                             7174 ; 268  |        unsigned int BROWNOUT_STATUS  : HW_DCDC_VDDA_BROWNOUT_STATUS_WIDTH;
                             7175 ; 269  |             unsigned int VDDA_OK          : HW_DCDC_VDDA_OK_WIDTH;
                             7176 ; 270  |        unsigned int RSVD3            : HW_DCDC_VDDA_RSVD3_WIDTH;
                             7177 ; 271  |    } B;
                             7178 ; 272  |    unsigned int I;
                             7179 ; 273  |} dcdc_vdda_type;
                             7180 ; 274  |#define HW_DCDC_VDDA      (*(volatile dcdc_vdda_type _X*) (HW_DCDC_BASEADDR+4))    /* DcDc VDDA Register */
                             7181 ; 275  |
                             7182 ; 276  |
                             7183 ; 277  |
                             7184 ; 278  |
                             7185 ; 279  |/////////////////////////////////////////////////////////////////////////////////
                             7186 ; 280  |
                             7187 ; 281  |//  DcDc#2 Control Register 0 (HW_DCDC2_CTRL0) Bit Definitions
                             7188 ; 282  |
                             7189 ; 283  |#define HW_DCDC2_CTRL0_PLEVBU_WIDTH (5)
                             7190 ; 284  |#define HW_DCDC2_CTRL0_RSVD0_WIDTH (3)
                             7191 ; 285  |#define HW_DCDC2_CTRL0_PLEVBO_WIDTH (5)
                             7192 ; 286  |#define HW_DCDC2_CTRL0_RSVD1_WIDTH (3)
                             7193 ; 287  |#define HW_DCDC2_CTRL0_NLEV_WIDTH (5)
                             7194 ; 288  |#define HW_DCDC2_CTRL0_RSVD2_WIDTH (3)
                             7195 ; 289  |
                             7196 ; 290  |
                             7197 ; 291  |
                             7198 ; 292  |#define HW_DCDC2_CTRL0_PLEVBU_BITPOS (0)
                             7199 ; 293  |#define HW_DCDC2_CTRL0_PLEVBO_BITPOS (8)
                             7200 ; 294  |#define HW_DCDC2_CTRL0_NLEV_BITPOS (16)
                             7201 ; 295  |
                             7202 ; 296  |#define HW_DCDC2_CTRL0_PLEVBU_SETMASK (((1<<HW_DCDC2_CTRL0_PLEVBU_WIDTH)-1)<<HW_DCDC2_CTRL0_PLEVBU_BITPOS)        
                             7203 ; 297  |#define HW_DCDC2_CTRL0_PLEVBO_SETMASK (((1<<HW_DCDC2_CTRL0_PLEVBO_WIDTH)-1)<<HW_DCDC2_CTRL0_PLEVBO_BITPOS) 
                             7204 ; 298  |#define HW_DCDC2_CTRL0_NLEV_SETMASK (((1<<HW_DCDC2_CTRL0_NLEV_WIDTH)-1)<<HW_DCDC2_CTRL0_NLEV_BITPOS)  
                             7205 ; 299  |
                             7206 ; 300  |#define HW_DCDC2_CTRL0_PLEVBU_CLRMASK (~(WORD)HW_DCDC2_CTRL0_PLEVBU_SETMASK)     
                             7207 ; 301  |#define HW_DCDC2_CTRL0_PLEVBO_CLRMASK (~(WORD)HW_DCDC2_CTRL0_PLEVBO_SETMASK) 
                             7208 ; 302  |#define HW_DCDC2_CTRL0_NLEV_CLRMASK (~(WORD)HW_DCDC2_CTRL0_NLEV_SETMASK)  
                             7209 ; 303  |
                             7210 ; 304  |
                             7211 ; 305  |typedef union               
                             7212 ; 306  |{
                             7213 ; 307  |    struct {
                             7214 ; 308  |        unsigned int PLEVBU           : HW_DCDC2_CTRL0_PLEVBU_WIDTH;
                             7215 ; 309  |        unsigned int RSVD0            : HW_DCDC2_CTRL0_RSVD0_WIDTH;
                             7216 ; 310  |        unsigned int PLEVBO           : HW_DCDC2_CTRL0_PLEVBO_WIDTH;
                             7217 ; 311  |        unsigned int RSVD1            : HW_DCDC2_CTRL0_RSVD1_WIDTH;
                             7218 ; 312  |        unsigned int NLEV             : HW_DCDC2_CTRL0_NLEV_WIDTH;
                             7219 ; 313  |        unsigned int RSVD2            : HW_DCDC2_CTRL0_RSVD2_WIDTH;
                             7220 ; 314  |    } B;
                             7221 ; 315  |    unsigned int I;
                             7222 ; 316  |} dcdc2_ctrl0_type; 
                             7223 ; 317  |#define HW_DCDC2_CTRL0      (*(volatile dcdc2_ctrl0_type _X*) (HW_DCDC_BASEADDR+5))    /* DcDc#2 Limit Level Register */
                             7224 ; 318  |
                             7225 ; 319  |
                             7226 ; 320  |
                             7227 ; 321  |
                             7228 ; 322  |/////////////////////////////////////////////////////////////////////////////////
                             7229 ; 323  |
                             7230 ; 324  |//  DcDc#2 Control Register #1 (HW_DCDC2_CTRL1) Bit Definitions
                             7231 ; 325  |
                             7232 ; 326  |#define HW_DCDC2_CTRL1_C_WIDTH (4)
                             7233 ; 327  |#define HW_DCDC2_CTRL1_R_WIDTH (4)
                             7234 ; 328  |#define HW_DCDC2_CTRL1_FFOR_WIDTH (3)
                             7235 ; 329  |#define HW_DCDC2_CTRL1_RSVD0_WIDTH (1)
                             7236 ; 330  |#define HW_DCDC2_CTRL1_PFMCTRL_WIDTH (12)
                             7237 ; 331  |
                             7238 ; 332  |
                             7239 ; 333  |#define HW_DCDC2_CTRL1_C_BITPOS (0)
                             7240 ; 334  |#define HW_DCDC2_CTRL1_R_BITPOS (4)
                             7241 ; 335  |#define HW_DCDC2_CTRL1_FFOR_BITPOS (8)
                             7242 ; 336  |#define HW_DCDC2_CTRL1_PFMCTRL_BITPOS (12)
                             7243 ; 337  |
                             7244 ; 338  |
                             7245 ; 339  |
                             7246 ; 340  |#define HW_DCDC2_CTRL1_C_SETMASK (((1<<HW_DCDC2_CTRL1_C_WIDTH)-1)<<HW_DCDC2_CTRL1_C_BITPOS)        
                             7247 ; 341  |#define HW_DCDC2_CTRL1_R_SETMASK (((1<<HW_DCDC2_CTRL1_R_WIDTH)-1)<<HW_DCDC2_CTRL1_R_BITPOS) 
                             7248 ; 342  |#define HW_DCDC2_CTRL1_FFOR_SETMASK (((1<<HW_DCDC2_CTRL1_FFOR_WIDTH)-1)<<HW_DCDC2_CTRL1_FFOR_BITPOS)  
                             7249 ; 343  |#define HW_DCDC2_CTRL1_PFMCTRL_SETMASK (((1<<HW_DCDC2_CTRL1_PFMCTRL_WIDTH)-1)<<HW_DCDC2_CTRL1_PFMCTRL_BITPOS)  
                             7250 ; 344  |
                             7251 ; 345  |
                             7252 ; 346  |
                             7253 ; 347  |#define HW_DCDC2_CTRL1_C_CLRMASK (~(WORD)HW_DCDC2_CTRL1_C_SETMASK)     
                             7254 ; 348  |#define HW_DCDC2_CTRL1_R_CLRMASK (~(WORD)HW_DCDC2_CTRL1_R_SETMASK) 
                             7255 ; 349  |#define HW_DCDC2_CTRL1_FFOR_CLRMASK (~(WORD)HW_DCDC2_CTRL1_FFOR_SETMASK)  
                             7256 ; 350  |#define HW_DCDC2_CTRL1_PFMCTRL_CLRMASK (~(WORD)HW_DCDC2_CTRL1_PFMCTRL_SETMASK)  
                             7257 ; 351  |
                             7258 ; 352  |
                             7259 ; 353  |typedef union               
                             7260 ; 354  |{
                             7261 ; 355  |    struct {
                             7262 ; 356  |        unsigned int C                : HW_DCDC2_CTRL1_C_WIDTH;
                             7263 ; 357  |        unsigned int R                : HW_DCDC2_CTRL1_R_WIDTH;
                             7264 ; 358  |        unsigned int FFOR             : HW_DCDC2_CTRL1_FFOR_WIDTH;
                             7265 ; 359  |        unsigned int RSVD0            : HW_DCDC2_CTRL1_RSVD0_WIDTH;
                             7266 ; 360  |        unsigned int PFMCTRL          : HW_DCDC2_CTRL1_FFOR_WIDTH;
                             7267 ; 361  |    } B;
                             7268 ; 362  |    unsigned int I;
                             7269 ; 363  |} dcdc2_ctrl1_type;
                             7270 ; 364  |#define HW_DCDC2_CTRL1      (*(volatile dcdc2_ctrl1_type _X*) (HW_DCDC_BASEADDR+6))    /* DcDc#2 Ctrl Register #1 */
                             7271 ; 365  |
                             7272 ; 366  |
                             7273 ; 367  |
                             7274 ; 368  |
                             7275 ; 369  |/////////////////////////////////////////////////////////////////////////////////
                             7276 ; 370  |
                             7277 ; 371  |//  Speed Monitoring Register (HW_SPEED) Bit Definitions
                             7278 ; 372  |
                             7279 ; 373  |#define HW_SPEED_OSC1_PWRUP_WIDTH (1)
                             7280 ; 374  |#define HW_SPEED_OSC1_START_COUNT_WIDTH (1)
                             7281 ; 375  |#define HW_SPEED_RSVD0_WIDTH (2)
                             7282 ; 376  |#define HW_SPEED_RINGOSC1_WIDTH (7)
                             7283 ; 377  |#define HW_SPEED_RSVD1_WIDTH (1)
                             7284 ; 378  |#define HW_SPEED_OSC2_PWRUP_WIDTH (1)
                             7285 ; 379  |#define HW_SPEED_OSC2_START_COUNT_WIDTH (1)
                             7286 ; 380  |#define HW_SPEED_RSVD2_WIDTH (2)
                             7287 ; 381  |#define HW_SPEED_RINGOSC2_WIDTH (7)
                             7288 ; 382  |#define HW_SPEED_RSVD3_WIDTH (1)
                             7289 ; 383  |
                             7290 ; 384  |
                             7291 ; 385  |
                             7292 ; 386  |#define HW_SPEED_OSC1_PWRUP_BITPOS (0)
                             7293 ; 387  |#define HW_SPEED_OSC1_START_COUNT_BITPOS (1)
                             7294 ; 388  |#define HW_SPEED_RINGOSC1_BITPOS (4)
                             7295 ; 389  |#define HW_SPEED_OSC2_PWRUP_BITPOS (12)
                             7296 ; 390  |#define HW_SPEED_OSC2_START_COUNT_BITPOS (13)
                             7297 ; 391  |#define HW_SPEED_RINGOSC2_BITPOS (16)
                             7298 ; 392  |
                             7299 ; 393  |
                             7300 ; 394  |#define HW_SPEED_OSC1_PWRUP_SETMASK (((1<<HW_SPEED_OSC1_PWRUP_WIDTH)-1)<<HW_SPEED_OSC1_PWRUP_BITPOS)        
                             7301 ; 395  |#define HW_SPEED_OSC1_START_COUNT_SETMASK (((1<<HW_SPEED_OSC1_START_COUNT_WIDTH)-1)<<HW_SPEED_OSC1_START_COUNT_BITPOS)        
                             7302 ; 396  |#define HW_SPEED_RINGOSC1_SETMASK (((1<<HW_SPEED_RINGOSC1_WIDTH)-1)<<HW_SPEED_RINGOSC1_BITPOS) 
                             7303 ; 397  |#define HW_SPEED_OSC2_PWRUP_SETMASK (((1<<HW_SPEED_OSC2_PWRUP_WIDTH)-1)<<HW_SPEED_OSC2_PWRUP_BITPOS)        
                             7304 ; 398  |
                             7305 ; 399  |#define HW_SPEED_OSC2_START_COUNT_SETMASK (((1<<HW_SPEED_OSC2_START_COUNT_WIDTH)-1)<<HW_SPEED_OSC2_START_COUNT_BITPOS)        
                             7306 ; 400  |#define HW_SPEED_RINGOSC2_SETMASK (((1<<HW_SPEED_RINGOSC2_WIDTH)-1)<<HW_SPEED_RINGOSC2_BITPOS) 
                             7307 ; 401  |
                             7308 ; 402  |
                             7309 ; 403  |
                             7310 ; 404  |#define HW_SPEED_OSC1_PWRUP_CLRMASK (~(WORD)HW_SPEED_OSC1_PWRUP_SETMASK)     
                             7311 ; 405  |#define HW_SPEED_OSC1_START_COUNT_CLRMASK (~(WORD)HW_SPEED_OSC1_START_COUNT_SETMASK)     
                             7312 ; 406  |#define HW_SPEED_RINGOSC1_CLRMASK (~(WORD)HW_SPEED_RINGOSC1_SETMASK) 
                             7313 ; 407  |#define HW_SPEED_OSC2_PWRUP_CLRMASK (~(WORD)HW_SPEED_OSC2_PWRUP_SETMASK)   
                             7314 ; 408  |#define HW_SPEED_OSC2_START_COUNT_CLRMASK (~(WORD)HW_SPEED_OSC2_START_COUNT_SETMASK)     
                             7315 ; 409  |#define HW_SPEED_RINGOSC2_CLRMASK (~(WORD)HW_SPEED_RINGOSC2_SETMASK) 
                             7316 ; 410  |
                             7317 ; 411  |
                             7318 ; 412  |typedef union               
                             7319 ; 413  |{
                             7320 ; 414  |    struct {
                             7321 ; 415  |        unsigned int OSC1_PWRUP          : HW_SPEED_OSC1_PWRUP_WIDTH;
                             7322 ; 416  |        unsigned int OSC1_START_COUNT    : HW_SPEED_OSC1_START_COUNT_WIDTH;
                             7323 ; 417  |        unsigned int RSVD0               : HW_SPEED_RSVD0_WIDTH;
                             7324 ; 418  |        unsigned int RINGOSC1            : HW_SPEED_RINGOSC1_WIDTH;
                             7325 ; 419  |        unsigned int RSVD1               : HW_SPEED_RSVD1_WIDTH;
                             7326 ; 420  |        unsigned int OSC2_PWRUP          : HW_SPEED_OSC2_PWRUP_WIDTH;
                             7327 ; 421  |        unsigned int OSC2_START_COUNT    : HW_SPEED_OSC2_START_COUNT_WIDTH;
                             7328 ; 422  |        unsigned int RSVD2               : HW_SPEED_RSVD2_WIDTH;
                             7329 ; 423  |        unsigned int RINGOSC2            : HW_SPEED_RINGOSC2_WIDTH;
                             7330 ; 424  |        unsigned int RSVD3               : HW_SPEED_RSVD3_WIDTH;
                             7331 ; 425  |    } B;
                             7332 ; 426  |    unsigned int I;
                             7333 ; 427  |} speed_type;
                             7334 ; 428  |#define HW_SPEED      (*(volatile speed_type _X*) (HW_DCDC_BASEADDR+7))    /* Speed Measurement Register */
                             7335 ; 429  |
                             7336 ; 430  |
                             7337 ; 431  |
                             7338 ; 432  |
                             7339 ; 433  |
                             7340 ; 434  |
                             7341 ; 435  |
                             7342 ; 436  |// DC DC Test Bit Register (HW_DCDCTBR) Definitions
                             7343 ; 437  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_WIDTH 4
                             7344 ; 438  |#define HW_DCDC_TBR_DCDC1_DIS_5BIT_WIDTH 1
                             7345 ; 439  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_WIDTH 1
                             7346 ; 440  |#define HW_DCDC_TBR_DCDC1_CLK4X_WIDTH 1
                             7347 ; 441  |#define HW_DCDC_TBR_DCDC1_CLK2X_WIDTH 1
                             7348 ; 442  |#define HW_DCDC_TBR_DCDC1_NOZERO_WIDTH 1
                             7349 ; 443  |#define HW_DCDC_TBR_DCDC1_VDD5V_ACTIVE_WIDTH 1
                             7350 ; 444  |#define HW_DCDC_TBR_DCDC1_PFM_WIDTH 1
                             7351 ; 445  |#define HW_DCDC_TBR_DCDC1_STOPCLK_WIDTH 1
                             7352 ; 446  |#define HW_DCDC_TBR_PWRUP_VDDIO_BRNOUT_WIDTH 1
                             7353 ; 447  |#define HW_DCDC_TBR_DCDC_ANA_LESSI_WIDTH 1
                             7354 ; 448  |#define HW_DCDC_TBR_DCDC_MORE_CAP_WIDTH 1
                             7355 ; 449  |#define HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_WIDTH 1
                             7356 ; 450  |#define HW_DCDC_TBR_DCDC1_NEW_SCHEME_WIDTH 1
                             7357 ; 451  |#define HW_DCDC_TBR_DCDC1_HALF_FETS_WIDTH 1
                             7358 ; 452  |#define HW_DCDC_TBR_DCDC2_DIS_5BIT_WIDTH 1
                             7359 ; 453  |#define HW_DCDC_TBR_DCDC2_CLK4X_WIDTH 1
                             7360 ; 454  |#define HW_DCDC_TBR_DCDC2_CLK2X_WIDTH 1
                             7361 ; 455  |#define HW_DCDC_TBR_DCDC2_VDD5V_ACTIVE_WIDTH 1
                             7362 ; 456  |#define HW_DCDC_TBR_DCDC2_PFM_WIDTH 1
                             7363 ; 457  |#define HW_DCDC_TBR_DCDC2_STOPCLK_WIDTH 1
                             7364 ; 458  |
                             7365 ; 459  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_BITPOS (0)
                             7366 ; 460  |#define HW_DCDC_TBR_DCDC1_DIS_5BIT_BITPOS (4)
                             7367 ; 461  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_BITPOS (5)
                             7368 ; 462  |#define HW_DCDC_TBR_DCDC1_CLK4X_BITPOS (6)
                             7369 ; 463  |#define HW_DCDC_TBR_DCDC1_CLK2X_BITPOS (7)
                             7370 ; 464  |#define HW_DCDC_TBR_DCDC1_NOZERO_BITPOS (8)
                             7371 ; 465  |#define HW_DCDC_TBR_DCDC1_VDD5V_ACTIVE_BITPOS (9)
                             7372 ; 466  |#define HW_DCDC_TBR_DCDC1_PFM_BITPOS (10)
                             7373 ; 467  |#define HW_DCDC_TBR_DCDC1_STOPCLK_BITPOS (11)
                             7374 ; 468  |#define HW_DCDC_TBR_PWRUP_VDDIO_BRNOUT_BITPOS (12)
                             7375 ; 469  |#define HW_DCDC_TBR_DCDC_ANA_LESSI_BITPOS (13)
                             7376 ; 470  |#define HW_DCDC_TBR_DCDC_MORE_CAP_BITPOS (14)
                             7377 ; 471  |#define HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS (15)
                             7378 ; 472  |#define HW_DCDC_TBR_DCDC1_NEW_SCHEME_BITPOS (16)
                             7379 ; 473  |#define HW_DCDC_TBR_DCDC1_HALF_FETS_BITPOS (17)
                             7380 ; 474  |#define HW_DCDC_TBR_DCDC2_DIS_5BIT_BITPOS (18)
                             7381 ; 475  |#define HW_DCDC_TBR_DCDC2_CLK4X_BITPOS (19)
                             7382 ; 476  |#define HW_DCDC_TBR_DCDC2_CLK2X_BITPOS (20)
                             7383 ; 477  |#define HW_DCDC_TBR_DCDC2_VDD5V_ACTIVE_BITPOS (21)
                             7384 ; 478  |#define HW_DCDC_TBR_DCDC2_PFM_BITPOS (22)
                             7385 ; 479  |#define HW_DCDC_TBR_DCDC2_STOPCLK_BITPOS (23)
                             7386 ; 480  |
                             7387 ; 481  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_SETMASK (((1<<HW_DCDC_TBR_DCDC1_ADJ_TN_WIDTH)-1)<<HW_DCDC_TBR_DCDC1_ADJ_TN_BITPOS)
                             7388 ; 482  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_SETMASK (((1<<HW_DCDC_TBR_DCDC1_BAT_ADJ_WIDTH)-1)<<HW_DCDC_TBR_DCDC1_BAT_ADJ_BITPOS)
                             7389 ; 483  |#define HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_SETMASK (((1<<HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_WIDTH)-1)<<HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS)
                             7390 ; 484  |
                             7391 ; 485  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_CLRMASK (~(WORD)HW_DCDC_TBR_DCDC1_ADJ_TN_SETMASK)
                             7392 ; 486  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_CLRMASK (~(WORD)HW_DCDC_TBR_DCDC1_BAT_ADJ_SETMASK)
                             7393 ; 487  |#define HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_CLRMASK (~(WORD)HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_SETMASK)
                             7394 ; 488  |
                             7395 ; 489  |// Defines for What needs to change to be able to use a higher Core voltage and when the change should happen
                             7396 ; 490  |#define HW_DCDC_VDDD_CHANGE_TBR_CUTOFF_VALUE ((18<<HW_DCDC_VDDD_VOLTAGE_LEVEL_BITPOS)&HW_DCDC_VDDD_VOLTAGE_LEVEL_SETMASK)
                             7397 ; 491  |#define HW_DCDC_TBR_VDDD_HI_VALUE ((1<<HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS)&HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_SETMASK)
                             7398 ; 492  |#define HW_DCDC_TBR_VDDD_LO_VALUE (((1<<HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS)&HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_SETMASK)+((2<<HW_DCDC_TBR_DCDC1_ADJ_TN_BITPOS)&HW_DCDC_TBR_DCDC1_ADJ_TN_SETMASK)+((1<<HW_DCDC_TBR_DC
                                  DC1_BAT_ADJ_BITPOS)&HW_DCDC_TBR_DCDC1_BAT_ADJ_SETMASK))
                             7399 ; 493  |
                             7400 ; 494  |typedef union               
                             7401 ; 495  |{
                             7402 ; 496  |    struct {
                             7403 ; 497  |        unsigned int DCDC1_ADJ_TN               : HW_DCDC_TBR_DCDC1_ADJ_TN_WIDTH;
                             7404 ; 498  |        unsigned int DCDC1_DIS_5BIT             : HW_DCDC_TBR_DCDC1_DIS_5BIT_WIDTH;
                             7405 ; 499  |        unsigned int DCDC1_BAT_ADJ              : HW_DCDC_TBR_DCDC1_BAT_ADJ_WIDTH;
                             7406 ; 500  |        unsigned int DCDC1_CLK4X                : HW_DCDC_TBR_DCDC1_CLK4X_WIDTH;
                             7407 ; 501  |        unsigned int DCDC1_CLK2X                : HW_DCDC_TBR_DCDC1_CLK2X_WIDTH;
                             7408 ; 502  |        unsigned int DCDC1_NOZERO               : HW_DCDC_TBR_DCDC1_NOZERO_WIDTH;
                             7409 ; 503  |        unsigned int DCDC1_VDD5V_ACTIVE         : HW_DCDC_TBR_DCDC1_VDD5V_ACTIVE_WIDTH;
                             7410 ; 504  |        unsigned int DCDC1_PFM                  : HW_DCDC_TBR_DCDC1_PFM_WIDTH;
                             7411 ; 505  |        unsigned int DCDC1_STOPCLK              : HW_DCDC_TBR_DCDC1_STOPCLK_WIDTH;
                             7412 ; 506  |        unsigned int PWRUP_VDDIO_BRNOUT         : HW_DCDC_TBR_PWRUP_VDDIO_BRNOUT_WIDTH;
                             7413 ; 507  |        unsigned int DCDC_ANA_LESSI             : HW_DCDC_TBR_DCDC_ANA_LESSI_WIDTH;
                             7414 ; 508  |        unsigned int DCDC_MORE_CAP              : HW_DCDC_TBR_DCDC_MORE_CAP_WIDTH;
                             7415 ; 509  |        unsigned int DCDC_ANA_BGR_BIAS          : HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_WIDTH;
                             7416 ; 510  |        unsigned int DCDC1_NEW_SCHEME           : HW_DCDC_TBR_DCDC1_NEW_SCHEME_WIDTH;
                             7417 ; 511  |        unsigned int DCDC1_HALF_FETS            : HW_DCDC_TBR_DCDC1_HALF_FETS_WIDTH;
                             7418 ; 512  |        unsigned int DCDC2_DIS_5BIT             : HW_DCDC_TBR_DCDC2_DIS_5BIT_WIDTH;
                             7419 ; 513  |        unsigned int DCDC2_CLK4X                : HW_DCDC_TBR_DCDC2_CLK4X_WIDTH;
                             7420 ; 514  |        unsigned int DCDC2_CLK2X                : HW_DCDC_TBR_DCDC2_CLK2X_WIDTH;
                             7421 ; 515  |        unsigned int DCDC2_VDD5V_ACTIVE         : HW_DCDC_TBR_DCDC2_VDD5V_ACTIVE_WIDTH;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  30

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7422 ; 516  |        unsigned int DCDC2_PFM                  : HW_DCDC_TBR_DCDC2_PFM_WIDTH;
                             7423 ; 517  |        unsigned int DCDC2_STOPCLK              : HW_DCDC_TBR_DCDC2_STOPCLK_WIDTH;
                             7424 ; 518  |    } B;
                             7425 ; 519  |    unsigned int I;
                             7426 ; 520  |} usb_dcdctbr_type;
                             7427 ; 521  |#define HW_DCDC_TBR                     (*(volatile usb_dcdctbr_type _X*) (HW_DCDC_BASEADDR+8))    /* Analog test bit register*/
                             7428 ; 522  |
                             7429 ; 523  |
                             7430 ; 524  |/////////////////////////////////////////////////////////////////////////////////
                             7431 ; 525  |
                             7432 ; 526  |//  Analog Persistent Config (HW_VDD5V_PWR_CHARGE) Bit Definitions
                             7433 ; 527  |
                             7434 ; 528  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_WIDTH (6)
                             7435 ; 529  |#define HW_VDD5V_PWR_CHARGE_RSVD0_WIDTH (2)
                             7436 ; 530  |#define HW_VDD5V_PWR_CHARGE_PWD_WIDTH (1)
                             7437 ; 531  |#define HW_VDD5V_PWR_CHARGE_RES_WIDTH (1)
                             7438 ; 532  |#define HW_VDD5V_PWR_CHARGE_NIMH_WIDTH (1)
                             7439 ; 533  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_WIDTH (1)
                             7440 ; 534  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_WIDTH (1)
                             7441 ; 535  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_WIDTH (1)
                             7442 ; 536  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_WIDTH (1)
                             7443 ; 537  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_WIDTH (1)
                             7444 ; 538  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_WIDTH (1)
                             7445 ; 539  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_WIDTH (1)
                             7446 ; 540  |#define HW_VDD5V_PWR_CHARGE_RSVD1_WIDTH (2)
                             7447 ; 541  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_WIDTH (1)
                             7448 ; 542  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_WIDTH (2)
                             7449 ; 543  |#define HW_VDD5V_PWR_CHARGE_RSVD2_WIDTH (3)
                             7450 ; 544  |
                             7451 ; 545  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_BITPOS (0)
                             7452 ; 546  |#define HW_VDD5V_PWR_CHARGE_PWD_BITPOS (8)
                             7453 ; 547  |#define HW_VDD5V_PWR_CHARGE_RES_BITPOS (9)
                             7454 ; 548  |#define HW_VDD5V_PWR_CHARGE_NIMH_BITPOS (10)
                             7455 ; 549  |
                             7456 ; 550  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_BITPOS (11)
                             7457 ; 551  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_BITPOS (12)
                             7458 ; 552  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_BITPOS (13)
                             7459 ; 553  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_BITPOS (14)
                             7460 ; 554  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_BITPOS (15)
                             7461 ; 555  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_BITPOS (16)
                             7462 ; 556  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_BITPOS (17)
                             7463 ; 557  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_BITPOS (20)
                             7464 ; 558  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_BITPOS (21)
                             7465 ; 559  |
                             7466 ; 560  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_BATT_CURRENT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_BATT_CURRENT_BITPOS)        
                             7467 ; 561  |#define HW_VDD5V_PWR_CHARGE_PWD_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_PWD_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_PWD_BITPOS)        
                             7468 ; 562  |#define HW_VDD5V_PWR_CHARGE_RES_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_RES_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_RES_BITPOS) 
                             7469 ; 563  |#define HW_VDD5V_PWR_CHARGE_NIMH_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_NIMH_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_NIMH_BITPOS) 
                             7470 ; 564  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_LI_TYPE_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_LI_TYPE_BITPOS) 
                             7471 ; 565  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_BITPOS)        
                             7472 ; 566  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_BITPOS)        
                             7473 ; 567  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_DCANA_LP_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_DCANA_LP_BITPOS) 
                             7474 ; 568  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_TEST_USBREGS_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_TEST_USBREGS_BITPOS) 
                             7475 ; 569  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_DRV_BATT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_DRV_BATT_BITPOS) 
                             7476 ; 570  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_BITPOS) 
                             7477 ; 571  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_BITPOS) 
                             7478 ; 572  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_BATT_INFO_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_BATT_INFO_BITPOS) 
                             7479 ; 573  |
                             7480 ; 574  |
                             7481 ; 575  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_BATT_CURRENT_SETMASK)     
                             7482 ; 576  |#define HW_VDD5V_PWR_CHARGE_PWD_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_PWD_SETMASK)     
                             7483 ; 577  |#define HW_VDD5V_PWR_CHARGE_RES_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_RES_SETMASK) 
                             7484 ; 578  |#define HW_VDD5V_PWR_CHARGE_NIMH_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_NIMH_SETMASK) 
                             7485 ; 579  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_LI_TYPE_SETMASK) 
                             7486 ; 580  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_SETMASK)     
                             7487 ; 581  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_SETMASK)     
                             7488 ; 582  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_DCANA_LP_SETMASK) 
                             7489 ; 583  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_TEST_USBREGS_SETMASK) 
                             7490 ; 584  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_DRV_BATT_SETMASK) 
                             7491 ; 585  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_SETMASK) 
                             7492 ; 586  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_SETMASK) 
                             7493 ; 587  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_BATT_INFO_SETMASK) 
                             7494 ; 588  |
                             7495 ; 589  |typedef union               
                             7496 ; 590  |{
                             7497 ; 591  |    struct {
                             7498 ; 592  |        unsigned int BATT_CURRENT               : HW_VDD5V_PWR_CHARGE_BATT_CURRENT_WIDTH;
                             7499 ; 593  |        unsigned int RSVD0                      : HW_VDD5V_PWR_CHARGE_RSVD0_WIDTH;
                             7500 ; 594  |        unsigned int PWD                        : HW_VDD5V_PWR_CHARGE_PWD_WIDTH;
                             7501 ; 595  |        unsigned int RES                        : HW_VDD5V_PWR_CHARGE_RES_WIDTH;
                             7502 ; 596  |        unsigned int NIMH                       : HW_VDD5V_PWR_CHARGE_NIMH_WIDTH;
                             7503 ; 597  |        unsigned int LI_TYPE                    : HW_VDD5V_PWR_CHARGE_LI_TYPE_WIDTH;
                             7504 ; 598  |        unsigned int DISABLE_ILIMIT             : HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_WIDTH;
                             7505 ; 599  |        unsigned int PWDN_ON_IOBRNOUT           : HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_WIDTH;
                             7506 ; 600  |        unsigned int DCANA_LP                   : HW_VDD5V_PWR_CHARGE_DCANA_LP_WIDTH;
                             7507 ; 601  |        unsigned int TEST_USBREGS               : HW_VDD5V_PWR_CHARGE_TEST_USBREGS_WIDTH;
                             7508 ; 602  |        unsigned int DRV_BATT                   : HW_VDD5V_PWR_CHARGE_DRV_BATT_WIDTH;
                             7509 ; 603  |        unsigned int SWCHRG_BAT                 : HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_WIDTH;
                             7510 ; 604  |        unsigned int RSVD1                      : HW_VDD5V_PWR_CHARGE_RSVD1_WIDTH;
                             7511 ; 605  |        unsigned int VDD5V_PRESENT              : HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_WIDTH;
                             7512 ; 606  |        unsigned int RSVD2                      : HW_VDD5V_PWR_CHARGE_RSVD2_WIDTH;
                             7513 ; 607  |    } B;
                             7514 ; 608  |    unsigned int I;
                             7515 ; 609  |} usb_pwr_charge_type;
                             7516 ; 610  |#define HW_VDD5V_PWR_CHARGE      (*(volatile usb_pwr_charge_type _X*) (HW_DCDC_BASEADDR+17))    /* Analog Persistent Config Register */
                             7517 ; 611  |
                             7518 ; 612  |#define HW_DCDC_PERSIST_AUTO_RESTART_STAT_WIDTH 1
                             7519 ; 613  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_STAT_WIDTH 1
                             7520 ; 614  |#define HW_DCDC_PERSIST_UPDATE_WIDTH 1
                             7521 ; 615  |#define HW_DCDC_PERSIST_AUTO_RESTART_WIDTH 1
                             7522 ; 616  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_WIDTH 1
                             7523 ; 617  |#define HW_DCDC_PERSIST_LOW_BATT_TYPE_WIDTH 1
                             7524 ; 618  |#define HW_DCDC_PERSIST_LOW_BATTERY_ENABLE_WIDTH 1
                             7525 ; 619  |#define HW_DCDC_PERSIST_SLEEP_XTAL_ENABLE_WIDTH 1
                             7526 ; 620  |#define HW_DCDC_PERSIST_XTAL_TRIM1_WIDTH 1
                             7527 ; 621  |#define HW_DCDC_PERSIST_XTAL_TRIM0_WIDTH 1
                             7528 ; 622  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN1_WIDTH 1
                             7529 ; 623  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN0_WIDTH 1
                             7530 ; 624  |#define HW_DCDC_PERSIST_XTAL_TRM_ENABLE_WIDTH 1
                             7531 ; 625  |#define HW_DCDC_PERSIST_RSRVD_WIDTH 2
                             7532 ; 626  |
                             7533 ; 627  |#define HW_DCDC_PERSIST_AUTO_RESTART_STAT_BITPOS 12
                             7534 ; 628  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_STAT_BITPOS 11
                             7535 ; 629  |#define HW_DCDC_PERSIST_UPDATE_BITPOS 10
                             7536 ; 630  |#define HW_DCDC_PERSIST_AUTO_RESTART_BITPOS 9
                             7537 ; 631  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_BITPOS 8 
                             7538 ; 632  |#define HW_DCDC_PERSIST_LOW_BATT_TYPE_BITPOS 7
                             7539 ; 633  |#define HW_DCDC_PERSIST_LOW_BATTERY_ENABLE_BITPOS 6
                             7540 ; 634  |#define HW_DCDC_PERSIST_SLEEP_XTAL_ENABLE_BITPOS 5
                             7541 ; 635  |#define HW_DCDC_PERSIST_XTAL_TRIM1_BITPOS 4
                             7542 ; 636  |#define HW_DCDC_PERSIST_XTAL_TRIM0_BITPOS 3
                             7543 ; 637  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN1_BITPOS 2
                             7544 ; 638  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN0_BITPOS 1
                             7545 ; 639  |#define HW_DCDC_PERSIST_XTAL_TRM_ENABLE_BITPOS 0
                             7546 ; 640  |
                             7547 ; 641  |typedef union               
                             7548 ; 642  |{
                             7549 ; 643  |    struct {       
                             7550 ; 644  |       int XTAL_TRM_ENABLE             : HW_DCDC_PERSIST_XTAL_TRM_ENABLE_WIDTH;
                             7551 ; 645  |       int XTAL_BIAS_DOWN0             : HW_DCDC_PERSIST_XTAL_BIAS_DOWN0_WIDTH;
                             7552 ; 646  |       int XTAL_BIAS_DOWN1             : HW_DCDC_PERSIST_XTAL_BIAS_DOWN1_WIDTH;
                             7553 ; 647  |       int XTAL_TRIM0                  : HW_DCDC_PERSIST_XTAL_TRIM0_WIDTH;
                             7554 ; 648  |       int XTAL_TRIM1                  : HW_DCDC_PERSIST_XTAL_TRIM1_WIDTH;
                             7555 ; 649  |       int SLEEP_XTAL_ENABLE           : HW_DCDC_PERSIST_SLEEP_XTAL_ENABLE_WIDTH;
                             7556 ; 650  |       int LOW_BATTERY_ENABLE          : HW_DCDC_PERSIST_LOW_BATTERY_ENABLE_WIDTH;
                             7557 ; 651  |       int LOW_BATT_TYPE               : HW_DCDC_PERSIST_LOW_BATT_TYPE_WIDTH;
                             7558 ; 652  |       int DELAY_5V_AUTO_RESTART       : HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_WIDTH;
                             7559 ; 653  |       int AUTO_RESTART                : HW_DCDC_PERSIST_AUTO_RESTART_WIDTH;
                             7560 ; 654  |       int UPDATE                      : HW_DCDC_PERSIST_UPDATE_WIDTH;
                             7561 ; 655  |       int DELAY_5V_AUTO_RESTART_STAT  : HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_STAT_WIDTH;
                             7562 ; 656  |       int AUTO_RESTART_STAT           : HW_DCDC_PERSIST_AUTO_RESTART_STAT_WIDTH;
                             7563 ; 657  |       int RSRVD                       : HW_DCDC_PERSIST_RSRVD_WIDTH;
                             7564 ; 658  |    } B;
                             7565 ; 659  |    int I;
                             7566 ; 660  |} usb_dcdcpersist_type;
                             7567 ; 661  |#define HW_DCDC_PERSIST                (*(volatile usb_dcdcpersist_type _X*) (HW_DCDC_BASEADDR+15))    /* Analog test bit register*/
                             7568 ; 662  |
                             7569 ; 663  |
                             7570 ; 664  |
                             7571 ; 665  |#endif
                             7572 ; 666  |
                             7573 ; 667  |
                             7574 ; 668  |
                             7575 
                             7577 
                             7578 ; 24   |#include "regsclkctrl.h"
                             7579 
                             7581 
                             7582 ; 1    |#if !(defined(__REGS_CLK_CONTROL_INC))
                             7583 ; 2    |#define __REGS_CLK_CONTROL_INC 1
                             7584 ; 3    |
                             7585 ; 4    |
                             7586 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             7587 ; 6    |//  Clock Control Register (HW_CCR) Bit Positions
                             7588 ; 7    |#define HW_CCR_CKRST_BITPOS 0
                             7589 ; 8    |#define HW_CCR_LTC_BITPOS 1
                             7590 ; 9    |#define HW_CCR_PLLEN_BITPOS 2
                             7591 ; 10   |#define HW_CCR_XTLEN_BITPOS 3
                             7592 ; 11   |#define HW_CCR_PLL_SOURCE_SEL_BITPOS 4
                             7593 ; 12   |#define HW_CCR_ADIV_B0_BITPOS 5
                             7594 ; 13   |#define HW_CCR_ADIV_B1_BITPOS 6
                             7595 ; 14   |#define HW_CCR_ADIV_B2_BITPOS 7
                             7596 ; 15   |#define HW_CCR_CKSRC_BITPOS 8
                             7597 ; 16   |#define HW_CCR_DDIV_BITPOS 9
                             7598 ; 17   |#define HW_CCR_DDIV_B0_BITPOS 9
                             7599 ; 18   |#define HW_CCR_DDIV_B1_BITPOS 10
                             7600 ; 19   |#define HW_CCR_DDIV_B2_BITPOS 11
                             7601 ; 20   |#define HW_CCR_PDIV_BITPOS 12
                             7602 ; 21   |#define HW_CCR_PDIV_B0_BITPOS 12
                             7603 ; 22   |#define HW_CCR_PDIV_B1_BITPOS 13
                             7604 ; 23   |#define HW_CCR_PDIV_B2_BITPOS 14
                             7605 ; 24   |#define HW_CCR_PDIV_B3_BITPOS 15
                             7606 ; 25   |#define HW_CCR_PDIV_B4_BITPOS 16
                             7607 ; 26   |#define HW_CCR_PWDN_BITPOS 17
                             7608 ; 27   |#define HW_CCR_ACKEN_BITPOS 18
                             7609 ; 28   |#define HW_CCR_LOCK_BITPOS 19
                             7610 ; 29   |#define HW_CCR_DACDIV_BITPOS 20
                             7611 ; 30   |#define HW_CCR_ADIV1_B0_BITPOS 20
                             7612 ; 31   |#define HW_CCR_ADIV1_B1_BITPOS 21
                             7613 ; 32   |#define HW_CCR_ADIV1_B2_BITPOS 22
                             7614 ; 33   |#define HW_CCR_DDIV_MSB_BITPOS 23
                             7615 ; 34   |
                             7616 ; 35   |#define HW_CCR_CKRST_SETMASK 1<<HW_CCR_CKRST_BITPOS
                             7617 ; 36   |#define HW_CCR_LTC_SETMASK 1<<HW_CCR_LTC_BITPOS
                             7618 ; 37   |#define HW_CCR_PLLEN_SETMASK 1<<HW_CCR_PLLEN_BITPOS
                             7619 ; 38   |#define HW_CCR_XTLEN_SETMASK 1<<HW_CCR_XTLEN_BITPOS
                             7620 ; 39   |#define HW_CCR_ADCDIV_SETMASK 0x7<<HW_CCR_ADIV_B0_BITPOS
                             7621 ; 40   |#define HW_CCR_CKSRC_SETMASK 1<<HW_CCR_CKSRC_BITPOS
                             7622 ; 41   |#define HW_CCR_DDIV_SETMASK 0x7<<HW_CCR_DDIV_BITPOS
                             7623 ; 42   |#define HW_CCR_PDIV_SETMASK 0x1F<<HW_CCR_PDIV_BITPOS
                             7624 ; 43   |#define HW_CCR_PWDN_SETMASK 1<<HW_CCR_PWDN_BITPOS
                             7625 ; 44   |#define HW_CCR_ACKEN_SETMASK 1<<HW_CCR_ACKEN_BITPOS
                             7626 ; 45   |#define HW_CCR_LOCK_SETMASK 1<<HW_CCR_LOCK_BITPOS
                             7627 ; 46   |#define HW_CCR_DACDIV_SETMASK 0x7<<HW_CCR_DACDIV_BITPOS
                             7628 ; 47   |
                             7629 ; 48   |#define HW_CCR_CKRST_CLRMASK ~(WORD)HW_CCR_CKRST_SETMASK
                             7630 ; 49   |#define HW_CCR_LTC_CLRMASK ~(WORD)HW_CCR_LTC_SETMASK
                             7631 ; 50   |#define HW_CCR_PLLEN_CLRMASK ~(WORD)HW_CCR_PLLEN_SETMASK
                             7632 ; 51   |#define HW_CCR_XTLEN_CLRMASK ~(WORD)HW_CCR_XTLEN_SETMASK
                             7633 ; 52   |#define HW_CCR_ADCDIV_CLRMASK ~(WORD)HW_CCR_ADCDIV_SETMASK
                             7634 ; 53   |#define HW_CCR_CKSRC_CLRMASK ~(WORD)HW_CCR_CKSRC_SETMASK
                             7635 ; 54   |#define HW_CCR_DDIV_CLRMASK ~(WORD)HW_CCR_DDIV_SETMASK
                             7636 ; 55   |#define HW_CCR_PDIV_CLRMASK ~(WORD)HW_CCR_PDIV_SETMASK
                             7637 ; 56   |#define HW_CCR_PWDN_CLRMASK ~(WORD)HW_CCR_PWDN_SETMASK
                             7638 ; 57   |#define HW_CCR_ACKEN_CLRMASK ~(WORD)HW_CCR_ACKEN_SETMASK
                             7639 ; 58   |#define HW_CCR_LOCK_CLRMASK ~(WORD)HW_CCR_LOCK_SETMASK
                             7640 ; 59   |#define HW_CCR_DACDIV_CLRMASK ~(WORD)HW_CCR_DACDIV_SETMASK
                             7641 ; 60   |
                             7642 ; 61   |typedef union               
                             7643 ; 62   |{
                             7644 ; 63   |    struct
                             7645 ; 64   |    {
                             7646 ; 65   |        int CKRST       :1; // Clock Reset
                             7647 ; 66   |        int LTC         :1;
                             7648 ; 67   |        int PLLEN       :1;
                             7649 ; 68   |        int XTLEN       :1;
                             7650 ; 69   |        int FLB         :1;
                             7651 ; 70   |        unsigned ADIV   :3;
                             7652 ; 71   |        int CKSRC       :1;
                             7653 ; 72   |        unsigned DDIV   :3;
                             7654 ; 73   |        unsigned PDIV   :5;
                             7655 ; 74   |        int PWDN        :1;
                             7656 ; 75   |        int ACKEN       :1;
                             7657 ; 76   |        int LOCK        :1;
                             7658 ; 77   |        unsigned ADIV1  :3;
                             7659 ; 78   |        unsigned DDIV_MSB:1;
                             7660 ; 79   |    } B;
                             7661 ; 80   |
                             7662 ; 81   |    int I;
                             7663 ; 82   |    unsigned int U;
                             7664 ; 83   |
                             7665 ; 84   |} ccr_type;
                             7666 ; 85   |#define HW_CCR     (*(volatile ccr_type _X*) (0xFA00))
                             7667 ; 86   |
                             7668 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                             7669 ; 88   |//  Reset Control Register (HW_RCR) Bit Positions
                             7670 ; 89   |#define HW_RCR_STKLVL_BITPOS 0
                             7671 ; 90   |#define HW_RCR_SRST_BITPOS 4
                             7672 ; 91   |#define HW_RCR_IRQA_BITPOS 8
                             7673 ; 92   |#define HW_RCR_IRQB_BITPOS 9
                             7674 ; 93   |#define HW_RCR_NMI_BITPOS 10
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  31

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7675 ; 94   |#define HW_RCR_SUNFLLVL_BITPOS 11
                             7676 ; 95   |#define HW_RCR_SUNFLEN_BITPOS 15
                             7677 ; 96   |#define HW_RCR_SOVFLLVL_BITPOS 16
                             7678 ; 97   |#define HW_RCR_SOVFLEN_BITPOS 20
                             7679 ; 98   |#define HW_RCR_IRQB2NMI_BITPOS 21
                             7680 ; 99   |#define HW_RCR_SUNFL_BITPOS 22
                             7681 ; 100  |#define HW_RCR_SOVFL_BITPOS 23
                             7682 ; 101  |
                             7683 ; 102  |#define HW_RCR_STKLVL_WIDTH (4)
                             7684 ; 103  |#define HW_RCR_SRST_WIDTH (4)
                             7685 ; 104  |#define HW_RCR_IRQA_WIDTH (1)
                             7686 ; 105  |#define HW_RCR_IRQB_WIDTH (1)
                             7687 ; 106  |#define HW_RCR_NMI_WIDTH (1)
                             7688 ; 107  |#define HW_RCR_SUNFLLVL_WIDTH (4)
                             7689 ; 108  |#define HW_RCR_SUNFLEN_WIDTH (1)
                             7690 ; 109  |#define HW_RCR_SOVFLLVL_WIDTH (4)
                             7691 ; 110  |#define HW_RCR_SOVFLEN_WIDTH (1)
                             7692 ; 111  |#define HW_RCR_IRQB2NMI_WIDTH (1)
                             7693 ; 112  |#define HW_RCR_SUNFL_WIDTH (1)
                             7694 ; 113  |#define HW_RCR_SOVFL_WIDTH (1)
                             7695 ; 114  |
                             7696 ; 115  |#define HW_RCR_STKLVL_SETMASK (((1<<HW_RCR_STKLVL_WIDTH)-1)<<HW_RCR_STKLVL_BITPOS)
                             7697 ; 116  |#define HW_RCR_SRST_SETMASK (((1<<HW_RCR_SRST_WIDTH)-1)<<HW_RCR_SRST_BITPOS)
                             7698 ; 117  |#define HW_RCR_IRQA_SETMASK (((1<<HW_RCR_IRQA_WIDTH)-1)<<HW_RCR_IRQA_BITPOS)
                             7699 ; 118  |#define HW_RCR_IRQB_SETMASK (((1<<HW_RCR_IRQB_WIDTH)-1)<<HW_RCR_IRQB_BITPOS)
                             7700 ; 119  |#define HW_RCR_NMI_SETMASK (((1<<HW_RCR_NMI_WIDTH)-1)<<HW_RCR_NMI_BITPOS)
                             7701 ; 120  |#define HW_RCR_SUNFLLVL_SETMASK (((1<<HW_RCR_SUNFLLVL_WIDTH)-1)<<HW_RCR_SUNFLLVL_BITPOS)
                             7702 ; 121  |#define HW_RCR_SUNFLEN_SETMASK (((1<<HW_RCR_SUNFLEN_WIDTH)-1)<<HW_RCR_SUNFLEN_BITPOS)
                             7703 ; 122  |#define HW_RCR_SOVFLLVL_SETMASK (((1<<HW_RCR_SOVFLLVL_WIDTH)-1)<<HW_RCR_SOVFLLVL_BITPOS)
                             7704 ; 123  |#define HW_RCR_SOVFLEN_SETMASK (((1<<HW_RCR_SOVFLEN_WIDTH)-1)<<HW_RCR_SOVFLEN_BITPOS)
                             7705 ; 124  |#define HW_RCR_IRQB2NMI_SETMASK (((1<<HW_RCR_IRQB2NMI_WIDTH)-1)<<HW_RCR_IRQB2NMI_BITPOS)
                             7706 ; 125  |#define HW_RCR_SUNFL_SETMASK (((1<<HW_RCR_SUNFL_WIDTH)-1)<<HW_RCR_SUNFL_BITPOS)
                             7707 ; 126  |#define HW_RCR_SOVFL_SETMASK (((1<<HW_RCR_SOVFL_WIDTH)-1)<<HW_RCR_SOVFL_BITPOS)
                             7708 ; 127  |
                             7709 ; 128  |#define HW_RCR_STKLVL_CLRMASK ~(WORD)HW_RCR_STKLVL_SETMASK
                             7710 ; 129  |#define HW_RCR_SRST_CLRMASK ~(WORD)HW_RCR_SRST_SETMASK
                             7711 ; 130  |#define HW_RCR_IRQA_CLRMASK ~(WORD)HW_RCR_IRQA_SETMASK
                             7712 ; 131  |#define HW_RCR_IRQB_CLRMASK ~(WORD)HW_RCR_IRQB_SETMASK
                             7713 ; 132  |#define HW_RCR_NMI_CLRMASK ~(WORD)HW_RCR_NMI_SETMASK
                             7714 ; 133  |#define HW_RCR_SUNFLLVL_CLRMASK ~(WORD)HW_RCR_SUNFLLVL_SETMASK
                             7715 ; 134  |#define HW_RCR_SUNFLEN_CLRMASK ~(WORD)HW_RCR_SUNFLEN_SETMASK
                             7716 ; 135  |#define HW_RCR_SOVFLLVL_CLRMASK ~(WORD)HW_RCR_SOVFLLVL_SETMASK
                             7717 ; 136  |#define HW_RCR_SOVFLEN_CLRMASK ~(WORD)HW_RCR_SOVFLEN_SETMASK
                             7718 ; 137  |#define HW_RCR_IRQB2NMI_CLRMASK ~(WORD)HW_RCR_IRQB2NMI_SETMASK
                             7719 ; 138  |#define HW_RCR_SUNFL_CLRMASK ~(WORD)HW_RCR_SUNFL_SETMASK
                             7720 ; 139  |#define HW_RCR_SOVFL_CLRMASK ~(WORD)HW_RCR_SOVFL_SETMASK
                             7721 ; 140  |
                             7722 ; 141  |typedef union               
                             7723 ; 142  |{
                             7724 ; 143  |    struct
                             7725 ; 144  |   {
                             7726 ; 145  |        int STKLVL   : HW_RCR_STKLVL_WIDTH;
                             7727 ; 146  |        int SRST     : HW_RCR_SRST_WIDTH;
                             7728 ; 147  |        int IRQA     : HW_RCR_IRQA_WIDTH;
                             7729 ; 148  |        int IRQB     : HW_RCR_IRQB_WIDTH;
                             7730 ; 149  |        int NMI      : HW_RCR_NMI_WIDTH;
                             7731 ; 150  |        int SUNFLLVL : HW_RCR_SUNFLLVL_WIDTH;
                             7732 ; 151  |        int SUNFLEN  : HW_RCR_SUNFLEN_WIDTH;
                             7733 ; 152  |        int SOVFLLVL : HW_RCR_SOVFLLVL_WIDTH;
                             7734 ; 153  |        int SOVFLEN  : HW_RCR_SOVFLEN_WIDTH;
                             7735 ; 154  |        int IRQB2NMI : HW_RCR_IRQB2NMI_WIDTH;
                             7736 ; 155  |        int SUNFL    : HW_RCR_SUNFL_WIDTH;
                             7737 ; 156  |        int SOVFL    : HW_RCR_SOVFL_WIDTH;
                             7738 ; 157  |    } B;
                             7739 ; 158  |
                             7740 ; 159  |    int I;
                             7741 ; 160  |    unsigned int U;
                             7742 ; 161  |
                             7743 ; 162  |} rcr_type;
                             7744 ; 163  |#define HW_RCR     (*(volatile rcr_type _X*) (0xFA01))
                             7745 ; 164  |
                             7746 ; 165  |
                             7747 ; 166  |/////////////////////////////////////////////////////////////////////////////////
                             7748 ; 167  |//  DCLK Count Lower register (HW_DCLKCNTL) Bit Positions
                             7749 ; 168  |#define HW_DCLKCNTL_LOW_BITPOS 0
                             7750 ; 169  |
                             7751 ; 170  |#define HW_DCLKCNTL_LOW_WIDTH (24)        
                             7752 ; 171  |
                             7753 ; 172  |#define HW_DCLKCNTL_LOW_SETMASK (((1<<HW_DCLKCNTL_LOW_WIDTH)-1)<<HW_DCLKCNTL_LOW_BITPOS) 
                             7754 ; 173  |#define HW_DCLKCNTL_LOW_CLRMASK ~(WORD)HW_DCLKCNTL_LOW_SETMASK
                             7755 ; 174  |typedef union               
                             7756 ; 175  |{
                             7757 ; 176  |    struct
                             7758 ; 177  |   {
                             7759 ; 178  |        int LOW;
                             7760 ; 179  |    } B;
                             7761 ; 180  |
                             7762 ; 181  |    int I;
                             7763 ; 182  |    unsigned int U;
                             7764 ; 183  |
                             7765 ; 184  |} dclkcntl_type;
                             7766 ; 185  |#define HW_DCLKCNTL (*(volatile dclkcntl_type _X*) (0xFFEA))
                             7767 ; 186  |
                             7768 ; 187  |/////////////////////////////////////////////////////////////////////////////////
                             7769 ; 188  |//  DCLK Count UPPER register (HW_DCLKCNTU) Bit Positions
                             7770 ; 189  |#define HW_DCLKCNTU_HIGH_BITPOS 0
                             7771 ; 190  |
                             7772 ; 191  |#define HW_DCLKCNTU_HIGH_WIDTH (24)        
                             7773 ; 192  |
                             7774 ; 193  |#define HW_DCLKCNTU_HIGH_SETMASK (((1<<HW_DCLKCNTU_HIGH_WIDTH)-1)<<HW_DCLKCNTU_HIGH_BITPOS) 
                             7775 ; 194  |#define HW_DCLKCNTU_HIGH_CLRMASK ~(WORD)HW_DCLKCNTU_HIGH_SETMASK
                             7776 ; 195  |typedef union               
                             7777 ; 196  |{
                             7778 ; 197  |    struct
                             7779 ; 198  |   {
                             7780 ; 199  |        int HIGH;
                             7781 ; 200  |    } B;
                             7782 ; 201  |
                             7783 ; 202  |    int I;
                             7784 ; 203  |    unsigned int U;
                             7785 ; 204  |
                             7786 ; 205  |} dclkcntu_type;
                             7787 ; 206  |#define HW_DCLKCNTU (*(volatile dclkcntu_type _X*) (0xFFEB))
                             7788 ; 207  |
                             7789 ; 208  |//*********************  REGISTER ALIAS DEFINES TO MATCH LEGACY CODE *******************************
                             7790 ; 209  |// The following defines were added to match regs3410.inc definition to build SDK2XXX code without needing 
                             7791 ; 210  |// to update the actual files. Only the defines needed to build SDK2.400 were added. 
                             7792 ; 211  |
                             7793 ; 212  |// Clock count register (lower)
                             7794 ; 213  |#define HW_CLK_CNT_L 0x00FFEA         
                             7795 ; 214  |// Clock count register (upper)
                             7796 ; 215  |#define HW_CLK_CNT_U 0x00FFEB         
                             7797 ; 216  |// Cycle steal count register
                             7798 ; 217  |#define HW_CYC_STEAL 0x00FFEC         
                             7799 ; 218  |
                             7800 ; 219  |#endif
                             7801 ; 220  |
                             7802 ; 221  |
                             7803 
                             7805 
                             7806 ; 25   |#include "sysirq.h"
                             7807 
                             7809 
                             7810 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             7811 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             7812 ; 3    |//
                             7813 ; 4    |// Filename: sysirq.h
                             7814 ; 5    |// Description: 
                             7815 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             7816 ; 7    |
                             7817 ; 8    |#ifndef _SYSIRQ_H
                             7818 ; 9    |#define _SYSIRQ_H
                             7819 ; 10   |
                             7820 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             7821 ; 12   |// Defs
                             7822 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             7823 ; 14   |
                             7824 ; 15   |#define     INTERRUPTS_UNMASK_ALL   0x000000
                             7825 ; 16   |
                             7826 ; 17   |///////////////////////////////////////////////////////////////////////////////
                             7827 ; 18   |// Structure definitions
                             7828 ; 19   |///////////////////////////////////////////////////////////////////////////////
                             7829 ; 20   |
                             7830 ; 21   |///////////////////////////////////////////////////////////////////////////////
                             7831 ; 22   |// Prototypes
                             7832 ; 23   |///////////////////////////////////////////////////////////////////////////////
                             7833 ; 24   |
                             7834 ; 25   |WORD _reentrant SysMaskAllInterrupts(void);
                             7835 ; 26   |void _reentrant SysUnMaskAllInterrupts(WORD wLevel);
                             7836 ; 27   |WORD _reentrant SysGetIrqLevel(void);
                             7837 ; 28   |RETCODE _reentrant SysSetIrqLevel(WORD wIrqLevel);
                             7838 ; 29   |
                             7839 ; 30   |#endif // #ifndef _SYSIRQ_H
                             7840 
                             7842 
                             7843 ; 26   |#include "icoll.h"
                             7844 
                             7846 
                             7847 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             7848 ; 2    |// Copyright(C) SigmaTel, Inc. 2002
                             7849 ; 3    |//
                             7850 ; 4    |// Filename: icoll.h
                             7851 ; 5    |// Description: 
                             7852 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             7853 ; 7    |
                             7854 ; 8    |#ifndef _ICOLL_H
                             7855 ; 9    |#define _ICOLL_H
                             7856 ; 10   |
                             7857 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             7858 ; 12   |// Defs
                             7859 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             7860 ; 14   |                                                                                          
                             7861 ; 15   |#define ICOLL_SOURCE_DAC_REFILL                                 (DWORD)0             
                             7862 ; 16   |#define ICOLL_SOURCE_DAC_UNDERFLOW                              (DWORD)1             
                             7863 ; 17   |#define ICOLL_SOURCE_ADC_REFILL                                 (DWORD)2             
                             7864 ; 18   |#define ICOLL_SOURCE_ADC_OVERFLOW                               (DWORD)3             
                             7865 ; 19   |#define ICOLL_SOURCE_FLASH_DONE                                 (DWORD)4              
                             7866 ; 20   |#define ICOLL_SOURCE_COMPACTFLASH_CARD_IRQ                      (DWORD)5              
                             7867 ; 21   |#define ICOLL_SOURCE_SMARTMEDIA_TIMEOUT                         (DWORD)6              
                             7868 ; 22   |#define ICOLL_SOURCE_SMARTMEDIA_INTERFACE_INVALID_PROGRAMMING   (DWORD)7              
                             7869 ; 23   |#define ICOLL_SOURCE_COMPACTFLASH_NO_CARD                       (DWORD)8               
                             7870 ; 24   |#define ICOLL_SOURCE_COMPACTFLASH_STATUS_CHANGE                 (DWORD)9               
                             7871 ; 25   |#define ICOLL_SOURCE_GPIO_0                                     (DWORD)10               
                             7872 ; 26   |#define ICOLL_SOURCE_GPIO_1                                     (DWORD)11               
                             7873 ; 27   |#define ICOLL_SOURCE_GPIO_2                                     (DWORD)12                
                             7874 ; 28   |#define ICOLL_SOURCE_TIMER_0                                    (DWORD)13                
                             7875 ; 29   |#define ICOLL_SOURCE_TIMER_1                                    (DWORD)14                
                             7876 ; 30   |#define ICOLL_SOURCE_TIMER_2                                    (DWORD)15                
                             7877 ; 31   |#define ICOLL_SOURCE_TIMER_3                                    (DWORD)16                 
                             7878 ; 32   |#define ICOLL_SOURCE_GPIO_3                                     (DWORD)17                 
                             7879 ; 33   |#define ICOLL_SOURCE_SDRAM                                      (DWORD)18                 
                             7880 ; 34   |#define ICOLL_SOURCE_CDI                                        (DWORD)19                 
                             7881 ; 35   |
                             7882 ; 36   |#if (defined(DEVICE_3410) || defined(DEVICE_3310))
                             7883 ; 37   |
                             7884 ; 38   |#define ICOLL_SOURCE_USB_SOF                                    (DWORD)20                  
                             7885 ; 39   |#define ICOLL_SOURCE_USB_SET_INTERFACE_REQUEST                  (DWORD)21                  
                             7886 ; 40   |#define ICOLL_SOURCE_USB_HOST_RESET                             (DWORD)22                  
                             7887 ; 41   |#define ICOLL_SOURCE_USB_ENDPOINT_START                         (DWORD)23
                             7888 ; 42   |#define ICOLL_SOURCE_USB_ENDPOINT_0                             (DWORD)23                  
                             7889 ; 43   |#define ICOLL_SOURCE_USB_ENDPOINT_1                             (DWORD)24                  
                             7890 ; 44   |#define ICOLL_SOURCE_USB_ENDPOINT_2                             (DWORD)25                  
                             7891 ; 45   |#define ICOLL_SOURCE_USB_ENDPOINT_3                             (DWORD)26                  
                             7892 ; 46   |#define ICOLL_SOURCE_USB_ENDPOINT_4                             (DWORD)27                  
                             7893 ; 47   |#define ICOLL_SOURCE_USB_ENDPOINT_5                             (DWORD)28                    
                             7894 ; 48   |#define ICOLL_SOURCE_USB_ENDPOINT_6                             (DWORD)29                    
                             7895 ; 49   |#define ICOLL_SOURCE_USB_ENDPOINT_7                             (DWORD)30                    
                             7896 ; 50   |
                             7897 ; 51   |#else
                             7898 ; 52   |
                             7899 ; 53   |#define ICOLL_SOURCE_VDD_5V_CONNECTED                           (DWORD)20                  
                             7900 ; 54   |#define ICOLL_SOURCE_USB_CONTROLLER                             (DWORD)21                  
                             7901 ; 55   |#define ICOLL_SOURCE_USB_WAKEUP                                 (DWORD)22                  
                             7902 ; 56   |#define ICOLL_SOURCE_VDD_5V_DISCONNECTED                        (DWORD)23
                             7903 ; 57   |#define ICOLL_SOURCE_ESPI                                       (DWORD)24                  
                             7904 ; 58   |#define ICOLL_SOURCE_FILCO                                      (DWORD)25                  
                             7905 ; 59   |#define ICOLL_SOURCE_LRADC1                                     (DWORD)26                  
                             7906 ; 60   |#define ICOLL_SOURCE_RTC_ALARM                                  (DWORD)27                  
                             7907 ; 61   |#define ICOLL_SOURCE_LRADC2                                     (DWORD)28                  
                             7908 ; 62   |#define ICOLL_SOURCE_FLASH_ECC                                  (DWORD)29                    
                             7909 ; 63   |
                             7910 ; 64   |#endif
                             7911 ; 65   |
                             7912 ; 66   |#define ICOLL_SOURCE_CDSYNC                                     (DWORD)31                    
                             7913 ; 67   |#define ICOLL_SOURCE_CDSYNC_EXCEPTION                           (DWORD)32                     
                             7914 ; 68   |#define ICOLL_SOURCE_REED_SOLOMON                               (DWORD)33
                             7915 ; 69   |#define ICOLL_END_OF_TRUE_SOURCES                                ICOLL_SOURCE_REED_SOLOMON
                             7916 ; 70   |// The rest of these "sources" are not really ICOLL sources.  They are not
                             7917 ; 71   |//  routed through the ICOLL but are included here to make interrupt abstraction
                             7918 ; 72   |//  as simple as possible.  The ICOLL functions special-case these.
                             7919 ; 73   |#define ICOLL_SOURCE_I2C_RX_READY                               (DWORD)34
                             7920 ; 74   |#define ICOLL_SOURCE_I2C_RX_OVERFLOW                            (DWORD)35
                             7921 ; 75   |#define ICOLL_SOURCE_I2C_TX_EMPTY                               (DWORD)36
                             7922 ; 76   |#define ICOLL_SOURCE_I2C_TX_UNDERFLOW                           (DWORD)37
                             7923 ; 77   |#define ICOLL_SOURCE_SPI_COMPLETE                               (DWORD)38
                             7924 ; 78   |#define ICOLL_SOURCE_I2S_RX_OVERFLOW                            (DWORD)39
                             7925 ; 79   |#define ICOLL_SOURCE_I2S_TX_UNDERFLOW                           (DWORD)40
                             7926 ; 80   |#define ICOLL_SOURCE_I2S_RX_READY                               (DWORD)41
                             7927 ; 81   |#define ICOLL_SOURCE_I2S_TX_EMPTY                               (DWORD)42
                             7928 ; 82   |#define ICOLL_SOURCE_HARDWARE_RESET                             (DWORD)43
                             7929 ; 83   |#define ICOLL_SOURCE_STACK_ERROR                                (DWORD)44
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  32

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7930 ; 84   |#define ICOLL_SOURCE_TRACE                                      (DWORD)45
                             7931 ; 85   |#define ICOLL_SOURCE_SWI                                        (DWORD)46
                             7932 ; 86   |#define ICOLL_SOURCE_IRQA                                       (DWORD)47
                             7933 ; 87   |#define ICOLL_SOURCE_BROWNOUT                                   (DWORD)48
                             7934 ; 88   |#define ICOLL_SOURCE_ILLEGAL_INSTRUCTION                        (DWORD)49
                             7935 ; 89   |#define ICOLL_SOURCE_END                                        ICOLL_SOURCE_ILLEGAL_INSTRUCTION
                             7936 ; 90   |#define ICOLL_NUM_SOURCES                                       ICOLL_SOURCE_END+1
                             7937 ; 91   |
                             7938 ; 92   |#define ICOLL_ICLENABLE_REG_0_LAST_SRC                          (DWORD)23
                             7939 ; 93   |
                             7940 ; 94   |#define ICOLL_PRIORITY_000              0x000000
                             7941 ; 95   |#define ICOLL_PRIORITY_001              0x000001
                             7942 ; 96   |#define ICOLL_PRIORITY_010              0x000002
                             7943 ; 97   |#define ICOLL_PRIORITY_011              0x000003
                             7944 ; 98   |#define ICOLL_PRIORITY_100              0x000004
                             7945 ; 99   |#define ICOLL_PRIORITY_101              0x000005
                             7946 ; 100  |#define ICOLL_PRIORITY_110              0x000006
                             7947 ; 101  |#define ICOLL_PRIORITY_111              0x000007
                             7948 ; 102  |
                             7949 ; 103  |#define ICOLL_STEERING_IVL1             0x000000
                             7950 ; 104  |#define ICOLL_STEERING_IVL2             0x000001
                             7951 ; 105  |#define ICOLL_STEERING_IVL3             0x000002
                             7952 ; 106  |#define ICOLL_STEERING_IVL6             0x000003
                             7953 ; 107  |
                             7954 ; 108  |///////////////////////////////////////////////////////////////////////////////
                             7955 ; 109  |// ERRORS
                             7956 ; 110  |///////////////////////////////////////////////////////////////////////////////
                             7957 ; 111  |                                                                                          
                             7958 ; 112  |#define ICOLL_ERROR_INVALID_SOURCE              (RETCODE)0x000001
                             7959 ; 113  |
                             7960 ; 114  |///////////////////////////////////////////////////////////////////////////////
                             7961 ; 115  |// Structure definitions
                             7962 ; 116  |///////////////////////////////////////////////////////////////////////////////
                             7963 ; 117  |
                             7964 ; 118  |typedef void (*ISR_VECTOR)(void);
                             7965 ; 119  |
                             7966 ; 120  |typedef struct
                             7967 ; 121  |{
                             7968 ; 122  |    WORD wSource;
                             7969 ; 123  |    WORD wPriority;
                             7970 ; 124  |    WORD wSteering;
                             7971 ; 125  |} ICOLL_ELEMENT;
                             7972 ; 126  |
                             7973 ; 127  |///////////////////////////////////////////////////////////////////////////////
                             7974 ; 128  |// Prototypes
                             7975 ; 129  |///////////////////////////////////////////////////////////////////////////////
                             7976 ; 130  |
                             7977 ; 131  |void _reentrant IcollShutDown(void);
                             7978 ; 132  |RETCODE _reentrant IcollEnable(DWORD dwSource);
                             7979 ; 133  |RETCODE _reentrant IcollDisable(DWORD dwSource);
                             7980 ; 134  |BOOL _reentrant IcollGetStatus(DWORD dwSource);
                             7981 ; 135  |RETCODE _reentrant IcollSetPriority(DWORD dwSource, WORD wPriority);
                             7982 ; 136  |RETCODE _reentrant IcollSetSteering(DWORD dwSource, WORD wSteering);
                             7983 
                             7988 
                             7989 ; 137  |RETCODE _reentrant IcollInstallIsrVector(ISR_VECTOR pISR, WORD wSource);
                             7990 ; 138  |void _asmfunc IcollResetVectorTable(void);
                             7991 ; 139  |#endif // #ifndef _ICOLL_H
                             7992 
                             7994 
                             7995 ; 27   |#include "ipr.h"
                             7996 
                             7998 
                             7999 ; 1    |#ifndef __IPR_H
                             8000 ; 2    |#define __IPR_H
                             8001 ; 3    |
                             8002 ; 4    |
                             8003 ; 5    |
                             8004 ; 6    |#define IVL_DISABLED    0
                             8005 ; 7    |#define IVL_PRIORITY_0  1
                             8006 ; 8    |#define IVL_PRIORITY_1  2
                             8007 ; 9    |#define IVL_PRIORITY_2  3
                             8008 ; 10   |
                             8009 ; 11   |#define IVL_LINE_0     10
                             8010 ; 12   |#define IVL_LINE_1     12
                             8011 ; 13   |#define IVL_LINE_2     14
                             8012 ; 14   |#define IVL_LINE_3     16
                             8013 ; 15   |#define IVL_LINE_4     18
                             8014 ; 16   |#define IVL_LINE_5     20
                             8015 ; 17   |#define IVL_LINE_6     22
                             8016 ; 18   |
                             8017 ; 19   |
                             8018 ; 20   |_asmfunc WORD IPRSetIVLPriority(WORD wIVL, WORD wPriority);
                             8019 ; 21   |
                             8020 ; 22   |#endif 
                             8021 
                             8023 
                             8024 ; 28   |#include "regscore.h"
                             8025 
                             8027 
                             8028 ; 1    |#if !(defined(__REGS_STATUS_INC))
                             8029 ; 2    |#define __REGS_STATUS_INC 1
                             8030 ; 3    |
                             8031 ; 4    |
                             8032 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             8033 ; 6    |//  OMR Register (HW_OMR) Bit Positions
                             8034 ; 7    |#define HW_OMR_MA_BITPOS 0
                             8035 ; 8    |#define HW_OMR_MB_BITPOS 1
                             8036 ; 9    |#define HW_OMR_DE_BITPOS 2
                             8037 ; 10   |#define HW_OMR_YE_BITPOS 3
                             8038 ; 11   |#define HW_OMR_MC_BITPOS 4
                             8039 ; 12   |#define HW_OMR_SD_BITPOS 6
                             8040 ; 13   |
                             8041 ; 14   |#define HW_OMR_MA_SETMASK 1<<HW_OMR_MA_BITPOS
                             8042 ; 15   |#define HW_OMR_MB_SETMASK 1<<HW_OMR_MB_BITPOS
                             8043 ; 16   |#define HW_OMR_DE_SETMASK 1<<HW_OMR_DE_BITPOS
                             8044 ; 17   |#define HW_OMR_YE_SETMASK 1<<HW_OMR_YE_BITPOS
                             8045 ; 18   |#define HW_OMR_MC_SETMASK 1<<HW_OMR_MC_BITPOS
                             8046 ; 19   |#define HW_OMR_SD_SETMASK 1<<HW_OMR_SD_BITPOS
                             8047 ; 20   |
                             8048 ; 21   |#define HW_OMR_MA_CLRMASK ~(WORD)HW_OMR_MA_SETMASK
                             8049 ; 22   |#define HW_OMR_MB_CLRMASK ~(WORD)HW_OMR_MB_SETMASK
                             8050 ; 23   |#define HW_OMR_DE_CLRMASK ~(WORD)HW_OMR_DE_SETMASK
                             8051 ; 24   |#define HW_OMR_YE_CLRMASK ~(WORD)HW_OMR_YE_SETMASK
                             8052 ; 25   |#define HW_OMR_MC_CLRMASK ~(WORD)HW_OMR_MC_SETMASK
                             8053 ; 26   |#define HW_OMR_SD_CLRMASK ~(WORD)HW_OMR_SD_SETMASK
                             8054 ; 27   |
                             8055 ; 28   |
                             8056 ; 29   |/////////////////////////////////////////////////////////////////////////////////
                             8057 ; 30   |//  Status Register (HW_SR) Bit Positions
                             8058 ; 31   |#define HW_SR_C_BITPOS 0
                             8059 ; 32   |#define HW_SR_O_BITPOS 1
                             8060 ; 33   |#define HW_SR_Z_BITPOS 2
                             8061 ; 34   |#define HW_SR_N_BITPOS 3
                             8062 ; 35   |#define HW_SR_U_BITPOS 4
                             8063 ; 36   |#define HW_SR_E_BITPOS 5
                             8064 ; 37   |#define HW_SR_L_BITPOS 6
                             8065 ; 38   |#define HW_SR_IM_BITPOS 8
                             8066 ; 39   |#define HW_SR_IM0_BITPOS 8
                             8067 ; 40   |#define HW_SR_IM1_BITPOS 9
                             8068 ; 41   |#define HW_SR_SM_BITPOS 10
                             8069 ; 42   |#define HW_SR_SM0_BITPOS 10
                             8070 ; 43   |#define HW_SR_SM1_BITPOS 11
                             8071 ; 44   |#define HW_SR_TM_BITPOS 13
                             8072 ; 45   |#define HW_SR_DP_BITPOS 14
                             8073 ; 46   |#define HW_SR_LOOP_BITPOS 15
                             8074 ; 47   |
                             8075 ; 48   |#define HW_SR_C_SETMASK 1<<HW_SR_C_BITPOS
                             8076 ; 49   |#define HW_SR_O_SETMASK 1<<HW_SR_O_BITPOS
                             8077 ; 50   |#define HW_SR_Z_SETMASK 1<<HW_SR_Z_BITPOS
                             8078 ; 51   |#define HW_SR_N_SETMASK 1<<HW_SR_N_BITPOS
                             8079 ; 52   |#define HW_SR_U_SETMASK 1<<HW_SR_U_BITPOS
                             8080 ; 53   |#define HW_SR_E_SETMASK 1<<HW_SR_E_BITPOS
                             8081 ; 54   |#define HW_SR_L_SETMASK 1<<HW_SR_L_BITPOS
                             8082 ; 55   |#define HW_SR_IM_SETMASK 3<<HW_SR_IM_BITPOS
                             8083 ; 56   |#define HW_SR_IM0_SETMASK 1<<HW_SR_IM0_BITPOS
                             8084 ; 57   |#define HW_SR_IM1_SETMASK 1<<HW_SR_IM1_BITPOS
                             8085 ; 58   |#define HW_SR_IM_L0_SETMASK 0<<HW_SR_IM_BITPOS
                             8086 ; 59   |#define HW_SR_IM_L1_SETMASK 1<<HW_SR_IM_BITPOS
                             8087 ; 60   |#define HW_SR_IM_L2_SETMASK 2<<HW_SR_IM_BITPOS
                             8088 ; 61   |#define HW_SR_IM_L3_SETMASK 3<<HW_SR_IM_BITPOS
                             8089 ; 62   |#define HW_SR_SM_SETMASK 3<<HW_SR_SM_BITPOS
                             8090 ; 63   |#define HW_SR_SM0_SETMASK 1<<HW_SR_SM0_BITPOS
                             8091 ; 64   |#define HW_SR_SM1_SETMASK 1<<HW_SR_SM1_BITPOS
                             8092 ; 65   |#define HW_SR_TM_SETMASK 1<<HW_SR_TM_BITPOS
                             8093 ; 66   |#define HW_SR_DP_SETMASK 1<<HW_SR_DP_BITPOS
                             8094 ; 67   |#define HW_SR_LOOP_SETMASK 1<<HW_SR_LOOP_BITPOS
                             8095 ; 68   |
                             8096 ; 69   |#define HW_SR_C_CLRMASK ~(WORD)HW_SR_C_SETMASK
                             8097 ; 70   |#define HW_SR_O_CLRMASK ~(WORD)HW_SR_O_SETMASK
                             8098 ; 71   |#define HW_SR_Z_CLRMASK ~(WORD)HW_SR_Z_SETMASK
                             8099 ; 72   |#define HW_SR_N_CLRMASK ~(WORD)HW_SR_N_SETMASK
                             8100 ; 73   |#define HW_SR_U_CLRMASK ~(WORD)HW_SR_U_SETMASK
                             8101 ; 74   |#define HW_SR_E_CLRMASK ~(WORD)HW_SR_E_SETMASK
                             8102 ; 75   |#define HW_SR_L_CLRMASK ~(WORD)HW_SR_L_SETMASK
                             8103 ; 76   |#define HW_SR_IM_CLRMASK (0x00FFFF)&(~(WORD)HW_SR_IM_SETMASK)
                             8104 ; 77   |#define HW_SR_IM0_CLRMASK ~(WORD)HW_SR_IM0_SETMASK
                             8105 ; 78   |#define HW_SR_IM1_CLRMASK ~(WORD)HW_SR_IM1_SETMASK
                             8106 ; 79   |#define HW_SR_SM_CLRMASK ~(WORD)HW_SR_SM_SETMASK
                             8107 ; 80   |#define HW_SR_SM0_CLRMASK ~(WORD)HW_SR_SM0_SETMASK
                             8108 ; 81   |#define HW_SR_SM1_CLRMASK ~(WORD)HW_SR_SM1_SETMASK
                             8109 ; 82   |#define HW_SR_TM_CLRMASK ~(WORD)HW_SR_TM_SETMASK
                             8110 ; 83   |#define HW_SR_DP_CLRMASK ~(WORD)HW_SR_DP_SETMASK
                             8111 ; 84   |#define HW_SR_LOOP_CLRMASK ~(WORD)HW_SR_LOOP_SETMASK
                             8112 ; 85   |
                             8113 ; 86   |/////////////////////////////////////////////////////////////////////////////////
                             8114 ; 87   |//  RAM/ROM Config Register Bit Positions
                             8115 ; 88   |#define HW_RAM_ROM_CFG_ROM_IMAGE_EN_BITPOS 18
                             8116 ; 89   |#define HW_RAM_ROM_CFG_ROM_CLK_EN_BITPOS 19
                             8117 ; 90   |#define HW_RAM_ROM_CFG_PXRAM_CLK_EN_BITPOS 20
                             8118 ; 91   |#define HW_RAM_ROM_CFG_PYRAM_CLK_EN_BITPOS 21
                             8119 ; 92   |#endif
                             8120 ; 93   |
                             8121 ; 94   |
                             8122 
                             8124 
                             8125 ; 29   |//#define INSTRUMENT_ENABLE 1
                             8126 ; 30   |#include "instrument.h"
                             8127 
                             8129 
                             8130 ; 1    |//  Event   Pin       GP      Function       Bank  Bit
                             8131 ; 2    |//    00     22       42      Button         GPIO1 18
                             8132 ; 3    |//    01     40       46      Button         GPIO1 22
                             8133 ; 4    |//    02     41       47      Button         GPIO1 23
                             8134 ; 5    |//    03     42       48      Button         GPIO2  0
                             8135 ; 6    |//    04      1       14      SPI MOSI       GPIO0 14
                             8136 ; 7    |//    05      2       13      SPI MISO       GPIO0 13
                             8137 ; 8    |//    06      3       12      SPI SCK        GPIO0 12
                             8138 ; 9    |//    07    100       15      SPI SS         GPIO0 15
                             8139 ; 10   |
                             8140 ; 11   |#ifndef _INSTRUMENT_H
                             8141 ; 12   |#define _INSTRUMENT_H
                             8142 ; 13   |
                             8143 ; 14   |#ifdef INSTRUMENT_ENABLE
                             8144 ; 15   |
                             8145 ; 16   |#include "regsgpio.h"
                             8146 ; 17   |
                             8147 ; 18   |#define EventSetup00();  HW_GP1DOER.B.B18=1; HW_GP1DOR.B.B18=0; HW_GP1ENR.B.B18=1;
                             8148 ; 19   |#define EventSetup01();  HW_GP1DOER.B.B22=1; HW_GP1DOR.B.B22=0; HW_GP1ENR.B.B22=1;
                             8149 ; 20   |#define EventSetup02();  HW_GP1DOER.B.B23=1; HW_GP1DOR.B.B23=0; HW_GP1ENR.B.B23=1;
                             8150 ; 21   |#define EventSetup03();  HW_GP2DOER.B.B0=1;  HW_GP2DOR.B.B0=0;  HW_GP2ENR.B.B0=1;
                             8151 ; 22   |#define EventSetup04();  HW_GP0DOER.B.B14=1; HW_GP0DOR.B.B14=0; HW_GP0ENR.B.B14=1;
                             8152 ; 23   |#define EventSetup05();  HW_GP0DOER.B.B13=1; HW_GP0DOR.B.B13=0; HW_GP0ENR.B.B13=1;
                             8153 ; 24   |#define EventSetup06();  HW_GP0DOER.B.B12=1; HW_GP0DOR.B.B12=0; HW_GP0ENR.B.B12=1;
                             8154 ; 25   |#define EventSetup07();  HW_GP0DOER.B.B15=1; HW_GP0DOR.B.B15=0; HW_GP0ENR.B.B15=1;
                             8155 ; 26   |
                             8156 ; 27   |#define EventSet00();   HW_GP1DOR.B.B18=1;
                             8157 ; 28   |#define EventSet01();   HW_GP1DOR.B.B22=1;
                             8158 ; 29   |#define EventSet02();   HW_GP1DOR.B.B23=1;
                             8159 ; 30   |#define EventSet03();   HW_GP2DOR.B.B0=1;
                             8160 ; 31   |#define EventSet04();   HW_GP0DOR.B.B14=1;
                             8161 ; 32   |#define EventSet05();   HW_GP0DOR.B.B13=1;
                             8162 ; 33   |//#define EventSet04();
                             8163 ; 34   |//#define EventSet05();
                             8164 ; 35   |#define EventSet06();   HW_GP0DOR.B.B12=1;
                             8165 ; 36   |#define EventSet07();   HW_GP0DOR.B.B15=1;
                             8166 ; 37   |                        
                             8167 ; 38   |#define EventClear00(); HW_GP1DOR.B.B18=0;
                             8168 ; 39   |#define EventClear01(); HW_GP1DOR.B.B22=0;
                             8169 ; 40   |#define EventClear02(); HW_GP1DOR.B.B23=0;
                             8170 ; 41   |#define EventClear03(); HW_GP2DOR.B.B0=0;
                             8171 ; 42   |#define EventClear04(); HW_GP0DOR.B.B14=0;
                             8172 ; 43   |#define EventClear05(); HW_GP0DOR.B.B13=0;
                             8173 ; 44   |//#define EventClear04();
                             8174 ; 45   |//#define EventClear05();
                             8175 ; 46   |#define EventClear06(); HW_GP0DOR.B.B12=0;
                             8176 ; 47   |#define EventClear07(); HW_GP0DOR.B.B15=0;
                             8177 ; 48   |                        
                             8178 ; 49   |#else // #ifdef INSTRUMENT_ENABLE
                             8179 ; 50   |
                             8180 ; 51   |#define EventSetup00();
                             8181 ; 52   |#define EventSetup01();
                             8182 ; 53   |#define EventSetup02();
                             8183 ; 54   |#define EventSetup03();
                             8184 ; 55   |#define EventSetup04();
                             8185 ; 56   |#define EventSetup05();
                             8186 ; 57   |#define EventSetup06();
                             8187 ; 58   |#define EventSetup07();
                             8188 ; 59   |
                             8189 ; 60   |#define EventSet00();
                             8190 ; 61   |#define EventSet01();
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  33

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8191 ; 62   |#define EventSet02();
                             8192 ; 63   |#define EventSet03();
                             8193 ; 64   |#define EventSet04();
                             8194 ; 65   |#define EventSet05();
                             8195 ; 66   |#define EventSet06();
                             8196 ; 67   |#define EventSet07();
                             8197 ; 68   |                        
                             8198 ; 69   |#define EventClear00();
                             8199 ; 70   |#define EventClear01();
                             8200 ; 71   |#define EventClear02();
                             8201 ; 72   |#define EventClear03();
                             8202 ; 73   |#define EventClear04();
                             8203 ; 74   |#define EventClear05();
                             8204 ; 75   |#define EventClear06();
                             8205 ; 76   |#define EventClear07();
                             8206 ; 77   |
                             8207 ; 78   |#endif // #ifdef INSTRUMENT_ENABLE
                             8208 ; 79   |
                             8209 ; 80   |#endif // #ifndef _INSTRUMENT_H
                             8210 
                             8212 
                             8213 ; 31   |#include "..\phy.h"
                             8214 
                             8216 
                             8217 ; 1    |#ifndef __PHY
                             8218 ; 2    |RETCODE PHY_Startup(void);
                             8219 ; 3    |RETCODE PHY_Resume(void);
                             8220 ; 4    |RETCODE PHY_Shutdown(void);
                             8221 ; 5    |#endif
                             8222 
                             8224 
                             8225 ; 32   |#include "regsgpio.h"
                             8226 
                             8228 
                             8229 ; 1    |#if !(defined(__REGS_GPIO_INC))
                             8230 ; 2    |#define __REGS_GPIO_INC 1
                             8231 ; 3    |
                             8232 ; 4    |#include "types.h"
                             8233 
                             8235 
                             8236 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             8237 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             8238 ; 3    |//
                             8239 ; 4    |// Filename: types.h
                             8240 ; 5    |// Description: Standard data types
                             8241 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             8242 ; 7    |
                             8243 ; 8    |#ifndef _TYPES_H
                             8244 ; 9    |#define _TYPES_H
                             8245 ; 10   |
                             8246 ; 11   |// TODO:  move this outta here!
                             8247 ; 12   |#if !defined(NOERROR)
                             8248 ; 13   |#define NOERROR 0
                             8249 ; 14   |#define SUCCESS 0
                             8250 ; 15   |#endif 
                             8251 ; 16   |#if !defined(SUCCESS)
                             8252 ; 17   |#define SUCCESS  0
                             8253 ; 18   |#endif
                             8254 ; 19   |#if !defined(ERROR)
                             8255 ; 20   |#define ERROR   -1
                             8256 ; 21   |#endif
                             8257 ; 22   |#if !defined(FALSE)
                             8258 ; 23   |#define FALSE 0
                             8259 ; 24   |#endif
                             8260 ; 25   |#if !defined(TRUE)
                             8261 ; 26   |#define TRUE  1
                             8262 ; 27   |#endif
                             8263 ; 28   |
                             8264 ; 29   |#if !defined(NULL)
                             8265 ; 30   |#define NULL 0
                             8266 ; 31   |#endif
                             8267 ; 32   |
                             8268 ; 33   |#define MAX_INT     0x7FFFFF
                             8269 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             8270 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             8271 ; 36   |#define MAX_ULONG   (-1) 
                             8272 ; 37   |
                             8273 ; 38   |#define WORD_SIZE   24              // word size in bits
                             8274 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             8275 ; 40   |
                             8276 ; 41   |
                             8277 ; 42   |#define BYTE    unsigned char       // btVarName
                             8278 ; 43   |#define CHAR    signed char         // cVarName
                             8279 ; 44   |#define USHORT  unsigned short      // usVarName
                             8280 ; 45   |#define SHORT   unsigned short      // sVarName
                             8281 ; 46   |#define WORD    unsigned int        // wVarName
                             8282 ; 47   |#define INT     signed int          // iVarName
                             8283 ; 48   |#define DWORD   unsigned long       // dwVarName
                             8284 ; 49   |#define LONG    signed long         // lVarName
                             8285 ; 50   |#define BOOL    unsigned int        // bVarName
                             8286 ; 51   |#define FRACT   _fract              // frVarName
                             8287 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             8288 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             8289 ; 54   |#define FLOAT   float               // fVarName
                             8290 ; 55   |#define DBL     double              // dVarName
                             8291 ; 56   |#define ENUM    enum                // eVarName
                             8292 ; 57   |#define CMX     _complex            // cmxVarName
                             8293 ; 58   |typedef WORD UCS3;                   // 
                             8294 ; 59   |
                             8295 ; 60   |#define UINT16  unsigned short
                             8296 ; 61   |#define UINT8   unsigned char   
                             8297 ; 62   |#define UINT32  unsigned long
                             8298 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             8299 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             8300 ; 65   |#define WCHAR   UINT16
                             8301 ; 66   |
                             8302 ; 67   |//UINT128 is 16 bytes or 6 words
                             8303 ; 68   |typedef struct UINT128_3500 {   
                             8304 ; 69   |    int val[6];     
                             8305 ; 70   |} UINT128_3500;
                             8306 ; 71   |
                             8307 ; 72   |#define UINT128   UINT128_3500
                             8308 ; 73   |
                             8309 ; 74   |// Little endian word packed byte strings:   
                             8310 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             8311 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             8312 ; 77   |// Little endian word packed byte strings:   
                             8313 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             8314 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             8315 ; 80   |
                             8316 ; 81   |// Declare Memory Spaces To Use When Coding
                             8317 ; 82   |// A. Sector Buffers
                             8318 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             8319 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             8320 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             8321 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             8322 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             8323 ; 88   |// B. Media DDI Memory
                             8324 ; 89   |#define MEDIA_DDI_MEM _Y
                             8325 ; 90   |
                             8326 ; 91   |
                             8327 ; 92   |
                             8328 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             8329 ; 94   |// Examples of circular pointers:
                             8330 ; 95   |//    INT CIRC cpiVarName
                             8331 ; 96   |//    DWORD CIRC cpdwVarName
                             8332 ; 97   |
                             8333 ; 98   |#define RETCODE INT                 // rcVarName
                             8334 ; 99   |
                             8335 ; 100  |// generic bitfield structure
                             8336 ; 101  |struct Bitfield {
                             8337 ; 102  |    unsigned int B0  :1;
                             8338 ; 103  |    unsigned int B1  :1;
                             8339 ; 104  |    unsigned int B2  :1;
                             8340 ; 105  |    unsigned int B3  :1;
                             8341 ; 106  |    unsigned int B4  :1;
                             8342 ; 107  |    unsigned int B5  :1;
                             8343 ; 108  |    unsigned int B6  :1;
                             8344 ; 109  |    unsigned int B7  :1;
                             8345 ; 110  |    unsigned int B8  :1;
                             8346 ; 111  |    unsigned int B9  :1;
                             8347 ; 112  |    unsigned int B10 :1;
                             8348 ; 113  |    unsigned int B11 :1;
                             8349 ; 114  |    unsigned int B12 :1;
                             8350 ; 115  |    unsigned int B13 :1;
                             8351 ; 116  |    unsigned int B14 :1;
                             8352 ; 117  |    unsigned int B15 :1;
                             8353 ; 118  |    unsigned int B16 :1;
                             8354 ; 119  |    unsigned int B17 :1;
                             8355 ; 120  |    unsigned int B18 :1;
                             8356 ; 121  |    unsigned int B19 :1;
                             8357 ; 122  |    unsigned int B20 :1;
                             8358 ; 123  |    unsigned int B21 :1;
                             8359 ; 124  |    unsigned int B22 :1;
                             8360 ; 125  |    unsigned int B23 :1;
                             8361 ; 126  |};
                             8362 ; 127  |
                             8363 ; 128  |union BitInt {
                             8364 ; 129  |        struct Bitfield B;
                             8365 ; 130  |        int        I;
                             8366 ; 131  |};
                             8367 ; 132  |
                             8368 ; 133  |#define MAX_MSG_LENGTH 10
                             8369 ; 134  |struct CMessage
                             8370 ; 135  |{
                             8371 ; 136  |        unsigned int m_uLength;
                             8372 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             8373 ; 138  |};
                             8374 ; 139  |
                             8375 ; 140  |typedef struct {
                             8376 ; 141  |    WORD m_wLength;
                             8377 ; 142  |    WORD m_wMessage;
                             8378 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             8379 ; 144  |} Message;
                             8380 ; 145  |
                             8381 ; 146  |struct MessageQueueDescriptor
                             8382 ; 147  |{
                             8383 ; 148  |        int *m_pBase;
                             8384 ; 149  |        int m_iModulo;
                             8385 ; 150  |        int m_iSize;
                             8386 ; 151  |        int *m_pHead;
                             8387 ; 152  |        int *m_pTail;
                             8388 ; 153  |};
                             8389 ; 154  |
                             8390 ; 155  |struct ModuleEntry
                             8391 ; 156  |{
                             8392 ; 157  |    int m_iSignaledEventMask;
                             8393 ; 158  |    int m_iWaitEventMask;
                             8394 ; 159  |    int m_iResourceOfCode;
                             8395 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             8396 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             8397 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             8398 ; 163  |    int m_uTimeOutHigh;
                             8399 ; 164  |    int m_uTimeOutLow;
                             8400 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             8401 ; 166  |};
                             8402 ; 167  |
                             8403 ; 168  |union WaitMask{
                             8404 ; 169  |    struct B{
                             8405 ; 170  |        unsigned int m_bNone     :1;
                             8406 ; 171  |        unsigned int m_bMessage  :1;
                             8407 ; 172  |        unsigned int m_bTimer    :1;
                             8408 ; 173  |        unsigned int m_bButton   :1;
                             8409 ; 174  |    } B;
                             8410 ; 175  |    int I;
                             8411 ; 176  |} ;
                             8412 ; 177  |
                             8413 ; 178  |
                             8414 ; 179  |struct Button {
                             8415 ; 180  |        WORD wButtonEvent;
                             8416 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             8417 ; 182  |};
                             8418 ; 183  |
                             8419 ; 184  |struct Message {
                             8420 ; 185  |        WORD wMsgLength;
                             8421 ; 186  |        WORD wMsgCommand;
                             8422 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             8423 ; 188  |};
                             8424 ; 189  |
                             8425 ; 190  |union EventTypes {
                             8426 ; 191  |        struct CMessage msg;
                             8427 ; 192  |        struct Button Button ;
                             8428 ; 193  |        struct Message Message;
                             8429 ; 194  |};
                             8430 ; 195  |
                             8431 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             8432 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             8433 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             8434 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             8435 ; 200  |
                             8436 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             8437 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             8438 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             8439 ; 204  |
                             8440 ; 205  |#if DEBUG
                             8441 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             8442 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             8443 ; 208  |#else 
                             8444 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             8445 ; 210  |#define DebugBuildAssert(x)    
                             8446 ; 211  |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  34

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8447 ; 212  |
                             8448 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             8449 ; 214  |//  #pragma asm
                             8450 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             8451 ; 216  |//  #pragma endasm
                             8452 ; 217  |
                             8453 ; 218  |
                             8454 ; 219  |#ifdef COLOR_262K
                             8455 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             8456 ; 221  |#elif defined(COLOR_65K)
                             8457 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             8458 ; 223  |#else
                             8459 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             8460 ; 225  |#endif
                             8461 ; 226  |    
                             8462 ; 227  |#endif // #ifndef _TYPES_H
                             8463 
                             8465 
                             8466 ; 5    |
                             8467 ; 6    |/////////////////////////////////////////////////////////////////////////////////
                             8468 ; 7    |//  Interrupt Collector Registers
                             8469 ; 8    |/////////////////////////////////////////////////////////////////////////////////
                             8470 ; 9    |
                             8471 ; 10   |#define HW_GPIO_BASEADDR 0xF400
                             8472 ; 11   |
                             8473 ; 12   |#define HW_GPB0_BASEADDR HW_GPIO_BASEADDR
                             8474 ; 13   |#define HW_GPB1_BASEADDR HW_GPIO_BASEADDR+0x10
                             8475 ; 14   |#define HW_GPB2_BASEADDR HW_GPIO_BASEADDR+0x20
                             8476 ; 15   |#define HW_GPB3_BASEADDR HW_GPIO_BASEADDR+0x30
                             8477 ; 16   |
                             8478 ; 17   |#define HW_GPB0_BLOCKNUM 0
                             8479 ; 18   |#define HW_GPB1_BLOCKNUM 1
                             8480 ; 19   |#define HW_GPB2_BLOCKNUM 2
                             8481 ; 20   |#define HW_GPB3_BLOCKNUM 3
                             8482 ; 21   |
                             8483 ; 22   |#define HW_GPB_GPENR 0
                             8484 ; 23   |#define HW_GPB_GPDOR 1
                             8485 ; 24   |#define HW_GPB_GPDIR 2
                             8486 ; 25   |#define HW_GPB_GPDOER 3
                             8487 ; 26   |#define HW_GPB_GPIPENR 4
                             8488 ; 27   |#define HW_GPB_GPIENR 5
                             8489 ; 28   |#define HW_GPB_GPILVLR 6
                             8490 ; 29   |#define HW_GPB_GPIPOLR 7
                             8491 ; 30   |#define HW_GPB_GPISTATR 8
                             8492 ; 31   |#define HW_GPB_GPPWR 9
                             8493 ; 32   |#define HW_GPB_GP8MA 10
                             8494 ; 33   |
                             8495 ; 34   |
                             8496 ; 35   |
                             8497 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                             8498 ; 37   |//  GPIO Register Bit Positions
                             8499 ; 38   |typedef union               /* GPIO Pin Register Bank 0 */
                             8500 ; 39   |{
                             8501 ; 40   |    struct Bitfield B;      // Bitfield is generic structure B0 - B23 in types.h
                             8502 ; 41   |    unsigned int I;
                             8503 ; 42   |    unsigned int U;
                             8504 ; 43   |} gpr_type;
                             8505 ; 44   |
                             8506 ; 45   |#define HW_GP_B0_BITPOS 0
                             8507 ; 46   |#define HW_GP_B1_BITPOS 1
                             8508 ; 47   |#define HW_GP_B2_BITPOS 2
                             8509 ; 48   |#define HW_GP_B3_BITPOS 3
                             8510 ; 49   |#define HW_GP_B4_BITPOS 4
                             8511 ; 50   |#define HW_GP_B5_BITPOS 5
                             8512 ; 51   |#define HW_GP_B6_BITPOS 6
                             8513 ; 52   |#define HW_GP_B7_BITPOS 7
                             8514 ; 53   |#define HW_GP_B8_BITPOS 8
                             8515 ; 54   |#define HW_GP_B9_BITPOS 9
                             8516 ; 55   |#define HW_GP_B10_BITPOS 10
                             8517 ; 56   |#define HW_GP_B11_BITPOS 11
                             8518 ; 57   |#define HW_GP_B12_BITPOS 12
                             8519 ; 58   |#define HW_GP_B13_BITPOS 13
                             8520 ; 59   |#define HW_GP_B14_BITPOS 14
                             8521 ; 60   |#define HW_GP_B15_BITPOS 15
                             8522 ; 61   |#define HW_GP_B16_BITPOS 16
                             8523 ; 62   |#define HW_GP_B17_BITPOS 17
                             8524 ; 63   |#define HW_GP_B18_BITPOS 18
                             8525 ; 64   |#define HW_GP_B19_BITPOS 19
                             8526 ; 65   |#define HW_GP_B20_BITPOS 20
                             8527 ; 66   |#define HW_GP_B21_BITPOS 21
                             8528 ; 67   |#define HW_GP_B22_BITPOS 22
                             8529 ; 68   |#define HW_GP_B23_BITPOS 23
                             8530 ; 69   |
                             8531 ; 70   |#define HW_GP_B0_SETMASK (1<<HW_GP_B0_BITPOS)
                             8532 ; 71   |#define HW_GP_B1_SETMASK (1<<HW_GP_B1_BITPOS)
                             8533 ; 72   |#define HW_GP_B2_SETMASK (1<<HW_GP_B2_BITPOS)
                             8534 ; 73   |#define HW_GP_B3_SETMASK (1<<HW_GP_B3_BITPOS)
                             8535 ; 74   |#define HW_GP_B4_SETMASK (1<<HW_GP_B4_BITPOS)
                             8536 ; 75   |#define HW_GP_B5_SETMASK (1<<HW_GP_B5_BITPOS)
                             8537 ; 76   |#define HW_GP_B6_SETMASK (1<<HW_GP_B6_BITPOS)
                             8538 ; 77   |#define HW_GP_B7_SETMASK (1<<HW_GP_B7_BITPOS)
                             8539 ; 78   |#define HW_GP_B8_SETMASK (1<<HW_GP_B8_BITPOS)
                             8540 ; 79   |#define HW_GP_B9_SETMASK (1<<HW_GP_B9_BITPOS)
                             8541 ; 80   |#define HW_GP_B10_SETMASK (1<<HW_GP_B10_BITPOS)
                             8542 ; 81   |#define HW_GP_B11_SETMASK (1<<HW_GP_B11_BITPOS)
                             8543 ; 82   |#define HW_GP_B12_SETMASK (1<<HW_GP_B12_BITPOS)
                             8544 ; 83   |#define HW_GP_B13_SETMASK (1<<HW_GP_B13_BITPOS)
                             8545 ; 84   |#define HW_GP_B14_SETMASK (1<<HW_GP_B14_BITPOS)
                             8546 ; 85   |#define HW_GP_B15_SETMASK (1<<HW_GP_B15_BITPOS)
                             8547 ; 86   |#define HW_GP_B16_SETMASK (1<<HW_GP_B16_BITPOS)
                             8548 ; 87   |#define HW_GP_B17_SETMASK (1<<HW_GP_B17_BITPOS)
                             8549 ; 88   |#define HW_GP_B18_SETMASK (1<<HW_GP_B18_BITPOS)
                             8550 ; 89   |#define HW_GP_B19_SETMASK (1<<HW_GP_B19_BITPOS)
                             8551 ; 90   |#define HW_GP_B20_SETMASK (1<<HW_GP_B20_BITPOS)
                             8552 ; 91   |#define HW_GP_B21_SETMASK (1<<HW_GP_B21_BITPOS)
                             8553 ; 92   |#define HW_GP_B22_SETMASK (1<<HW_GP_B22_BITPOS)
                             8554 ; 93   |#define HW_GP_B23_SETMASK (1<<HW_GP_B23_BITPOS)
                             8555 ; 94   |
                             8556 ; 95   |#define HW_GP_B0_CLRMASK (~(WORD)HW_GP_B0_SETMASK)
                             8557 ; 96   |#define HW_GP_B1_CLRMASK (~(WORD)HW_GP_B1_SETMASK)
                             8558 ; 97   |#define HW_GP_B2_CLRMASK (~(WORD)HW_GP_B2_SETMASK)
                             8559 ; 98   |#define HW_GP_B3_CLRMASK (~(WORD)HW_GP_B3_SETMASK)
                             8560 ; 99   |#define HW_GP_B4_CLRMASK (~(WORD)HW_GP_B4_SETMASK)
                             8561 ; 100  |#define HW_GP_B5_CLRMASK (~(WORD)HW_GP_B5_SETMASK)
                             8562 ; 101  |#define HW_GP_B6_CLRMASK (~(WORD)HW_GP_B6_SETMASK)
                             8563 ; 102  |#define HW_GP_B7_CLRMASK (~(WORD)HW_GP_B7_SETMASK)
                             8564 ; 103  |#define HW_GP_B8_CLRMASK (~(WORD)HW_GP_B8_SETMASK)
                             8565 ; 104  |#define HW_GP_B9_CLRMASK (~(WORD)HW_GP_B9_SETMASK)
                             8566 ; 105  |#define HW_GP_B10_CLRMASK (~(WORD)HW_GP_B10_SETMASK)
                             8567 ; 106  |#define HW_GP_B11_CLRMASK (~(WORD)HW_GP_B11_SETMASK)
                             8568 ; 107  |#define HW_GP_B12_CLRMASK (~(WORD)HW_GP_B12_SETMASK)
                             8569 ; 108  |#define HW_GP_B13_CLRMASK (~(WORD)HW_GP_B13_SETMASK)
                             8570 ; 109  |#define HW_GP_B14_CLRMASK (~(WORD)HW_GP_B14_SETMASK)
                             8571 ; 110  |#define HW_GP_B15_CLRMASK (~(WORD)HW_GP_B15_SETMASK)
                             8572 ; 111  |#define HW_GP_B16_CLRMASK (~(WORD)HW_GP_B16_SETMASK)
                             8573 ; 112  |#define HW_GP_B17_CLRMASK (~(WORD)HW_GP_B17_SETMASK)
                             8574 ; 113  |#define HW_GP_B18_CLRMASK (~(WORD)HW_GP_B18_SETMASK)
                             8575 ; 114  |#define HW_GP_B19_CLRMASK (~(WORD)HW_GP_B19_SETMASK)
                             8576 ; 115  |#define HW_GP_B20_CLRMASK (~(WORD)HW_GP_B20_SETMASK)
                             8577 ; 116  |#define HW_GP_B21_CLRMASK (~(WORD)HW_GP_B21_SETMASK)
                             8578 ; 117  |#define HW_GP_B22_CLRMASK (~(WORD)HW_GP_B22_SETMASK)
                             8579 ; 118  |#define HW_GP_B23_CLRMASK (~(WORD)HW_GP_B23_SETMASK)
                             8580 ; 119  |
                             8581 ; 120  |/////////////////////////////////////////////////////////////////////////////////
                             8582 ; 121  |//  GPIO 8mA Register Bit Positions
                             8583 ; 122  |#define HW_GP8MA_B7_B0_BITPOS 0
                             8584 ; 123  |#define HW_GP8MA_B15_B8_BITPOS 1
                             8585 ; 124  |#define HW_GP8MA_B23_B16_BITPOS 2
                             8586 ; 125  |#define HW_GP8MA_CLK_GATE_BITPOS 23
                             8587 ; 126  |
                             8588 ; 127  |
                             8589 ; 128  |/////////////////////////////////////////////////////////////////////////////////
                             8590 ; 129  |//  Logical GPIO numbers
                             8591 ; 130  |#define HW_GPIO_000 0
                             8592 ; 131  |#define HW_GPIO_001 1
                             8593 ; 132  |#define HW_GPIO_002 2
                             8594 ; 133  |#define HW_GPIO_003 3
                             8595 ; 134  |#define HW_GPIO_004 4
                             8596 ; 135  |#define HW_GPIO_005 5
                             8597 ; 136  |#define HW_GPIO_006 6
                             8598 ; 137  |#define HW_GPIO_007 7
                             8599 ; 138  |#define HW_GPIO_008 8
                             8600 ; 139  |#define HW_GPIO_009 9
                             8601 ; 140  |#define HW_GPIO_010 10
                             8602 ; 141  |#define HW_GPIO_011 11
                             8603 ; 142  |#define HW_GPIO_012 12
                             8604 ; 143  |#define HW_GPIO_013 13
                             8605 ; 144  |#define HW_GPIO_014 14
                             8606 ; 145  |#define HW_GPIO_015 15
                             8607 ; 146  |#define HW_GPIO_016 16
                             8608 ; 147  |#define HW_GPIO_017 17
                             8609 ; 148  |#define HW_GPIO_018 18
                             8610 ; 149  |#define HW_GPIO_019 19
                             8611 ; 150  |#define HW_GPIO_020 20
                             8612 ; 151  |#define HW_GPIO_021 21
                             8613 ; 152  |#define HW_GPIO_022 22
                             8614 ; 153  |#define HW_GPIO_023 23
                             8615 ; 154  |#define HW_GPIO_024 24
                             8616 ; 155  |#define HW_GPIO_025 25
                             8617 ; 156  |#define HW_GPIO_026 26
                             8618 ; 157  |#define HW_GPIO_027 27
                             8619 ; 158  |#define HW_GPIO_028 28
                             8620 ; 159  |#define HW_GPIO_029 29
                             8621 ; 160  |#define HW_GPIO_030 30
                             8622 ; 161  |#define HW_GPIO_031 31
                             8623 ; 162  |#define HW_GPIO_032 32
                             8624 ; 163  |#define HW_GPIO_033 33
                             8625 ; 164  |#define HW_GPIO_034 34
                             8626 ; 165  |#define HW_GPIO_035 35
                             8627 ; 166  |#define HW_GPIO_036 36
                             8628 ; 167  |#define HW_GPIO_037 37
                             8629 ; 168  |#define HW_GPIO_038 38
                             8630 ; 169  |#define HW_GPIO_039 39
                             8631 ; 170  |#define HW_GPIO_040 40
                             8632 ; 171  |#define HW_GPIO_041 41
                             8633 ; 172  |#define HW_GPIO_042 42
                             8634 ; 173  |#define HW_GPIO_043 43
                             8635 ; 174  |#define HW_GPIO_044 44
                             8636 ; 175  |#define HW_GPIO_045 45
                             8637 ; 176  |#define HW_GPIO_046 46
                             8638 ; 177  |#define HW_GPIO_047 47
                             8639 ; 178  |#define HW_GPIO_048 48
                             8640 ; 179  |#define HW_GPIO_049 49
                             8641 ; 180  |#define HW_GPIO_050 50
                             8642 ; 181  |#define HW_GPIO_051 51
                             8643 ; 182  |#define HW_GPIO_052 52
                             8644 ; 183  |#define HW_GPIO_053 53
                             8645 ; 184  |#define HW_GPIO_054 54
                             8646 ; 185  |#define HW_GPIO_055 55
                             8647 ; 186  |#define HW_GPIO_056 56
                             8648 ; 187  |#define HW_GPIO_057 57
                             8649 ; 188  |#define HW_GPIO_058 58
                             8650 ; 189  |#define HW_GPIO_059 59
                             8651 ; 190  |#define HW_GPIO_060 60
                             8652 ; 191  |#define HW_GPIO_061 61
                             8653 ; 192  |#define HW_GPIO_062 62
                             8654 ; 193  |#define HW_GPIO_063 63
                             8655 ; 194  |#define HW_GPIO_064 64
                             8656 ; 195  |#define HW_GPIO_065 65
                             8657 ; 196  |#define HW_GPIO_066 66
                             8658 ; 197  |#define HW_GPIO_067 67
                             8659 ; 198  |#define HW_GPIO_068 68
                             8660 ; 199  |#define HW_GPIO_069 69
                             8661 ; 200  |#define HW_GPIO_070 70
                             8662 ; 201  |#define HW_GPIO_071 71
                             8663 ; 202  |#define HW_GPIO_072 72
                             8664 ; 203  |#define HW_GPIO_073 73
                             8665 ; 204  |#define HW_GPIO_074 74
                             8666 ; 205  |#define HW_GPIO_075 75
                             8667 ; 206  |#define HW_GPIO_076 76
                             8668 ; 207  |#define HW_GPIO_077 77
                             8669 ; 208  |#define HW_GPIO_078 78
                             8670 ; 209  |#define HW_GPIO_079 79
                             8671 ; 210  |#define HW_GPIO_080 80
                             8672 ; 211  |#define HW_GPIO_081 81
                             8673 ; 212  |#define HW_GPIO_082 82
                             8674 ; 213  |#define HW_GPIO_083 83
                             8675 ; 214  |#define HW_GPIO_084 84
                             8676 ; 215  |#define HW_GPIO_085 85
                             8677 ; 216  |#define HW_GPIO_086 86
                             8678 ; 217  |#define HW_GPIO_087 87
                             8679 ; 218  |#define HW_GPIO_088 88
                             8680 ; 219  |#define HW_GPIO_089 89
                             8681 ; 220  |#define HW_GPIO_090 90
                             8682 ; 221  |#define HW_GPIO_091 91
                             8683 ; 222  |#define HW_GPIO_092 92
                             8684 ; 223  |#define HW_GPIO_093 93
                             8685 ; 224  |#define HW_GPIO_094 94
                             8686 ; 225  |#define HW_GPIO_095 95
                             8687 ; 226  |#define HW_GPIO_LAST HW_GPIO_095
                             8688 ; 227  |
                             8689 ; 228  |#define HW_GP0ENR      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPENR))  /* GPIO 0 Enable Register   */
                             8690 ; 229  |#define HW_GP0DOR      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPDOR)) /* GPIO 0 Data Out Register */
                             8691 ; 230  |#define HW_GP0DIR      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPDIR)) /* GPIO 0 Dait In Register  */
                             8692 ; 231  |#define HW_GP0DOER     (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPDOER)) /* GPIO 0 Dait Out Enable Register  */
                             8693 ; 232  |#define HW_GP0IPENR    (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPIPENR)) /* GPIO 0 Interrupt Pin Enable Register */
                             8694 ; 233  |#define HW_GP0IENR     (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPIENR)) /* GPIO 0 Interrupt Enable Register */
                             8695 ; 234  |#define HW_GP0ILVLR    (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPILVLR)) /* GPIO 0 Interrupt Level Register  */
                             8696 ; 235  |#define HW_GP0IPOLR    (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPIPOLR)) /* GPIO 0 Interrupt Polarity Register   */
                             8697 ; 236  |#define HW_GP0ISTATR   (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPISTATR)) /* GPIO 0 Interrupt Status Register */
                             8698 ; 237  |#define HW_GP0PWR      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPPWR)) /* GPIO 0 Power Register */
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  35

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8699 ; 238  |#define HW_GP08MA      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GP8MA)) 
                             8700 ; 239  |#define HW_GP1ENR      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPENR))     /* GPIO 1 Enable Register   */
                             8701 ; 240  |#define HW_GP1DOR      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPDOR)) /* GPIO 1 Data Out Register */
                             8702 ; 241  |#define HW_GP1DIR      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPDIR)) /* GPIO 1 Dait In Register  */
                             8703 ; 242  |#define HW_GP1DOER     (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPDOER)) /* GPIO 1 Dait Out Enable Register  */
                             8704 ; 243  |#define HW_GP1IPENR    (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPIPENR)) /* GPIO 1 Interrupt Pin Enable Register */
                             8705 ; 244  |#define HW_GP1IENR     (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPIENR)) /* GPIO 1 Interrupt Enable Register */
                             8706 ; 245  |#define HW_GP1ILVLR    (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPILVLR)) /* GPIO 1 Interrupt Level Register  */
                             8707 ; 246  |#define HW_GP1IPOLR    (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPIPOLR)) /* GPIO 1 Interrupt Polarity Register   */
                             8708 ; 247  |#define HW_GP1ISTATR   (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPISTATR)) /* GPIO 1 Interrupt Status Register */
                             8709 ; 248  |#define HW_GP1PWR      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPPWR)) /* GPIO 0 Power Register */
                             8710 ; 249  |#define HW_GP18MA      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GP8MA)) 
                             8711 ; 250  |#define HW_GP2ENR      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPENR))     /* GPIO 2 Enable Register   */
                             8712 ; 251  |#define HW_GP2DOR      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPDOR)) /* GPIO 2 Data Out Register */
                             8713 ; 252  |#define HW_GP2DIR      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPDIR)) /* GPIO 2 Dait In Register  */
                             8714 ; 253  |#define HW_GP2DOER     (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPDOER)) /* GPIO 2 Dait Out Enable Register  */
                             8715 ; 254  |#define HW_GP2IPENR    (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPIPENR)) /* GPIO 2 Interrupt Pin Enable Register */
                             8716 ; 255  |#define HW_GP2IENR     (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPIENR)) /* GPIO 2 Interrupt Enable Register */
                             8717 ; 256  |#define HW_GP2ILVLR    (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPILVLR)) /* GPIO 2 Interrupt Level Register  */
                             8718 ; 257  |#define HW_GP2IPOLR    (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPIPOLR)) /* GPIO 2 Interrupt Polarity Register   */
                             8719 ; 258  |#define HW_GP2ISTATR   (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPISTATR)) /* GPIO 2 Interrupt Status Register */
                             8720 ; 259  |#define HW_GP2PWR      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPPWR)) /* GPIO 0 Power Register */
                             8721 ; 260  |#define HW_GP28MA      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GP8MA)) 
                             8722 ; 261  |#define HW_GP3ENR      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPENR))     /* GPIO 2 Enable Register   */
                             8723 ; 262  |#define HW_GP3DOR      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPDOR)) /* GPIO 2 Data Out Register */
                             8724 ; 263  |#define HW_GP3DIR      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPDIR)) /* GPIO 2 Dait In Register  */
                             8725 ; 264  |#define HW_GP3DOER     (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPDOER)) /* GPIO 2 Dait Out Enable Register  */
                             8726 ; 265  |#define HW_GP3IPENR    (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPIPENR)) /* GPIO 2 Interrupt Pin Enable Register */
                             8727 ; 266  |#define HW_GP3IENR     (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPIENR)) /* GPIO 2 Interrupt Enable Register */
                             8728 ; 267  |#define HW_GP3ILVLR    (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPILVLR)) /* GPIO 2 Interrupt Level Register  */
                             8729 ; 268  |#define HW_GP3IPOLR    (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPIPOLR)) /* GPIO 2 Interrupt Polarity Register   */
                             8730 ; 269  |#define HW_GP3ISTATR   (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPISTATR)) /* GPIO 2 Interrupt Status Register */
                             8731 ; 270  |#define HW_GP3PWR      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPPWR)) /* GPIO 0 Power Register */
                             8732 ; 271  |#define HW_GP38MA      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GP8MA)) 
                             8733 ; 272  |
                             8734 ; 273  |#endif
                             8735 ; 274  |
                             8736 
                             8738 
                             8739 ; 33   |#include "regsrevision.h"
                             8740 
                             8742 
                             8743 ; 1    |#if !(defined(__HW_REVR))
                             8744 ; 2    |#define __HW_REVR 1
                             8745 ; 3    |
                             8746 ; 4    |
                             8747 ; 5    |#define HW_GLUE_BASEADDR 0xFA00
                             8748 ; 6    |
                             8749 ; 7    |#define HW_REVR_RMN_BITPOS (0)
                             8750 ; 8    |#define HW_REVR_DCDCMODE_BITPOS (5)
                             8751 ; 9    |#define HW_REVR_RMJ_BITPOS (8)
                             8752 ; 10   |
                             8753 ; 11   |#define HW_REVR_RMN_WIDTH (5)
                             8754 ; 12   |#define HW_REVR_DCDCMODE_WIDTH (3)
                             8755 ; 13   |
                             8756 ; 14   |#define HW_REVR_DCDCMODE_SETMASK (((1<<HW_REVR_DCDCMODE_WIDTH)-1)<<HW_REVR_DCDCMODE_BITPOS)
                             8757 ; 15   |
                             8758 ; 16   |#define HW_REVR_DCDCMODE_CLRMASK (~(WORD)HW_REVR_DCDCMODE_SETMASK)
                             8759 ; 17   |
                             8760 ; 18   |
                             8761 ; 19   |/////////////////////////////////////////////////////////////////////////////////
                             8762 ; 20   |//  Revision Register (HW_REVR) bitfields and values. (read only)
                             8763 ; 21   |//  June15 2004: C struct updated to be correct: 
                             8764 ; 22   |//   Added DCDCMODE bitfield. Removed RMP bitfield. Reduced size of RMN bitfield to 5 bits.
                             8765 ; 23   |typedef union               
                             8766 ; 24   |{
                             8767 ; 25   |    struct {
                             8768 ; 26   |        unsigned RMN    :5;     //Minor Revision
                             8769 ; 27   |        unsigned DCDCMODE : 3;  //DCDC mode field function depends on DCDC mode pin strapping
                             8770 ; 28   |           #define DCDCMODE_7_CONVERTER1_2CH_BOOST_CONVERTER2_OFF      7
                             8771 ; 29   |           #define DCDCMODE_6_RESERVED                                 6
                             8772 ; 30   |           #define DCDCMODE_5_CONVERTER1_3CH_BOOST_CONVERTER2_OFF      5
                             8773 ; 31   |           #define DCDCMODE_4_RESERVED                                 4
                             8774 ; 32   |           #define DCDCMODE_3_CONVERTER1_1CH_BUCK_CONVERTER2_OFF       3
                             8775 ; 33   |           #define DCDCMODE_2_CONVERTER1_OFF_CONVERTER2_OFF            2
                             8776 ; 34   |           #define DCDCMODE_1_CONVERTER1_1CH_BUCK_CONVERTER2_1CH_BOOST 1
                             8777 ; 35   |           #define DCDCMODE_0_CONVERTER1_1CH_BUCK_CONVERTER2_1CH_BUCK  0
                             8778 ; 36   |           #define DCDCMODE_X_BUCK_MASKED_SETMASK 0x4
                             8779 ; 37   |        unsigned RMJ    :16;    //Major Revision
                             8780 ; 38   |    } B;
                             8781 ; 39   |
                             8782 ; 40   |    int I;
                             8783 ; 41   |
                             8784 ; 42   |} revr_type;
                             8785 ; 43   |#define HW_REVR (*(volatile revr_type _X*) (HW_GLUE_BASEADDR+2))
                             8786 ; 44   |
                             8787 ; 45   |#define HW_REVR_DCDCMODE_B0_BITPOS 5
                             8788 ; 46   |#define HW_REVR_DCDCMODE_B1_BITPOS 6
                             8789 ; 47   |#define HW_REVR_DCDCMODE_B2_BITPOS 7
                             8790 ; 48   |
                             8791 ; 49   |#define HW_REVR_DCDCMODE_BUCK_MASK_POS HW_REVR_DCDCMODE_B2_BITPOS
                             8792 ; 50   |// 3 bit bitfield: (HW_REVR_DCDCMODE_B2_BITPOS|HW_REVR_DCDCMODE_B1_BITPOS|HW_REVR_DCDCMODE_B0_BITPOS)
                             8793 ; 51   |#define HW_REVR_DCDC_MODE_SETMASK 0x0000E0
                             8794 ; 52   |#define HW_REVR_RMN_SETMASK 0xFF<<HW_REVR_RMN_BITPOS
                             8795 ; 53   |#define HW_REVR_RMJ_SETMASK 0xFFFF<<HW_REVR_RMJ_BITPOS
                             8796 ; 54   |
                             8797 ; 55   |#define HW_REVR_RMN_CLRMASK ~(WORD)HW_REVR_RMN_SETMASK
                             8798 ; 56   |#define HW_REVR_RMJ_CLRMASK ~(WORD)HW_REVR_RMJ_SETMASK
                             8799 ; 57   |
                             8800 ; 58   |#endif //!@def(__HW_REVR)
                             8801 ; 59   |
                             8802 
                             8804 
                             8805 ; 34   |
                             8806 ; 35   |#pragma optimize 1   
                             8808 ; 36   |
                             8809 ; 37   |#ifdef MTP_BUILD
                             8810 ; 38   |#ifdef CLCD
                             8811 ; 39   |#define MTP_LCD_SUSPEND 
                             8812 ; 40   |#endif
                             8813 ; 41   |#endif
                             8814 ; 42   |
                             8815 ; 43   |#ifdef MTP_LCD_SUSPEND
                             8816 ; 44   |#include "s6b33b0a.h"
                             8817 ; 45   |#endif
                             8818 ; 46   |
                             8819 ; 47   |////////////////////////////////////////////////////////////////////////////////
                             8820 ; 48   |//  External Definitions
                             8821 ; 49   |////////////////////////////////////////////////////////////////////////////////
                             8822 ; 50   |WORD wUsbIsrSaveSp;
                             8823 ; 51   |
                             8824 ; 52   |extern WORD CapGetChipPartID(void);
                             8825 ; 53   |
                             8826 ; 54   |#ifdef CLCD
                             8827 ; 55   |#include "displaydriver_color.h"
                             8828 ; 56   |#endif
                             8829 
                             8839 
                             8840 ; 57   |////////////////////////////////////////////////////////////////////////////////
                             8841 ; 58   |//  External References
                             8842 ; 59   |////////////////////////////////////////////////////////////////////////////////
                             8843 ; 60   |
                             8844 ; 61   |extern dQH_Struct_Cap _X dQH_Scratch_Cap;
                             8845 
                             8856 
                             8857 ; 62   |extern dQH_Struct_Setup _X dQH_Scratch_Setup_Buf;
                             8858 
                             8870 
                             8871 ; 63   |extern dTD_Struct _X * _X dTD_Base_Scratch_Address[];
                             8872 ; 64   |extern Dev_State_Struct _USB_MEM stDeviceState;
                             8873 ; 65   |extern xd_struct _X * _X dXD_Base_Address[];
                             8874 ; 66   |extern BYTE _X * _X dQH_Base_Add;
                             8875 ; 67   |extern BYTE _X * _X dTD_Base_Address[];
                             8876 ; 68   |
                             8877 ; 69   |extern xd_struct _USB_MEM * g_dXD_Queues[MAX_NUM_EP][2];
                             8878 ; 70   |
                             8879 ; 71   |////////////////////////////////////////////////////////////////////////////////
                             8880 ; 72   |//  Equates
                             8881 ; 73   |////////////////////////////////////////////////////////////////////////////////
                             8882 ; 74   |
                             8883 ; 75   |////////////////////////////////////////////////////////////////////////////////
                             8884 ; 76   |//  Prototypes
                             8885 ; 77   |////////////////////////////////////////////////////////////////////////////////
                             8886 ; 78   |void _long_interrupt(-1) usb_dci_resume_wrapper(void);
                             8887 ; 79   |WORD _reentrant read_and_clear_arc_reg_usbsts(void);
                             8888 ; 80   |WORD _reentrant read_usb_reg_16(USHORT usRegAdd);
                             8889 ; 81   |void _reentrant read_and_clear_usb_reg(USHORT usRegAdd, DWORD * dwData);
                             8890 ; 82   |
                             8891 ; 83   |////////////////////////////////////////////////////////////////////////////////
                             8892 ; 84   |//  X Memory
                             8893 ; 85   |////////////////////////////////////////////////////////////////////////////////
                             8894 ; 86   |#define  USB_TEST_MODE_TEST_PACKET_LENGTH   (53)
                             8895 ; 87   |
                             8896 ; 88   |// Chip capability register locations
                             8897 ; 89   |#define CHP_CAP_0               0xFA90
                             8898 ; 90   |#define CHP_CAP_1               0xFA91
                             8899 ; 91   |#define CHP_CAP_2               0xFA92
                             8900 ; 92   |#define CHP_CAP_3               0xFA93
                             8901 ; 93   |#define CHP_CAP_4               0xFA94
                             8902 ; 94   |#define CHP_CAP_5       0xFA95
                             8903 ; 95   |#define ChipCapReg0             (*((volatile WORD _X *) (CHP_CAP_0)))  
                             8904 ; 96   |#define ChipCapReg1             (*((volatile WORD _X *) (CHP_CAP_1)))
                             8905 ; 97   |#define ChipCapReg2             (*((volatile WORD _X *) (CHP_CAP_2)))
                             8906 ; 98   |#define ChipCapReg3             (*((volatile WORD _X *) (CHP_CAP_3)))
                             8907 ; 99   |#define ChipCapReg4             (*((volatile WORD _X *) (CHP_CAP_4)))
                             8908 ; 100  |#define ChipCapReg5             (*((volatile WORD _X *) (CHP_CAP_5)))
                             8909 ; 101  |
                             8910 ; 102  |/* Test packet for Test Mode : TEST_PACKET. USB 2.0 Specification section 7.1.20 */
                             8911 ; 103  |_packed BYTE _X TestPacket[USB_TEST_MODE_TEST_PACKET_LENGTH + 1] = 
                             8912 
                             8913 
X:0000                       8914         org     x,".xdatausb20dd",init:
                             8916 FTestPacket:
X:0000 000000 000000         8917         dc      $00++$00++$00++$00++$00++$00++$00++$00++$00++$aa++$aa++$aa++$aa++$aa++$aa
       000000 AAAAAA              
       AAAAAA                     
X:0005 EEAAAA EEEEEE         8918         dc      $ee++$aa++$aa++$ee++$ee++$ee++$ee++$ee++$ee++$ff++$fe++$ee++$ff++$ff++$ff
       EEEEEE FFFEEE              
       FFFFFF                     
X:000A FFFFFF FFFFFF         8919         dc      $ff++$ff++$ff++$ff++$ff++$ff++""++$7f++$ff++""++$fd++"~"
       BF7FFF F7EFDF              
       FCFDFB DFBF7E              
X:0010 FBF7EF 007EFD         8920         dc      ""++$00++"~"++$fd
                             8924 
                             8925 ; 104  |{
                             8926 ; 105  |    // This is three byte little endian, little bit endian.
                             8927 ; 106  |    // We only need the data portion of the test packet. The ARC 
                             8928 ; 107  |    // core will generate the synch, data PID parts of the packet
                             8929 ; 108  |    // before the data, followed by the CRC and end of packet
                             8930 ; 109  |    // after the data.
                             8931 ; 110  |    
                             8932 ; 111  |    // Synch
                             8933 ; 112  |    // PID = 0xC3
                             8934 ; 113  |    0x00, 0x00, 0x00, 
                             8935 ; 114  |    0x00, 0x00, 0x00, 
                             8936 ; 115  |    0x00, 0x00, 0x00, 
                             8937 ; 116  |    0xAA, 0xAA, 0xAA, 
                             8938 ; 117  |    0xAA, 0xAA, 0xAA, 
                             8939 ; 118  |    0xEE, 0xAA, 0xAA,
                             8940 ; 119  |    0xEE, 0xEE, 0xEE, 
                             8941 ; 120  |    0xEE, 0xEE, 0xEE, 
                             8942 ; 121  |    0xFF, 0xFE, 0xEE,
                             8943 ; 122  |    0xFF, 0xFF, 0xFF, 
                             8944 ; 123  |    0xFF, 0xFF, 0xFF, 
                             8945 ; 124  |    0xFF, 0xFF, 0xFF, 
                             8946 ; 125  |    0xBF, 0x7F, 0xFF,
                             8947 ; 126  |    0xF7, 0xEF, 0xDF,
                             8948 ; 127  |    0xFC, 0xFD, 0xFB,
                             8949 ; 128  |    0xDF, 0xBF, 0x7E,
                             8950 ; 129  |    0xFB, 0xF7, 0xEF,
                             8951 ; 130  |    0x00, 0x7E, 0xFD
                             8952 ; 131  |    // CRC = 0xCEB6
                             8953 ; 132  |    // End
                             8954 ; 133  |};
                             8955 ; 134  |
                             8956 ; 135  |USHORT _X usDevDriverSendData;
                             8957 ; 136  |////////////////////////////////////////////////////////////////////////////////
                             8958 ; 137  |//  Y Memory
                             8959 ; 138  |////////////////////////////////////////////////////////////////////////////////
                             8960 ; 139  |#ifdef MTP_BUILD
                             8961 ; 140  |#define N_SETUP_ENDPT   1
                             8962 ; 141  |#else
                             8963 ; 142  |#define N_SETUP_ENDPT   8
                             8964 ; 143  |#endif
                             8965 ; 144  |
                             8966 ; 145  |USB_SetupData g_SetupData[N_SETUP_ENDPT];
                             8967 ; 146  |
                             8968 ; 147  |static WORD s_wArcUsbIntRegShadow;
                             8969 ; 148  |
                             8970 ; 149  |////////////////////////////////////////////////////////////////////////////////
                             8971 ; 150  |//  P Memory
                             8972 ; 151  |////////////////////////////////////////////////////////////////////////////////
                             8973 ; 152  |
                             8974 ; 153  |
                             8975 ; 154  |////////////////////////////////////////////////////////////////////////////////
                             8976 ; 155  |//
                             8977 ; 156  |//>  Name:          ChipUpdateIdFlag
                             8978 ; 157  |//
                             8979 ; 158  |//   Type:          Function
                             8980 ; 159  |//
                             8981 ; 160  |//   Description:   Gets the Device ID from the registers.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  36

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8982 ; 161  |//
                             8983 ; 162  |//   Inputs:        None
                             8984 ; 163  |//
                             8985 ; 164  |//   Outputs:       The Device ID.
                             8986 ; 165  |//
                             8987 ; 166  |//   Notes:         none
                             8988 ; 167  |//<
                             8989 ; 168  |////////////////////////////////////////////////////////////////////////////////
                             8990 ; 169  |WORD ChipUpdateIdFlag(void)
                             8991 ; 170  |{
                             8992 
P:0000                       8993         org     p,".ptextusb20dd":
                             9009 FChipUpdateIdFlag:
                             9012 
                             9013 ; 171  |    WORD wDeviceIdExt = (ChipCapReg2 >>14) & (0x0001FF); // 9-bit field
                             9014 
P:0000 55F000 00FA92  3    3 9016         move    x:$FA92,b1
P:0002 060EA0         4    7 9017         rep     #14   
P:0003 20002B         2    9 9019         lsr     b
                             9021 L3:
                             9029 
                             9030 ; 172  |    WORD wAlternateDeviceIdExt = ( (ChipCapReg2 >> 15) & 0x000100) | (ChipCapReg5 & 0x0000FF); // 9bit alt id
                             9031 
P:0004 45F400 0001FF  3   12 9023         move    #$1FF,x1
P:0006 54F06E 00FA92  3   15 9024         and     x1,b	                x:$FA92,a1
P:0008 21A400         2   17 9025         move    b1,x0
P:0009 060FA0         4   21 9034         rep     #15   
P:000A 200023         2   23 9036         lsr     a
                             9038 L4:
                             9050 
                             9051 ; 173  |    WORD wDeviceId;
                             9052 ; 174  |    
                             9053 ; 175  |    // Note: 16 bit field RMJ is revision major field == 0x3500 if 35xx family
                             9054 ; 176  |    wDeviceId = HW_REVR.I;
                             9055 
                             9059 
                             9060 ; 177  |        
                             9061 ; 178  |    wDeviceId >>= 8;
                             9062 
P:000B 46F400 000100  3   26 9040         move    #$100,y0
P:000D 47F400 0000FF  3   29 9043         move    #>$FF,y1
P:000F 55F056 00FA95  3   32 9041         and     y0,a	                x:$FA95,b1
P:0011 20007E         2   34 9044         and     y1,b
P:0012 21A500         2   36 9045         move    b1,x1
P:0013 57F062 00FA02  3   39 9046         or      x1,a	                x:$FA02,b
P:0015 20002B         2   41 9066         lsr     b
P:0016 20002B         2   43 9066         lsr     b
P:0017 20002B         2   45 9066         lsr     b
P:0018 20002B         2   47 9066         lsr     b
P:0019 20002B         2   49 9066         lsr     b
P:001A 20002B         2   51 9066         lsr     b
P:001B 20002B         2   53 9066         lsr     b
P:001C 20002B         2   55 9066         lsr     b
                             9068 L5:
                             9070 
                             9071 ; 179  |    
                             9072 ; 180  |    wDeviceId ^= (wDeviceIdExt | wAlternateDeviceIdExt); // 0x35xx
                             9073 
                             9087 
                             9088 ; 181  |    
                             9089 ; 182  |    return wDeviceId;
                             9090 ; 183  |}  
                             9091 
P:001D 218641         2   57 9076         tfr     x0,a	                a1,y0
P:001E 200052         2   59 9077         or      y0,a
P:001F 218600         2   61 9082         move    a1,y0
P:0020 20005B         2   63 9083         eor     y0,b
P:0021 21AE00         2   65 9084         move    b1,a
P:0022 00000C         4   69 9093         rts
                             9096 
                             9097 ; 184  |
                             9098 ; 185  |////////////////////////////////////////////////////////////////////////////////
                             9099 ; 186  |//
                             9100 ; 187  |//>  Name:          usb_dci_init
                             9101 ; 188  |//
                             9102 ; 189  |//   Type:          Function
                             9103 ; 190  |//
                             9104 ; 191  |//   Description:   Initializes the USB device controller
                             9105 ; 192  |//
                             9106 ; 193  |//   Inputs:        pStDeviceState = Pointer to the device state structure
                             9107 ; 194  |//
                             9108 ; 195  |//   Outputs:       USB_OK or error code
                             9109 ; 196  |//
                             9110 ; 197  |//   Notes:         When this function is compiled as a funclet is is really
                             9111 ; 198  |//      part of another funclet SYSFUNCLET_USB_DEVICE_INIT.   This funclet has
                             9112 ; 199  |//      the entry point usb_device_init() which is the only function that should
                             9113 ; 200  |//      ever call the usb_dci_init function.
                             9114 ; 201  |//<
                             9115 ; 202  |////////////////////////////////////////////////////////////////////////////////
                             9116 ; 203  |#ifdef FUNCLET
                             9117 ; 204  |    #pragma asm
                             9118 ; 205  |        org p,"SYSFUNCLET_USB_DCI_INIT_P":
                             9119 ; 206  |    #pragma endasm
                             9120 ; 207  |#endif
                             9121 ; 208  |BYTE _reentrant usb_dci_init(Dev_State_Struct _USB_MEM * pStDeviceState)
                             9122 ; 209  |{
                             9123 
                             9176 Fusb_dci_init:
                             9186 
                             9187 ; 210  |   
                             9188 ; 211  |    INT i;
                             9189 
                             9196 
                             9197 ; 212  |
                             9198 ; 213  |    // parse_configurationtree();
                             9199 ; 214  |
                             9200 ; 215  |    PHY_Startup();
                             9201 
P:0023 055F7C         2   71 9177         movec   ssh,y:(r7)+
P:0024 045FA0         2   73 9191         movec   m0,n7
P:0025 205F00         2   75 9180         move    (r7)+
P:0026 686F00         4   79 9193         move    r0,y:(r7+n7)
P:0027 0BF080 rrrrrr  6   85 9203         jsr     FPHY_Startup
                             9204 
                             9205 ; 216  |
                             9206 ; 217  |    pStDeviceState->usUsbState = USB_STATE_UNKNOWN;
                             9207 
                             9217 
                             9218 ; 218  |   
                             9219 ; 219  |    // Initialize DMA ARC Offset
                             9220 ; 220  |    HW_USBDMAOFF.B.ADD = (INT) &dQH_Base_Add;
                             9221 
                             9232 
                             9233 ; 221  |
                             9234 ; 222  |    // Turn ON USB port clock        
                             9235 ; 223  |    
                             9236 ; 224  |    HW_USBCSR.B.USBEN = 0;
                             9237 
                             9240 
                             9241 ; 225  |    HW_USBCSR.B.CLKOFF = 0;
                             9242 
                             9245 
                             9246 ; 226  |    HW_USBCSR.B.USBEN = 1;
                             9247 
                             9250 
                             9251 ; 227  |   
                             9252 ; 228  |   //install all the interrupt vectors, etc.
                             9253 ; 229  |   //5V Disconnect/Connect IRQ's should be at PRIORITY 000.
                             9254 ; 230  |   IcollInstallIsrVector(usb_dci_isr,ICOLL_SOURCE_USB_CONTROLLER);
                             9255 
P:0029 60F400 rrrrrr  3   88 9257         move    #Fusb_dci_isr,r0
P:002B 045FA0         2   90 9210         movec   m0,n7
P:002C 26FF00         2   92 9225         move    #<$FF,y0
P:002D 6EEF00         4   96 9212         move    y:(r7+n7),r6
P:002E 56F000 00F201  3   99 9224         move    x:$F201,a
P:0030 57F456 rrrrrr  3  102 9226         and     y0,a	                #FdQH_Base_Add,b
P:0032 46F400 00FFFF  3  105 9227         move    #$FFFF,y0
P:0034 3E045E         2  107 9228         and     y0,b	                #4,n6
P:0035 21A600         2  109 9229         move    b1,y0
P:0036 35FF52         2  111 9230         or      y0,a	                #$FF,r5
P:0037 547000 00F201  3  114 9231         move    a1,x:$F201
P:0039 6D6E00         4  118 9214         move    r5,y:(r6+n6)
P:003A 0A7000 00F200  6  124 9239         bclr    #0,x:$F200
P:003C 56F400 000015  3  127 9258         move    #>21,a
P:003E 0A7007 00F200  6  133 9244         bclr    #7,x:$F200
P:0040 0A7020 00F200  6  139 9249         bset    #0,x:$F200
P:0042 0BF080 rrrrrr  6  145 9259         jsr     FIcollInstallIsrVector
                             9261 
                             9262 ; 231  |        
                             9263 ; 232  |   IcollSetPriority(ICOLL_SOURCE_USB_CONTROLLER,ICOLL_PRIORITY_001);
                             9264 
P:0044 57F413 000001  3  148 9266         clr     a	                #>1,b
P:0046 281500         2  150 9267         move    #21,a0
P:0047 0BF080 rrrrrr  6  156 9269         jsr     FIcollSetPriority
                             9270 
                             9271 ; 233  |   IcollSetSteering(ICOLL_SOURCE_USB_CONTROLLER,ICOLL_STEERING_IVL1);    
                             9272 
P:0049 2E0000         2  158 9274         move    #0,a
P:004A 28151B         2  160 9276         clr     b	                #21,a0
P:004B 0BF080 rrrrrr  6  166 9277         jsr     FIcollSetSteering
                             9278 
                             9279 ; 234  |   IcollEnable(ICOLL_SOURCE_USB_CONTROLLER);
                             9280 
P:004D 2E0000         2  168 9282         move    #0,a
P:004E 281500         2  170 9283         move    #21,a0
P:004F 0BF080 rrrrrr  6  176 9284         jsr     FIcollEnable
                             9285 
                             9286 ; 235  |
                             9287 ; 236  |   IPRSetIVLPriority(IVL_LINE_1,IVL_PRIORITY_1);
                             9288 
P:0051 56F400 00000C  3  179 9290         move    #>12,a
P:0053 57F400 000002  3  182 9291         move    #>2,b
P:0055 0BF080 rrrrrr  6  188 9292         jsr     IPRSetIVLPriority
                             9293 
                             9294 ; 237  |
                             9295 ; 238  |   for(i=0;i<N_SETUP_ENDPT;i++)
                             9296 
P:0057 75F400 rrrrrr  3  191 9302         move    #Fg_SetupData,n5
P:0059 260013         2  193 9299         clr     a	                #0,y0
P:005A 47F400 000006  3  196 9301         move    #>6,y1
P:005C 44F400 000001  3  199 9303         move    #>1,x0
P:005E 060880 rrrrrr  6  205 9304         do      #8,L8
                             9306 
                             9307 ; 239  |   {
                             9308 ; 240  |       g_SetupData[i].bValid = FALSE;
                             9309 
P:0060 218500         2  207 9311         move    a1,x1
P:0061 2000F8         2  209 9312         mpy     x1,y1,b
P:0062 20002A         2  211 9313         asr     b
P:0063 213540         2  213 9320         add     x0,a	                b0,r5
P:0064 000000         2  215 9320         nop             ; (inserted)
P:0065 044D16         4  219 9316         lua     (r5)+n5,r6
P:0066 000000         2  221 9316         nop             ; (inserted)
P:0067 4E6600         2  223 9318         move    y0,y:(r6)
                        (18) 9321 L8:
                             9323 
                             9324 ; 241  |   }
                             9325 ; 242  |   
                             9326 ; 243  |   if (0x3502==CapGetChipPartID())
                             9327 
P:0068 0BF080 rrrrrr  6  229 9329         jsr     FCapGetChipPartID
P:006A 2A0000         2  231 9332         move    #0,a2
P:006B 46F400 003502  3  234 9331         move    #13570,y0
P:006D 200055         2  236 9333         cmp     y0,a
P:006E 0AF0A2 rrrrrr  6  242 9334         jne     L7
                             9335 
                             9336 ; 244  |   {
                             9337 ; 245  |     g_pStrings[MS_OS_STRING_DESCRIPTOR_INDEX_IN_ARRAY] = NULL;
                             9338 
                             9342 
                             9343 ; 246  |   }
                             9344 ; 247  |   
                             9345 ; 248  |   parse_strings();
                             9346 
P:0070 3E0000         2  244 9340         move    #0,n6
P:0071 7E7000 rrrrrr  3  247 9341         move    n6,y:Fg_pStrings+7
P:0073 0BF080 rrrrrr  6  253 9348 L7:     jsr     Fparse_strings
                             9349 
                             9350 ; 249  |   
                             9351 ; 250  |   // Update USB Connection status
                             9352 ; 251  |   usb_dci_update_connection_status();
                             9353 
P:0075 0BF080 rrrrrr  6  259 9355         jsr     Fusb_dci_update_connection_status
                             9356 
                             9357 ; 252  |        
                             9358 ; 253  |   return USB_OK;   
                             9359 
                             9362 
                             9363 ; 254  |}
                             9364 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  37

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0077 205713         2  261 9361         clr     a	                (r7)-
P:0078 05FF7C         4  265 9368         movec   y:-(r7),ssh
P:0079 000000         2  267 9368         nop             ; (inserted)
P:007A 00000C         4  271 9372         rts
                             9374 
                             9375 ; 255  |
                             9376 ; 256  |#ifdef FUNCLET
                             9377 ; 257  |    #pragma asm
                             9378 ; 258  |        org p,".ptextusb20dd":
                             9379 ; 259  |    #pragma endasm
                             9380 ; 260  |#endif
                             9381 ; 261  |
                             9382 ; 262  |////////////////////////////////////////////////////////////////////////////////
                             9383 ; 263  |//
                             9384 ; 264  |//>  Name:          usb_dci_chip_enable
                             9385 ; 265  |//
                             9386 ; 266  |//   Type:          Function
                             9387 ; 267  |//
                             9388 ; 268  |//   Description:   Initializes the USB device controller
                             9389 ; 269  |//
                             9390 ; 270  |//   Inputs:        none
                             9391 ; 271  |//
                             9392 ; 272  |//   Outputs:       none
                             9393 ; 273  |//
                             9394 ; 274  |//   Notes:         none
                             9395 ; 275  |//<
                             9396 ; 276  |////////////////////////////////////////////////////////////////////////////////
                             9397 ; 277  |void _reentrant usb_dci_chip_enable()
                             9398 ; 278  |{ /* Body */
                             9399 
                             9404 Fusb_dci_chip_enable:
                             9412 
                             9413 ; 279  |    USHORT      usEndpointCounter;
                             9414 ; 280  |
                             9415 ; 281  |    DWORD       dwTempRegister;
                             9416 ; 282  |
                             9417 ; 283  |   // Enable the ARC Core
                             9418 ; 284  |   HW_USBCSR.B.ARCCONNECT = 1;
                             9419 
                             9422 
                             9423 ; 285  |
                             9424 ; 286  |   /* Stop the controller */
                             9425 ; 287  |    read_usb_reg(HW_ARC_USBCMD, &dwTempRegister);
                             9426 
P:007B 055F7C         2  273 9405         movec   ssh,y:(r7)+
P:007C 3F0300         2  275 9408         move    #3,n7
P:007D 22F500         2  277 9428         move    r7,r5
P:007E 22B000         2  279 9432         move    r5,r0
P:007F 0A702B 00F200  6  285 9421         bset    #11,x:$F200
P:0081 56F400 000140  3  288 9431         move    #320,a
P:0083 204F00         2  290 9429         move    (r7)+n7
P:0084 0BF080 rrrrrr  6  296 9433         jsr     Fread_usb_reg
                             9434 
                             9435 ; 288  |
                             9436 ; 289  |   dwTempRegister &= HW_ARC_USBCMD_RS_CLRMASK; 
                             9437 
                             9460 
                             9461 ; 290  |
                             9462 ; 291  |    write_usb_reg(HW_ARC_USBCMD, dwTempRegister);
                             9463 
P:0086 77F400 FFFFFD  3  299 9439         move    #-3,n7
P:0088 270000         2  301 9446         move    #0,y1
P:0089 46F400 FFFFFE  3  304 9447         move    #$FFFFFE,y0
P:008B 205F00         2  306 9440         move    (r7)+
P:008C 5EEF00         4  310 9442         move    y:(r7+n7),a
P:008D 205700         2  312 9443         move    (r7)-
P:008E 218400         2  314 9448         move    a1,x0
P:008F 58EF00         4  318 9445         move    y:(r7+n7),a0
P:0090 210C00         2  320 9449         move    a0,a1
P:0091 205F56         2  322 9450         and     y0,a	                (r7)+
P:0092 218800         2  324 9451         move    a1,a0
P:0093 208C00         2  326 9452         move    x0,a1
P:0094 57F476 000140  3  329 9453         and     y1,a	                #320,b
P:0096 5C6F00         4  333 9456         move    a1,y:(r7+n7)
P:0097 205700         2  335 9457         move    (r7)-
P:0098 586F00         4  339 9459         move    a0,y:(r7+n7)
P:0099 205F00         2  341 9465         move    (r7)+
P:009A 5EEF00         4  345 9467         move    y:(r7+n7),a
P:009B 205700         2  347 9468         move    (r7)-
P:009C 58EF00         4  351 9470         move    y:(r7+n7),a0
P:009D 0BF080 rrrrrr  6  357 9472         jsr     Fwrite_usb_reg
                             9473 
                             9474 ; 292  |      
                             9475 ; 293  |   /* Reset the controller to get default values */
                             9476 ; 294  |   dwTempRegister |= HW_ARC_USBCMD_RST_SETMASK; 
                             9477 
                             9500 
                             9501 ; 295  |
                             9502 ; 296  |   write_usb_reg(HW_ARC_USBCMD, dwTempRegister);
                             9503 
P:009F 77F400 FFFFFD  3  360 9479         move    #-3,n7
P:00A1 270000         2  362 9486         move    #0,y1
P:00A2 46F400 000002  3  365 9487         move    #>2,y0
P:00A4 205F00         2  367 9480         move    (r7)+
P:00A5 5EEF00         4  371 9482         move    y:(r7+n7),a
P:00A6 205700         2  373 9483         move    (r7)-
P:00A7 218400         2  375 9488         move    a1,x0
P:00A8 58EF00         4  379 9485         move    y:(r7+n7),a0
P:00A9 210C00         2  381 9489         move    a0,a1
P:00AA 205F52         2  383 9490         or      y0,a	                (r7)+
P:00AB 218800         2  385 9491         move    a1,a0
P:00AC 208C00         2  387 9492         move    x0,a1
P:00AD 57F472 000140  3  390 9493         or      y1,a	                #320,b
P:00AF 5C6F00         4  394 9496         move    a1,y:(r7+n7)
P:00B0 205700         2  396 9497         move    (r7)-
P:00B1 586F00         4  400 9499         move    a0,y:(r7+n7)
P:00B2 205F00         2  402 9505         move    (r7)+
P:00B3 5EEF00         4  406 9507         move    y:(r7+n7),a
P:00B4 205700         2  408 9508         move    (r7)-
P:00B5 58EF00         4  412 9510         move    y:(r7+n7),a0
P:00B6 0BF080 rrrrrr  6  418 9512         jsr     Fwrite_usb_reg
                             9513 
                             9514 ; 297  |
                             9515 ; 298  |   do
                             9516 
                             9518 L9:
                             9522 
                             9523 ; 299  |   {
                             9524 ; 300  |        // Wait for the controller reset to complete
                             9525 ; 301  |        read_usb_reg(HW_ARC_USBCMD, &dwTempRegister);
                             9526 
P:00B8 77F400 FFFFFD  3  421 9519         move    #-3,n7
P:00BA 56F400 000140  3  424 9518         move    #320,a
P:00BC 044F10         4  428 9521         lua     (r7)+n7,r0
P:00BD 0BF080 rrrrrr  6  434 9528         jsr     Fread_usb_reg
                             9529 
                             9530 ; 302  |   }while(dwTempRegister & HW_ARC_USBCMD_RST_SETMASK);
                             9531 
P:00BF 77F400 FFFFFD  3  437 9533         move    #-3,n7
P:00C1 205F00         2  439 9534         move    (r7)+
P:00C2 5FEF00         4  443 9536         move    y:(r7+n7),b
P:00C3 205700         2  445 9537         move    (r7)-
P:00C4 59EF00         4  449 9539         move    y:(r7+n7),b0
P:00C5 0AC921 rrrrrr  6  455 9540         jset    #1,b0,L9
                             9541 
                             9542 ; 303  |
                             9543 ; 304  |
                             9544 ; 305  |   // Program the endpoint list address
                             9545 ; 306  |   // dQHs structures are always the 1st in our memory map,
                             9546 ; 307  |   // therefore the endpoint list address is set to 0x0000. 
                             9547 ; 308  |    write_usb_reg(HW_ARC_ENDPTLISTADDR, (DWORD)0x00); 
                             9548 
P:00C7 57F413 000158  3  458 9550         clr     a	                #344,b
P:00C9 0BF080 rrrrrr  6  464 9552         jsr     Fwrite_usb_reg
                             9553 
                             9554 ; 309  |
                             9555 ; 310  |   /* Program the controller to be the USB device controller */
                             9556 ; 311  |    write_usb_reg(HW_ARC_USBMODE, (DWORD)0x02); 
                             9557 
P:00CB 57F413 0001A8  3  467 9559         clr     a	                #424,b
P:00CD 280200         2  469 9560         move    #2,a0
P:00CE 0BF080 rrrrrr  6  475 9562         jsr     Fwrite_usb_reg
                             9563 
                             9564 ; 312  |   
                             9565 ; 313  |    // Zero out the USB structures (dQHs, dTDs and dXDs)  
                             9566 ; 314  |    FInitUsbStructures();
                             9567 
P:00D0 0BF080 rrrrrr  6  481 9569         jsr     FInitUsbStructures
                             9570 
                             9571 ; 315  |   
                             9572 ; 316  |   // Make sure the setup endpoint status are cleared
                             9573 ; 317  |    write_usb_reg(HW_ARC_ENDPTSETUPSTAT, (DWORD)0x00);
                             9574 
P:00D2 57F413 0001AC  3  484 9576         clr     a	                #428,b
P:00D4 0BF080 rrrrrr  6  490 9578         jsr     Fwrite_usb_reg
                             9579 
                             9580 ; 318  |   
                             9581 ; 319  |    // Initialize dQH Scratch Cap structure
                             9582 ; 320  |    // MaxPacketSize to Max_Control_Payload (64)
                             9583 ; 321  |    // Generate interrupt on setup packet
                             9584 ; 322  |    dQH_Scratch_Cap.usMaxPktLengthZltMult = (USHORT)USB_MAX_CTRL_PAYLOAD;
                             9585 
                             9589 
                             9590 ; 323  |    dQH_Scratch_Cap.usIos = (USHORT)USB_EP_QUEUE_HEAD_IOS;
                             9591 
                             9595 
                             9596 ; 324  |    dQH_Scratch_Cap.pbtNextdTDPointer = (BYTE *) 0x0;
                             9597 
                             9601 
                             9602 ; 325  |    dQH_Scratch_Cap.usStatusIoc = (USHORT) 0x0; 
                             9603 
                             9606 
                             9607 ; 326  |
                             9608 ; 327  |   /* Initialize all device queue heads */
                             9609 ; 328  |   for( usEndpointCounter = 0 ; usEndpointCounter < MAX_NUM_EP  ; usEndpointCounter++)
                             9610 
                             9615 
                             9616 ; 329  |   {
                             9617 ; 330  |        FdQHPackCap(usEndpointCounter, (USHORT)USB_OUT, (BYTE)0x01);
                             9618 
P:00D6 34401B         2  492 9599         clr     b	                #$40,r4
P:00D7 73F413 008000  3  495 9612         clr     a	                #$8000,n3
P:00D9 46F400 000001  3  498 9614         move    #>1,y0
P:00DB 647000 rrrrrr  3  501 9588         move    r4,x:FdQH_Scratch_Cap+1
P:00DD 737000 rrrrrr  3  504 9594         move    n3,x:FdQH_Scratch_Cap
P:00DF 557000 rrrrrr  3  507 9600         move    b1,x:FdQH_Scratch_Cap+2
P:00E1 557000 rrrrrr  3  510 9605         move    b1,x:FdQH_Scratch_Cap+3
                             9620 L10:
P:00E3 045FA0         2  512 9620         movec   m0,n7
P:00E4 44F41B 000001  3  515 9627         clr     b	                #>1,x0
P:00E6 5C6F00         4  519 9622         move    a1,y:(r7+n7)
P:00E7 0BF080 rrrrrr  6  525 9629         jsr     FdQHPackCap
                             9632 
                             9633 ; 331  |        FdQHPackCap(usEndpointCounter, (USHORT)USB_IN, (BYTE)0x01);
                             9634 
P:00E9 045FA0         2  527 9637         movec   m0,n7
P:00EA 57F400 000001  3  530 9636         move    #>1,b
P:00EC 1AEF00         4  534 9639         move    y:(r7+n7),a	                b,x0
P:00ED 0BF080 rrrrrr  6  540 9643         jsr     FdQHPackCap
P:00EF 045FA0         2  542 9647         movec   m0,n7
P:00F0 46F400 000001  3  545 9650         move    #>1,y0
P:00F2 5EEF00         4  549 9649         move    y:(r7+n7),a
P:00F3 47F450 000004  3  552 9651         add     y0,a	                #>4,y1
P:00F5 218F00         2  554 9654         move    a1,b
P:00F6 20007D         2  556 9656         cmp     y1,b
P:00F7 0AF0A9 rrrrrr  6  562 9657         jlt     L10
                             9658 
                             9659 ; 332  |    } // Endfor      
                             9660 ; 333  |
                             9661 ; 334  |   /* Initialize the endpoint 0 properties */
                             9662 ; 335  |   // Reset the Toggle bit
                             9663 ; 336  |   // Make sure that the enpoint is not stall
                             9664 ; 337  |   read_usb_reg(HW_ARC_ENDPTCTRL(0), &dwTempRegister);
                             9665 
P:00F9 77F400 FFFFFD  3  565 9669         move    #-3,n7
P:00FB 56F400 0001C0  3  568 9667         move    #$1C0,a
P:00FD 044F10         4  572 9671         lua     (r7)+n7,r0
P:00FE 0BF080 rrrrrr  6  578 9672         jsr     Fread_usb_reg
                             9673 
                             9674 ; 338  |
                             9675 ; 339  |   dwTempRegister = dwTempRegister 
                             9676 ; 340  |                    | (DWORD)HW_ARC_ENDPTCTRL_TXR_SETMASK
                             9677 ; 341  |                    | (DWORD)HW_ARC_ENDPTCTRL_RXR_SETMASK;
                             9678 
                             9701 
                             9702 ; 342  |
                             9703 ; 343  |    dwTempRegister = dwTempRegister 
                             9704 ; 344  |                    & (DWORD)HW_ARC_ENDPTCTRL_TXS_CLRMASK 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  38

M:ADDR CODE           CYCLES LINE SOURCELINE
                             9705 ; 345  |                    & (DWORD)HW_ARC_ENDPTCTRL_RXS_CLRMASK;
                             9706 
                             9727 
                             9728 ; 346  |
                             9729 ; 347  |    write_usb_reg(HW_ARC_ENDPTCTRL(0), dwTempRegister);                                                     
                             9730 
P:0100 77F400 FFFFFD  3  581 9680         move    #-3,n7
P:0102 270000         2  583 9687         move    #0,y1
P:0103 46F400 400040  3  586 9688         move    #4194368,y0
P:0105 205F00         2  588 9681         move    (r7)+
P:0106 5EEF00         4  592 9683         move    y:(r7+n7),a
P:0107 205700         2  594 9684         move    (r7)-
P:0108 218400         2  596 9689         move    a1,x0
P:0109 58EF00         4  600 9686         move    y:(r7+n7),a0
P:010A 210C00         2  602 9690         move    a0,a1
P:010B 205F52         2  604 9691         or      y0,a	                (r7)+
P:010C 218800         2  606 9692         move    a1,a0
P:010D 208C00         2  608 9693         move    x0,a1
P:010E 46F472 FEFFFE  3  611 9694         or      y1,a	                #16711678,y0
P:0110 5C6F00         4  615 9697         move    a1,y:(r7+n7)
P:0111 205700         2  617 9698         move    (r7)-
P:0112 586F00         4  621 9700         move    a0,y:(r7+n7)
P:0113 205F00         2  623 9708         move    (r7)+
P:0114 5EEF00         4  627 9710         move    y:(r7+n7),a
P:0115 205700         2  629 9711         move    (r7)-
P:0116 218400         2  631 9715         move    a1,x0
P:0117 58EF00         4  635 9713         move    y:(r7+n7),a0
P:0118 210C00         2  637 9716         move    a0,a1
P:0119 205F56         2  639 9717         and     y0,a	                (r7)+
P:011A 218800         2  641 9718         move    a1,a0
P:011B 208C00         2  643 9719         move    x0,a1
P:011C 57F476 0001C0  3  646 9720         and     y1,a	                #$1C0,b
P:011E 5C6F00         4  650 9723         move    a1,y:(r7+n7)
P:011F 205700         2  652 9724         move    (r7)-
P:0120 586F00         4  656 9726         move    a0,y:(r7+n7)
P:0121 205F00         2  658 9732         move    (r7)+
P:0122 5EEF00         4  662 9734         move    y:(r7+n7),a
P:0123 205700         2  664 9735         move    (r7)-
P:0124 58EF00         4  668 9737         move    y:(r7+n7),a0
P:0125 0BF080 rrrrrr  6  674 9739         jsr     Fwrite_usb_reg
                             9740 
                             9741 ; 348  |   
                             9742 ; 349  |   /* Enable interrupts */
                             9743 ; 350  |   read_usb_reg(HW_ARC_USBINTR, &dwTempRegister);
                             9744 
P:0127 77F400 FFFFFD  3  677 9747         move    #-3,n7
P:0129 56F400 000148  3  680 9746         move    #328,a
P:012B 044F10         4  684 9749         lua     (r7)+n7,r0
P:012C 0BF080 rrrrrr  6  690 9750         jsr     Fread_usb_reg
                             9751 
                             9752 ; 351  |
                             9753 ; 352  |   dwTempRegister = dwTempRegister 
                             9754 ; 353  |                    | (DWORD)HW_ARC_USBINTR_UE_SETMASK
                             9755 ; 354  |                    | (DWORD)HW_ARC_USBINTR_UEE_SETMASK
                             9756 ; 355  |                    | (DWORD)HW_ARC_USBINTR_PCE_SETMASK
                             9757 ; 356  |                    | (DWORD)HW_ARC_USBINTR_URE_SETMASK;
                             9758 
                             9781 
                             9782 ; 357  |                            
                             9783 ; 358  |    write_usb_reg(HW_ARC_USBINTR, dwTempRegister);
                             9784 
P:012E 77F400 FFFFFD  3  693 9760         move    #-3,n7
P:0130 270000         2  695 9767         move    #0,y1
P:0131 46F400 000047  3  698 9768         move    #>71,y0
P:0133 205F00         2  700 9761         move    (r7)+
P:0134 5EEF00         4  704 9763         move    y:(r7+n7),a
P:0135 205700         2  706 9764         move    (r7)-
P:0136 218400         2  708 9769         move    a1,x0
P:0137 58EF00         4  712 9766         move    y:(r7+n7),a0
P:0138 210C00         2  714 9770         move    a0,a1
P:0139 205F52         2  716 9771         or      y0,a	                (r7)+
P:013A 218800         2  718 9772         move    a1,a0
P:013B 208C00         2  720 9773         move    x0,a1
P:013C 57F472 000148  3  723 9774         or      y1,a	                #328,b
P:013E 5C6F00         4  727 9777         move    a1,y:(r7+n7)
P:013F 205700         2  729 9778         move    (r7)-
P:0140 586F00         4  733 9780         move    a0,y:(r7+n7)
P:0141 205F00         2  735 9786         move    (r7)+
P:0142 5EEF00         4  739 9788         move    y:(r7+n7),a
P:0143 205700         2  741 9789         move    (r7)-
P:0144 58EF00         4  745 9791         move    y:(r7+n7),a0
P:0145 0BF080 rrrrrr  6  751 9793         jsr     Fwrite_usb_reg
                             9794 
                             9795 ; 359  |
                             9796 ; 360  |    s_wArcUsbIntRegShadow = (WORD)dwTempRegister;
                             9797 
                             9807 
                             9808 ; 361  |
                             9809 ; 362  |    // Note - need to enable the device separately.  See usb_dci_chip_enable below
                             9810 ; 363  |   /* Set the Run bit in the command register */
                             9811 ; 364  |    write_usb_reg(HW_ARC_USBCMD, (DWORD)HW_ARC_USBCMD_RS_SETMASK); 
                             9812 
P:0147 77F400 FFFFFD  3  754 9799         move    #-3,n7
P:0149 57F400 000140  3  757 9814         move    #320,b
P:014B 205F00         2  759 9800         move    (r7)+
P:014C 5EEF00         4  763 9802         move    y:(r7+n7),a
P:014D 205700         2  765 9803         move    (r7)-
P:014E 58EF00         4  769 9805         move    y:(r7+n7),a0
P:014F 587013 rrrrrr  3  772 9815         clr     a	                a0,y:Fs_wArcUsbIntRegShadow
P:0151 000008         2  774 9816         inc     a
P:0152 0BF080 rrrrrr  6  780 9817         jsr     Fwrite_usb_reg
                             9818 
                             9819 ; 365  |   
                             9820 ; 366  |} /* EndBody */
                             9821 
P:0154 77F400 FFFFFC  3  783 9823         move    #-4,n7
P:0156 000000         2  785 9823         nop             ; (inserted)
P:0157 05EF7C         4  789 9825         movec   y:(r7+n7),ssh
P:0158 204F00         2  791 9827         move    (r7)+n7
P:0159 00000C         4  795 9829         rts
                             9831 
                             9832 ; 367  |
                             9833 ; 368  |
                             9834 ; 369  |
                             9835 ; 370  |
                             9836 ; 371  |////////////////////////////////////////////////////////////////////////////////
                             9837 ; 372  |//
                             9838 ; 373  |//>  Name:          usb_dci_isr
                             9839 ; 374  |//
                             9840 ; 375  |//   Type:          Function
                             9841 ; 376  |//
                             9842 ; 377  |//   Description:   USB2.0 Interrupt Handler
                             9843 ; 378  |//
                             9844 ; 379  |//   Inputs:        none
                             9845 ; 380  |//
                             9846 ; 381  |//   Outputs:       none
                             9847 ; 382  |//
                             9848 ; 383  |//   Notes:         none
                             9849 ; 384  |//<
                             9850 ; 385  |////////////////////////////////////////////////////////////////////////////////
                             9851 ; 386  |void _long_interrupt(-1) usb_dci_isr(void)
                             9852 ; 387  |{ /* Body */
                             9853 
                             9858 Fusb_dci_isr:
                             9901 
                             9902 ; 388  |
                             9903 ; 389  |    // Saves the Hardware Stack 
                             9904 ; 390  |    #pragma asm
                             9905 
P:015A 05707D rrrrrr  4  799 9859         movec   ssl,y:ss_usb_dci_isr
P:015C 05707C rrrrrr  4  803 9860         movec   ssh,y:ss_usb_dci_isr+1
P:015E 7F7000 rrrrrr  3  806 9862         move    n7,y:ss_usb_dci_isr+2
P:0160 6E7000 rrrrrr  3  809 9863         move    r6,y:ss_usb_dci_isr+3
                             9908     extern  FwUsbIsrSaveSp
                             9909     extern  SaveSystemStack
                             9910 
                             9911     ; Clear the DM bit (double-precision multiply mode, bit 6) of the Mode Register
                             9912     ; This will be returned to its previous state when the RTI occurs (since the SR
                             9913     ; will be popped back off System Stack Low (SSL).
                             9914     ; Accumulator behavior is unpredictable when the DM bit is set.
                             9915     ; Next cycle after clearing it should NOT be an ALU instruction.
                             9917 
P:0162 66F400 rrrrrr  3  812 9918     move    #_ReturnFromHardwareStackSave,r6 ; return address
P:0164 057066 rrrrrr  4  816 9864         movec   m6,y:ss_usb_dci_isr+4
P:0166 0466A7         2  818 9865         movec   m7,m6
P:0167 7E7000 rrrrrr  3  821 9866         move    n6,y:ss_usb_dci_isr+5
P:0169 6D7000 rrrrrr  3  824 9867         move    r5,y:ss_usb_dci_isr+6
P:016B 65F400 rrrrrr  3  827 9919     move    #>FwUsbIsrSaveSp,r5
P:016D 057065 rrrrrr  4  831 9868         movec   m5,y:ss_usb_dci_isr+7
P:016F 0465A7         2  833 9869         movec   m7,m5
P:0170 7D7000 rrrrrr  3  836 9870         move    n5,y:ss_usb_dci_isr+8
P:0172 6C7000 rrrrrr  3  839 9871         move    r4,y:ss_usb_dci_isr+9
P:0174 057064 rrrrrr  4  843 9872         movec   m4,y:ss_usb_dci_isr+10
P:0176 0464A7         2  845 9873         movec   m7,m4
P:0177 7C7000 rrrrrr  3  848 9874         move    n4,y:ss_usb_dci_isr+11
P:0179 6B7000 rrrrrr  3  851 9875         move    r3,y:ss_usb_dci_isr+12
P:017B 057063 rrrrrr  4  855 9876         movec   m3,y:ss_usb_dci_isr+13
P:017D 0463A7         2  857 9877         movec   m7,m3
P:017E 7B7000 rrrrrr  3  860 9878         move    n3,y:ss_usb_dci_isr+14
P:0180 6A7000 rrrrrr  3  863 9879         move    r2,y:ss_usb_dci_isr+15
P:0182 057062 rrrrrr  4  867 9880         movec   m2,y:ss_usb_dci_isr+16
P:0184 0462A7         2  869 9881         movec   m7,m2
P:0185 7A7000 rrrrrr  3  872 9882         move    n2,y:ss_usb_dci_isr+17
P:0187 697000 rrrrrr  3  875 9883         move    r1,y:ss_usb_dci_isr+18
P:0189 057061 rrrrrr  4  879 9884         movec   m1,y:ss_usb_dci_isr+19
P:018B 0461A7         2  881 9885         movec   m7,m1
P:018C 797000 rrrrrr  3  884 9886         move    n1,y:ss_usb_dci_isr+20
P:018E 687000 rrrrrr  3  887 9887         move    r0,y:ss_usb_dci_isr+21
P:0190 057060 rrrrrr  4  891 9888         movec   m0,y:ss_usb_dci_isr+22
P:0192 0460A7         2  893 9889         movec   m7,m0
P:0193 787000 rrrrrr  3  896 9890         move    n0,y:ss_usb_dci_isr+23
P:0195 4E7000 rrrrrr  3  899 9891         move    y0,y:ss_usb_dci_isr+24
P:0197 4F7000 rrrrrr  3  902 9892         move    y1,y:ss_usb_dci_isr+25
P:0199 4C7000 rrrrrr  3  905 9893         move    x0,y:ss_usb_dci_isr+26
P:019B 4D7000 rrrrrr  3  908 9894         move    x1,y:ss_usb_dci_isr+27
P:019D 5B7000 rrrrrr  3  911 9895         move    b2,y:ss_usb_dci_isr+28
P:019F 597000 rrrrrr  3  914 9896         move    b0,y:ss_usb_dci_isr+29
P:01A1 5D7000 rrrrrr  3  917 9897         move    b1,y:ss_usb_dci_isr+30
P:01A3 5A7000 rrrrrr  3  920 9898         move    a2,y:ss_usb_dci_isr+31
P:01A5 587000 rrrrrr  3  923 9899         move    a0,y:ss_usb_dci_isr+32
P:01A7 5C7000 rrrrrr  3  926 9900         move    a1,y:ss_usb_dci_isr+33
P:01A9 00BFB8         2  928 9916     andi #$BF,mr
P:01AA 0AF080 rrrrrr  6  934 9920     jmp     SaveSystemStack
                             9921 _ReturnFromHardwareStackSave
                             9926 
                             9927 ; 405  |    #pragma endasm
                             9928 ; 406  |    WORD     wStatus;
                             9929 ; 407  |    WORD     wOldIVL;
                             9930 ; 408  |   
                             9931 ; 409  |   EventSet04();
                             9932 ; 410  |   
                             9933 ; 411  |   wOldIVL = SysMaskAllInterrupts();
                             9934 
P:01AC 0BF080 rrrrrr  6  940 9936         jsr     FSysMaskAllInterrupts
                             9939 
                             9940 ; 412  |   
                             9941 ; 413  |   for (;;) 
                             9942 ; 414  |   {
                             9943 ; 415  |      //get the status
                             9944 ; 416  |      wStatus = read_and_clear_arc_reg_usbsts();
                             9945 
P:01AE 5C7000 rrrrrr  3  943 9937         move    a1,y:ss_usb_dci_isr+34
P:01B0 0BF080 rrrrrr  6  949 9947 L11:    jsr     Fread_and_clear_arc_reg_usbsts
                             9949 
                             9950 ; 417  |      wStatus &= s_wArcUsbIntRegShadow; //only care about the events that we've got enabled in the interrupt enable mask
                             9951 
                             9958 
                             9959 ; 418  |
                             9960 ; 419  |      if (!wStatus)
                             9961 
P:01B2 218F00         2  951 9954         move    a1,b
P:01B3 4EF000 rrrrrr  3  954 9953         move    y:Fs_wArcUsbIntRegShadow,y0
P:01B5 2B005E         2  956 9955         and     y0,b	                #0,b2
P:01B6 20000B         2  958 9964         tst     b
P:01B7 0AF0AA rrrrrr  6  964 9965         jeq     L16
                             9966 
                             9967 ; 420  |      {
                             9968 ; 421  |         break;             // No more interruption to process
                             9969 ; 422  |      } /* Endif */
                             9970 ; 423  |   
                             9971 ; 424  |      if (wStatus & HW_ARC_USBSTS_URI_SETMASK) 
                             9972 
P:01B9 0ACD06 rrrrrr  6  970 9974         jclr    #6,b1,L12
                             9978 
                             9979 ; 425  |      {
                             9980 ; 426  |         usb_dci_process_reset(&stDeviceState);
                             9981 
P:01BB 60F400 rrrrrr  3  973 9983         move    #FstDeviceState,r0
P:01BD 5D7000 rrrrrr  3  976 9975         move    b1,y:ss_usb_dci_isr+35
P:01BF 0BF080 rrrrrr  6  982 9984         jsr     Fusb_dci_process_reset
                             9988 
                             9989 ; 427  |      } /* Endif */
                             9990 ; 428  |   
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  39

M:ADDR CODE           CYCLES LINE SOURCELINE
                             9991 ; 429  |      if (wStatus & HW_ARC_USBSTS_PCI_SETMASK) 
                             9992 
P:01C1 5FF000 rrrrrr  3  985 9985         move    y:ss_usb_dci_isr+35,b
P:01C3 0ACD02 rrrrrr  6  991 9994 L12:    jclr    #2,b1,L13
                             9998 
                             9999 ; 430  |      {
                            10000 ; 431  |         usb_dci_process_port_change(&stDeviceState);
                            10001 
P:01C5 60F400 rrrrrr  3  99410003         move    #FstDeviceState,r0
P:01C7 5D7000 rrrrrr  3  997 9995         move    b1,y:ss_usb_dci_isr+35
P:01C9 0BF080 rrrrrr  6 100310004         jsr     Fusb_dci_process_port_change
                            10008 
                            10009 ; 432  |      } /* Endif */
                            10010 ; 433  |   
                            10011 ; 434  |      if (wStatus & HW_ARC_USBSTS_UEI_SETMASK) 
                            10012 
P:01CB 5FF000 rrrrrr  3 100610005         move    y:ss_usb_dci_isr+35,b
P:01CD 0BCD61         4 101010014 L13:    btst    #1,b1
P:01CE 46F400 000001  3 101310015         move    #>1,y0
P:01D0 0AF0A0 rrrrrr  6 101910016         jcc     L14
                            10017 
                            10018 ; 435  |      {
                            10019 ; 436  |         (stDeviceState.wError)++;
                            10020 
                            10025 
                            10026 ; 437  |
                            10027 ; 438  |      } /* Endif */
                            10028 ; 439  |   
                            10029 ; 440  |      if (wStatus & HW_ARC_USBSTS_UI_SETMASK)
                            10030 
P:01D2 5EF000 rrrrrr  3 102210022         move    y:FstDeviceState+10,a
P:01D4 200050         2 102410023         add     y0,a
P:01D5 5C7000 rrrrrr  3 102710024         move    a1,y:FstDeviceState+10
P:01D7 0ACD00 rrrrrr  6 103310032 L14:    jclr    #0,b1,L15
                            10036 
                            10037 ; 441  |      {
                            10038 ; 442  |         usb_dci_process_tr_complete(&stDeviceState);
                            10039 
P:01D9 60F400 rrrrrr  3 103610041         move    #FstDeviceState,r0
P:01DB 5D7000 rrrrrr  3 103910033         move    b1,y:ss_usb_dci_isr+35
P:01DD 0BF080 rrrrrr  6 104510042         jsr     Fusb_dci_process_tr_complete
                            10046 
                            10047 ; 443  |      } /* Endif */
                            10048 ; 444  |      
                            10049 ; 445  |      if (wStatus & HW_ARC_USBSTS_SLI_SETMASK)
                            10050 
P:01DF 5FF000 rrrrrr  3 104810043         move    y:ss_usb_dci_isr+35,b
P:01E1 0ACD08 rrrrrr  6 105410052 L15:    jclr    #8,b1,L11
                            10053 
                            10054 ; 446  |      {
                            10055 ; 447  |                 //IRQ's are blocked.  Must ensure 5V Disconnect IRQ is active before
                            10056 ; 448  |                 //entering suspend to detect a disconnect event.
                            10057 ; 449  |                 SysSetIrqLevel(HW_SR_IM_L2_SETMASK);
                            10058 
P:01E3 56F400 000200  3 105710060         move    #$200,a
P:01E5 0BF080 rrrrrr  6 106310061         jsr     FSysSetIrqLevel
                            10063 
                            10064 ; 450  |         usb_dci_process_suspend(&stDeviceState);
                            10065 
P:01E7 60F400 rrrrrr  3 106610067         move    #FstDeviceState,r0
P:01E9 0BF080 rrrrrr  6 107210068         jsr     Fusb_dci_process_suspend
                            10069 
                            10070 ; 451  |         break;
                            10071 ; 452  |      } /* Endif */
                            10072 ; 453  |      
                            10073 ; 454  |      if (wStatus & HW_ARC_USBSTS_SRI_SETMASK)
                            10074 ; 455  |      {
                            10075 ; 456  |         // This should not occur. Interruption is disabled during initialization
                            10076 ; 457  |
                            10077 ; 458  |      } /* Endif */
                            10078 ; 459  |      
                            10079 ; 460  |   } /* Endfor */
                            10080 ; 461  |
                            10081 ; 462  |   SysUnMaskAllInterrupts(wOldIVL);
                            10082 
P:01EB 5EF000 rrrrrr  3 107510084 L16:    move    y:ss_usb_dci_isr+34,a
P:01ED 0BF080 rrrrrr  6 108110085         jsr     FSysUnMaskAllInterrupts
                            10089 
                            10090 ; 463  |
                            10091 ; 464  |    // Restores the hardware stack
                            10092 ; 465  |    #pragma asm
                            10093 
                            10096     extern  RestoreSystemStack
                            10097     
P:01EF 66F400 rrrrrr  3 108410098     move    #_ReturnFromHardwareStackRestore,r6
P:01F1 65F400 rrrrrr  3 108710099     move    #>FwUsbIsrSaveSp,r5
P:01F3 0AF080 rrrrrr  6 109310100     jmp     RestoreSystemStack
                            10101 _ReturnFromHardwareStackRestore
                            10102 
                            10103 ; 472  |    #pragma endasm
                            10104 ; 473  |
                            10105 ; 474  |    EventClear04();
                            10106 ; 475  |
                            10107 ; 476  |    
                            10108 ; 477  |} /* EndBody */
                            10109 
P:01F5 05F07C rrrrrr  4 109710143         movec   y:ss_usb_dci_isr+1,ssh
P:01F7 05F07D rrrrrr  4 110110145         movec   y:ss_usb_dci_isr,ssl
P:01F9 6AF000 rrrrrr  3 110410129         move    y:ss_usb_dci_isr+15,r2
P:01FB 68F000 rrrrrr  3 110710123         move    y:ss_usb_dci_isr+21,r0
P:01FD 79F000 rrrrrr  3 111010124         move    y:ss_usb_dci_isr+20,n1
P:01FF 05F064 rrrrrr  4 111410134         movec   y:ss_usb_dci_isr+10,m4
P:0201 69F000 rrrrrr  3 111710126         move    y:ss_usb_dci_isr+18,r1
P:0203 05F065 rrrrrr  4 112110137         movec   y:ss_usb_dci_isr+7,m5
P:0205 7AF000 rrrrrr  3 112410127         move    y:ss_usb_dci_isr+17,n2
P:0207 05F061 rrrrrr  4 112810125         movec   y:ss_usb_dci_isr+19,m1
P:0209 6DF000 rrrrrr  3 113110138         move    y:ss_usb_dci_isr+6,r5
P:020B 7BF000 rrrrrr  3 113410130         move    y:ss_usb_dci_isr+14,n3
P:020D 6BF000 rrrrrr  3 113710132         move    y:ss_usb_dci_isr+12,r3
P:020F 7CF000 rrrrrr  3 114010133         move    y:ss_usb_dci_isr+11,n4
P:0211 05F060 rrrrrr  4 114410122         movec   y:ss_usb_dci_isr+22,m0
P:0213 6CF000 rrrrrr  3 114710135         move    y:ss_usb_dci_isr+9,r4
P:0215 05F066 rrrrrr  4 115110140         movec   y:ss_usb_dci_isr+4,m6
P:0217 7DF000 rrrrrr  3 115410136         move    y:ss_usb_dci_isr+8,n5
P:0219 78F000 rrrrrr  3 115710121         move    y:ss_usb_dci_isr+23,n0
P:021B 05F063 rrrrrr  4 116110131         movec   y:ss_usb_dci_isr+13,m3
P:021D 7EF000 rrrrrr  3 116410139         move    y:ss_usb_dci_isr+5,n6
P:021F 05F062 rrrrrr  4 116810128         movec   y:ss_usb_dci_isr+16,m2
P:0221 6EF000 rrrrrr  3 117110141         move    y:ss_usb_dci_isr+3,r6
P:0223 7FF000 rrrrrr  3 117410142         move    y:ss_usb_dci_isr+2,n7
P:0225 5CF000 rrrrrr  3 117710111         move    y:ss_usb_dci_isr+33,a1
P:0227 58F000 rrrrrr  3 118010112         move    y:ss_usb_dci_isr+32,a0
P:0229 4DF000 rrrrrr  3 118310117         move    y:ss_usb_dci_isr+27,x1
P:022B 5AF000 rrrrrr  3 118610113         move    y:ss_usb_dci_isr+31,a2
P:022D 4CF000 rrrrrr  3 118910118         move    y:ss_usb_dci_isr+26,x0
P:022F 5DF000 rrrrrr  3 119210114         move    y:ss_usb_dci_isr+30,b1
P:0231 4FF000 rrrrrr  3 119510119         move    y:ss_usb_dci_isr+25,y1
P:0233 59F000 rrrrrr  3 119810115         move    y:ss_usb_dci_isr+29,b0
P:0235 4EF000 rrrrrr  3 120110120         move    y:ss_usb_dci_isr+24,y0
P:0237 5BF000 rrrrrr  3 120410116         move    y:ss_usb_dci_isr+28,b2
P:0239 000004         4 120810147         rti
                            10148 
Y:0000                      10149         org     y,".yovlusb20dd@usb_dci_isr",overlay:
                            10150 ss_usb_dci_isr:
Y:0000                      10151         ds      36
   |   RESERVED                   
Y:0023
                            10152 
P:023A                      10153         org     p,".ptextusb20dd":
                            10155 
                            10156 ; 478  |
                            10157 ; 479  |
                            10158 ; 480  |
                            10159 ; 481  |////////////////////////////////////////////////////////////////////////////////
                            10160 ; 482  |//
                            10161 ; 483  |//>  Name:          usb_dci_wait_until_suspend_ends
                            10162 ; 484  |//
                            10163 ; 485  |//   Type:          Function
                            10164 ; 486  |//
                            10165 ; 487  |//   Description:   Waits until an event happens on the bus to break out of suspend.
                            10166 ; 488  |//
                            10167 ; 489  |//   Inputs:        pStDeviceState = Pointer to the device state structure
                            10168 ; 490  |//
                            10169 ; 491  |//   Outputs:       none
                            10170 ; 492  |//
                            10171 ; 493  |//   Notes:         none
                            10172 ; 494  |//<
                            10173 ; 495  |////////////////////////////////////////////////////////////////////////////////
                            10174 ; 496  |WORD usb_dci_wait_until_suspend_ends(Dev_State_Struct _USB_MEM * pStDeviceState)
                            10175 ; 497  |{
                            10176 
                            10181 Fusb_dci_wait_until_suspend_ends:
                            10184 
                            10185 ; 498  |
                            10186 ; 499  |    // Prepare for reading PORTSC1 ARC Register
                            10187 ; 500  |    #pragma asm
                            10188 
                            10196 
                            10197         ;Set Address, R/W/ Bit and kick transaction
P:023A 56F400 000184  3 121110199         move    #>HW_ARC_PORTSC1,a
P:023C 44F400 0001FF  3 121410198         move    #>HW_USBARCACCESS_ADD_SETMASK,x0
P:023E 200046         2 121610200         and     x0,a
P:023F 547000 00F202  3 121910201         move    a1,x:HW_USBARCACCESS
P:0241 0A7030 00F202  6 122510202         bset    #HW_USBARCACCESS_RWB_BITPOS,x:HW_USBARCACCESS
                            10203 
                            10204         ;kick transaction
                            10205 _Test_Again
P:0243 0A7037 00F202  6 123110206         bset    #HW_USBARCACCESS_KICK_BITPOS,x:HW_USBARCACCESS
                            10207 
                            10208         ;Wait end of transaction
                            10209 _Loop
P:0245 50F000 00F202  3 123410210         move    x:HW_USBARCACCESS,a0
P:0247 0AC837 rrrrrr  6 124010211         jset    #HW_USBARCACCESS_KICK_BITPOS,a0,_Loop
                            10212 
P:0249 44F413 000C00  3 124310213         clr     a	                #>$000c00,x0
P:024B 54F000 00F203  3 124610214         move    x:HW_USBARCDATALOW,a1        ;a1=XLL
P:024D 44F446 000000  3 124910216         and     x0,a    #>$000000,x0
                            10217         
P:024F 200045         2 125110218         cmp     x0,a
P:0250 0AF0AA rrrrrr  6 125710219         jeq     _Reset_True 
                            10220 
P:0252 44F400 000400  3 126010221         move    #>$000400,x0
P:0254 200045         2 126210222         cmp     x0,a
P:0255 0AF0AA rrrrrr  6 126810223         jeq     _Test_Again
                            10224         
P:0257 200013         2 127010225         clr     a
                            10226         
P:0258 0AF080 rrrrrr  6 127610227         jmp     _Done
                            10228         
                            10229 _Reset_True
P:025A 56F400 000001  3 127910230         move    #>1,a
                            10231         
                            10232 _Done        
                            10233 
                            10234 
                            10235 ; 544  |#pragma endasm  
                            10236 ; 545  |
                            10237 ; 546  |}
                            10238 
P:025C 00000C         4 128310240         rts
                            10243 
                            10244 ; 547  |
                            10245 ; 548  |#ifdef MTP_LCD_SUSPEND
                            10246 ; 549  |extern INT gTUNER_STFM1000;
                            10247 ; 550  |extern INT gi16BitOn;
                            10248 ; 551  |_reentrant void MtpDisplaySendCommand(WORD wCommand)
                            10249 ; 552  |{
                            10250 ; 553  |        //LCD_RD_GPDO = TRUE;
                            10251 ; 554  |        LCD_DC_GPDO = FALSE;
                            10252 ; 555  |        LCD_CS_GPDO = FALSE;
                            10253 ; 556  |        //_MultiNop();  //slight pause
                            10254 ; 557  |        LCD_WR_GPDO = FALSE;
                            10255 ; 558  |        //_MultiNop();  //slight pause
                            10256 ; 559  |#ifdef CLCD_8BIT
                            10257 ; 560  |        if (gTUNER_STFM1000) 
                            10258 ; 561  |#else
                            10259 ; 562  |        if (gTUNER_STFM1000 && !gi16BitOn)
                            10260 ; 563  |#endif
                            10261 ; 564  |        {
                            10262 ; 565  |        LCD_DATA_D00 = wCommand & 0x01;
                            10263 ; 566  |        LCD_DATA_D03 = (wCommand & 0x08) ? 1 : 0;
                            10264 ; 567  |        LCD_DATA_D04 = (wCommand & 0x10) ? 1 : 0;
                            10265 ; 568  |    }
                            10266 ; 569  |        LCD_DATA_DO     = wCommand;     
                            10267 ; 570  |        //_MultiNop();  //10ns pause
                            10268 ; 571  |#ifdef CLCD_16BIT
                            10269 ; 572  |        _MultiNop();_MultiNop();_MultiNop();_MultiNop();
                            10270 ; 573  |#endif //#ifdef CLCD_16BIT
                            10271 ; 574  |        LCD_WR_GPDO = TRUE;   
                            10272 ; 575  |        LCD_CS_GPDO = TRUE;
                            10273 ; 576  |}
                            10274 ; 577  |_reentrant void MtpDisplaySuspendIn(void)
                            10275 ; 578  |{
                            10276 ; 579  |    HW_PWM_CSR.I = 0; //MASTER ENABLE to Start clocks
                            10277 ; 580  |
                            10278 ; 581  |    LCD_BLON_GPDOE  = FALSE;
                            10279 ; 582  |    LCD_BLON_GPDO   = FALSE;
                            10280 ; 583  |    LCD_BLON_GPDI   = TRUE;
                            10281 ; 584  |    LCD_BLON_GPEN   = TRUE;
                            10282 ; 585  |    LCD_BLON_GPPWR  = FALSE;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  40

M:ADDR CODE           CYCLES LINE SOURCELINE
                            10283 ; 586  |    
                            10284 ; 587  |    MtpDisplaySendCommand(0x50);    //Display off
                            10285 ; 588  |#ifdef CLCD_8BIT
                            10286 ; 589  |    MtpDisplaySendCommand(0x2D);    //Standby mode on   note: s6b33b0a could not wake up from standby mode if 16bit by experiment
                            10287 ; 590  |#endif
                            10288 ; 591  |    LCD_DC_GPDOE    = FALSE;
                            10289 ; 592  |    LCD_DC_GPDO     = FALSE;
                            10290 ; 593  |    LCD_DC_GPDI     = TRUE;
                            10291 ; 594  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10292 ; 595  |    LCD_DC_GPPWR    = FALSE;
                            10293 ; 596  |#endif
                            10294 ; 597  |
                            10295 ; 598  |    LCD_CS_GPDOE    = FALSE;
                            10296 ; 599  |    LCD_CS_GPDO     = FALSE;
                            10297 ; 600  |    LCD_CS_GPDI     = TRUE;
                            10298 ; 601  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10299 ; 602  |    LCD_CS_GPPWR    = FALSE;
                            10300 ; 603  |#endif
                            10301 ; 604  |
                            10302 ; 605  |    LCD_RD_GPDOE    = FALSE;
                            10303 ; 606  |    LCD_RD_GPDO     = FALSE;
                            10304 ; 607  |    LCD_RD_GPDI     = TRUE;
                            10305 ; 608  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10306 ; 609  |    LCD_RD_GPPWR    = FALSE;
                            10307 ; 610  |#endif
                            10308 ; 611  |
                            10309 ; 612  |    LCD_WR_GPDOE    = FALSE;
                            10310 ; 613  |    LCD_WR_GPDO     = FALSE;
                            10311 ; 614  |    LCD_WR_GPDI     = TRUE;
                            10312 ; 615  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10313 ; 616  |    LCD_WR_GPPWR    = FALSE;
                            10314 ; 617  |#endif
                            10315 ; 618  |
                            10316 ; 619  |#ifdef CLCD_8BIT
                            10317 ; 620  |        if (gTUNER_STFM1000)
                            10318 ; 621  |        {   LCD_DATA_D00_GPDOE  =  FALSE; 
                            10319 ; 622  |            LCD_DATA_D00        =  FALSE;       
                            10320 ; 623  |            LCD_DATA_D00_DI     =  TRUE;
                            10321 ; 624  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10322 ; 625  |            LCD_DATA_D00_GPPWR  =  FALSE;    
                            10323 ; 626  |#endif
                            10324 ; 627  |        
                            10325 ; 628  |            LCD_DATA_D03_GPDOE  =  FALSE; 
                            10326 ; 629  |            LCD_DATA_D03        =  FALSE;       
                            10327 ; 630  |            LCD_DATA_D03_DI     =  TRUE;
                            10328 ; 631  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10329 ; 632  |            LCD_DATA_D03_GPPWR  =  FALSE;    
                            10330 ; 633  |#endif
                            10331 ; 634  |        
                            10332 ; 635  |            LCD_DATA_D04_GPDOE  =  FALSE; 
                            10333 ; 636  |            LCD_DATA_D04        =  FALSE;       
                            10334 ; 637  |            LCD_DATA_D04_DI     =  TRUE;
                            10335 ; 638  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10336 ; 639  |            LCD_DATA_D04_GPPWR  =  FALSE;    
                            10337 ; 640  |#endif
                            10338 ; 641  |        
                            10339 ; 642  |            LCD_DATA_DOE   &= ~(0xe6);  // 1110 0110 except bits 0, 3, 4
                            10340 ; 643  |                LCD_DATA_DO    &= ~(0xe6);  // 1110 0110 except bits 0, 3, 4  
                            10341 ; 644  |                LCD_DATA_DI    |=   0xe6;   // 1110 0110 except bits 0, 3, 4  
                            10342 ; 645  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10343 ; 646  |            LCD_DATA_PWR   &= ~(0xe6);
                            10344 ; 647  |#endif
                            10345 ; 648  |        }        
                            10346 ; 649  |        else // non STFM1000 layout
                            10347 ; 650  |    {   LCD_DATA_DOE   &= ~(0xff);
                            10348 ; 651  |            LCD_DATA_DO    &= ~(0xff);
                            10349 ; 652  |            LCD_DATA_DI    |=   0xff;
                            10350 ; 653  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10351 ; 654  |        LCD_DATA_PWR   &= ~(0xff);
                            10352 ; 655  |#endif
                            10353 ; 656  |     }
                            10354 ; 657  |#else //#ifdef CLCD_8BIT
                            10355 ; 658  |    LCD_DATA_DOE   &= ~(0xffff);
                            10356 ; 659  |    LCD_DATA_DO    &= ~(0xffff);
                            10357 ; 660  |    LCD_DATA_DI    |=   0xffff;
                            10358 ; 661  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10359 ; 662  |    LCD_DATA_PWR   &= ~(0xffff);
                            10360 ; 663  |#endif
                            10361 ; 664  |    CLCD_16BIT_SWITCH_GPDOE = FALSE;
                            10362 ; 665  |    CLCD_16BIT_SWITCH       = FALSE;
                            10363 ; 666  |    CLCD_16BIT_SWITCH_GPDI  = TRUE;
                            10364 ; 667  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10365 ; 668  |    CLCD_16BIT_SWITCH_GPPWR = FALSE;
                            10366 ; 669  |#endif
                            10367 ; 670  |#endif //#ifdef CLCD_8BIT
                            10368 ; 671  |}
                            10369 ; 672  |_reentrant void MtpDisplaySuspendOut(void)
                            10370 ; 673  |{
                            10371 ; 674  |    LCD_DC_GPDI     = FALSE;
                            10372 ; 675  |    LCD_DC_GPDO     = TRUE;
                            10373 ; 676  |    LCD_DC_GPDOE    = TRUE;
                            10374 ; 677  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10375 ; 678  |    LCD_DC_GPPWR    = TRUE;
                            10376 ; 679  |#endif
                            10377 ; 680  |
                            10378 ; 681  |    LCD_CS_GPDI     = FALSE;
                            10379 ; 682  |    LCD_CS_GPDO     = FALSE;
                            10380 ; 683  |    LCD_CS_GPDOE    = TRUE;
                            10381 ; 684  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10382 ; 685  |    LCD_CS_GPPWR    = TRUE;
                            10383 ; 686  |#endif
                            10384 ; 687  |
                            10385 ; 688  |    LCD_RD_GPDI     = FALSE;
                            10386 ; 689  |    LCD_RD_GPDO     = TRUE;
                            10387 ; 690  |    LCD_RD_GPDOE    = TRUE;
                            10388 ; 691  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10389 ; 692  |    LCD_RD_GPPWR    = TRUE;
                            10390 ; 693  |#endif
                            10391 ; 694  |
                            10392 ; 695  |    LCD_WR_GPDI     = FALSE;
                            10393 ; 696  |    LCD_WR_GPDO     = TRUE;
                            10394 ; 697  |    LCD_WR_GPDOE    = TRUE;
                            10395 ; 698  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10396 ; 699  |    LCD_WR_GPPWR    = TRUE;
                            10397 ; 700  |#endif
                            10398 ; 701  |
                            10399 ; 702  |#ifdef CLCD_8BIT
                            10400 ; 703  |        if (gTUNER_STFM1000)
                            10401 ; 704  |        {   LCD_DATA_D00_DI     =  FALSE;
                            10402 ; 705  |            LCD_DATA_D00        =  TRUE;       
                            10403 ; 706  |            LCD_DATA_D00_GPDOE  =  TRUE; 
                            10404 ; 707  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10405 ; 708  |            LCD_DATA_D00_GPPWR  =  TRUE;    
                            10406 ; 709  |#endif
                            10407 ; 710  |        
                            10408 ; 711  |            LCD_DATA_D03_DI     =  FALSE;
                            10409 ; 712  |            LCD_DATA_D03        =  TRUE;       
                            10410 ; 713  |            LCD_DATA_D03_GPDOE  =  TRUE; 
                            10411 ; 714  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10412 ; 715  |            LCD_DATA_D03_GPPWR  =  TRUE;    
                            10413 ; 716  |#endif
                            10414 ; 717  |        
                            10415 ; 718  |            LCD_DATA_D04_DI     =  FALSE;
                            10416 ; 719  |            LCD_DATA_D04        =  TRUE;       
                            10417 ; 720  |            LCD_DATA_D04_GPDOE  =  TRUE; 
                            10418 ; 721  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10419 ; 722  |            LCD_DATA_D04_GPPWR  =  TRUE;    
                            10420 ; 723  |#endif
                            10421 ; 724  |        
                            10422 ; 725  |                LCD_DATA_DI    &= ~(0xe6);  // 1110 0110 except bits 0, 3, 4  
                            10423 ; 726  |                LCD_DATA_DO    |=   0xe6;   // 1110 0110 except bits 0, 3, 4  
                            10424 ; 727  |            LCD_DATA_DOE   |=   0xe6;   // 1110 0110 except bits 0, 3, 4
                            10425 ; 728  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10426 ; 729  |            LCD_DATA_PWR   |=   0xe6;
                            10427 ; 730  |#endif
                            10428 ; 731  |        }        
                            10429 ; 732  |        else // non STFM1000 layout
                            10430 ; 733  |    {   LCD_DATA_DI    &= ~(0xff);
                            10431 ; 734  |            LCD_DATA_DO    |=   0xff;
                            10432 ; 735  |            LCD_DATA_DOE   |=   0xff;
                            10433 ; 736  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10434 ; 737  |        LCD_DATA_PWR   |=   0xff;
                            10435 ; 738  |#endif
                            10436 ; 739  |     }
                            10437 ; 740  |#else //#ifdef CLCD_8BIT
                            10438 ; 741  |    //******* 16-bit interface is already turned on before.
                            10439 ; 742  |    LCD_DATA_DI    &= ~(0xffff);
                            10440 ; 743  |    LCD_DATA_DO    |=   0xffff;
                            10441 ; 744  |    LCD_DATA_DOE   |=   0xffff;
                            10442 ; 745  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10443 ; 746  |    LCD_DATA_PWR   |=   0xffff;
                            10444 ; 747  |#endif
                            10445 ; 748  |
                            10446 ; 749  |    CLCD_16BIT_SWITCH_GPDI  =  FALSE;
                            10447 ; 750  |    CLCD_16BIT_SWITCH       =  CLCD_16BIT_SWITCH_16BIT_ON;
                            10448 ; 751  |    CLCD_16BIT_SWITCH_GPDOE =  TRUE;        
                            10449 ; 752  |#if defined(DEVICE_3410) || defined(DEVICE_3310) || defined(DEVICE_3500)
                            10450 ; 753  |        CLCD_16BIT_SWITCH_GPPWR =  TRUE;        
                            10451 ; 754  |#endif
                            10452 ; 755  |#endif //#ifdef CLCD_8BIT
                            10453 ; 756  |
                            10454 ; 757  |#ifdef CLCD_8BIT
                            10455 ; 758  |    MtpDisplaySendCommand(0x2C);    //Standby mode off  note: s6b33b0a could not wake up from standby mode if 16bit by experiment
                            10456 ; 759  |#endif
                            10457 ; 760  |    MtpDisplaySendCommand(0x51);    //Display on
                            10458 ; 761  |
                            10459 ; 762  |    LCD_BLON_GPDOE  = FALSE;
                            10460 ; 763  |    LCD_BLON_GPDO   = FALSE;
                            10461 ; 764  |    LCD_BLON_GPDI   = FALSE;
                            10462 ; 765  |    LCD_BLON_GPEN   = FALSE;
                            10463 ; 766  |    LCD_BLON_GPPWR  = TRUE;
                            10464 ; 767  |
                            10465 ; 768  |    HW_PWM_CSR.I = PWM_ENABLE_MASK; //MASTER ENABLE to Start clocks
                            10466 ; 769  |}
                            10467 ; 770  |#endif
                            10468 ; 771  |////////////////////////////////////////////////////////////////////////////////
                            10469 ; 772  |//
                            10470 ; 773  |//>  Name:          usb_dci_process_suspend
                            10471 ; 774  |//
                            10472 ; 775  |//   Type:          Function
                            10473 ; 776  |//
                            10474 ; 777  |//   Description:   Services DC Suspend interrupt
                            10475 ; 778  |//
                            10476 ; 779  |//   Inputs:        pStDeviceState = Pointer to the device state structure
                            10477 ; 780  |//
                            10478 ; 781  |//   Outputs:       none
                            10479 ; 782  |//
                            10480 ; 783  |//   Notes:         none
                            10481 ; 784  |//<
                            10482 ; 785  |////////////////////////////////////////////////////////////////////////////////
                            10483 ; 786  |void _reentrant usb_dci_process_suspend(Dev_State_Struct _USB_MEM * pStDeviceState)
                            10484 ; 787  |{ /* Body */
                            10485 
                            10578 Fusb_dci_process_suspend:
                            10589 
                            10590 ; 788  |    WORD wReset = FALSE;
                            10591 ; 789  |    
                            10592 ; 790  |    if(pStDeviceState->usUsbState != (USHORT)USB_STATE_SUSPENDED)
                            10593 
P:025D 055F7C         2 128510579         movec   ssh,y:(r7)+
P:025E 3E0400         2 128710595         move    #4,n6
P:025F 77F400 FFFFFE  3 129010597         move    #-2,n7
P:0261 221600         2 129210596         move    r0,r6
P:0262 47F400 000080  3 129510603         move    #>$80,y1
P:0264 205F00         2 129710582         move    (r7)+
P:0265 205F00         2 129910583         move    (r7)+
P:0266 6E6F00         4 130310599         move    r6,y:(r7+n7)
P:0267 5FEE00         4 130710600         move    y:(r6+n6),b
P:0268 20007D         2 130910604         cmp     y1,b
P:0269 0AF0AA rrrrrr  6 131510605         jeq     L20
                            10606 
                            10607 ; 791  |    {    
                            10608 ; 792  |#ifdef CLCD
                            10609 ; 793  |#ifdef MTP_LCD_SUSPEND   
                            10610 ; 794  |        MtpDisplaySuspendIn();
                            10611 ; 795  |#else
                            10612 ; 796  |        HALDisplaySuspendIn();
                            10613 ; 797  |#endif
                            10614 ; 798  |#endif
                            10615 ; 799  |        //shut down the phy
                            10616 ; 800  |        PHY_Shutdown();
                            10617 
P:026B 0BF080 rrrrrr  6 132110619         jsr     FPHY_Shutdown
                            10620 
                            10621 ; 801  |
                            10622 ; 802  |        //call the suspend service
                            10623 ; 803  |        usb_device_call_service(USB_SERVICE_SUSPEND, FALSE, 0, 0, 0,0);
                            10624 
P:026D 26001B         2 132310626         clr     b	                #0,y0
P:026E 240000         2 132510628         move    #0,x0
P:026F 250013         2 132710627         clr     a	                #0,x1
P:0270 219000         2 132910631         move    a1,r0
P:0271 56F400 000011  3 133210632         move    #>17,a
P:0273 0BF080 rrrrrr  6 133810633         jsr     Fusb_device_call_service
                            10634 
                            10635 ; 804  |
                            10636 ; 805  |        //put the clock as low as possible
                            10637 ; 806  |        HW_CCR.B.DDIV_MSB = 1;
                            10638 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  41

M:ADDR CODE           CYCLES LINE SOURCELINE
                            10641 
                            10642 ; 807  |        HW_CCR.B.DDIV = 3;
                            10643 
                            10656 
                            10657 ; 808  |
                            10658 ; 809  |        wReset=usb_dci_wait_until_suspend_ends(pStDeviceState);
                            10659 
P:0275 0A7037 00FA00  6 134410640         bset    #23,x:$FA00
P:0277 46F400 FFF1FF  3 134710646         move    #$FFF1FF,y0
P:0279 57F000 00FA00  3 135010645         move    x:$FA00,b
P:027B 77F45E FFFFFE  3 135310647         and     y0,b	                #-2,n7
P:027D 46F400 000600  3 135610648         move    #$600,y0
P:027F 68EF5A         4 136010649         or      y0,b	                y:(r7+n7),r0
P:0280 557000 00FA00  3 136310650         move    b1,x:$FA00
P:0282 0BF080 rrrrrr  6 136910661         jsr     Fusb_dci_wait_until_suspend_ends
                            10668 
                            10669 ; 810  |
                            10670 ; 811  |        HW_CCR.B.DDIV_MSB = 0;
                            10671 
                            10674 
                            10675 ; 812  |        HW_CCR.B.DDIV = 0;
                            10676 
                            10682 
                            10683 ; 813  |        HW_GP0DOR.B.B14 = TRUE;
                            10684 
                            10687 
                            10688 ; 814  |
                            10689 ; 815  |        usb_device_call_service(USB_SERVICE_RESUME, FALSE, 0, 0, 0,0);
                            10690 
P:0284 045FA0         2 137110664         movec   m0,n7
P:0285 0A7017 00FA00  6 137710673         bclr    #23,x:$FA00
P:0287 46F400 FFF1FF  3 138010679         move    #$FFF1FF,y0
P:0289 5C6F00         4 138410666         move    a1,y:(r7+n7)
P:028A 56F000 00FA00  3 138710678         move    x:$FA00,a
P:028C 250056         2 138910680         and     y0,a	                #0,x1
P:028D 547000 00FA00  3 139210681         move    a1,x:$FA00
P:028F 20A400         2 139410694         move    x1,x0
P:0290 20A600         2 139610695         move    x1,y0
P:0291 0A702E 00F401  6 140210686         bset    #14,x:$F401
P:0293 30001B         2 140410693         clr     b	                #0,r0
P:0294 56F400 000013  3 140710697         move    #>19,a
P:0296 0BF080 rrrrrr  6 141310698         jsr     Fusb_device_call_service
                            10699 
                            10700 ; 816  |
                            10701 ; 817  |        PHY_Resume();
                            10702 
P:0298 0BF080 rrrrrr  6 141910704         jsr     FPHY_Resume
                            10705 
                            10706 ; 818  |
                            10707 ; 819  |#ifdef CLCD
                            10708 ; 820  |#ifdef MTP_LCD_SUSPEND
                            10709 ; 821  |        MtpDisplaySuspendOut(); //CQ
                            10710 ; 822  |#else
                            10711 ; 823  |        HALDisplaySuspendOut();
                            10712 ; 824  |#endif
                            10713 ; 825  |#endif
                            10714 ; 826  |        if(wReset)
                            10715 
P:029A 045FA0         2 142110717         movec   m0,n7
P:029B 000000         2 142310717         nop             ; (inserted)
P:029C 5FEF00         4 142710719         move    y:(r7+n7),b
P:029D 2B0000         2 142910720         move    #0,b2
P:029E 20000B         2 143110721         tst     b
P:029F 0AF0AA rrrrrr  6 143710724         jeq     L20
                            10725 
                            10726 ; 827  |        {
                            10727 ; 828  |            usb_dci_process_reset(pStDeviceState);
                            10728 
P:02A1 77F400 FFFFFE  3 144010730         move    #-2,n7
P:02A3 000000         2 144210730         nop             ; (inserted)
P:02A4 68EF00         4 144610732         move    y:(r7+n7),r0
P:02A5 0BF080 rrrrrr  6 145210733         jsr     Fusb_dci_process_reset
                            10738 
                            10739 ; 829  |            
                            10740 ; 830  |            // JCP - If we have problems to wake up from suspend, we may want to 
                            10741 ; 831  |                        // comment the next usb_device_hold() call ...
                            10742 ; 832  |            usb_device_hold();
                            10743 
P:02A7 0BF080 rrrrrr  6 145810745         jsr     Fusb_device_hold
                            10746 
                            10747 ; 833  |            
                            10748 ; 834  |            usb_device_set_first_init();
                            10749 
P:02A9 0BF080 rrrrrr  6 146410751         jsr     Fusb_device_set_first_init
                            10752 
                            10753 ; 835  |            
                            10754 ; 836  |        }
                            10755 ; 837  |
                            10756 ; 838  |    }        
                            10757 
                            10759 L20:
                            10760 
                            10761 ; 839  |
                            10762 ; 840  |} /* EndBody */
                            10763 
P:02AB 205700         2 146610765         move    (r7)-
P:02AC 205700         2 146810766         move    (r7)-
P:02AD 05FF7C         4 147210768         movec   y:-(r7),ssh
P:02AE 000000         2 147410768         nop             ; (inserted)
P:02AF 00000C         4 147810772         rts
                            10774 
                            10775 ; 841  |
                            10776 ; 842  |
                            10777 ; 843  |
                            10778 ; 844  |
                            10779 ; 845  |////////////////////////////////////////////////////////////////////////////////
                            10780 ; 846  |//
                            10781 ; 847  |//>  Name:          usb_dci_process_port_change
                            10782 ; 848  |//
                            10783 ; 849  |//   Type:          Function
                            10784 ; 850  |//
                            10785 ; 851  |//   Description:   Services Port Change Detect Interrupt
                            10786 ; 852  |//
                            10787 ; 853  |//   Inputs:        pStDeviceState = Pointer to the device state structure
                            10788 ; 854  |//
                            10789 ; 855  |//   Outputs:       none
                            10790 ; 856  |//
                            10791 ; 857  |//   Notes:         none
                            10792 ; 858  |//<
                            10793 ; 859  |////////////////////////////////////////////////////////////////////////////////
                            10794 ; 860  |void _reentrant usb_dci_process_port_change(Dev_State_Struct _USB_MEM * pStDeviceState)
                            10795 ; 861  |{ /* Body */
                            10796 
                            10801 Fusb_dci_process_port_change:
                            10815 
                            10816 ; 862  |
                            10817 ; 863  |    DWORD   dwStatus, dwReg;
                            10818 ; 864  |    BYTE    btEndpoint;
                            10819 ; 865  |    
                            10820 ; 866  |    if (pStDeviceState->btBusResetting == TRUE)
                            10821 
P:02B0 055F7C         2 148010802         movec   ssh,y:(r7)+
P:02B1 3F0700         2 148210805         move    #7,n7
P:02B2 3E0800         2 148410823         move    #8,n6
P:02B3 221600         2 148610824         move    r0,r6
P:02B4 57F400 000001  3 148910831         move    #>1,b
P:02B6 204F00         2 149110807         move    (r7)+n7
P:02B7 77F400 FFFFFD  3 149410825         move    #-3,n7
P:02B9 000000         2 149610825         nop             ; (inserted)
P:02BA 6E6F00         4 150010827         move    r6,y:(r7+n7)
P:02BB 5EEE00         4 150410828         move    y:(r6+n6),a
P:02BC 200005         2 150610832         cmp     b,a
P:02BD 0AF0A2 rrrrrr  6 151210833         jne     L22
                            10834 
                            10835 ; 867  |    {   // Port change Detect issue due probably to the end of USB bus reset
                            10836 ; 868  |
                            10837 ; 869  |        // Clear the bus resetting flag
                            10838 ; 870  |        pStDeviceState->btBusResetting = FALSE;
                            10839 
                            10846 
                            10847 ; 871  |
                            10848 ; 872  |        // Set the state of USB to DEFAULT
                            10849 ; 873  |        pStDeviceState->usUsbState = USB_STATE_DEFAULT;
                            10850 
                            10859 
                            10860 ; 874  |        // At this point we need to enable all endpoints so to NAK in response
                            10861 ; 875  |        // to a host transfer. If the enpoint is not enable and the host initiates
                            10862 ; 876  |        // a transfer, ARC will ignore it and who knows what the host will do.
                            10863 ; 877  |        for(btEndpoint = 1 ; btEndpoint < MAX_NUM_EP ; btEndpoint++)
                            10864 
                            10868 
                            10869 ; 878  |        {    
                            10870 ; 879  |            read_usb_reg(HW_ARC_ENDPTCTRL(btEndpoint), &dwReg);
                            10871 
P:02BF 3B0000         2 151410842         move    #0,n3
P:02C0 3D0400         2 151610853         move    #4,n5
P:02C1 22D500         2 151810841         move    r6,r5
P:02C2 21E500         2 152010866         move    b,x1
P:02C3 44F400 000004  3 152310852         move    #>4,x0
P:02C5 7B6E00         4 152710843         move    n3,y:(r6+n6)
P:02C6 360200         2 152910855         move    #2,r6
P:02C7 6D6F00         4 153310854         move    r5,y:(r7+n7)
P:02C8 6E6D00         4 153710856         move    r6,y:(r5+n5)
                            10873 L21:
P:02C9 77F400 FFFFFE  3 154010873         move    #-2,n7
P:02CB 50F400 0001C0  3 154310876         move    #$1C0,a0
P:02CD 4D6F00         4 154710875         move    x1,y:(r7+n7)
P:02CE 77F400 FFFFF9  3 155010881         move    #-7,n7
P:02D0 0116F2         2 155210877         mac     x1,#22,a
P:02D1 044F10         4 155610883         lua     (r7)+n7,r0
P:02D2 045FA0         2 155810884         movec   m0,n7
P:02D3 210E00         2 156010880         move    a0,a
P:02D4 5C6F00         4 156410886         move    a1,y:(r7+n7)
P:02D5 0BF080 rrrrrr  6 157010887         jsr     Fread_usb_reg
                            10891 
                            10892 ; 880  |      
                            10893 ; 881  |            dwReg = dwReg | (DWORD)HW_ARC_ENDPTCTRL_RXE_SETMASK
                            10894 ; 882  |                          | (DWORD)HW_ARC_ENDPTCTRL_TXE_SETMASK;
                            10895 
                            10918 
                            10919 ; 883  |      
                            10920 ; 884  |            write_usb_reg((HW_ARC_ENDPTCTRL(btEndpoint)), dwReg);
                            10921 
P:02D7 045FA0         2 157210888         movec   m0,n7
P:02D8 250000         2 157410904         move    #0,x1
P:02D9 44F400 800080  3 157710905         move    #8388736,x0
P:02DB 5FEF00         4 158110890         move    y:(r7+n7),b
P:02DC 77F400 FFFFF9  3 158410897         move    #-7,n7
P:02DE 205F00         2 158610898         move    (r7)+
P:02DF 5EEF00         4 159010900         move    y:(r7+n7),a
P:02E0 205700         2 159210901         move    (r7)-
P:02E1 218600         2 159410906         move    a1,y0
P:02E2 58EF00         4 159810903         move    y:(r7+n7),a0
P:02E3 210C00         2 160010907         move    a0,a1
P:02E4 205F42         2 160210908         or      x0,a	                (r7)+
P:02E5 218800         2 160410909         move    a1,a0
P:02E6 20CC00         2 160610910         move    y0,a1
P:02E7 200062         2 160810911         or      x1,a
P:02E8 5C6F00         4 161210914         move    a1,y:(r7+n7)
P:02E9 205700         2 161410915         move    (r7)-
P:02EA 586F00         4 161810917         move    a0,y:(r7+n7)
P:02EB 205F00         2 162010923         move    (r7)+
P:02EC 5EEF00         4 162410925         move    y:(r7+n7),a
P:02ED 205700         2 162610926         move    (r7)-
P:02EE 58EF00         4 163010928         move    y:(r7+n7),a0
P:02EF 0BF080 rrrrrr  6 163610929         jsr     Fwrite_usb_reg
P:02F1 77F400 FFFFFE  3 163910931         move    #-2,n7
P:02F3 56F400 000001  3 164210934         move    #>1,a
P:02F5 5FEF00         4 164610933         move    y:(r7+n7),b
P:02F6 44F418 000004  3 164910935         add     a,b	                #>4,x0
P:02F8 21A500         2 165110939         move    b1,x1
P:02F9 20AF00         2 165310941         move    x1,b
P:02FA 20004D         2 165510943         cmp     x0,b
P:02FB 0AF0A9 rrrrrr  6 166110944         jlt     L21
                            10945 
                            10946 ; 885  |        } // Endfor
                            10947 ; 886  |
                            10948 ; 887  |    } /* Endif */
                            10949 ; 888  |
                            10950 ; 889  |    // Check if reset is still present on the bus
                            10951 ; 890  |    read_usb_reg(HW_ARC_PORTSC1, &dwStatus);
                            10952 
P:02FD 77F400 FFFFFB  3 166410954 L22:    move    #-5,n7
P:02FF 56F400 000184  3 166710957         move    #388,a
P:0301 044F10         4 167110956         lua     (r7)+n7,r0
P:0302 0BF080 rrrrrr  6 167710958         jsr     Fread_usb_reg
                            10960 
                            10961 ; 891  |
                            10962 ; 892  |    if (!(dwStatus & HW_ARC_PORTSC1_PR_SETMASK)) 
                            10963 
P:0304 77F400 FFFFFB  3 168010965         move    #-5,n7
P:0306 205F00         2 168210966         move    (r7)+
P:0307 5FEF00         4 168610968         move    y:(r7+n7),b
P:0308 205700         2 168810969         move    (r7)-
P:0309 59EF00         4 169210971         move    y:(r7+n7),b0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  42

M:ADDR CODE           CYCLES LINE SOURCELINE
P:030A 0AC928 rrrrrr  6 169810972         jset    #8,b0,L25
                            10973 
                            10974 ; 893  |    {   // Reset completed, check which speed we will operate at
                            10975 ; 894  |        if (dwStatus & HW_ARC_PORTSC1_HSP_SETMASK) 
                            10976 
P:030C 0AC909 rrrrrr  6 170410978         jclr    #9,b0,L23
                            10979 
                            10980 ; 895  |            pStDeviceState->btSpeed = (BYTE)USB_SPEED_HIGH;
                            10981 
P:030E 3E0200         2 170610986         move    #2,n6
P:030F 77F400 FFFFFD  3 170910983         move    #-3,n7
P:0311 000000         2 171110983         nop             ; (inserted)
P:0312 6EEF00         4 171510985         move    y:(r7+n7),r6
P:0313 000000         2 171710985         nop             ; (inserted)
P:0314 7E6600         2 171910987         move    n6,y:(r6)
P:0315 0AF080 rrrrrr  6 172510990         jmp     L24
                            10991 
                            10992 ; 896  |        else    
                            10993 ; 897  |            pStDeviceState->btSpeed = (BYTE)USB_SPEED_FULL;
                            10994 
                            10996 L23:
                            11006 
                            11007 ; 898  |      
                            11008 ; 899  |        usb_device_call_service(USB_SERVICE_SPEED_DETECTION, FALSE, 0, 0, (WORD)pStDeviceState->btSpeed,0);
                            11009 
P:0317 3D0000         2 172711002         move    #0,n5
P:0318 77F400 FFFFFD  3 173010999         move    #-3,n7
P:031A 000000         2 173210999         nop             ; (inserted)
P:031B 6EEF00         4 173611001         move    y:(r7+n7),r6
P:031C 000000         2 173811001         nop             ; (inserted)
P:031D 7D6600         2 174011003         move    n5,y:(r6)
                            11011 L24:
P:031E 300000         2 174211013         move    #0,r0
P:031F 77F400 FFFFFD  3 174511014         move    #-3,n7
P:0321 25001B         2 174711012         clr     b	                #0,x1
P:0322 56F400 000015  3 175011021         move    #>21,a
P:0324 6E6F00         4 175411016         move    r6,y:(r7+n7)
P:0325 20A400         2 175611020         move    x1,x0
P:0326 4EE600         2 175811017         move    y:(r6),y0
P:0327 0BF080 rrrrrr  6 176411022         jsr     Fusb_device_call_service
                            11023 
                            11024 ; 900  |
                            11025 ; 901  |    } // Endif
                            11026 ; 902  |      
                            11027 ; 903  |      
                            11028 ; 904  |    
                            11029 ; 905  |
                            11030 ; 906  |
                            11031 ; 907  |    // Port change detect could have been generated by a SUSPEND state
                            11032 ; 908  |    if (dwStatus & (DWORD)HW_ARC_PORTSC1_SUSP_SETMASK) 
                            11033 
                            11035 L25:
P:0329 77F400 FFFFFB  3 176711035         move    #-5,n7
P:032B 205F00         2 176911036         move    (r7)+
P:032C 5EEF00         4 177311038         move    y:(r7+n7),a
P:032D 205700         2 177511039         move    (r7)-
P:032E 5FEF00         4 177911041         move    y:(r7+n7),b
P:032F 21A800         2 178111042         move    b1,a0
P:0330 200009         2 178311043         tfr     a,b
P:0331 0AC907 rrrrrr  6 178911044         jclr    #7,b0,L27
                            11045 
                            11046 ; 909  |    {   // If so, suspend the system
                            11047 ; 910  |        //I don't believe this branch is ever called. RS
                            11048 ; 911  |
                            11049 ; 912  |        // Save the USB state prior the SUSPEND, to restore after a resume
                            11050 ; 913  |        // Set the state of USB to SUSPEND
                            11051 ; 914  |        if(pStDeviceState->usUsbState != USB_STATE_SUSPENDED)
                            11052 
P:0333 3E0400         2 179111054         move    #4,n6
P:0334 77F400 FFFFFD  3 179411055         move    #-3,n7
P:0336 47F400 000080  3 179711061         move    #>$80,y1
P:0338 6EEF00         4 180111057         move    y:(r7+n7),r6
P:0339 000000         2 180311057         nop             ; (inserted)
P:033A 4EEE00         4 180711059         move    y:(r6+n6),y0
P:033B 20CF00         2 180911060         move    y0,b
P:033C 20007D         2 181111062         cmp     y1,b
P:033D 0AF0AA rrrrrr  6 181711063         jeq     L26
                            11064 
                            11065 ; 915  |        { 
                            11066 ; 916  |            pStDeviceState->usUsbStatePriorSusp = pStDeviceState->usUsbState;
                            11067 
                            11075 
                            11076 ; 917  |            pStDeviceState->usUsbState = USB_STATE_SUSPENDED;
                            11077 
                            11083 
                            11084 ; 918  |        }        
                            11085 ; 919  |      
                            11086 ; 920  |      usb_device_call_service(USB_SERVICE_SUSPEND, FALSE, 0, 0, 0,0);
                            11087 
P:033F 3D0500         2 181911069         move    #5,n5
P:0340 22D500         2 182111070         move    r6,r5
P:0341 000000         2 182311070         nop             ; (inserted)
P:0342 4E6D00         4 182711072         move    y0,y:(r5+n5)
P:0343 6E6F00         4 183111079         move    r6,y:(r7+n7)
P:0344 4F6E00         4 183511080         move    y1,y:(r6+n6)
                            11089 L26:
P:0345 300000         2 183711091         move    #0,r0
P:0346 25001B         2 183911090         clr     b	                #0,x1
P:0347 56F400 000011  3 184211094         move    #>17,a
P:0349 20A400         2 184411092         move    x1,x0
P:034A 20A600         2 184611093         move    x1,y0
P:034B 0BF080 rrrrrr  6 185211095         jsr     Fusb_device_call_service
                            11096 
                            11097 ; 921  |    } // Endif
                            11098 ; 922  |
                            11099 ; 923  |    // Port change detect could have been generated by leaving a SUSPEND state
                            11100 ; 924  |    if ((!(dwStatus & (DWORD)HW_ARC_PORTSC1_SUSP_SETMASK)) && (pStDeviceState->usUsbState == USB_STATE_SUSPENDED)) 
                            11101 
                            11103 L27:
P:034D 77F400 FFFFFB  3 185511103         move    #-5,n7
P:034F 205F00         2 185711104         move    (r7)+
P:0350 5EEF00         4 186111106         move    y:(r7+n7),a
P:0351 205700         2 186311107         move    (r7)-
P:0352 58EF00         4 186711109         move    y:(r7+n7),a0
P:0353 0AC827 rrrrrr  6 187311110         jset    #7,a0,L29
P:0355 3E0400         2 187511111         move    #4,n6
P:0356 77F400 FFFFFD  3 187811112         move    #-3,n7
P:0358 47F400 000080  3 188111119         move    #>$80,y1
P:035A 6EEF00         4 188511114         move    y:(r7+n7),r6
P:035B 000000         2 188711114         nop             ; (inserted)
P:035C 5FEE00         4 189111116         move    y:(r6+n6),b
P:035D 20007D         2 189311120         cmp     y1,b
P:035E 0AF0A2 rrrrrr  6 189911121         jne     L29
                            11122 
                            11123 ; 925  |    {
                            11124 ; 926  |        //I don't believe this branch is ever called. RS
                            11125 ; 927  |        pStDeviceState->usUsbState = pStDeviceState->usUsbStatePriorSusp;
                            11126 
                            11133 
                            11134 ; 928  |    } // Endif 
                            11135 
P:0360 3D0500         2 190111128         move    #5,n5
P:0361 22D500         2 190311129         move    r6,r5
P:0362 000000         2 190511129         nop             ; (inserted)
P:0363 7DED00         4 190911131         move    y:(r5+n5),n5
P:0364 7D6E00         4 191311132         move    n5,y:(r6+n6)
                            11137 L29:
                            11138 
                            11139 ; 929  |
                            11140 ; 930  |
                            11141 ; 931  |
                            11142 ; 932  |} /* EndBody */
                            11143 
P:0365 77F400 FFFFF8  3 191611145         move    #-8,n7
P:0367 000000         2 191811145         nop             ; (inserted)
P:0368 05EF7C         4 192211147         movec   y:(r7+n7),ssh
P:0369 204F00         2 192411149         move    (r7)+n7
P:036A 00000C         4 192811151         rts
                            11154 
                            11155 ; 933  |
                            11156 ; 934  |
                            11157 ; 935  |////////////////////////////////////////////////////////////////////////////////
                            11158 ; 936  |//
                            11159 ; 937  |//>  Name:          usb_dci_clear_dxd_queue
                            11160 ; 938  |//
                            11161 ; 939  |//   Type:          Function
                            11162 ; 940  |//
                            11163 ; 941  |//   Description:   Clears a particular dxd queue
                            11164 ; 942  |//
                            11165 ; 943  |//   Inputs:        wEndpoint
                            11166 ; 944  |//                  wDirection
                            11167 ; 945  |//
                            11168 ; 946  |//   Outputs:       none
                            11169 ; 947  |//
                            11170 ; 948  |//   Notes:         none
                            11171 ; 949  |//<
                            11172 ; 950  |////////////////////////////////////////////////////////////////////////////////
                            11173 ; 951  |void _reentrant usb_dci_clear_dxd_queue(WORD wEndpoint, WORD wDirection)
                            11174 ; 952  |{
                            11175 
                            11180 Fusb_dci_clear_dxd_queue:
                            11187 
                            11188 ; 953  |    xd_struct _USB_MEM * pCurrentXd = g_dXD_Queues[wEndpoint][wDirection];
                            11189 
                            11212 
                            11213 ; 954  |    xd_struct _USB_MEM * pNextXd;
                            11214 ; 955  |    while(pCurrentXd)
                            11215 
P:036B 055F7C         2 193011181         movec   ssh,y:(r7)+
P:036C 63F400 rrrrrr  3 193311202         move    #Fg_dXD_Queues,r3
P:036E 77F400 FFFFFE  3 193611205         move    #-2,n7
P:0370 205F12         2 193811191         addl    b,a	                (r7)+
P:0371 219B00         2 194011201         move    a1,n3
P:0372 205F00         2 194211185         move    (r7)+
P:0373 044B16         4 194611204         lua     (r3)+n3,r6
P:0374 6E6F00         4 195011207         move    r6,y:(r7+n7)
P:0375 68E600         2 195211208         move    y:(r6),r0
P:0376 0AF080 rrrrrr  6 195811217         jmp     L31
                            11218 
                            11219 ; 956  |    {
                            11220 ; 957  |        pNextXd = pCurrentXd->pNext;
                            11221 
                            11223 L30:
                            11230 
                            11231 ; 958  |        FreeXd(pCurrentXd);
                            11232 
P:0378 380A00         2 196011223         move    #10,n0
P:0379 045FA0         2 196211226         movec   m0,n7
P:037A 6EE800         4 196611225         move    y:(r0+n0),r6
P:037B 6E6F00         4 197011228         move    r6,y:(r7+n7)
P:037C 0BF080 rrrrrr  6 197611234         jsr     FFreeXd
P:037E 045FA0         2 197811237         movec   m0,n7
P:037F 000000         2 198011237         nop             ; (inserted)
P:0380 68EF00         4 198411239         move    y:(r7+n7),r0
P:0381 220E00         2 198611245 L31:    move    r0,a
P:0382 200003         2 198811246         tst     a
P:0383 0AF0A2 rrrrrr  6 199411247         jne     L30
                            11248 
                            11249 ; 959  |        pCurrentXd = pNextXd;
                            11250 ; 960  |    }
                            11251 ; 961  |    g_dXD_Queues[wEndpoint][wDirection] = NULL;
                            11252 
                            11260 
                            11261 ; 962  |
                            11262 ; 963  |}
                            11263 
P:0385 77F41B FFFFFE  3 199711254         clr     b	                #-2,n7
P:0387 000000         2 199911254         nop             ; (inserted)
P:0388 6EEF00         4 200311257         move    y:(r7+n7),r6
P:0389 204F00         2 200511265         move    (r7)+n7
P:038A 5D6600         2 200711259         move    b1,y:(r6)
P:038B 05FF7C         4 201111267         movec   y:-(r7),ssh
P:038C 000000         2 201311267         nop             ; (inserted)
P:038D 00000C         4 201711271         rts
                            11274 
                            11275 ; 964  |
                            11276 ; 965  |////////////////////////////////////////////////////////////////////////////////
                            11277 ; 966  |//
                            11278 ; 967  |//>  Name:          usb_dci_process_reset
                            11279 ; 968  |//
                            11280 ; 969  |//   Type:          Function
                            11281 ; 970  |//
                            11282 ; 971  |//   Description:   Services reset interrupt
                            11283 ; 972  |//
                            11284 ; 973  |//   Inputs:        pStDeviceState = Pointer to the device state structure
                            11285 ; 974  |//
                            11286 ; 975  |//   Outputs:       none
                            11287 ; 976  |//
                            11288 ; 977  |//   Notes:         none
                            11289 ; 978  |//<
                            11290 ; 979  |////////////////////////////////////////////////////////////////////////////////
                            11291 ; 980  |void _reentrant usb_dci_process_reset(Dev_State_Struct _USB_MEM * pStDeviceState)
                            11292 ; 981  |{ /* Body */
                            11293 
                            11298 Fusb_dci_process_reset:
                            11313 
                            11314 ; 982  |   DWORD    dwRegister;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  43

M:ADDR CODE           CYCLES LINE SOURCELINE
                            11315 ; 983  |   BYTE     btEndpoint;
                            11316 ; 984  |   int i;
                            11317 
                            11324 
                            11325 ; 985  |   
                            11326 ; 986  |      // Initializes the endpoint 0. If application needs different init params 
                            11327 ; 987  |    // for endpoint 0 it must do it in the USB_SERVICE_BUS_RESET service
                            11328 ; 988  |    usb_device_init_endpoint(0, 64, USB_OUT, USB_CONTROL_ENDPOINT, TRUE);
                            11329 
P:038E 055F7C         2 201911299         movec   ssh,y:(r7)+
P:038F 3F0513         2 202111331         clr     a	                #5,n7
P:0390 260000         2 202311334         move    #0,y0
P:0391 240000         2 202511332         move    #0,x0
P:0392 57F400 000040  3 202811333         move    #>$40,b
P:0394 45F400 000001  3 203111335         move    #>1,x1
P:0396 204F00         2 203311304         move    (r7)+n7
P:0397 77F400 FFFFFD  3 203611319         move    #-3,n7
P:0399 000000         2 203811319         nop             ; (inserted)
P:039A 686F00         4 204211321         move    r0,y:(r7+n7)
P:039B 0BF080 rrrrrr  6 204811336         jsr     Fusb_device_init_endpoint
                            11337 
                            11338 ; 989  |    usb_device_init_endpoint(0, 64, USB_IN, USB_CONTROL_ENDPOINT, TRUE);
                            11339 
P:039D 260013         2 205011341         clr     a	                #0,y0
P:039E 57F400 000040  3 205311345         move    #>$40,b
P:03A0 44F400 000001  3 205611342         move    #>1,x0
P:03A2 208500         2 205811344         move    x0,x1
P:03A3 0BF080 rrrrrr  6 206411346         jsr     Fusb_device_init_endpoint
                            11347 
                            11348 ; 990  |    
                            11349 ; 991  |    //clear out the dxds
                            11350 ; 992  |    for(i=0;i<MAX_NUM_EP;i++)
                            11351 
                            11356 
                            11357 ; 993  |    {
                            11358 ; 994  |        usb_dci_clear_dxd_queue(i,0);
                            11359 
P:03A5 47F41B 000001  3 206711353         clr     b	                #>1,y1
                            11361 L32:
P:03A7 77F400 FFFFFE  3 207011361         move    #-2,n7
P:03A9 21AE00         2 207211369         move    b1,a
P:03AA 5D6F00         4 207611363         move    b1,y:(r7+n7)
P:03AB 045FA0         2 207811366         movec   m0,n7
P:03AC 000000         2 208011366         nop             ; (inserted)
P:03AD 5D6F1B         4 208411370         clr     b	                b1,y:(r7+n7)
P:03AE 0BF080 rrrrrr  6 209011371         jsr     Fusb_dci_clear_dxd_queue
                            11376 
                            11377 ; 995  |        usb_dci_clear_dxd_queue(i,1);
                            11378 
P:03B0 045FA0         2 209211372         movec   m0,n7
P:03B1 57F400 000001  3 209511375         move    #>1,b
P:03B3 5EEF00         4 209911374         move    y:(r7+n7),a
P:03B4 0BF080 rrrrrr  6 210511380         jsr     Fusb_dci_clear_dxd_queue
P:03B6 77F400 FFFFFE  3 210811382         move    #-2,n7
P:03B8 47F400 000001  3 211111385         move    #>1,y1
P:03BA 5FEF00         4 211511384         move    y:(r7+n7),b
P:03BB 46F478 000004  3 211811386         add     y1,b	                #>4,y0
P:03BD 20005D         2 212011390         cmp     y0,b
P:03BE 0AF0A9 rrrrrr  6 212611391         jlt     L32
                            11392 
                            11393 ; 996  |    }
                            11394 ; 997  |
                            11395 ; 998  |
                            11396 ; 999  |   /* Inform the application so that it can cancel all previously queued transfers */
                            11397 ; 1000 |   usb_device_call_service(USB_SERVICE_BUS_RESET, FALSE, 0, 0, 0,0);
                            11398 
P:03C0 300000         2 212811402         move    #0,r0
P:03C1 24001B         2 213011400         clr     b	                #0,x0
P:03C2 260000         2 213211404         move    #0,y0
P:03C3 250000         2 213411405         move    #0,x1
P:03C4 56F400 000010  3 213711406         move    #>16,a
P:03C6 0BF080 rrrrrr  6 214311407         jsr     Fusb_device_call_service
                            11408 
                            11409 ; 1001 |   
                            11410 ; 1002 |   // Clear the device address register
                            11411 ; 1003 |   // The address bits are past bit 25-31. Set the address
                            11412 ; 1004 |   read_usb_reg(HW_ARC_DEVADDR, &dwRegister);
                            11413 
P:03C8 77F400 FFFFFB  3 214611415         move    #-5,n7
P:03CA 56F400 000154  3 214911418         move    #340,a
P:03CC 044F16         4 215311417         lua     (r7)+n7,r6
P:03CD 22D000         2 215511419         move    r6,r0
P:03CE 0BF080 rrrrrr  6 216111420         jsr     Fread_usb_reg
                            11421 
                            11422 ; 1005 |
                            11423 ; 1006 |   dwRegister = dwRegister & 0x01ffffff;
                            11424 
                            11447 
                            11448 ; 1007 |
                            11449 ; 1008 |    write_usb_reg(HW_ARC_DEVADDR, dwRegister);
                            11450 
P:03D0 77F400 FFFFFB  3 216411426         move    #-5,n7
P:03D2 46F400 FFFFFF  3 216711434         move    #$FFFFFF,y0
P:03D4 47F400 000001  3 217011433         move    #>1,y1
P:03D6 205F00         2 217211427         move    (r7)+
P:03D7 5FEF00         4 217611429         move    y:(r7+n7),b
P:03D8 205700         2 217811430         move    (r7)-
P:03D9 21A400         2 218011435         move    b1,x0
P:03DA 59EF00         4 218411432         move    y:(r7+n7),b0
P:03DB 212D00         2 218611436         move    b0,b1
P:03DC 205F5E         2 218811437         and     y0,b	                (r7)+
P:03DD 21A900         2 219011438         move    b1,b0
P:03DE 208D00         2 219211439         move    x0,b1
P:03DF 20007E         2 219411440         and     y1,b
P:03E0 5D6F00         4 219811443         move    b1,y:(r7+n7)
P:03E1 205700         2 220011444         move    (r7)-
P:03E2 596F00         4 220411446         move    b0,y:(r7+n7)
P:03E3 205F00         2 220611452         move    (r7)+
P:03E4 57F400 000154  3 220911458         move    #340,b
P:03E6 5EEF00         4 221311454         move    y:(r7+n7),a
P:03E7 205700         2 221511455         move    (r7)-
P:03E8 58EF00         4 221911457         move    y:(r7+n7),a0
P:03E9 0BF080 rrrrrr  6 222511459         jsr     Fwrite_usb_reg
                            11460 
                            11461 ; 1009 |
                            11462 ; 1010 |
                            11463 ; 1011 |   //Enable the suspend interrupt.............................
                            11464 ; 1012 |   read_usb_reg(HW_ARC_USBINTR, &dwRegister);               //
                            11465 
P:03EB 77F400 FFFFFB  3 222811468         move    #-5,n7
P:03ED 56F400 000148  3 223111467         move    #328,a
P:03EF 044F10         4 223511470         lua     (r7)+n7,r0
P:03F0 0BF080 rrrrrr  6 224111471         jsr     Fread_usb_reg
                            11472 
                            11473 ; 1013 |   dwRegister = dwRegister                                  // Suspend is initially not enabled to avoid the
                            11474 ; 1014 |                    | (DWORD)HW_ARC_USBINTR_SLE_SETMASK;    // suspend at the beginning of the enumeration process
                            11475 
                            11498 
                            11499 ; 1015 |    write_usb_reg(HW_ARC_USBINTR, dwRegister);              //
                            11500 
P:03F2 77F400 FFFFFB  3 224411477         move    #-5,n7
P:03F4 250000         2 224611484         move    #0,x1
P:03F5 44F400 000100  3 224911485         move    #$100,x0
P:03F7 205F00         2 225111478         move    (r7)+
P:03F8 5FEF00         4 225511480         move    y:(r7+n7),b
P:03F9 205700         2 225711481         move    (r7)-
P:03FA 21A700         2 225911486         move    b1,y1
P:03FB 59EF00         4 226311483         move    y:(r7+n7),b0
P:03FC 212D00         2 226511487         move    b0,b1
P:03FD 205F4A         2 226711488         or      x0,b	                (r7)+
P:03FE 21A900         2 226911489         move    b1,b0
P:03FF 20ED00         2 227111490         move    y1,b1
P:0400 20006A         2 227311491         or      x1,b
P:0401 5D6F00         4 227711494         move    b1,y:(r7+n7)
P:0402 205700         2 227911495         move    (r7)-
P:0403 596F00         4 228311497         move    b0,y:(r7+n7)
P:0404 205F00         2 228511502         move    (r7)+
P:0405 57F400 000148  3 228811508         move    #328,b
P:0407 5EEF00         4 229211504         move    y:(r7+n7),a
P:0408 205700         2 229411505         move    (r7)-
P:0409 58EF00         4 229811507         move    y:(r7+n7),a0
P:040A 0BF080 rrrrrr  6 230411509         jsr     Fwrite_usb_reg
                            11510 
                            11511 ; 1016 |    s_wArcUsbIntRegShadow = (WORD) dwRegister;
                            11512 
                            11522 
                            11523 ; 1017 |   //.........................................................
                            11524 ; 1018 |   dwRegister = HW_ARC_USBSTS_SLI_SETMASK;
                            11525 
                            11535 
                            11536 ; 1019 |   write_usb_reg(HW_ARC_USBSTS, dwRegister);
                            11537 
P:040C 77F400 FFFFFB  3 230711514         move    #-5,n7
P:040E 205F1B         2 230911527         clr     b	                (r7)+
P:040F 51F400 000100  3 231211528         move    #$100,b0
P:0411 5EEF00         4 231611517         move    y:(r7+n7),a
P:0412 205700         2 231811518         move    (r7)-
P:0413 58EF00         4 232211520         move    y:(r7+n7),a0
P:0414 587013 rrrrrr  3 232511539         clr     a	                a0,y:Fs_wArcUsbIntRegShadow
P:0416 205F00         2 232711529         move    (r7)+
P:0417 212800         2 232911540         move    b0,a0
P:0418 5D6F00         4 233311531         move    b1,y:(r7+n7)
P:0419 205700         2 233511532         move    (r7)-
P:041A 596F00         4 233911534         move    b0,y:(r7+n7)
P:041B 57F400 000144  3 234211541         move    #324,b
P:041D 0BF080 rrrrrr  6 234811542         jsr     Fwrite_usb_reg
                            11543 
                            11544 ; 1020 |
                            11545 ; 1021 |    // Update the device state structure
                            11546 ; 1022 |    pStDeviceState->btAddress = (BYTE)0x00;
                            11547 
                            11558 
                            11559 ; 1023 |    
                            11560 ; 1024 |   
                            11561 ; 1025 |   /* Clear all the setup token semaphores */
                            11562 ; 1026 |    read_usb_reg(HW_ARC_ENDPTSETUPSTAT, &dwRegister);
                            11563 
P:041F 3E031B         2 235011553         clr     b	                #3,n6
P:0420 77F400 FFFFFD  3 235311550         move    #-3,n7
P:0422 56F400 0001AC  3 235611565         move    #428,a
P:0424 6EEF00         4 236011552         move    y:(r7+n7),r6
P:0425 77F400 FFFFFE  3 236311554         move    #-2,n7
P:0427 000000         2 236511554         nop             ; (inserted)
P:0428 7E6F00         4 236911556         move    n6,y:(r7+n7)
P:0429 77F400 FFFFFB  3 237211566         move    #-5,n7
P:042B 5D6E00         4 237611557         move    b1,y:(r6+n6)
P:042C 044F10         4 238011568         lua     (r7)+n7,r0
P:042D 0BF080 rrrrrr  6 238611569         jsr     Fread_usb_reg
                            11570 
                            11571 ; 1027 |
                            11572 ; 1028 |    write_usb_reg(HW_ARC_ENDPTSETUPSTAT, dwRegister);
                            11573 
P:042F 77F400 FFFFFB  3 238911575         move    #-5,n7
P:0431 57F400 0001AC  3 239211582         move    #428,b
P:0433 205F00         2 239411576         move    (r7)+
P:0434 5EEF00         4 239811578         move    y:(r7+n7),a
P:0435 205700         2 240011579         move    (r7)-
P:0436 58EF00         4 240411581         move    y:(r7+n7),a0
P:0437 0BF080 rrrrrr  6 241011583         jsr     Fwrite_usb_reg
                            11584 
                            11585 ; 1029 |
                            11586 ; 1030 |   /* Clear all the endpoint complete status bits */   
                            11587 ; 1031 |    read_usb_reg(HW_ARC_ENDPTCOMPLETE, &dwRegister);
                            11588 
P:0439 77F400 FFFFFB  3 241311590         move    #-5,n7
P:043B 56F400 0001BC  3 241611593         move    #444,a
P:043D 044F10         4 242011592         lua     (r7)+n7,r0
P:043E 0BF080 rrrrrr  6 242611594         jsr     Fread_usb_reg
                            11595 
                            11596 ; 1032 |
                            11597 ; 1033 |    write_usb_reg(HW_ARC_ENDPTCOMPLETE, dwRegister);
                            11598 
P:0440 77F400 FFFFFB  3 242911600         move    #-5,n7
P:0442 57F400 0001BC  3 243211607         move    #444,b
P:0444 205F00         2 243411601         move    (r7)+
P:0445 5EEF00         4 243811603         move    y:(r7+n7),a
P:0446 205700         2 244011604         move    (r7)-
P:0447 58EF00         4 244411606         move    y:(r7+n7),a0
P:0448 0BF080 rrrrrr  6 245011608         jsr     Fwrite_usb_reg
                            11609 
                            11610 ; 1034 |
                            11611 ; 1035 |   // Cancel all primed status by waiting untill all bits in the ENDPTPRIME are 0
                            11612 ; 1036 |   // then writing 0xffffffff to ENDPTFLUSH
                            11613 ; 1037 |    do
                            11614 ; 1038 |    {
                            11615 ; 1039 |        // Wait until all ENDPTPRIME bits cleared
                            11616 ; 1040 |        read_usb_reg(HW_ARC_ENDPTPRIME, &dwRegister);
                            11617 
P:044A 77F400 FFFFFB  3 245311619 L33:    move    #-5,n7
P:044C 56F400 0001B0  3 245611622         move    #432,a
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  44

M:ADDR CODE           CYCLES LINE SOURCELINE
P:044E 044F10         4 246011621         lua     (r7)+n7,r0
P:044F 0BF080 rrrrrr  6 246611623         jsr     Fread_usb_reg
                            11624 
                            11625 ; 1041 |    }while(dwRegister & (DWORD)0xffffffffffff);
                            11626 
P:0451 77F400 FFFFFB  3 246911628         move    #-5,n7
P:0453 205F00         2 247111629         move    (r7)+
P:0454 5FEF00         4 247511631         move    y:(r7+n7),b
P:0455 2B0000         2 247711635         move    #0,b2
P:0456 205700         2 247911632         move    (r7)-
P:0457 59EF00         4 248311634         move    y:(r7+n7),b0
P:0458 20000B         2 248511636         tst     b
P:0459 0AF0A2 rrrrrr  6 249111637         jne     L33
                            11638 
                            11639 ; 1042 |
                            11640 ; 1043 |
                            11641 ; 1044 |   /* Write 1s to the Flush register */
                            11642 ; 1045 |    write_usb_reg(HW_ARC_ENDPTFLUSH, (DWORD)0xffffffffffff);
                            11643 
P:045B 57F413 0001B4  3 249411645         clr     a	                #436,b
P:045D 00000A         2 249611646         dec     a
P:045E 0BF080 rrrrrr  6 250211648         jsr     Fwrite_usb_reg
                            11649 
                            11650 ; 1046 |   
                            11651 ; 1047 |    // Read the reset bit in the PORTSCx register and make sure that it is still active
                            11652 ; 1048 |    // A USB reset will occur for a minimum of 3ms and the device driver software
                            11653 ; 1049 |    // must reach this point in the reset cleanup before the end of the reset occurs
                            11654 ; 1050 |    // Otherwise a hardware reset of the device controller is recommended (rare)
                            11655 ; 1051 |    read_usb_reg(HW_ARC_PORTSC1, &dwRegister);
                            11656 
P:0460 77F400 FFFFFB  3 250511659         move    #-5,n7
P:0462 56F400 000184  3 250811658         move    #388,a
P:0464 044F10         4 251211661         lua     (r7)+n7,r0
P:0465 0BF080 rrrrrr  6 251811662         jsr     Fread_usb_reg
                            11663 
                            11664 ; 1052 |    
                            11665 ; 1053 |   if (dwRegister & (DWORD)HW_ARC_PORTSC1_PR_SETMASK) 
                            11666 
P:0467 77F400 FFFFFB  3 252111668         move    #-5,n7
P:0469 205F00         2 252311669         move    (r7)+
P:046A 5FEF00         4 252711671         move    y:(r7+n7),b
P:046B 205700         2 252911672         move    (r7)-
P:046C 59EF00         4 253311674         move    y:(r7+n7),b0
P:046D 0AC928 rrrrrr  6 253911675         jset    #8,b0,L34
                            11676 
                            11677 ; 1054 |   {
                            11678 ; 1055 |      pStDeviceState->btBusResetting = TRUE;
                            11679 ; 1056 |      pStDeviceState->usUsbState = USB_STATE_POWERED;
                            11680 ; 1057 |   } 
                            11681 ; 1058 |   else 
                            11682 ; 1059 |   { 
                            11683 ; 1060 |      /* re-initialize */      
                            11684 ; 1061 |      usb_dci_chip_enable();
                            11685 
P:046F 0BF080 rrrrrr  6 254511687         jsr     Fusb_dci_chip_enable
                            11688 
                            11689 ; 1062 |      return;
                            11690 
P:0471 0AF080 rrrrrr  6 255111692         jmp     L36
                            11694 L34:
                            11707 
                            11708 ; 1063 |   } /* Endif */
                            11709 ; 1064 |   
                            11710 ; 1065 |
                            11711 ; 1066 |    // Set all transfer structures to idle
                            11712 ; 1067 |    for(btEndpoint = 0 ; btEndpoint < MAX_NUM_EP ; btEndpoint++)
                            11713 
P:0473 3E0800         2 255311694         move    #8,n6
P:0474 3D0400         2 255511704         move    #4,n5
P:0475 77F400 FFFFFD  3 255811695         move    #-3,n7
P:0477 63F400 rrrrrr  3 256111719         move    #FdXD_Base_Address,r3
P:0479 6EEF00         4 256511697         move    y:(r7+n7),r6
P:047A 22D500         2 256711698         move    r6,r5
P:047B 290300         2 256911705         move    #3,b0
P:047C 56F400 000004  3 257211715         move    #>4,a
P:047E 46F400 000001  3 257511699         move    #>1,y0
P:0480 4E6E00         4 257911700         move    y0,y:(r6+n6)
P:0481 66F400 rrrrrr  3 258211720         move    #FdXD_Base_Address+1,r6
P:0483 596D1B         4 258611717         clr     b	                b0,y:(r5+n5)
P:0484 240003         2 258811721         tst     a	                #0,x0
P:0485 0AF0AA rrrrrr  6 259411722         jeq     L37
P:0487 06CC00 rrrrrr  6 260011723         do      a1,L37
                            11725 
                            11726 ; 1068 |    {    
                            11727 ; 1069 |        dXD_Base_Address[btEndpoint*2]->btStatus = USB_STATUS_TRANSFER_IDLE;
                            11728 
                            11744 
                            11745 ; 1070 |        dXD_Base_Address[(btEndpoint*2) + 1]->btStatus = USB_STATUS_TRANSFER_IDLE;
                            11746 
P:0489 77F400 FFFFFE  3 260311739         move    #-2,n7
P:048B 21AE00         2 260511730         move    b1,a
P:048C 7DEF00         4 260911741         move    y:(r7+n7),n5
P:048D 227233         2 261111731         lsl     a	                r3,r2
P:048E 23B800         2 261311742         move    n5,n0
P:048F 219A58         2 261511756         add     y0,b	                a1,n2
P:0490 000000         2 261711756         nop             ; (inserted)
P:0491 044A14         4 262111735         lua     (r2)+n2,r4
P:0492 22D200         2 262311748         move    r6,r2
P:0493 65E400         2 262511737         move    x:(r4),r5
P:0494 044A11         4 262911750         lua     (r2)+n2,r1
P:0495 446D00         4 263311743         move    x0,x:(r5+n5)
P:0496 60E100         2 263511752         move    x:(r1),r0
P:0497 000000         2 263711752         nop             ; (inserted)
P:0498 446800         4 264111754         move    x0,x:(r0+n0)
                        (41)11757 L37:
                            11759 
                            11760 ; 1071 |    }        
                            11761 ; 1072 |    
                            11762 ; 1073 |} /* EndBody */
                            11763 
                            11765 L36:
P:0499 77F400 FFFFFA  3 264411765         move    #-6,n7
P:049B 000000         2 264611765         nop             ; (inserted)
P:049C 05EF7C         4 265011767         movec   y:(r7+n7),ssh
P:049D 204F00         2 265211769         move    (r7)+n7
P:049E 00000C         4 265611771         rts
                            11774 
                            11775 ; 1074 |
                            11776 ; 1075 |
                            11777 ; 1076 |
                            11778 ; 1077 |////////////////////////////////////////////////////////////////////////////////
                            11779 ; 1078 |//
                            11780 ; 1079 |//>  Name:          usb_dci_process_tr_complete
                            11781 ; 1080 |//
                            11782 ; 1081 |//   Type:          Function
                            11783 ; 1082 |//
                            11784 ; 1083 |//   Description:   Services transaction complete interrupt
                            11785 ; 1084 |//
                            11786 ; 1085 |//   Inputs:        pStDeviceState = Pointer to the device state structure
                            11787 ; 1086 |//
                            11788 ; 1087 |//   Outputs:       none
                            11789 ; 1088 |//
                            11790 ; 1089 |//   Notes:         none
                            11791 ; 1090 |//<
                            11792 ; 1091 |////////////////////////////////////////////////////////////////////////////////
                            11793 ; 1092 |void _reentrant usb_dci_process_tr_complete(Dev_State_Struct _USB_MEM * pStDeviceState)
                            11794 ; 1093 |{ /* Body */
                            11795 
                            11800 Fusb_dci_process_tr_complete:
                            11818 
                            11819 ; 1094 |
                            11820 ; 1095 |   WORD         wRegSetup;
                            11821 ; 1096 |   DWORD        dwRegComplete;
                            11822 ; 1097 |   void (*ProcessFirst)(DWORD, WORD) = &ProcessEndptSetup;
                            11823 
                            11835 
                            11836 ; 1098 |   void (*ProcessLast)(DWORD, WORD) = &ProcessEndptComplete;
                            11837 
                            11844 
                            11845 ; 1099 |   
                            11846 ; 1100 |    // We use separate loops for SETUP packets and other packet types.
                            11847 ; 1101 |    // The setup packet is processed first. It must be done as soon as possible
                            11848 ; 1102 |    
                            11849 ; 1103 |    // Processing the setup transaction .......
                            11850 ; 1104 |    wRegSetup = read_usb_reg_16(HW_ARC_ENDPTSETUPSTAT);     // Reads the setup status register
                            11851 
P:049F 055F7C         2 265811801         movec   ssh,y:(r7)+
P:04A0 3F0500         2 266011804         move    #5,n7
P:04A1 64F400 rrrrrr  3 266311825         move    #FProcessEndptSetup,r4
P:04A3 61F400 rrrrrr  3 266611839         move    #FProcessEndptComplete,r1
P:04A5 56F400 0001AC  3 266911853         move    #428,a
P:04A7 204F00         2 267111806         move    (r7)+n7
P:04A8 77F400 FFFFFD  3 267411826         move    #-3,n7
P:04AA 000000         2 267611826         nop             ; (inserted)
P:04AB 6C6F00         4 268011828         move    r4,y:(r7+n7)
P:04AC 77F400 FFFFFE  3 268311840         move    #-2,n7
P:04AE 000000         2 268511840         nop             ; (inserted)
P:04AF 696F00         4 268911842         move    r1,y:(r7+n7)
P:04B0 0BF080 rrrrrr  6 269511854         jsr     Fread_usb_reg_16
                            11860 
                            11861 ; 1105 |    
                            11862 ; 1106 |    // Processing the non-setup transaction .......
                            11863 ; 1107 |    read_and_clear_usb_reg(HW_ARC_ENDPTCOMPLETE, &dwRegComplete);    // Reads the end point complete register
                            11864 
P:04B2 045FA0         2 269711856         movec   m0,n7
P:04B3 000000         2 269911856         nop             ; (inserted)
P:04B4 5C6F00         4 270311858         move    a1,y:(r7+n7)
P:04B5 77F400 FFFFFB  3 270611866         move    #-5,n7
P:04B7 56F400 0001BC  3 270911869         move    #444,a
P:04B9 044F10         4 271311868         lua     (r7)+n7,r0
P:04BA 0BF080 rrrrrr  6 271911870         jsr     Fread_and_clear_usb_reg
                            11871 
                            11872 ; 1108 |    
                            11873 ; 1109 |    // The order to process setup packets and non setup packets depends on
                            11874 ; 1110 |    // the previous transactions.
                            11875 ; 1111 |    // If a control endpoint has a setup packet and a non setup transfer complete
                            11876 ; 1112 |    // pending, then we should handle the non setup transfer first because it is
                            11877 ; 1113 |    // probably a result of the last setup transaction.
                            11878 ; 1114 |    if(((WORD)(dwRegComplete) & wRegSetup) || ((WORD)(dwRegComplete >> 24) & wRegSetup))
                            11879 
P:04BC 77F400 FFFFFB  3 272211881         move    #-5,n7
P:04BE 205F00         2 272411882         move    (r7)+
P:04BF 5FEF00         4 272811884         move    y:(r7+n7),b
P:04C0 205700         2 273011885         move    (r7)-
P:04C1 59EF00         4 273411887         move    y:(r7+n7),b0
P:04C2 045FA0         2 273611889         movec   m0,n7
P:04C3 212F01         2 273811888         tfr     b,a	                b0,b
P:04C4 4EEF00         4 274211891         move    y:(r7+n7),y0
P:04C5 2B005E         2 274411893         and     y0,b	                #0,b2
P:04C6 20000B         2 274611897         tst     b
P:04C7 0AF0A2 rrrrrr  6 275211898         jne     L38
P:04C9 200009         2 275411899         tfr     a,b
P:04CA 2B0000         2 275611900         move    #0,b2
P:04CB 21A900         2 275811901         move    b1,b0
P:04CC 216D00         2 276011902         move    b2,b1
P:04CD 212F00         2 276211903         move    b0,b
P:04CE 2B005E         2 276411904         and     y0,b	                #0,b2
P:04CF 20000B         2 276611906         tst     b
P:04D0 0AF0AA rrrrrr  6 277211907         jeq     L39
                            11908 
                            11909 ; 1115 |    {
                            11910 ; 1116 |        ProcessFirst = &ProcessEndptComplete;
                            11911 
                            11913 L38:
                            11917 
                            11918 ; 1117 |        ProcessLast = &ProcessEndptSetup;
                            11919 
                            11925 
                            11926 ; 1118 |    }
                            11927 ; 1119 |
                            11928 ; 1120 |    (*ProcessFirst)(dwRegComplete, wRegSetup);
                            11929 
P:04D2 77F400 FFFFFD  3 277511914         move    #-3,n7
P:04D4 73F400 rrrrrr  3 277811913         move    #FProcessEndptComplete,n3
P:04D6 70F400 rrrrrr  3 278111921         move    #FProcessEndptSetup,n0
P:04D8 7B6F00         4 278511916         move    n3,y:(r7+n7)
P:04D9 77F400 FFFFFE  3 278811922         move    #-2,n7
P:04DB 000000         2 279011922         nop             ; (inserted)
P:04DC 786F00         4 279411924         move    n0,y:(r7+n7)
                            11931 L39:
P:04DD 045FA0         2 279611931         movec   m0,n7
P:04DE 20CF00         2 279811934         move    y0,b
P:04DF 4E6F00         4 280211933         move    y0,y:(r7+n7)
P:04E0 77F400 FFFFFD  3 280511937         move    #-3,n7
P:04E2 000000         2 280711937         nop             ; (inserted)
P:04E3 6EEF00         4 281111939         move    y:(r7+n7),r6
P:04E4 000000         2 281311939         nop             ; (inserted)
P:04E5 0BE680         4 281711941         jsr     (r6)
                            11945 
                            11946 ; 1121 |    (*ProcessLast)(dwRegComplete, wRegSetup);
                            11947 
P:04E6 77F400 FFFFFB  3 282011949         move    #-5,n7
P:04E8 205F00         2 282211950         move    (r7)+
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  45

M:ADDR CODE           CYCLES LINE SOURCELINE
P:04E9 5EEF00         4 282611952         move    y:(r7+n7),a
P:04EA 205700         2 282811953         move    (r7)-
P:04EB 58EF00         4 283211955         move    y:(r7+n7),a0
P:04EC 045FA0         2 283411956         movec   m0,n7
P:04ED 000000         2 283611956         nop             ; (inserted)
P:04EE 5FEF00         4 284011958         move    y:(r7+n7),b
P:04EF 77F400 FFFFFE  3 284311959         move    #-2,n7
P:04F1 000000         2 284511959         nop             ; (inserted)
P:04F2 6EEF00         4 284911961         move    y:(r7+n7),r6
P:04F3 000000         2 285111961         nop             ; (inserted)
P:04F4 0BE680         4 285511963         jsr     (r6)
                            11970 
                            11971 ; 1122 |    
                            11972 ; 1123 |}    
                            11973 
P:04F5 77F400 FFFFFA  3 285811975         move    #-6,n7
P:04F7 000000         2 286011975         nop             ; (inserted)
P:04F8 05EF7C         4 286411977         movec   y:(r7+n7),ssh
P:04F9 204F00         2 286611979         move    (r7)+n7
P:04FA 00000C         4 287011981         rts
                            11983 
                            11984 ; 1124 |     
                            11985 ; 1125 |    
                            11986 ; 1126 |////////////////////////////////////////////////////////////////////////////////
                            11987 ; 1127 |//
                            11988 ; 1128 |//>  Name:          ProcessEndptSetup
                            11989 ; 1129 |//
                            11990 ; 1130 |//   Type:          Function
                            11991 ; 1131 |//
                            11992 ; 1132 |//   Description:   Services transaction complete for setup phase 
                            11993 ; 1133 |//
                            11994 ; 1134 |//   Inputs:        dwRegComplete = Endpoints with Transaction complete pending
                            11995 ; 1135 |//                  wRegSetup = Endpoints with Setup pendings
                            11996 ; 1136 |//
                            11997 ; 1137 |//   Outputs:       none
                            11998 ; 1138 |//
                            11999 ; 1139 |//   Notes:        dwRegComplete is not used
                            12000 ; 1140 |//<
                            12001 ; 1141 |////////////////////////////////////////////////////////////////////////////////
                            12002 ; 1142 |void _reentrant ProcessEndptSetup(DWORD dwRegComplete, WORD wRegSetup)
                            12003 ; 1143 |{
                            12004 
                            12009 FProcessEndptSetup:
                            12022 
                            12023 ; 1144 |    BYTE         btEndpointNumber;
                            12024 ; 1145 |
                            12025 ; 1146 |    // a setup packet pending will have its bit set to '1'
                            12026 ; 1147 |    if(wRegSetup)
                            12027 
P:04FB 055F7C         2 287212010         movec   ssh,y:(r7)+
P:04FC 77F400 FFFFFE  3 287512029         move    #-2,n7
P:04FE 2B0000         2 287712032         move    #0,b2
P:04FF 205F00         2 287912013         move    (r7)+
P:0500 205F0B         2 288112033         tst     b	                (r7)+
P:0501 5D6F00         4 288512031         move    b1,y:(r7+n7)
P:0502 0AF0AA rrrrrr  6 289112036         jeq     L42
                            12037 
                            12038 ; 1148 |    { // Setup packets to process
                            12039 ; 1149 |        // for each endpoint define
                            12040 ; 1150 |        for(btEndpointNumber = 0 ; btEndpointNumber < MAX_NUM_EP ; btEndpointNumber++)
                            12041 
                            12046 
                            12047 ; 1151 |        {
                            12048 ; 1152 |            // Do we have a setup packet pending
                            12049 ; 1153 |            // If we have a setup packet pending do not clear the endpoint setup status
                            12050 ; 1154 |            // bit in the register. We need to keep the setup lockout enable until we
                            12051 ; 1155 |            // read the setup bytes. Clearing the bit is done there.
                            12052 ; 1156 |            if(wRegSetup & ((WORD)(1 << btEndpointNumber)))
                            12053 
P:0504 3C0000         2 289312043         move    #0,n4
P:0505 46F400 000001  3 289612045         move    #>1,y0
                            12055 L40:
P:0507 045FA0         2 289812056         movec   m0,n7
P:0508 238F00         2 290012055         move    n4,b
P:0509 2B0000         2 290212060         move    #0,b2
P:050A 5D6F00         4 290612058         move    b1,y:(r7+n7)
P:050B 20CC0B         2 290812061         tst     b	                y0,a1
P:050C 0AF0AA rrrrrr  6 291412062         jeq     L43
P:050E 06CD20         4 291812063         rep     b1    
P:050F 200033         2 292012065         lsl     a
                            12067 L43:
P:0510 77F400 FFFFFE  3 292312073         move    #-2,n7
P:0512 218600         2 292512072         move    a1,y0
P:0513 5EEF00         4 292912075         move    y:(r7+n7),a
P:0514 2A0056         2 293112076         and     y0,a	                #0,a2
P:0515 200003         2 293312078         tst     a
P:0516 0AF0AA rrrrrr  6 293912079         jeq     L41
                            12080 
                            12081 ; 1157 |                usb_device_call_service(btEndpointNumber, TRUE, 0, 0, NUMBER_BYTES_IN_SETUP,0);  // calls the service routine
                            12082 
P:0518 300000         2 294112084         move    #0,r0
P:0519 045FA0         2 294312086         movec   m0,n7
P:051A 240000         2 294512085         move    #0,x0
P:051B 250000         2 294712091         move    #0,x1
P:051C 57F400 000001  3 295012092         move    #>1,b
P:051E 46F400 000008  3 295312093         move    #>8,y0
P:0520 5EEF00         4 295712088         move    y:(r7+n7),a
P:0521 0BF080 rrrrrr  6 296312094         jsr     Fusb_device_call_service
                            12097 L41:
P:0523 045FA0         2 296512099         movec   m0,n7
P:0524 46F400 000001  3 296812102         move    #>1,y0
P:0526 5EEF00         4 297212101         move    y:(r7+n7),a
P:0527 200050         2 297412103         add     y0,a
P:0528 219C00         2 297612107         move    a1,n4
P:0529 56F400 000004  3 297912110         move    #>4,a
P:052B 238F00         2 298112109         move    n4,b
P:052C 20000D         2 298312111         cmp     a,b
P:052D 0AF0A9 rrrrrr  6 298912112         jlt     L40
                            12113 
                            12114 ; 1158 |        }    
                            12115 ; 1159 |    }
                            12116 
                            12118 L42:
                            12119 
                            12120 ; 1160 |}
                            12121 
P:052F 205700         2 299112123         move    (r7)-
P:0530 205700         2 299312124         move    (r7)-
P:0531 05FF7C         4 299712126         movec   y:-(r7),ssh
P:0532 000000         2 299912126         nop             ; (inserted)
P:0533 00000C         4 300312130         rts
                            12134 
                            12135 ; 1161 |    
                            12136 ; 1162 |   
                            12137 ; 1163 |WORD    wRegCompleteTx; 
                            12138 ; 1164 |WORD    wRegCompleteRx; 
                            12139 ; 1165 |WORD    wMask;
                            12140 ; 1166 |WORD    wRegComplete; 
                            12141 ; 1167 |
                            12142 ; 1168 |
                            12143 ; 1169 |
                            12144 ; 1170 |////////////////////////////////////////////////////////////////////////////////
                            12145 ; 1171 |//
                            12146 ; 1172 |//>  Name:          ProcessEndptComplete
                            12147 ; 1173 |//
                            12148 ; 1174 |//   Type:          Function
                            12149 ; 1175 |//
                            12150 ; 1176 |//   Description:   Services transaction complete for complete transaction others
                            12151 ; 1177 |//                  than setup packet
                            12152 ; 1178 |//
                            12153 ; 1179 |//   Inputs:        dwRegComplete = Endpoints with Transaction complete pending
                            12154 ; 1180 |//                  wRegSetup = Endpoints with Setup pendings
                            12155 ; 1181 |//
                            12156 ; 1182 |//   Outputs:       none
                            12157 ; 1183 |//
                            12158 ; 1184 |//   Notes:        dwRegSetup is not used
                            12159 ; 1185 |//<
                            12160 ; 1186 |////////////////////////////////////////////////////////////////////////////////
                            12161 ; 1187 |void _reentrant ProcessEndptComplete(DWORD dwRegComplete, WORD wRegSetup)
                            12162 ; 1188 |{   
                            12163 
                            12168 FProcessEndptComplete:
                            12194 
                            12195 ; 1189 |    BYTE         btEndpointNumber;
                            12196 ; 1190 |    BYTE         btEndpoint, btDirection;
                            12197 ; 1191 |    dTD_Struct _X * pStdTD;
                            12198 ; 1192 |    xd_struct  _USB_MEM * pStXd;
                            12199 ; 1193 |    USHORT       usActualBytesTransfer;
                            12200 ; 1194 |    
                            12201 ; 1195 |    wRegCompleteTx = (dwRegComplete >> 24);
                            12202 
                            12210 
                            12211 ; 1196 |    wRegCompleteRx = dwRegComplete & 0x00ffff;
                            12212 
                            12224 
                            12225 ; 1197 |    wMask = 1;
                            12226 
                            12230 
                            12231 ; 1198 |    wRegComplete = wRegCompleteRx;
                            12232 
                            12235 
                            12236 ; 1199 |    
                            12237 ; 1200 |
                            12238 ; 1201 |    if (dwRegComplete)
                            12239 
P:0534 055F7C         2 300512169         movec   ssh,y:(r7)+
P:0535 3F0500         2 300712172         move    #5,n7
P:0536 46F409 00FFFF  3 301012204         tfr     a,b	                #$FFFF,y0
P:0538 204F00         2 301212174         move    (r7)+n7
P:0539 2B0000         2 301412205         move    #0,b2
P:053A 21A900         2 301612206         move    b1,b0
P:053B 216D00         2 301812207         move    b2,b1
P:053C 597000 rrrrrr  3 302112209         move    b0,y:FwRegCompleteTx
P:053E 270009         2 302312214         tfr     a,b	                #0,y1
P:053F 21A400         2 302512217         move    b1,x0
P:0540 212D00         2 302712218         move    b0,b1
P:0541 2A005E         2 302912219         and     y0,b	                #0,a2
P:0542 21A900         2 303112220         move    b1,b0
P:0543 208D00         2 303312221         move    x0,b1
P:0544 59707E rrrrrr  3 303612222         and     y1,b	                b0,y:FwRegCompleteRx
P:0546 2D0103         2 303812242         tst     a	                #1,b1
P:0547 5D7000 rrrrrr  3 304112229         move    b1,y:FwMask
P:0549 597000 rrrrrr  3 304412234         move    b0,y:FwRegComplete
P:054B 0AF0AA rrrrrr  6 305012243         jeq     L61
                            12244 
                            12245 ; 1202 |    { // non setup packets to process
                            12246 ; 1203 |        // For each endpoint define
                            12247 ; 1204 |        for (btEndpointNumber = 0 ; btEndpointNumber < 32 ; )
                            12248 
                            12257 
                            12258 ; 1205 |        {
                            12259 ; 1206 |            if(!wRegCompleteTx && !wRegCompleteRx)
                            12260 
P:054D 77F400 FFFFFB  3 305312252         move    #-5,n7
P:054F 260000         2 305512250         move    #0,y0
P:0550 4E6F00         4 305912254         move    y0,y:(r7+n7)
P:0551 5FF000 rrrrrr  3 306212262 L44:    move    y:FwRegCompleteTx,b
P:0553 2B0000         2 306412263         move    #0,b2
P:0554 20000B         2 306612264         tst     b
P:0555 0AF0A2 rrrrrr  6 307212265         jne     L45
P:0557 5FF000 rrrrrr  3 307512266         move    y:FwRegCompleteRx,b
P:0559 2B0000         2 307712267         move    #0,b2
P:055A 20000B         2 307912268         tst     b
P:055B 0AF0AA rrrrrr  6 308512269         jeq     L61
                            12270 
                            12271 ; 1207 |                break;
                            12272 ; 1208 |
                            12273 ; 1209 |            if (wRegComplete & wMask)
                            12274 
                            12276 L45:
P:055D 5CF000 rrrrrr  3 308812276         move    y:FwRegComplete,a1
P:055F 4EF000 rrrrrr  3 309112278         move    y:FwMask,y0
P:0561 218F00         2 309312279         move    a1,b
P:0562 2B005E         2 309512280         and     y0,b	                #0,b2
P:0563 20000B         2 309712282         tst     b
P:0564 0AF0AA rrrrrr  6 310312283         jeq     L57
                            12284 
                            12285 ; 1210 |            {   // We have something , found which direction and endpoint
                            12286 ; 1211 |                
                            12287 ; 1212 |                wRegComplete &= ~wMask;
                            12288 
                            12295 
                            12296 ; 1213 |
                            12297 ; 1214 |                if (btEndpointNumber > 15) 
                            12298 
P:0566 20CD00         2 310512290         move    y0,b1
P:0567 77F41F FFFFFB  3 310812291         not     b	                #-5,n7
P:0569 21A600         2 311012292         move    b1,y0
P:056A 46F456 00000F  3 311312293         and     y0,a	                #>15,y0
P:056C 5C7000 rrrrrr  3 311612294         move    a1,y:FwRegComplete
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  46

M:ADDR CODE           CYCLES LINE SOURCELINE
P:056E 6AEF00         4 312012302         move    y:(r7+n7),r2
P:056F 224E00         2 312212303         move    r2,a
P:0570 200055         2 312412307         cmp     y0,a
P:0571 0AF0AF rrrrrr  6 313012308         jle     L46
                            12309 
                            12310 ; 1215 |                {
                            12311 ; 1216 |                    btEndpoint = btEndpointNumber - 16;
                            12312 
                            12319 
                            12320 ; 1217 |                    btDirection = USB_IN;
                            12321 
                            12325 
                            12326 ; 1218 |                }
                            12327 
P:0573 44F400 000010  3 313312315         move    #>16,x0
P:0575 224F00         2 313512314         move    r2,b
P:0576 3B014C         2 313712316         sub     x0,b	                #1,n3
P:0577 21B100         2 313912317         move    b1,r1
P:0578 0AF080 rrrrrr  6 314512329         jmp     L47
                            12330 
                            12331 ; 1219 |                else
                            12332 ; 1220 |                {
                            12333 ; 1221 |                    btEndpoint = btEndpointNumber;
                            12334 
                            12336 L46:
                            12337 
                            12338 ; 1222 |                    btDirection = USB_OUT;
                            12339 
                            12342 
                            12343 ; 1223 |                } /* Endif */
                            12344 
P:057A 3B0000         2 314712341         move    #0,n3
P:057B 225100         2 314912336         move    r2,r1
                            12346 L47:
                            12351 
                            12352 ; 1224 |                
                            12353 ; 1225 |
                            12354 ; 1226 |
                            12355 ; 1227 |                // Extract the specified dTD
                            12356 ; 1228 |                FdTDUnpack((USHORT)btEndpoint, btDirection);
                            12357 
P:057C 77F400 FFFFFB  3 315212346         move    #-5,n7
P:057E 222E00         2 315412362         move    r1,a
P:057F 236F00         2 315612370         move    n3,b
P:0580 6A6F00         4 316012348         move    r2,y:(r7+n7)
P:0581 77F400 FFFFFC  3 316312359         move    #-4,n7
P:0583 000000         2 316512359         nop             ; (inserted)
P:0584 696F00         4 316912361         move    r1,y:(r7+n7)
P:0585 77F400 FFFFFD  3 317212367         move    #-3,n7
P:0587 000000         2 317412367         nop             ; (inserted)
P:0588 7B6F00         4 317812369         move    n3,y:(r7+n7)
P:0589 0BF080 rrrrrr  6 318412375         jsr     FdTDUnpack
                            12390 
                            12391 ; 1229 |                pStdTD = dTD_Base_Scratch_Address[(2*btEndpoint) + btDirection];
                            12392 
                            12402 
                            12403 ; 1230 |                pStXd = g_dXD_Queues[btEndpoint][btDirection];
                            12404 
                            12412 
                            12413 ; 1231 |
                            12414 ; 1232 |
                            12415 ; 1233 |                // Check if the dTD is still active
                            12416 ; 1234 |                if(pStdTD->usStatusIoc & (USHORT)USB_EP_dTD_ACTIVE)
                            12417 
P:058B 77F400 FFFFFD  3 318712380         move    #-3,n7
P:058D 64F400 rrrrrr  3 319012398         move    #FdTD_Base_Scratch_Address,r4
P:058F 229100         2 319212399         move    r4,r1
P:0590 45F400 0000E8  3 319512424         move    #>232,x1
P:0592 4CEF00         4 319912382         move    y:(r7+n7),x0
P:0593 77F400 FFFFFC  3 320212385         move    #-4,n7
P:0595 000000         2 320412385         nop             ; (inserted)
P:0596 5EEF00         4 320812387         move    y:(r7+n7),a
P:0597 218F00         2 321012394         move    a1,b
P:0598 3D003A         2 321212395         asl     b	                #0,n5
P:0599 47F448 000001  3 321512396         add     x0,b	                #>1,y1
P:059B 21BC00         2 321712397         move    b1,n4
P:059C 000000         2 321912397         nop             ; (inserted)
P:059D 63EC00         4 322312400         move    x:(r4+n4),r3
P:059E 64F400 rrrrrr  3 322612406         move    #Fg_dXD_Queues,r4
P:05A0 045B12         4 323012420         lua     (r3)+,r2
P:05A1 044C15         4 323412408         lua     (r4)+n4,r5
P:05A2 3C0400         2 323612425         move    #4,n4
P:05A3 6EE500         2 323812410         move    y:(r5),r6
P:05A4 205B00         2 324012421         move    (r3)+
P:05A5 57D300         2 324212422         move    x:(r3)-,b
P:05A6 0BCD67         4 324612423         btst    #7,b1
P:05A7 0AF0A0 rrrrrr  6 325212427         jcc     L49
                            12428 
                            12429 ; 1235 |                {
                            12430 ; 1236 |                    if (pStXd)
                            12431 
P:05A9 22CF00         2 325412433         move    r6,b
P:05AA 20000B         2 325612434         tst     b
P:05AB 0AF0AA rrrrrr  6 326212435         jeq     L48
                            12436 
                            12437 ; 1237 |                    {
                            12438 ; 1238 |                        pStXd->btStatus = USB_STATUS_TRANSFER_IN_PROGRESS;
                            12439 
                            12444 
                            12445 ; 1239 |                    }
                            12446 ; 1240 |
                            12447 ; 1241 |                    usActualBytesTransfer = 0;
                            12448 
P:05AD 3E0300         2 326412441         move    #3,n6
P:05AE 290300         2 326612442         move    #3,b0
P:05AF 596E00         4 327012443         move    b0,y:(r6+n6)
                            12450 L48:
                            12452 
                            12453 ; 1242 |                }
                            12454 
P:05B0 23A600         2 327212450         move    n5,y0
P:05B1 0AF080 rrrrrr  6 327812456         jmp     L54
                            12457 
                            12458 ; 1243 |                else
                            12459 ; 1244 |                {
                            12460 ; 1245 |                    if(pStdTD->usStatusIoc & (USHORT)USB_EP_dTD_NO_ERROR)
                            12461 
P:05B3 20006E         2 328012463 L49:    and     x1,b
P:05B4 0AF0AA rrrrrr  6 328612464         jeq     L50
                            12465 
                            12466 ; 1246 |                    {   // Error detected
                            12467 ; 1247 |                        // For IN BULK no errors should ever be encountered
                            12468 ; 1248 |                        // For OUT BULK the only error encountered is when:
                            12469 ; 1249 |                        // A long packet was received (number of bytes greater
                            12470 ; 1250 |                        // than maximum packet size) or (total bytes received
                            12471 ; 1251 |                        // greater than total bytes specified).
                            12472 ; 1252 |                        // The ARC core discards the remaining packet and set
                            12473 ; 1253 |                        // the error bit in the dTD. In addition, the endpoint
                            12474 ; 1254 |                        // will be flushed and the USBERR interrupt will
                            12475 ; 1255 |                        // become active. 
                            12476 ; 1256 |                        if (pStXd)
                            12477 
P:05B6 22CF00         2 328812479         move    r6,b
P:05B7 20000B         2 329012480         tst     b
P:05B8 0AF0AA rrrrrr  6 329612481         jeq     L53
                            12482 
                            12483 ; 1257 |                        {
                            12484 ; 1258 |                            pStXd->btStatus = USB_STATUS_TRANSFER_ERROR;
                            12485 
                            12490 
                            12491 ; 1259 |                        }
                            12492 ; 1260 |                    }
                            12493 
P:05BA 3E0300         2 329812487         move    #3,n6
P:05BB 000000         2 330012487         nop             ; (inserted)
P:05BC 7C6E00         4 330412489         move    n4,y:(r6+n6)
P:05BD 0AF080 rrrrrr  6 331012495         jmp     L53
                            12496 
                            12497 ; 1261 |                    else
                            12498 ; 1262 |                    {   // Transfer successful
                            12499 ; 1263 |                        if (pStXd)
                            12500 
P:05BF 22CF00         2 331212502 L50:    move    r6,b
P:05C0 20000B         2 331412503         tst     b
P:05C1 0AF0AA rrrrrr  6 332012504         jeq     L53
                            12505 
                            12506 ; 1264 |                        {
                            12507 ; 1265 |                            pStXd->btStatus = USB_STATUS_TRANSFER_SUCCESS;
                            12508 
                            12513 
                            12514 ; 1266 |                        }
                            12515 ; 1267 |                    }                    
                            12516 ; 1268 |                   
                            12517 ; 1269 |                    // Calculate the actual number of bytes transfered
                            12518 ; 1270 |                    usActualBytesTransfer = pStXd->usTotalLength - pStdTD->usTotalBytes;
                            12519 
P:05C3 3E0300         2 332212510         move    #3,n6
P:05C4 000000         2 332412510         nop             ; (inserted)
P:05C5 4F6E00         4 332812512         move    y1,y:(r6+n6)
                            12521 L53:
                            12531 
                            12532 ; 1271 |
                            12533 ; 1272 |                    // Retire the dTD
                            12534 ; 1273 |                    pStdTD->pbtNextdTDPointer = 0x00;        // Set the next dTD pointer to 0
                            12535 
                            12539 
                            12540 ; 1274 |                    pStdTD->usStatusIoc = (USHORT)0x00;      // Clear status and Interrupt on Completion bit
                            12541 
                            12544 
                            12545 ; 1275 |
                            12546 ; 1276 |                }
                            12547 
P:05C6 3B0200         2 333012524         move    #2,n3
P:05C7 3E0600         2 333212521         move    #6,n6
P:05C8 46EB00         4 333612526         move    x:(r3+n3),y0
P:05C9 5FEE00         4 334012523         move    y:(r6+n6),b
P:05CA 20005C         2 334212528         sub     y0,b
P:05CB 21A61B         2 334412537         clr     b	                b1,y0
P:05CC 556300         2 334612538         move    b1,x:(r3)
P:05CD 756200         2 334812543         move    n5,x:(r2)
                            12549 L54:
                            12552 
                            12553 ; 1277 |
                            12554 ; 1278 |                // Call the function registered to service the specified endpoint
                            12555 ; 1279 |                usb_device_call_service(btEndpoint, FALSE, btDirection, (WORD _X *)pStXd->pbtStartAddressWord, usActualBytesTransfer, pStXd->wPrivateData);  
                            12556 
P:05CE 3E041B         2 335012568         clr     b	                #4,n6
P:05CF 77F400 FFFFFE  3 335312549         move    #-2,n7
P:05D1 000000         2 335512549         nop             ; (inserted)
P:05D2 6D6F00         4 335912551         move    r5,y:(r7+n7)
P:05D3 045FA0         2 336112562         movec   m0,n7
P:05D4 68EE00         4 336512560         move    y:(r6+n6),r0
P:05D5 3E0B00         2 336712561         move    #11,n6
P:05D6 6E6F00         4 337112564         move    r6,y:(r7+n7)
P:05D7 4DEE00         4 337512565         move    y:(r6+n6),x1
P:05D8 0BF080 rrrrrr  6 338112569         jsr     Fusb_device_call_service
                            12582 
                            12583 ; 1280 |
                            12584 ; 1281 |                //move the next DXD up.
                            12585 ; 1282 |                if (pStXd)
                            12586 
P:05DA 77F400 FFFFFE  3 338412574         move    #-2,n7
P:05DC 000000         2 338612574         nop             ; (inserted)
P:05DD 6DEF00         4 339012576         move    y:(r7+n7),r5
P:05DE 045FA0         2 339212577         movec   m0,n7
P:05DF 000000         2 339412577         nop             ; (inserted)
P:05E0 5FEF00         4 339812579         move    y:(r7+n7),b
P:05E1 21F00B         2 340012589         tst     b	                b,r0
P:05E2 0AF0AA rrrrrr  6 340612590         jeq     L55
                            12591 
                            12592 ; 1283 |                {
                            12593 ; 1284 |                    g_dXD_Queues[btEndpoint][btDirection] = pStXd->pNext;
                            12594 
                            12601 
                            12602 ; 1285 |
                            12603 ; 1286 |                    /* MPAYNE: 5/31/05
                            12604 ; 1287 |                    * The FreeXd call was outside of this IF statement and that
                            12605 ; 1288 |                    * was causing defect 7098.  The problem was that for some
                            12606 ; 1289 |                    * reason pStXd was getting set to NULL in some Plays For
                            12607 ; 1290 |                    * Sure content transfer tests.
                            12608 ; 1291 |                    */
                            12609 ; 1292 |                    //free current Xd
                            12610 ; 1293 |                    FreeXd(pStXd);
                            12611 
P:05E4 3E0A00         2 340812596         move    #10,n6
P:05E5 221600         2 341012597         move    r0,r6
P:05E6 000000         2 341212597         nop             ; (inserted)
P:05E7 6EEE00         4 341612599         move    y:(r6+n6),r6
P:05E8 6E6500         2 341812600         move    r6,y:(r5)
P:05E9 0BF080 rrrrrr  6 342412613         jsr     FFreeXd
                            12618 
                            12619 ; 1294 |                }
                            12620 ; 1295 |
                            12621 ; 1296 |
                            12622 ; 1297 |                // start new transfer if needed
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  47

M:ADDR CODE           CYCLES LINE SOURCELINE
                            12623 ; 1298 |                if(g_dXD_Queues[btEndpoint][btDirection] != NULL)
                            12624 
P:05EB 77F400 FFFFFE  3 342712615         move    #-2,n7
P:05ED 000000         2 342912615         nop             ; (inserted)
P:05EE 6DEF00         4 343312617         move    y:(r7+n7),r5
                            12626 L55:
                            12630 
                            12631 ; 1299 |                    usb_dci_transfer_data(g_dXD_Queues[btEndpoint][btDirection]);
                            12632 
P:05EF 000000         2 343512633         nop             ; (inserted)
P:05F0 5FE500         2 343712627         move    y:(r5),b
P:05F1 21F00B         2 343912629         tst     b	                b,r0
P:05F2 0BF0A2 rrrrrr  6 344512634         jsne    Fusb_dci_transfer_data
                            12635 
                            12636 ; 1300 |            }
                            12637 ; 1301 |
                            12638 ; 1302 |            if(btEndpointNumber < MAX_NUM_EP)
                            12639 
                            12641 L57:
P:05F4 77F400 FFFFFB  3 344812641         move    #-5,n7
P:05F6 46F400 000004  3 345112647         move    #>4,y0
P:05F8 5EEF00         4 345512643         move    y:(r7+n7),a
P:05F9 218F00         2 345712644         move    a1,b
P:05FA 20005D         2 345912648         cmp     y0,b
P:05FB 0AF0A1 rrrrrr  6 346512649         jge     L58
                            12650 
                            12651 ; 1303 |            {
                            12652 ; 1304 |                btEndpointNumber += 16;
                            12653 
                            12660 
                            12661 ; 1305 |                wRegCompleteRx = wRegComplete;
                            12662 
                            12666 
                            12667 ; 1306 |                wRegComplete = wRegCompleteTx;
                            12668 
                            12672 
                            12673 ; 1307 |            }
                            12674 
P:05FD 46F400 000010  3 346812655         move    #>16,y0
P:05FF 4EF050 rrrrrr  3 347112656         add     y0,a	                y:FwRegComplete,y0
P:0601 218F00         2 347312658         move    a1,b
P:0602 4E7000 rrrrrr  3 347612665         move    y0,y:FwRegCompleteRx
P:0604 4FF000 rrrrrr  3 347912670         move    y:FwRegCompleteTx,y1
P:0606 4F7000 rrrrrr  3 348212671         move    y1,y:FwRegComplete
P:0608 0AF080 rrrrrr  6 348812676         jmp     L59
                            12677 
                            12678 ; 1308 |            else
                            12679 ; 1309 |            {
                            12680 ; 1310 |                btEndpointNumber -= 15;
                            12681 
                            12683 L58:
                            12691 
                            12692 ; 1311 |                wRegCompleteTx = wRegComplete;
                            12693 
                            12697 
                            12698 ; 1312 |                wRegComplete = wRegCompleteRx;
                            12699 
                            12703 
                            12704 ; 1313 |                wMask *= 2;
                            12705 
                            12710 
                            12711 ; 1314 |            }
                            12712 
P:060A 57F400 00000F  3 349112686         move    #>15,b
P:060C 200014         2 349312687         sub     b,a
P:060D 218F00         2 349512689         move    a1,b
P:060E 58F000 rrrrrr  3 349812695         move    y:FwRegComplete,a0
P:0610 587000 rrrrrr  3 350112696         move    a0,y:FwRegCompleteTx
P:0612 4EF000 rrrrrr  3 350412701         move    y:FwRegCompleteRx,y0
P:0614 4E7000 rrrrrr  3 350712702         move    y0,y:FwRegComplete
P:0616 5EF000 rrrrrr  3 351012707         move    y:FwMask,a
P:0618 200033         2 351212708         lsl     a
P:0619 5C7000 rrrrrr  3 351512709         move    a1,y:FwMask
                            12714 L59:
P:061B 47F400 000020  3 351812721         move    #>$20,y1
P:061D 77F47D FFFFFB  3 352112722         cmp     y1,b	                #-5,n7
P:061F 000000         2 352312722         nop             ; (inserted)
P:0620 5D6F00         4 352712718         move    b1,y:(r7+n7)
P:0621 0AF0A9 rrrrrr  6 353312723         jlt     L44
                            12724 
                            12725 ; 1315 |
                            12726 ; 1316 |        } /* Endfor */
                            12727 ; 1317 |    } /* Endif */
                            12728 
                            12730 L61:
                            12731 
                            12732 ; 1318 |
                            12733 ; 1319 |} /* EndBody */
                            12734 
P:0623 77F400 FFFFFA  3 353612736         move    #-6,n7
P:0625 000000         2 353812736         nop             ; (inserted)
P:0626 05EF7C         4 354212738         movec   y:(r7+n7),ssh
P:0627 204F00         2 354412740         move    (r7)+n7
P:0628 00000C         4 354812742         rts
                            12745 
                            12746 ; 1320 |
                            12747 ; 1321 |
                            12748 ; 1322 |
                            12749 ; 1323 |
                            12750 ; 1324 |
                            12751 ; 1325 |
                            12752 ; 1326 |
                            12753 ; 1327 |////////////////////////////////////////////////////////////////////////////////
                            12754 ; 1328 |//
                            12755 ; 1329 |//>  Name:          usb_dci_init_endpoint
                            12756 ; 1330 |//
                            12757 ; 1331 |//   Type:          Function
                            12758 ; 1332 |//
                            12759 ; 1333 |//   Description:   Initializes the specified endpoint and the endpoint queue
                            12760 ; 1334 |//                  head
                            12761 ; 1335 |//
                            12762 ; 1336 |//   Inputs:        pStXD = Pointer to a XD structure
                            12763 ; 1337 |//
                            12764 ; 1338 |//   Outputs:       USB_OK or error code
                            12765 ; 1339 |//
                            12766 ; 1340 |//   Notes:         none
                            12767 ; 1341 |//<
                            12768 ; 1342 |////////////////////////////////////////////////////////////////////////////////
                            12769 ; 1343 |BYTE _reentrant usb_dci_init_endpoint(xd_struct _USB_MEM * pStXD)
                            12770 ; 1344 |{ /* Body */
                            12771 
                            12776 Fusb_dci_init_endpoint:
                            12790 
                            12791 ; 1345 |    DWORD   dwRegEndpointPrime;   
                            12792 ; 1346 |    DWORD   dwRegEndpointStatus;
                            12793 ; 1347 |    WORD wOldIVL;
                            12794 
                            12801 
                            12802 ; 1348 |   
                            12803 ; 1349 |    // Check if the Endpoint is Primed.
                            12804 ; 1350 |    // If the enpoint is primed, then return an error because the endpoint is 
                            12805 ; 1351 |    // in used already
                            12806 ; 1352 |    read_usb_reg(HW_ARC_ENDPTPRIME, &dwRegEndpointPrime);
                            12807 
P:0629 055F7C         2 355012777         movec   ssh,y:(r7)+
P:062A 3F0800         2 355212780         move    #8,n7
P:062B 56F400 0001B0  3 355512812         move    #432,a
P:062D 204F00         2 355712782         move    (r7)+n7
P:062E 77F400 FFFFFC  3 356012796         move    #-4,n7
P:0630 000000         2 356212796         nop             ; (inserted)
P:0631 686F00         4 356612798         move    r0,y:(r7+n7)
P:0632 77F400 FFFFFA  3 356912809         move    #-6,n7
P:0634 000000         2 357112809         nop             ; (inserted)
P:0635 044F10         4 357512811         lua     (r7)+n7,r0
P:0636 0BF080 rrrrrr  6 358112813         jsr     Fread_usb_reg
                            12814 
                            12815 ; 1353 |    read_usb_reg(HW_ARC_ENDPTSTATUS, &dwRegEndpointStatus);
                            12816 
P:0638 77F400 FFFFF8  3 358412818         move    #-8,n7
P:063A 56F400 0001B8  3 358712822         move    #440,a
P:063C 044F14         4 359112820         lua     (r7)+n7,r4
P:063D 229000         2 359312821         move    r4,r0
P:063E 0BF080 rrrrrr  6 359912823         jsr     Fread_usb_reg
                            12824 
                            12825 ; 1354 |    
                            12826 ; 1355 |    if(    (!(dwRegEndpointPrime  & (1 << ((16 * pStXD->btDirection) + pStXD->btEndpointNum))))     // Not requested for primed
                            12827 ; 1356 |        && (!(dwRegEndpointStatus & (1 << ((16 * pStXD->btDirection) + pStXD->btEndpointNum))))  )  // Endpoint buffer not ready
                            12828 
P:0640 77F400 FFFFFA  3 360212830         move    #-6,n7
P:0642 2D0100         2 360412846         move    #1,b1
P:0643 205F00         2 360612831         move    (r7)+
P:0644 4DEF00         4 361012833         move    y:(r7+n7),x1
P:0645 205700         2 361212834         move    (r7)-
P:0646 4CEF00         4 361612836         move    y:(r7+n7),x0
P:0647 77F400 FFFFFC  3 361912837         move    #-4,n7
P:0649 000000         2 362112837         nop             ; (inserted)
P:064A 6EEF00         4 362512839         move    y:(r7+n7),r6
P:064B 77F400 FFFFFD  3 362812847         move    #-3,n7
P:064D 58DE00         2 363012841         move    y:(r6)+,a0
P:064E 6E6F00         4 363412849         move    r6,y:(r7+n7)
P:064F 4EE600         2 363612850         move    y:(r6),y0
P:0650 0114E2         2 363812851         mac     y0,#20,a
P:0651 210E00         2 364012852         move    a0,a
P:0652 200003         2 364212853         tst     a
P:0653 0AF0AF rrrrrr  6 364812854         jle     L71
P:0655 06CC20         4 365212855         rep     a1    
P:0656 20003B         2 365412857         lsl     b
                            12859 L71:
P:0657 21A669         2 365612863         tfr     x1,b	                b1,y0
P:0658 208900         2 365812864         move    x0,b0
P:0659 21A400         2 366012865         move    b1,x0
P:065A 212D00         2 366212866         move    b0,b1
P:065B 27005E         2 366412867         and     y0,b	                #0,y1
P:065C 21A900         2 366612868         move    b1,b0
P:065D 208D00         2 366812869         move    x0,b1
P:065E 2B007E         2 367012870         and     y1,b	                #0,b2
P:065F 20000B         2 367212872         tst     b
P:0660 0AF0A2 rrrrrr  6 367812873         jne     L67
P:0662 77F400 FFFFF8  3 368112874         move    #-8,n7
P:0664 205F00         2 368312875         move    (r7)+
P:0665 5FEF00         4 368712877         move    y:(r7+n7),b
P:0666 205700         2 368912878         move    (r7)-
P:0667 21A400         2 369112881         move    b1,x0
P:0668 59EF00         4 369512880         move    y:(r7+n7),b0
P:0669 212D00         2 369712882         move    b0,b1
P:066A 2B005E         2 369912883         and     y0,b	                #0,b2
P:066B 21A900         2 370112884         move    b1,b0
P:066C 208D00         2 370312885         move    x0,b1
P:066D 20007E         2 370512886         and     y1,b
P:066E 20000B         2 370712888         tst     b
P:066F 0AF0A2 rrrrrr  6 371312889         jne     L67
                            12890 
                            12891 ; 1357 |    { 
                            12892 ; 1358 |        wOldIVL = SysMaskAllInterrupts();
                            12893 
P:0671 0BF080 rrrrrr  6 371912895         jsr     FSysMaskAllInterrupts
                            12897 
                            12898 ; 1359 |        
                            12899 ; 1360 |        // Fill the dQH cap scratch structure
                            12900 ; 1361 |
                            12901 ; 1362 |        // First check for type of endpoint
                            12902 ; 1363 |        if(pStXD->btEndpointType == USB_ISOCHRONOUS_ENDPOINT)
                            12903 
P:0673 3D0200         2 372112905         move    #2,n5
P:0674 77F400 FFFFFC  3 372412906         move    #-4,n7
P:0676 46F400 000001  3 372712916         move    #>1,y0
P:0678 6DEF00         4 373112908         move    y:(r7+n7),r5
P:0679 000000         2 373312908         nop             ; (inserted)
P:067A 044D16         4 373712910         lua     (r5)+n5,r6
P:067B 000000         2 373912910         nop             ; (inserted)
P:067C 7DE600         2 374112914         move    y:(r6),n5
P:067D 23AF00         2 374312915         move    n5,b
P:067E 20005D         2 374512917         cmp     y0,b
P:067F 0AF0A2 rrrrrr  6 375112918         jne     L62
                            12919 
                            12920 ; 1364 |        {
                            12921 ; 1365 |            // Isochronous endpoint type
                            12922 ; 1366 |            /* Mult bit should be set for isochronous endpoints */
                            12923 ; 1367 |            dQH_Scratch_Cap.usMaxPktLengthZltMult = (USHORT)(1 << USB_EP_QUEUE_HEAD_MULT_POS |
                            12924 ; 1368 |                                                              pStXD->usMaxPacketSize);
                            12925 
                            12932 
                            12933 ; 1369 |        }
                            12934 
P:0681 3D0700         2 375312927         move    #7,n5
P:0682 000000         2 375512927         nop             ; (inserted)
P:0683 7DED00         4 375912929         move    y:(r5+n5),n5
P:0684 0ADD6E         4 376312930         bset    #14,n5
P:0685 757000 rrrrrr  3 376612931         move    n5,x:FdQH_Scratch_Cap+1
P:0687 0AF080 rrrrrr  6 377212936         jmp     L65
                            12937 
                            12938 ; 1370 |        else
                            12939 ; 1371 |        {
                            12940 ; 1372 |            if (pStXD->btEndpointType != USB_CONTROL_ENDPOINT)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  48

M:ADDR CODE           CYCLES LINE SOURCELINE
                            12941 
P:0689 23AF00         2 377412943 L62:    move    n5,b
P:068A 2B0000         2 377612944         move    #0,b2
P:068B 20000B         2 377812945         tst     b
P:068C 0AF0AA rrrrrr  6 378412946         jeq     L63
                            12947 
                            12948 ; 1373 |            {
                            12949 ; 1374 |                // Bulk or interrupt endpoint type            
                            12950 ; 1375 |                dQH_Scratch_Cap.usMaxPktLengthZltMult = (USHORT) (pStXD->btDontZeroTerminate << USB_EP_QUEUE_HEAD_DONT_ZERO_TERMINATE_POS
                            12951 ; 1376 |                                                                    | pStXD->usMaxPacketSize);
                            12952 
                            12964 
                            12965 ; 1377 |            }                                                                    
                            12966 
P:068E 3D0800         2 378612954         move    #8,n5
P:068F 000000         2 378812954         nop             ; (inserted)
P:0690 4FED00         4 379212956         move    y:(r5+n5),y1
P:0691 3D0700         2 379412958         move    #7,n5
P:0692 010BC8         2 379612957         mpy     y1,#11,b
P:0693 212F00         2 379812961         move    b0,b
P:0694 4FED00         4 380212960         move    y:(r5+n5),y1
P:0695 20007A         2 380412962         or      y1,b
P:0696 557000 rrrrrr  3 380712963         move    b1,x:FdQH_Scratch_Cap+1
P:0698 0AF080 rrrrrr  6 381312968         jmp     L65
                            12969 
                            12970 ; 1378 |            else
                            12971 ; 1379 |            {            
                            12972 ; 1380 |                // Control endpoint type
                            12973 ; 1381 |                dQH_Scratch_Cap.usMaxPktLengthZltMult = (USHORT) (pStXD->btDontZeroTerminate << USB_EP_QUEUE_HEAD_DONT_ZERO_TERMINATE_POS
                            12974 ; 1382 |                                                                    | pStXD->usMaxPacketSize);
                            12975 
                            12977 L63:
                            12987 
                            12988 ; 1383 |                dQH_Scratch_Cap.usIos = (USHORT)USB_EP_QUEUE_HEAD_IOS;
                            12989 
                            12993 
                            12994 ; 1384 |            }                
                            12995 ; 1385 |         }
                            12996 
P:069A 3D0800         2 381512977         move    #8,n5
P:069B 60F400 008000  3 381812991         move    #$8000,r0
P:069D 4FED00         4 382212979         move    y:(r5+n5),y1
P:069E 3D0700         2 382412981         move    #7,n5
P:069F 010BC8         2 382612980         mpy     y1,#11,b
P:06A0 212F00         2 382812984         move    b0,b
P:06A1 4FED00         4 383212983         move    y:(r5+n5),y1
P:06A2 20007A         2 383412985         or      y1,b
P:06A3 557000 rrrrrr  3 383712986         move    b1,x:FdQH_Scratch_Cap+1
P:06A5 607000 rrrrrr  3 384012992         move    r0,x:FdQH_Scratch_Cap
                            12998 L65:
                            13006 
                            13007 ; 1386 |         
                            13008 ; 1387 |         // Write the scratch structure to the dQH field
                            13009 ; 1388 |         FdQHPackCap(pStXD->btEndpointNum, pStXD->btDirection, (BYTE)0x01);
                            13010 
P:06A7 77F400 FFFFFE  3 384312998         move    #-2,n7
P:06A9 44F400 000001  3 384613023         move    #>1,x0
P:06AB 5C6F00         4 385013000         move    a1,y:(r7+n7)
P:06AC 045FA0         2 385213003         movec   m0,n7
P:06AD 000000         2 385413003         nop             ; (inserted)
P:06AE 6E6F00         4 385813005         move    r6,y:(r7+n7)
P:06AF 77F400 FFFFFC  3 386113012         move    #-4,n7
P:06B1 000000         2 386313012         nop             ; (inserted)
P:06B2 6D6F00         4 386713014         move    r5,y:(r7+n7)
P:06B3 77F400 FFFFFD  3 387013018         move    #-3,n7
P:06B5 5EE500         2 387213015         move    y:(r5),a
P:06B6 6EEF00         4 387613020         move    y:(r7+n7),r6
P:06B7 000000         2 387813020         nop             ; (inserted)
P:06B8 5FE600         2 388013022         move    y:(r6),b
P:06B9 0BF080 rrrrrr  6 388613024         jsr     FdQHPackCap
                            13025 
                            13026 ; 1389 |         
                            13027 ; 1390 |         SysUnMaskAllInterrupts(wOldIVL);
                            13028 
P:06BB 77F400 FFFFFE  3 388913030         move    #-2,n7
P:06BD 000000         2 389113030         nop             ; (inserted)
P:06BE 5EEF00         4 389513032         move    y:(r7+n7),a
P:06BF 0BF080 rrrrrr  6 390113033         jsr     FSysUnMaskAllInterrupts
                            13037 
                            13038 ; 1391 |      
                            13039 ; 1392 |        /* Enable the endpoint for Rx and Tx and set the endpoint type */
                            13040 ; 1393 |        read_usb_reg(HW_ARC_ENDPTCTRL(pStXD->btEndpointNum), &dwRegEndpointStatus);
                            13041 
P:06C1 77F400 FFFFFC  3 390413043         move    #-4,n7
P:06C3 50F400 0001C0  3 390713048         move    #$1C0,a0
P:06C5 6EEF00         4 391113045         move    y:(r7+n7),r6
P:06C6 77F400 FFFFF8  3 391413051         move    #-8,n7
P:06C8 4EE600         2 391613047         move    y:(r6),y0
P:06C9 044F10         4 392013053         lua     (r7)+n7,r0
P:06CA 0116E2         2 392213049         mac     y0,#22,a
P:06CB 210E00         2 392413050         move    a0,a
P:06CC 0BF080 rrrrrr  6 393013054         jsr     Fread_usb_reg
                            13055 
                            13056 ; 1394 |      
                            13057 ; 1395 |        if(pStXD->btDirection == USB_IN)
                            13058 
P:06CE 77F400 FFFFFD  3 393313060         move    #-3,n7
P:06D0 46F400 000001  3 393613065         move    #>1,y0
P:06D2 6EEF00         4 394013062         move    y:(r7+n7),r6
P:06D3 000000         2 394213062         nop             ; (inserted)
P:06D4 5FE600         2 394413064         move    y:(r6),b
P:06D5 20005D         2 394613066         cmp     y0,b
P:06D6 0AF0A2 rrrrrr  6 395213067         jne     L68
                            13068 
                            13069 ; 1396 |        {
                            13070 ; 1397 |            dwRegEndpointStatus = dwRegEndpointStatus 
                            13071 ; 1398 |                                    | (DWORD)HW_ARC_ENDPTCTRL_TXE_SETMASK    //(DWORD)(1 << HW_ARC_ENDPTCTRL_TXE_BITPOS)     // (DWORD)HW_ARC_ENDPTCTRL_TXE_SETMASK
                            13072 ; 1399 |                                    | (DWORD)HW_ARC_ENDPTCTRL_TXR_SETMASK
                            13073 ; 1400 |                                    | (DWORD)((DWORD)pStXD->btEndpointType << HW_ARC_ENDPTCTRL_TXT_BITPOS) ;       
                            13074 
P:06D8 77F400 FFFFF8  3 395513076         move    #-8,n7
P:06DA 2D0000         2 395713088         move    #0,b1
P:06DB 205F00         2 395913077         move    (r7)+
P:06DC 5EEF00         4 396313079         move    y:(r7+n7),a
P:06DD 205700         2 396513080         move    (r7)-
P:06DE 58EF00         4 396913082         move    y:(r7+n7),a0
P:06DF 045FA0         2 397113083         movec   m0,n7
P:06E0 000000         2 397313083         nop             ; (inserted)
P:06E1 6EEF00         4 397713085         move    y:(r7+n7),r6
P:06E2 000000         2 397913085         nop             ; (inserted)
P:06E3 59E600         2 398113087         move    y:(r6),b0
P:06E4 0612A0         4 398513089         rep     #18    
P:06E5 20003A         2 398713091         asl     b
                            13093 L72:
                            13118 
                            13119 ; 1401 |        }
                            13120 
P:06E6 218400         2 398913097         move    a1,x0
P:06E7 212600         2 399113095         move    b0,y0
P:06E8 210C00         2 399313098         move    a0,a1
P:06E9 21A752         2 399513099         or      y0,a	                b1,y1
P:06EA 218800         2 399713100         move    a1,a0
P:06EB 208C00         2 399913101         move    x0,a1
P:06EC 26C072         2 400113102         or      y1,a	                #<$C0,y0
P:06ED 270000         2 400313103         move    #0,y1
P:06EE 218500         2 400513105         move    a1,x1
P:06EF 210C00         2 400713106         move    a0,a1
P:06F0 205F52         2 400913107         or      y0,a	                (r7)+
P:06F1 218800         2 401113108         move    a1,a0
P:06F2 20AC00         2 401313109         move    x1,a1
P:06F3 77F472 FFFFF8  3 401613110         or      y1,a	                #-8,n7
P:06F5 000000         2 401813110         nop             ; (inserted)
P:06F6 5C6F00         4 402213114         move    a1,y:(r7+n7)
P:06F7 205700         2 402413115         move    (r7)-
P:06F8 586F00         4 402813117         move    a0,y:(r7+n7)
P:06F9 0AF080 rrrrrr  6 403413122         jmp     L69
                            13123 
                            13124 ; 1402 |        else
                            13125 ; 1403 |        {
                            13126 ; 1404 |            dwRegEndpointStatus = dwRegEndpointStatus 
                            13127 ; 1405 |                                | (DWORD)HW_ARC_ENDPTCTRL_RXE_SETMASK
                            13128 ; 1406 |                                | (DWORD)HW_ARC_ENDPTCTRL_RXR_SETMASK
                            13129 ; 1407 |                                | ((DWORD)pStXD->btEndpointType << HW_ARC_ENDPTCTRL_RXT_BITPOS) ;       
                            13130 ; 1408 |      
                            13131 ; 1409 |        }
                            13132 ; 1410 |        
                            13133 ; 1411 |        write_usb_reg((HW_ARC_ENDPTCTRL(pStXD->btEndpointNum)), dwRegEndpointStatus);
                            13134 ; 1412 |   }
                            13135 ; 1413 |   else
                            13136 ; 1414 |   { 
                            13137 ; 1415 |      return USBERR_EP_INIT_FAILED;
                            13138 
P:06FB 56F400 000005  3 403713140 L67:    move    #>5,a
P:06FD 0AF080 rrrrrr  6 404313141         jmp     L70
                            13143 L68:
P:06FF 77F400 FFFFF8  3 404613143         move    #-8,n7
P:0701 2C0000         2 404813155         move    #0,a1
P:0702 205F00         2 405013144         move    (r7)+
P:0703 5FEF00         4 405413146         move    y:(r7+n7),b
P:0704 205700         2 405613147         move    (r7)-
P:0705 21A400         2 405813160         move    b1,x0
P:0706 59EF00         4 406213149         move    y:(r7+n7),b0
P:0707 045FA0         2 406413150         movec   m0,n7
P:0708 212D00         2 406613161         move    b0,b1
P:0709 6EEF00         4 407013152         move    y:(r7+n7),r6
P:070A 000000         2 407213152         nop             ; (inserted)
P:070B 58E600         2 407413154         move    y:(r6),a0
P:070C 205F32         2 407613156         asl     a	                (r7)+
P:070D 77F432 FFFFF8  3 407913157         asl     a	                #-8,n7
P:070F 210600         2 408113158         move    a0,y0
P:0710 21875A         2 408313162         or      y0,b	                a1,y1
P:0711 21A900         2 408513163         move    b1,b0
P:0712 208D00         2 408713164         move    x0,b1
P:0713 46F47A 0000C0  3 409013165         or      y1,b	                #>$C0,y0
P:0715 21A400         2 409213168         move    b1,x0
P:0716 212D00         2 409413169         move    b0,b1
P:0717 27005A         2 409613170         or      y0,b	                #0,y1
P:0718 21A900         2 409813171         move    b1,b0
P:0719 208D00         2 410013172         move    x0,b1
P:071A 20007A         2 410213173         or      y1,b
P:071B 5D6F00         4 410613177         move    b1,y:(r7+n7)
P:071C 205700         2 410813178         move    (r7)-
P:071D 596F00         4 411213180         move    b0,y:(r7+n7)
                            13182 L69:
P:071E 77F400 FFFFFC  3 411513182         move    #-4,n7
P:0720 51F400 0001C0  3 411813189         move    #$1C0,b0
P:0722 6EEF00         4 412213184         move    y:(r7+n7),r6
P:0723 77F400 FFFFF8  3 412513192         move    #-8,n7
P:0725 205F00         2 412713193         move    (r7)+
P:0726 4EE600         2 412913186         move    y:(r6),y0
P:0727 5EEF00         4 413313195         move    y:(r7+n7),a
P:0728 0116EA         2 413513190         mac     y0,#22,b
P:0729 205700         2 413713196         move    (r7)-
P:072A 212F00         2 413913191         move    b0,b
P:072B 58EF00         4 414313198         move    y:(r7+n7),a0
P:072C 0BF080 rrrrrr  6 414913199         jsr     Fwrite_usb_reg
                            13201 
                            13202 ; 1416 |   } /* Endif */
                            13203 ; 1417 |      
                            13204 ; 1418 |   return USB_OK;
                            13205 
                            13208 
                            13209 ; 1419 |   
                            13210 ; 1420 |} /* EndBody */
                            13211 
P:072E 2E0000         2 415113207         move    #0,a
                            13213 L70:
P:072F 77F400 FFFFF7  3 415413213         move    #-9,n7
P:0731 000000         2 415613213         nop             ; (inserted)
P:0732 05EF7C         4 416013215         movec   y:(r7+n7),ssh
P:0733 204F00         2 416213217         move    (r7)+n7
P:0734 00000C         4 416613219         rts
                            13221 
                            13222 ; 1421 |
                            13223 ; 1422 |
                            13224 ; 1423 |////////////////////////////////////////////////////////////////////////////////
                            13225 ; 1424 |//
                            13226 ; 1425 |//>  Name:          usb_dci_get_setup_data
                            13227 ; 1426 |//
                            13228 ; 1427 |//   Type:          Function
                            13229 ; 1428 |//
                            13230 ; 1429 |//   Description:   Reads the setup data from the dQH
                            13231 ; 1430 |//
                            13232 ; 1431 |//   Inputs:        
                            13233 ; 1432 |//                  btEndpoint  : Endpoint number
                            13234 ; 1433 |//
                            13235 ; 1434 |//   Outputs:       
                            13236 ; 1435 |//                  a pointer to the setup structure
                            13237 ; 1436 |//
                            13238 ; 1437 |//   Notes:         
                            13239 ; 1438 |//<
                            13240 ; 1439 |////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  49

M:ADDR CODE           CYCLES LINE SOURCELINE
                            13241 ; 1440 |USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint)
                            13242 ; 1441 |{ /* Body */
                            13243 
                            13250 Fusb_dci_get_setup_data:
                            13261 
                            13262 ; 1442 |    USB_SetupData * pSetupData =  &g_SetupData[btEndpoint];
                            13263 
                            13275 
                            13276 ; 1443 |
                            13277 ; 1444 |   
                            13278 ; 1445 |    if(!pSetupData->bValid)        
                            13279 
P:0735 055F7C         2 416813251         movec   ssh,y:(r7)+
P:0736 045FA0         2 417013281         movec   m0,n7
P:0737 218400         2 417213265         move    a1,x0
P:0738 45F400 000006  3 417513266         move    #>6,x1
P:073A 205FA8         2 417713267         mpy     x0,x1,b	                (r7)+
P:073B 65F42A rrrrrr  3 418013268         asr     b	                #Fg_SetupData,r5
P:073D 213D00         2 418213269         move    b0,n5
P:073E 205F00         2 418413255         move    (r7)+
P:073F 204D00         2 418613272         move    (r5)+n5
P:0740 22B600         2 418813273         move    r5,r6
P:0741 6E6F00         4 419213283         move    r6,y:(r7+n7)
P:0742 5FE600         2 419413284         move    y:(r6),b
P:0743 2B0000         2 419613287         move    #0,b2
P:0744 20000B         2 419813288         tst     b
P:0745 0AF0A2 rrrrrr  6 420413289         jne     L73
                            13290 
                            13291 ; 1446 |    {
                            13292 ; 1447 |        // Copies the 8 setup bytes into the dQH_Scratch_Setup_Buf 
                            13293 ; 1448 |        FdQHUnpackSetup((USHORT)btEndpoint, USB_OUT);
                            13294 
P:0747 77F41B FFFFFE  3 420713303         clr     b	                #-2,n7
P:0749 000000         2 420913303         nop             ; (inserted)
P:074A 5C6F00         4 421313298         move    a1,y:(r7+n7)
P:074B 0BF080 rrrrrr  6 421913304         jsr     FdQHUnpackSetup
                            13307 
                            13308 ; 1449 |        pSetupData->RequestType.I 
                            13309 ; 1450 |            =  dQH_Scratch_Setup_Buf.btRequestType;
                            13310 
                            13321 
                            13322 ; 1451 |        pSetupData->btRequest = dQH_Scratch_Setup_Buf.btRequest;
                            13323 
                            13330 
                            13331 ; 1452 |        pSetupData->wValue = dQH_Scratch_Setup_Buf.btValueLsb + (dQH_Scratch_Setup_Buf.btValueMsb<<8);
                            13332 
                            13342 
                            13343 ; 1453 |        pSetupData->wIndex = dQH_Scratch_Setup_Buf.btIndexLsb + (dQH_Scratch_Setup_Buf.btIndexMsb<<8);
                            13344 
                            13354 
                            13355 ; 1454 |        pSetupData->wLength = dQH_Scratch_Setup_Buf.btLengthLsb + (dQH_Scratch_Setup_Buf.btLengthMsb<<8);
                            13356 
                            13368 
                            13369 ; 1455 |        
                            13370 ; 1456 |        // Clear the bit in the endpoint setup status register
                            13371 ; 1457 |        // to disable the setup lockout mechanism
                            13372 ; 1458 |        write_usb_reg(HW_ARC_ENDPTSETUPSTAT, (DWORD)(1 << btEndpoint));
                            13373 
P:074D 3E0200         2 422113326         move    #2,n6
P:074E 3D0500         2 422313363         move    #5,n5
P:074F 73F000 rrrrrr  3 422613312         move    x:FdQH_Scratch_Setup_Buf,n3
P:0751 045FA0         2 422813313         movec   m0,n7
P:0752 46F000 rrrrrr  3 423113335         move    x:FdQH_Scratch_Setup_Buf+3,y0
P:0754 6DEF00         4 423513315         move    y:(r7+n7),r5
P:0755 44F000 rrrrrr  3 423813325         move    x:FdQH_Scratch_Setup_Buf+1,x0
P:0757 47F000 rrrrrr  3 424113334         move    x:FdQH_Scratch_Setup_Buf+2,y1
P:0759 45F000 rrrrrr  3 424413358         move    x:FdQH_Scratch_Setup_Buf+6,x1
P:075B 0110E0         2 424613336         mpy     y0,#16,a
P:075C 205D00         2 424813317         move    (r5)+
P:075D 210E00         2 425013337         move    a0,a
P:075E 46F000 rrrrrr  3 425313346         move    x:FdQH_Scratch_Setup_Buf+4,y0
P:0760 7B5500         2 425513318         move    n3,y:(r5)-
P:0761 22B600         2 425713327         move    r5,r6
P:0762 000000         2 425913327         nop             ; (inserted)
P:0763 4C6E00         4 426313329         move    x0,y:(r6+n6)
P:0764 3E0370         2 426513338         add     y1,a	                #3,n6
P:0765 44F000 rrrrrr  3 426813347         move    x:FdQH_Scratch_Setup_Buf+5,x0
P:0767 5C6E00         4 427213341         move    a1,y:(r6+n6)
P:0768 47F000 rrrrrr  3 427513359         move    x:FdQH_Scratch_Setup_Buf+7,y1
P:076A 0110D0         2 427713348         mpy     x0,#16,a
P:076B 210E00         2 427913349         move    a0,a
P:076C 3E0450         2 428113350         add     y0,a	                #4,n6
P:076D 000000         2 428313350         nop             ; (inserted)
P:076E 5C6E00         4 428713353         move    a1,y:(r6+n6)
P:076F 0110C0         2 428913360         mpy     y1,#16,a
P:0770 210E00         2 429113361         move    a0,a
P:0771 6D6F60         4 429513362         add     x1,a	                r5,y:(r7+n7)
P:0772 77F400 FFFFFE  3 429813375         move    #-2,n7
P:0774 5C6D00         4 430213365         move    a1,y:(r5+n5)
P:0775 5EEF00         4 430613377         move    y:(r7+n7),a
P:0776 2A0000         2 430813378         move    #0,a2
P:0777 2D0103         2 431013379         tst     a	                #1,b1
P:0778 0AF0AA rrrrrr  6 431613380         jeq     L74
P:077A 06CC20         4 432013381         rep     a1    
P:077B 20003B         2 432213383         lsl     b
                            13385 L74:
P:077C 2E0000         2 432413389         move    #0,a
P:077D 21A800         2 432613390         move    b1,a0
P:077E 57F400 0001AC  3 432913392         move    #428,b
P:0780 0BF080 rrrrrr  6 433513393         jsr     Fwrite_usb_reg
                            13394 
                            13395 ; 1459 |
                            13396 ; 1460 |        pSetupData->bValid = TRUE;
                            13397 
                            13404 
                            13405 ; 1461 |    
                            13406 ; 1462 |    }
                            13407 ; 1463 |
                            13408 ; 1464 |    return(pSetupData);   
                            13409 
P:0782 045FA0         2 433713399         movec   m0,n7
P:0783 290100         2 433913402         move    #1,b0
P:0784 6EEF00         4 434313401         move    y:(r7+n7),r6
P:0785 000000         2 434513401         nop             ; (inserted)
P:0786 596600         2 434713403         move    b0,y:(r6)
                            13411 L73:
                            13416 
                            13417 ; 1465 |} /* EndBody */
                            13418 
P:0787 045FA0         2 434913411         movec   m0,n7
P:0788 000000         2 435113411         nop             ; (inserted)
P:0789 68EF00         4 435513413         move    y:(r7+n7),r0
P:078A 205700         2 435713420         move    (r7)-
P:078B 205700         2 435913421         move    (r7)-
P:078C 05FF7C         4 436313423         movec   y:-(r7),ssh
P:078D 000000         2 436513423         nop             ; (inserted)
P:078E 00000C         4 436913427         rts
                            13430 
                            13431 ; 1466 |
                            13432 ; 1467 |
                            13433 ; 1468 |
                            13434 ; 1469 |////////////////////////////////////////////////////////////////////////////////
                            13435 ; 1470 |//
                            13436 ; 1471 |//>  Name:          usb_dci_get_endpoint_status
                            13437 ; 1472 |//
                            13438 ; 1473 |//   Type:          Function
                            13439 ; 1474 |//
                            13440 ; 1475 |//   Description:   Gets the endpoint stall status
                            13441 ; 1476 |//
                            13442 ; 1477 |//   Inputs:        
                            13443 ; 1478 |//                  btEndpoint  : Endpoint number
                            13444 ; 1479 |//
                            13445 ; 1480 |//   Outputs:       
                            13446 ; 1481 |//                  TRUE if endpoint stall
                            13447 ; 1482 |//                  FALSE otherwise
                            13448 ; 1483 |//
                            13449 ; 1484 |//   Notes:         
                            13450 ; 1485 |//<
                            13451 ; 1486 |////////////////////////////////////////////////////////////////////////////////
                            13452 ; 1487 |BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint)
                            13453 ; 1488 |{ /* Body */
                            13454 
                            13459 Fusb_dci_get_endpoint_status:
                            13469 
                            13470 ; 1489 |    DWORD dwRegister;
                            13471 ; 1490 |    
                            13472 ; 1491 |    read_usb_reg(HW_ARC_ENDPTCTRL(btEndpoint), &dwRegister);
                            13473 
P:078F 055F7C         2 437113460         movec   ssh,y:(r7)+
P:0790 77F400 FFFFFE  3 437413481         move    #-2,n7
P:0792 218700         2 437613475         move    a1,y1
P:0793 51F400 0001C0  3 437913476         move    #$1C0,b0
P:0795 205F00         2 438113463         move    (r7)+
P:0796 0116CA         2 438313477         mac     y1,#22,b
P:0797 205F00         2 438513464         move    (r7)+
P:0798 044F10         4 438913483         lua     (r7)+n7,r0
P:0799 212E00         2 439113480         move    b0,a
P:079A 0BF080 rrrrrr  6 439713484         jsr     Fread_usb_reg
                            13486 
                            13487 ; 1492 |    return((dwRegister & (DWORD)((DWORD)HW_ARC_ENDPTCTRL_TXS_SETMASK | (DWORD)HW_ARC_ENDPTCTRL_RXS_SETMASK)) ? TRUE : FALSE);
                            13488 
P:079C 77F400 FFFFFE  3 440013490         move    #-2,n7
P:079E 46F400 010001  3 440313498         move    #$10001,y0
P:07A0 205F00         2 440513491         move    (r7)+
P:07A1 5EEF00         4 440913493         move    y:(r7+n7),a
P:07A2 205700         2 441113494         move    (r7)-
P:07A3 218400         2 441313499         move    a1,x0
P:07A4 58EF00         4 441713496         move    y:(r7+n7),a0
P:07A5 210C00         2 441913500         move    a0,a1
P:07A6 270056         2 442113501         and     y0,a	                #0,y1
P:07A7 218800         2 442313502         move    a1,a0
P:07A8 208C00         2 442513503         move    x0,a1
P:07A9 2A0076         2 442713504         and     y1,a	                #0,a2
P:07AA 56F403 000001  3 443013506         tst     a	                #>1,a
P:07AC 0AF0A2 rrrrrr  6 443613508         jne     L76
P:07AE 2E0000         2 443813509         move    #0,a
                            13510 L76:
                            13511 
                            13512 ; 1493 |    
                            13513 ; 1494 |} /* EndBody */
                            13514 
P:07AF 205700         2 444013516         move    (r7)-
P:07B0 205700         2 444213517         move    (r7)-
P:07B1 05FF7C         4 444613519         movec   y:-(r7),ssh
P:07B2 000000         2 444813519         nop             ; (inserted)
P:07B3 00000C         4 445213523         rts
                            13525 
                            13526 ; 1495 |
                            13527 ; 1496 |
                            13528 ; 1497 |
                            13529 ; 1498 |////////////////////////////////////////////////////////////////////////////////
                            13530 ; 1499 |//
                            13531 ; 1500 |//>  Name:          usb_dci_set_endpoint_status
                            13532 ; 1501 |//
                            13533 ; 1502 |//   Type:          Function
                            13534 ; 1503 |//
                            13535 ; 1504 |//   Description:   STALLS the endpoint
                            13536 ; 1505 |//
                            13537 ; 1506 |//   Inputs:        
                            13538 ; 1507 |//                  btEndpoint  : Endpoint number
                            13539 ; 1508 |//                  usStatus    : New status (TRUE or FALSE)
                            13540 ; 1509 |//
                            13541 ; 1510 |//   Outputs:  none
                            13542 ; 1511 |//                  
                            13543 ; 1512 |//   Notes:         
                            13544 ; 1513 |//<
                            13545 ; 1514 |////////////////////////////////////////////////////////////////////////////////
                            13546 ; 1515 |void _reentrant usb_dci_set_endpoint_status(BYTE btEndpoint, USHORT usStatus)
                            13547 ; 1516 |{ /* Body */
                            13548 
                            13553 Fusb_dci_set_endpoint_status:
                            13564 
                            13565 ; 1517 |
                            13566 ; 1518 |    if (usStatus == TRUE)
                            13567 
P:07B4 055F7C         2 445413554         movec   ssh,y:(r7)+
P:07B5 47F400 000001  3 445713569         move    #>1,y1
P:07B7 205F7D         2 445913570         cmp     y1,b	                (r7)+
P:07B8 0AF0A2 rrrrrr  6 446513571         jne     L77
                            13572 
                            13573 ; 1519 |    {
                            13574 ; 1520 |        usb_dci_stall_endpoint(btEndpoint, USB_OUT);
                            13575 
P:07BA 045FA0         2 446713577         movec   m0,n7
P:07BB 2F0000         2 446913584         move    #0,b
P:07BC 5C6F00         4 447313579         move    a1,y:(r7+n7)
P:07BD 0BF080 rrrrrr  6 447913585         jsr     Fusb_dci_stall_endpoint
                            13588 
                            13589 ; 1521 |        usb_dci_stall_endpoint(btEndpoint, USB_IN);
                            13590 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  50

M:ADDR CODE           CYCLES LINE SOURCELINE
P:07BF 045FA0         2 448113592         movec   m0,n7
P:07C0 57F400 000001  3 448413595         move    #>1,b
P:07C2 5EEF00         4 448813594         move    y:(r7+n7),a
P:07C3 0BF080 rrrrrr  6 449413596         jsr     Fusb_dci_stall_endpoint
                            13600 
                            13601 ; 1522 |    }    
                            13602 
P:07C5 0AF080 rrrrrr  6 450013604         jmp     L78
                            13605 
                            13606 ; 1523 |    else
                            13607 ; 1524 |    {
                            13608 ; 1525 |        usb_dci_unstall_endpoint(btEndpoint, USB_OUT);
                            13609 
                            13611 L77:
P:07C7 045FA0         2 450213613         movec   m0,n7
P:07C8 2F0000         2 450413620         move    #0,b
P:07C9 5C6F00         4 450813615         move    a1,y:(r7+n7)
P:07CA 0BF080 rrrrrr  6 451413621         jsr     Fusb_dci_unstall_endpoint
                            13624 
                            13625 ; 1526 |        usb_dci_unstall_endpoint(btEndpoint, USB_IN);
                            13626 
P:07CC 045FA0         2 451613628         movec   m0,n7
P:07CD 57F400 000001  3 451913631         move    #>1,b
P:07CF 5EEF00         4 452313630         move    y:(r7+n7),a
P:07D0 0BF080 rrrrrr  6 452913632         jsr     Fusb_dci_unstall_endpoint
                            13636 
                            13637 ; 1527 |    }        
                            13638 
                            13640 L78:
                            13641 
                            13642 ; 1528 |    
                            13643 ; 1529 |} /* EndBody */
                            13644 
P:07D2 205700         2 453113646         move    (r7)-
P:07D3 05FF7C         4 453513648         movec   y:-(r7),ssh
P:07D4 000000         2 453713648         nop             ; (inserted)
P:07D5 00000C         4 454113652         rts
                            13654 
                            13655 ; 1530 |
                            13656 ; 1531 |
                            13657 ; 1532 |
                            13658 ; 1533 |////////////////////////////////////////////////////////////////////////////////
                            13659 ; 1534 |//
                            13660 ; 1535 |//>  Name:          usb_dci_set_address
                            13661 ; 1536 |//
                            13662 ; 1537 |//   Type:          Function
                            13663 ; 1538 |//
                            13664 ; 1539 |//   Description:   Sets the newly assigned device address
                            13665 ; 1540 |//
                            13666 ; 1541 |//   Inputs:        
                            13667 ; 1542 |//                  btAddress  : Address
                            13668 ; 1543 |//
                            13669 ; 1544 |//   Outputs:  none
                            13670 ; 1545 |//                  
                            13671 ; 1546 |//   Notes:         
                            13672 ; 1547 |//<
                            13673 ; 1548 |////////////////////////////////////////////////////////////////////////////////
                            13674 ; 1549 |void _reentrant usb_dci_set_address(BYTE btAddress)
                            13675 ; 1550 |{ /* Body */
                            13676 
                            13681 Fusb_dci_set_address:
                            13687 
                            13688 ; 1551 |    
                            13689 ; 1552 |   // The address bits are past bit 25-31. Set the address */
                            13690 ; 1553 |    write_usb_reg(HW_ARC_DEVADDR, (DWORD)((DWORD)btAddress << HW_ARC_DEVADDR_ADD_BITPOS));
                            13691 
P:07D6 055F7C         2 454313682         movec   ssh,y:(r7)+
P:07D7 218800         2 454513693         move    a1,a0
P:07D8 2C0000         2 454713694         move    #0,a1
P:07D9 210E00         2 454913696         move    a0,a
P:07DA 57F432 000154  3 455213697         asl     a	                #340,b
P:07DC 2A0000         2 455413699         move    #0,a2
P:07DD 0BF080 rrrrrr  6 456013700         jsr     Fwrite_usb_reg
                            13701 
                            13702 ; 1554 |
                            13703 ; 1555 |} /* EndBody */
                            13704 
P:07DF 05FF7C         4 456413706         movec   y:-(r7),ssh
P:07E0 000000         2 456613706         nop             ; (inserted)
P:07E1 00000C         4 457013710         rts
                            13712 
                            13713 ; 1556 |
                            13714 ; 1557 |
                            13715 ; 1558 |////////////////////////////////////////////////////////////////////////////////
                            13716 ; 1559 |//
                            13717 ; 1560 |//>  Name:          usb_dci_get_transfer_status
                            13718 ; 1561 |//
                            13719 ; 1562 |//   Type:          Functiorn
                            13720 ; 1563 |//
                            13721 ; 1564 |//   Description:   Gets the status of the last transfer on the specified
                            13722 ; 1565 |//                  couple endpoint/direction
                            13723 ; 1566 |//   Inputs:        
                            13724 ; 1567 |//                  btEndpoint      : Endpoint
                            13725 ; 1568 |//                  btDirection      : Direction
                            13726 ; 1569 |//
                            13727 ; 1570 |//   Outputs:       
                            13728 ; 1571 |//                  Transfer status
                            13729 ; 1572 |//
                            13730 ; 1573 |//   Notes:
                            13731 ; 1574 |//                  The status returned is the btStatus entry from the XD
                            13732 ; 1575 |//                  associated with the couple endpoint/direction         
                            13733 ; 1576 |//<
                            13734 ; 1577 |////////////////////////////////////////////////////////////////////////////////
                            13735 ; 1578 |BYTE _reentrant usb_dci_get_transfer_status(BYTE btEndpoint, BYTE btDirection)
                            13736 ; 1579 |{ /* Body */
                            13737 
                            13742 
                            13743 ; 1580 |
                            13744 ; 1581 |    xd_struct  _USB_MEM * pStXd;
                            13745 ; 1582 |   
                            13746 ; 1583 |    pStXd = g_dXD_Queues[btEndpoint][btDirection];
                            13747 
                            13749 Fusb_dci_get_transfer_status:
                            13763 
                            13764 ; 1584 |
                            13765 ; 1585 |    return(pStXd->btStatus);
                            13766 
                            13771 
                            13772 ; 1586 |   
                            13773 ; 1587 |} /* EndBody */
                            13774 
P:07E2 3E0300         2 457213768         move    #3,n6
P:07E3 60F412 rrrrrr  3 457513750         addl    b,a	                #Fg_dXD_Queues,r0
P:07E5 219800         2 457713758         move    a1,n0
P:07E6 000000         2 457913758         nop             ; (inserted)
P:07E7 6EE800         4 458313761         move    y:(r0+n0),r6
P:07E8 000000         2 458513761         nop             ; (inserted)
P:07E9 5EEE00         4 458913770         move    y:(r6+n6),a
P:07EA 00000C         4 459313776         rts
                            13780 
                            13781 ; 1588 |
                            13782 ; 1589 |////////////////////////////////////////////////////////////////////////////////
                            13783 ; 1590 |//
                            13784 ; 1591 |//>  Name:          usb_dci_stall_endpoint
                            13785 ; 1592 |//
                            13786 ; 1593 |//   Type:          Functiorn
                            13787 ; 1594 |//
                            13788 ; 1595 |//   Description:   Stalls the specified endpoint for the specified direction
                            13789 ; 1596 |//
                            13790 ; 1597 |//   Inputs:        
                            13791 ; 1598 |//                  btEndpoint      : Endpoint
                            13792 ; 1599 |//                  btDirection      : Direction
                            13793 ; 1600 |//
                            13794 ; 1601 |//   Outputs:       
                            13795 ; 1602 |//                  None
                            13796 ; 1603 |//
                            13797 ; 1604 |//   Notes:
                            13798 ; 1605 |//<
                            13799 ; 1606 |////////////////////////////////////////////////////////////////////////////////
                            13800 ; 1607 |void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection)
                            13801 ; 1608 |{ /* Body */
                            13802 
                            13807 Fusb_dci_stall_endpoint:
                            13820 
                            13821 ; 1609 |
                            13822 ; 1610 |    DWORD   dwRegister;
                            13823 
                            13830 
                            13831 ; 1611 |
                            13832 ; 1612 |    read_usb_reg(HW_ARC_ENDPTCTRL(btEndpoint), &dwRegister);
                            13833 
P:07EB 055F7C         2 459513808         movec   ssh,y:(r7)+
P:07EC 3F0400         2 459713811         move    #4,n7
P:07ED 218700         2 459913835         move    a1,y1
P:07EE 51F400 0001C0  3 460213836         move    #$1C0,b0
P:07F0 204F00         2 460413813         move    (r7)+n7
P:07F1 77F400 FFFFFE  3 460713825         move    #-2,n7
P:07F3 000000         2 460913825         nop             ; (inserted)
P:07F4 5D6F00         4 461313827         move    b1,y:(r7+n7)
P:07F5 77F400 FFFFFC  3 461613841         move    #-4,n7
P:07F7 0116CA         2 461813837         mac     y1,#22,b
P:07F8 044F10         4 462213843         lua     (r7)+n7,r0
P:07F9 045FA0         2 462413844         movec   m0,n7
P:07FA 212E00         2 462613840         move    b0,a
P:07FB 5C6F00         4 463013846         move    a1,y:(r7+n7)
P:07FC 0BF080 rrrrrr  6 463613847         jsr     Fread_usb_reg
                            13849 
                            13850 ; 1613 |    
                            13851 ; 1614 |    dwRegister |= (btDirection ? (DWORD)HW_ARC_ENDPTCTRL_TXS_SETMASK 
                            13852 ; 1615 |                               : (DWORD)HW_ARC_ENDPTCTRL_RXS_SETMASK); 
                            13853 
P:07FE 77F400 FFFFFC  3 463913855         move    #-4,n7
P:0800 205F00         2 464113856         move    (r7)+
P:0801 5EEF00         4 464513858         move    y:(r7+n7),a
P:0802 205700         2 464713859         move    (r7)-
P:0803 58EF00         4 465113861         move    y:(r7+n7),a0
P:0804 77F400 FFFFFE  3 465413862         move    #-2,n7
P:0806 000000         2 465613862         nop             ; (inserted)
P:0807 5FEF00         4 466013864         move    y:(r7+n7),b
P:0808 2B0000         2 466213865         move    #0,b2
P:0809 20000B         2 466413866         tst     b
P:080A 0AF0AA rrrrrr  6 467013869         jeq     L79
P:080C 250000         2 467213870         move    #0,x1
P:080D 240100         2 467413871         move    #<1,x0
P:080E 0AF080 rrrrrr  6 468013872         jmp     L80
P:0810 250000         2 468213873 L79:    move    #0,x1
P:0811 44F400 000001  3 468513874         move    #>1,x0
                            13875 L80:
                            13888 
                            13889 ; 1616 |
                            13890 ; 1617 |    // Reset the DATA0 to synchronize the DATA PID's between the Host and Device
                            13891 ; 1618 |    dwRegister |= (btDirection ? (DWORD)HW_ARC_ENDPTCTRL_TXR_SETMASK 
                            13892 ; 1619 |                               : (DWORD)HW_ARC_ENDPTCTRL_RXR_SETMASK); 
                            13893 
P:0813 77F400 FFFFFC  3 468813881         move    #-4,n7
P:0815 218600         2 469013875         move    a1,y0
P:0816 210C00         2 469213876         move    a0,a1
P:0817 205F42         2 469413877         or      x0,a	                (r7)+
P:0818 218800         2 469613878         move    a1,a0
P:0819 20CC00         2 469813879         move    y0,a1
P:081A 2B0062         2 470013880         or      x1,a	                #0,b2
P:081B 5C6F0B         4 470413902         tst     b	                a1,y:(r7+n7)
P:081C 205700         2 470613885         move    (r7)-
P:081D 586F00         4 471013887         move    a0,y:(r7+n7)
P:081E 205F00         2 471213895         move    (r7)+
P:081F 5EEF00         4 471613897         move    y:(r7+n7),a
P:0820 205700         2 471813898         move    (r7)-
P:0821 58EF00         4 472213900         move    y:(r7+n7),a0
P:0822 0AF0AA rrrrrr  6 472813903         jeq     L81
P:0824 270000         2 473013904         move    #0,y1
P:0825 264000         2 473213905         move    #<$40,y0
P:0826 0AF080 rrrrrr  6 473813906         jmp     L82
P:0828 270000         2 474013907 L81:    move    #0,y1
P:0829 46F400 000040  3 474313908         move    #>$40,y0
                            13909 L82:
                            13922 
                            13923 ; 1620 |
                            13924 ; 1621 |    /* Stall the endpoint for Rx or Tx and set the endpoint type */
                            13925 ; 1622 |    write_usb_reg((HW_ARC_ENDPTCTRL(btEndpoint)), dwRegister);
                            13926 
P:082B 218400         2 474513909         move    a1,x0
P:082C 210C00         2 474713910         move    a0,a1
P:082D 205F52         2 474913911         or      y0,a	                (r7)+
P:082E 218800         2 475113912         move    a1,a0
P:082F 208C00         2 475313913         move    x0,a1
P:0830 77F472 FFFFFC  3 475613914         or      y1,a	                #-4,n7
P:0832 000000         2 475813914         nop             ; (inserted)
P:0833 5C6F00         4 476213918         move    a1,y:(r7+n7)
P:0834 205700         2 476413919         move    (r7)-
P:0835 586F00         4 476813921         move    a0,y:(r7+n7)
P:0836 205F00         2 477013928         move    (r7)+
P:0837 5EEF00         4 477413930         move    y:(r7+n7),a
P:0838 205700         2 477613931         move    (r7)-
P:0839 58EF00         4 478013933         move    y:(r7+n7),a0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  51

M:ADDR CODE           CYCLES LINE SOURCELINE
P:083A 045FA0         2 478213934         movec   m0,n7
P:083B 000000         2 478413934         nop             ; (inserted)
P:083C 5FEF00         4 478813936         move    y:(r7+n7),b
P:083D 0BF080 rrrrrr  6 479413937         jsr     Fwrite_usb_reg
                            13939 
                            13940 ; 1623 |           
                            13941 ; 1624 |} /* EndBody */
                            13942 
P:083F 77F400 FFFFFB  3 479713944         move    #-5,n7
P:0841 000000         2 479913944         nop             ; (inserted)
P:0842 05EF7C         4 480313946         movec   y:(r7+n7),ssh
P:0843 204F00         2 480513948         move    (r7)+n7
P:0844 00000C         4 480913950         rts
                            13952 
                            13953 ; 1625 |
                            13954 ; 1626 |////////////////////////////////////////////////////////////////////////////////
                            13955 ; 1627 |//
                            13956 ; 1628 |//>  Name:          usb_dci_unstall_endpoint
                            13957 ; 1629 |//
                            13958 ; 1630 |//   Type:          Functiorn
                            13959 ; 1631 |//
                            13960 ; 1632 |//   Description:   Unstalls the specified endpoint for the specified direction
                            13961 ; 1633 |//
                            13962 ; 1634 |//   Inputs:        
                            13963 ; 1635 |//                  btEndpoint      : Endpoint
                            13964 ; 1636 |//                  btDirection      : Direction
                            13965 ; 1637 |//
                            13966 ; 1638 |//   Outputs:       
                            13967 ; 1639 |//                  None
                            13968 ; 1640 |//
                            13969 ; 1641 |//   Notes:
                            13970 ; 1642 |//<
                            13971 ; 1643 |////////////////////////////////////////////////////////////////////////////////
                            13972 ; 1644 |void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection)
                            13973 ; 1645 |{ /* Body */
                            13974 
                            13979 Fusb_dci_unstall_endpoint:
                            13992 
                            13993 ; 1646 |
                            13994 ; 1647 |    DWORD   dwRegister;
                            13995 
                            14002 
                            14003 ; 1648 |    
                            14004 ; 1649 |
                            14005 ; 1650 |    /* UnStall the endpoint for Rx or Tx and set the endpoint type */
                            14006 ; 1651 |    read_usb_reg(HW_ARC_ENDPTCTRL(btEndpoint), &dwRegister);
                            14007 
P:0845 055F7C         2 481113980         movec   ssh,y:(r7)+
P:0846 3F0400         2 481313983         move    #4,n7
P:0847 218700         2 481514009         move    a1,y1
P:0848 51F400 0001C0  3 481814010         move    #$1C0,b0
P:084A 204F00         2 482013985         move    (r7)+n7
P:084B 77F400 FFFFFE  3 482313997         move    #-2,n7
P:084D 000000         2 482513997         nop             ; (inserted)
P:084E 5D6F00         4 482913999         move    b1,y:(r7+n7)
P:084F 77F400 FFFFFC  3 483214015         move    #-4,n7
P:0851 0116CA         2 483414011         mac     y1,#22,b
P:0852 044F10         4 483814017         lua     (r7)+n7,r0
P:0853 045FA0         2 484014018         movec   m0,n7
P:0854 212E00         2 484214014         move    b0,a
P:0855 5C6F00         4 484614020         move    a1,y:(r7+n7)
P:0856 0BF080 rrrrrr  6 485214021         jsr     Fread_usb_reg
                            14023 
                            14024 ; 1652 |
                            14025 ; 1653 |    dwRegister &= (btDirection ? (DWORD)HW_ARC_ENDPTCTRL_TXS_CLRMASK 
                            14026 ; 1654 |                               : (DWORD)HW_ARC_ENDPTCTRL_RXS_CLRMASK); 
                            14027 
P:0858 77F400 FFFFFC  3 485514029         move    #-4,n7
P:085A 205F00         2 485714030         move    (r7)+
P:085B 5EEF00         4 486114032         move    y:(r7+n7),a
P:085C 205700         2 486314033         move    (r7)-
P:085D 58EF00         4 486714035         move    y:(r7+n7),a0
P:085E 77F400 FFFFFE  3 487014036         move    #-2,n7
P:0860 000000         2 487214036         nop             ; (inserted)
P:0861 5FEF00         4 487614038         move    y:(r7+n7),b
P:0862 2B0000         2 487814039         move    #0,b2
P:0863 20000B         2 488014040         tst     b
P:0864 0AF0AA rrrrrr  6 488614043         jeq     L83
P:0866 250000         2 488814044         move    #0,x1
P:0867 44F400 FEFFFF  3 489114045         move    #16711679,x0
P:0869 0AF080 rrrrrr  6 489714046         jmp     L84
P:086B 250000         2 489914047 L83:    move    #0,x1
P:086C 44F400 FFFFFE  3 490214048         move    #$FFFFFE,x0
                            14049 L84:
                            14062 
                            14063 ; 1655 |
                            14064 ; 1656 |    // Reset the DATA0 to synchronize the DATA PID's between the Host and Device
                            14065 ; 1657 |    dwRegister &= (btDirection ? (DWORD)HW_ARC_ENDPTCTRL_TXR_CLRMASK 
                            14066 ; 1658 |                               : (DWORD)HW_ARC_ENDPTCTRL_RXR_CLRMASK); 
                            14067 
P:086E 77F400 FFFFFC  3 490514055         move    #-4,n7
P:0870 218600         2 490714049         move    a1,y0
P:0871 210C00         2 490914050         move    a0,a1
P:0872 205F46         2 491114051         and     x0,a	                (r7)+
P:0873 218800         2 491314052         move    a1,a0
P:0874 20CC00         2 491514053         move    y0,a1
P:0875 2B0066         2 491714054         and     x1,a	                #0,b2
P:0876 5C6F0B         4 492114076         tst     b	                a1,y:(r7+n7)
P:0877 205700         2 492314059         move    (r7)-
P:0878 586F00         4 492714061         move    a0,y:(r7+n7)
P:0879 205F00         2 492914069         move    (r7)+
P:087A 5EEF00         4 493314071         move    y:(r7+n7),a
P:087B 205700         2 493514072         move    (r7)-
P:087C 58EF00         4 493914074         move    y:(r7+n7),a0
P:087D 0AF0AA rrrrrr  6 494514077         jeq     L85
P:087F 270000         2 494714078         move    #0,y1
P:0880 46F400 BFFFFF  3 495014079         move    #12582911,y0
P:0882 0AF080 rrrrrr  6 495614080         jmp     L86
P:0884 270000         2 495814081 L85:    move    #0,y1
P:0885 46F400 FFFFBF  3 496114082         move    #16777151,y0
                            14083 L86:
                            14096 
                            14097 ; 1659 |
                            14098 ; 1660 |    /* Stall the endpoint for Rx or Tx and set the endpoint type */
                            14099 ; 1661 |    write_usb_reg((HW_ARC_ENDPTCTRL(btEndpoint)), dwRegister);
                            14100 
P:0887 218400         2 496314083         move    a1,x0
P:0888 210C00         2 496514084         move    a0,a1
P:0889 205F56         2 496714085         and     y0,a	                (r7)+
P:088A 218800         2 496914086         move    a1,a0
P:088B 208C00         2 497114087         move    x0,a1
P:088C 77F476 FFFFFC  3 497414088         and     y1,a	                #-4,n7
P:088E 000000         2 497614088         nop             ; (inserted)
P:088F 5C6F00         4 498014092         move    a1,y:(r7+n7)
P:0890 205700         2 498214093         move    (r7)-
P:0891 586F00         4 498614095         move    a0,y:(r7+n7)
P:0892 205F00         2 498814102         move    (r7)+
P:0893 5EEF00         4 499214104         move    y:(r7+n7),a
P:0894 205700         2 499414105         move    (r7)-
P:0895 58EF00         4 499814107         move    y:(r7+n7),a0
P:0896 045FA0         2 500014108         movec   m0,n7
P:0897 000000         2 500214108         nop             ; (inserted)
P:0898 5FEF00         4 500614110         move    y:(r7+n7),b
P:0899 0BF080 rrrrrr  6 501214111         jsr     Fwrite_usb_reg
                            14113 
                            14114 ; 1662 |           
                            14115 ; 1663 |} /* EndBody */
                            14116 
P:089B 77F400 FFFFFB  3 501514118         move    #-5,n7
P:089D 000000         2 501714118         nop             ; (inserted)
P:089E 05EF7C         4 502114120         movec   y:(r7+n7),ssh
P:089F 204F00         2 502314122         move    (r7)+n7
P:08A0 00000C         4 502714124         rts
                            14126 
                            14127 ; 1664 |
                            14128 ; 1665 |
                            14129 ; 1666 |
                            14130 ; 1667 |
                            14131 ; 1668 |
                            14132 ; 1669 |////////////////////////////////////////////////////////////////////////////////
                            14133 ; 1670 |//
                            14134 ; 1671 |//>  Name:          usb_dci_init_data_toggle_endpoint
                            14135 ; 1672 |//
                            14136 ; 1673 |//   Type:          Functiorn
                            14137 ; 1674 |//
                            14138 ; 1675 |//   Description:   Unstalls the specified endpoint for the specified direction
                            14139 ; 1676 |//
                            14140 ; 1677 |//   Inputs:        
                            14141 ; 1678 |//                  btEndpoint      : Endpoint
                            14142 ; 1679 |//                  btDirection      : Direction
                            14143 ; 1680 |//
                            14144 ; 1681 |//   Outputs:       
                            14145 ; 1682 |//                  None
                            14146 ; 1683 |//
                            14147 ; 1684 |//   Notes:
                            14148 ; 1685 |//<
                            14149 ; 1686 |////////////////////////////////////////////////////////////////////////////////
                            14150 ; 1687 |void _reentrant usb_dci_init_data_toggle_endpoint(BYTE btEndpoint)
                            14151 ; 1688 |{
                            14152 
                            14157 Fusb_dci_init_data_toggle_endpoint:
                            14165 
                            14166 ; 1689 |    DWORD   dwTempRegister;
                            14167 ; 1690 |    
                            14168 ; 1691 |   // Reset the Toggle bit
                            14169 ; 1692 |   read_usb_reg(HW_ARC_ENDPTCTRL(btEndpoint), &dwTempRegister);
                            14170 
P:08A1 055F7C         2 502914158         movec   ssh,y:(r7)+
P:08A2 3F0300         2 503114161         move    #3,n7
P:08A3 22F000         2 503314178         move    r7,r0
P:08A4 218500         2 503514172         move    a1,x1
P:08A5 51F400 0001C0  3 503814173         move    #$1C0,b0
P:08A7 204F00         2 504014179         move    (r7)+n7
P:08A8 045FA0         2 504214181         movec   m0,n7
P:08A9 0116FA         2 504414174         mac     x1,#22,b
P:08AA 212E00         2 504614177         move    b0,a
P:08AB 5C6F00         4 505014183         move    a1,y:(r7+n7)
P:08AC 0BF080 rrrrrr  6 505614184         jsr     Fread_usb_reg
                            14186 
                            14187 ; 1693 |
                            14188 ; 1694 |   dwTempRegister = dwTempRegister 
                            14189 ; 1695 |                    | (DWORD)HW_ARC_ENDPTCTRL_TXR_SETMASK
                            14190 ; 1696 |                    | (DWORD)HW_ARC_ENDPTCTRL_RXR_SETMASK;
                            14191 
                            14214 
                            14215 ; 1697 |
                            14216 ; 1698 |    write_usb_reg(HW_ARC_ENDPTCTRL(btEndpoint), dwTempRegister);                                                     
                            14217 
P:08AE 77F400 FFFFFD  3 505914193         move    #-3,n7
P:08B0 250000         2 506114200         move    #0,x1
P:08B1 44F400 400040  3 506414201         move    #4194368,x0
P:08B3 205F00         2 506614194         move    (r7)+
P:08B4 5FEF00         4 507014196         move    y:(r7+n7),b
P:08B5 205700         2 507214197         move    (r7)-
P:08B6 21A600         2 507414202         move    b1,y0
P:08B7 59EF00         4 507814199         move    y:(r7+n7),b0
P:08B8 212D00         2 508014203         move    b0,b1
P:08B9 205F4A         2 508214204         or      x0,b	                (r7)+
P:08BA 21A900         2 508414205         move    b1,b0
P:08BB 20CD00         2 508614206         move    y0,b1
P:08BC 20006A         2 508814207         or      x1,b
P:08BD 5D6F00         4 509214210         move    b1,y:(r7+n7)
P:08BE 205700         2 509414211         move    (r7)-
P:08BF 596F00         4 509814213         move    b0,y:(r7+n7)
P:08C0 205F00         2 510014219         move    (r7)+
P:08C1 5EEF00         4 510414221         move    y:(r7+n7),a
P:08C2 205700         2 510614222         move    (r7)-
P:08C3 58EF00         4 511014224         move    y:(r7+n7),a0
P:08C4 045FA0         2 511214225         movec   m0,n7
P:08C5 000000         2 511414225         nop             ; (inserted)
P:08C6 5FEF00         4 511814227         move    y:(r7+n7),b
P:08C7 0BF080 rrrrrr  6 512414228         jsr     Fwrite_usb_reg
                            14229 
                            14230 ; 1699 |}
                            14231 
P:08C9 77F400 FFFFFC  3 512714233         move    #-4,n7
P:08CB 000000         2 512914233         nop             ; (inserted)
P:08CC 05EF7C         4 513314235         movec   y:(r7+n7),ssh
P:08CD 204F00         2 513514237         move    (r7)+n7
P:08CE 00000C         4 513914239         rts
                            14241 
                            14242 ; 1700 |
                            14243 ; 1701 |
                            14244 ; 1702 |
                            14245 ; 1703 |
                            14246 ; 1704 |////////////////////////////////////////////////////////////////////////////////
                            14247 ; 1705 |//
                            14248 ; 1706 |//>  Name:          usb_dci_transfer_data
                            14249 ; 1707 |//
                            14250 ; 1708 |//   Type:          Functiorn
                            14251 ; 1709 |//
                            14252 ; 1710 |//   Description:   Prepares the arc core to transfer the data described by 
                            14253 ; 1711 |//                  the XD descriptor
                            14254 ; 1712 |//
                            14255 ; 1713 |//   Inputs:        
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  52

M:ADDR CODE           CYCLES LINE SOURCELINE
                            14256 ; 1714 |//                  pStXd  : Pointer to the transfer descriptor
                            14257 ; 1715 |//
                            14258 ; 1716 |//   Outputs:       
                            14259 ; 1717 |//                  USB_OK
                            14260 ; 1718 |//
                            14261 ; 1719 |//   Notes:
                            14262 ; 1720 |//<
                            14263 ; 1721 |////////////////////////////////////////////////////////////////////////////////
                            14264 ; 1722 |BYTE _reentrant usb_dci_transfer_data(xd_struct _USB_MEM * pStXd)
                            14265 ; 1723 |{ /* Body */
                            14266 
                            14271 Fusb_dci_transfer_data:
                            14300 
                            14301 ; 1724 |    dTD_Struct _X * pStdTD;
                            14302 ; 1725 |    BYTE _X * pdTD;
                            14303 ; 1726 |    WORD    wStmpByteAddress, wReg;
                            14304 ; 1727 |    USHORT  usArcPage, usArcByteOffset, usArcdTD;
                            14305 ; 1728 |    DWORD   dwReg;
                            14306 ; 1729 |    
                            14307 ; 1730 |    
                            14308 ; 1731 |    int iEndPoint = pStXd->btEndpointNum;
                            14309 
                            14316 
                            14317 ; 1732 |    int iDirection = pStXd->btDirection;
                            14318 
                            14326 
                            14327 ; 1733 |    g_dXD_Queues[iEndPoint][iDirection] = pStXd ; 
                            14328 
                            14336 
                            14337 ; 1734 |
                            14338 ; 1735 |    if(pStXd->usTotalLength == 0)
                            14339 
P:08CF 055F7C         2 514114272         movec   ssh,y:(r7)+
P:08D0 3F0600         2 514314275         move    #6,n7
P:08D1 045815         4 514714321         lua     (r0)+,r5
P:08D2 7DE000         2 514914311         move    y:(r0),n5
P:08D3 5EE500         2 515114323         move    y:(r5),a
P:08D4 23AF00         2 515314312         move    n5,b
P:08D5 66F41A rrrrrr  3 515614330         addl    a,b	                #Fg_dXD_Queues,r6
P:08D7 21BE00         2 515814332         move    b1,n6
P:08D8 10B400 000001  3 516114324         move    a,y0	                #>1,x0
P:08DA 686E00         4 516514335         move    r0,y:(r6+n6)
P:08DB 3E0600         2 516714341         move    #6,n6
P:08DC 221600         2 516914342         move    r0,r6
P:08DD 000000         2 517114342         nop             ; (inserted)
P:08DE 5FEE00         4 517514344         move    y:(r6+n6),b
P:08DF 21B400         2 517714345         move    b1,r4
P:08E0 2B0000         2 517914346         move    #0,b2
P:08E1 204F0B         2 518114347         tst     b	                (r7)+n7
P:08E2 0AF0A2 rrrrrr  6 518714348         jne     L87
                            14349 
                            14350 ; 1736 |    {   // This is a zero length transfer. Initialize the buffer address to 0
                            14351 ; 1737 |        usArcPage = 0;
                            14352 
                            14356 
                            14357 ; 1738 |        usArcByteOffset = 0;
                            14358 
                            14362 
                            14363 ; 1739 |    }
                            14364 
P:08E4 36001B         2 518914354         clr     b	                #0,r6
P:08E5 0AF080 rrrrrr  6 519514366         jmp     L88
                            14367 
                            14368 ; 1740 |    else
                            14369 ; 1741 |    {
                            14370 ; 1742 |
                            14371 ; 1743 |        // Calculates the address of the data buffer in the arc space
                            14372 ; 1744 |        // Arc space is byte oriented with 4-byte words. The address on the dTDs
                            14373 ; 1745 |        // specifies a 4Kbyte page address and a byte offset in the page address
                            14374 ; 1746 |        // To convert the STMP address into a ARC address we must:
                            14375 ; 1747 |        //      1. Subtract STMP base address
                            14376 ; 1748 |        //          STMP_word_add = STMP_word_add - BASE_ADD
                            14377 ; 1749 |        //      2. Convert STMP 3-byte word in bytes
                            14378 ; 1750 |        //          ARC_byte_add = (STMP_word_add * 3) + STMP_byte_offset
                            14379 ; 1751 |        //      3. Calculate the 4k-page number
                            14380 ; 1752 |        //          ARC_page_number = ARC_byte_add >> 12  (Divide by 4K)
                            14381 ; 1753 |        //      4. Calculate ARC byte offset in page
                            14382 ; 1754 |        //          ARC_byte_offset = ARC_byte_add - (ARC_page_number * 0x1000) 
                            14383 ; 1755 |        //          
                            14384 ; 1756 |        
                            14385 ; 1757 |        // Phase 1 and 2
                            14386 ; 1758 |        //  STMP address is limited to 16 bits, therefore multiplying by 3 
                            14387 ; 1759 |        //  limits to 18 bits max. We will use a WORD for this math.
                            14388 ; 1760 |        wStmpByteAddress = (WORD) pStXd->pbtStartAddressWord;
                            14389 
                            14391 L87:
                            14396 
                            14397 ; 1761 |        wStmpByteAddress -= (WORD)&dQH_Base_Add;
                            14398 
                            14405 
                            14406 ; 1762 |        wStmpByteAddress = (WORD)(wStmpByteAddress * 3) + pStXd->btStartOffsetByte;
                            14407 
                            14419 
                            14420 ; 1763 |
                            14421 ; 1764 |        // Phase 3
                            14422 ; 1765 |        // The max size of the wStmpByteAddress is 18 bits, shifting right 12 bits
                            14423 ; 1766 |        // yields in a max size for usArcPage of 6 bits. We will use USHORT cast
                            14424 ; 1767 |        // because usArcPage will be casted later into a byte pointer.
                            14425 ; 1768 |        usArcPage = (USHORT)(wStmpByteAddress >> 12);
                            14426 
P:08E7 3E0400         2 519714391         move    #4,n6
P:08E8 47F400 rrrrrr  3 520014400         move    #FdQH_Base_Add,y1
P:08EA 5FEE00         4 520414393         move    y:(r6+n6),b
P:08EB 3E057C         2 520614401         sub     y1,b	                #5,n6
P:08EC 21A700         2 520814403         move    b1,y1
P:08ED 58EE00         4 521214411         move    y:(r6+n6),a0
P:08EE 45F432 000003  3 521514414         asl     a	                #>3,x1
P:08F0 2000F2         2 521714415         mac     y1,x1,a
P:08F1 200022         2 521914416         asr     a
P:08F2 210D00         2 522114428         move    a0,b1
P:08F3 21AE00         2 522314429         move    b1,a
P:08F4 060CA0         4 522714430         rep     #12    
P:08F5 20002B         2 522914432         lsr     b
                            14434 L92:
                            14439 
                            14440 ; 1769 |
                            14441 ; 1770 |        // Phase 4
                            14442 ; 1771 |        usArcByteOffset = (USHORT)(wStmpByteAddress & 0xFFF);
                            14443 
                            14448 
                            14449 ; 1772 |    }
                            14450 
P:08F6 45F400 000FFF  3 523214445         move    #$FFF,x1
P:08F8 21AF66         2 523414446         and     x1,a	                b1,b
P:08F9 219600         2 523614447         move    a1,r6
                            14452 L88:
                            14460 
                            14461 ; 1773 |
                            14462 ; 1774 |    // Get the address for the specific dTD
                            14463 ; 1775 |    pStdTD = dTD_Base_Scratch_Address[(pStXd->btEndpointNum<<1) + pStXd->btDirection];
                            14464 
                            14474 
                            14475 ; 1776 |
                            14476 ; 1777 |    // Get the address for the specific dTD
                            14477 ; 1778 |    pdTD = dTD_Base_Address[(pStXd->btEndpointNum<<1) + pStXd->btDirection];
                            14478 
                            14487 
                            14488 ; 1779 |
                            14489 ; 1780 |    // Initialize the dTD scratch 
                            14490 ; 1781 |    pStdTD->pbtNextdTDPointer = (BYTE *)0x00;     // Always one dTD per transfer
                            14491 
                            14495 
                            14496 ; 1782 |    pStdTD->usTotalBytes = pStXd->usTotalLength;  // Set the number of bytes to transfer
                            14497 
                            14502 
                            14503 ; 1783 |    pStdTD->usCurrentOffset = usArcByteOffset;     // Byte Offset
                            14504 
                            14512 
                            14513 ; 1784 |    pStdTD->pbtBufPage0 = (BYTE *)usArcPage;      // Set the page address
                            14514 
                            14521 
                            14522 ; 1785 |    pStdTD->pbtBufPage1 = (BYTE *)(usArcPage + 1);
                            14523 
                            14530 
                            14531 ; 1786 |
                            14532 ; 1787 |    // We never use more than 12KBytes buffer so setting those pages are just a waste
                            14533 ; 1788 |    // of MIPS
                            14534 ; 1789 |//    pStdTD->pbtBufPage2 = (BYTE *)(usArcPage + 2);
                            14535 ; 1790 |//    pStdTD->pbtBufPage3 = (BYTE *)(usArcPage + 3);
                            14536 ; 1791 |//    pStdTD->pbtBufPage4 = (BYTE *)(usArcPage + 4);
                            14537 ; 1792 |                                                    // Activate the dTD and set the IOC bit
                            14538 ; 1793 |    pStdTD->usStatusIoc = (USB_EP_dTD_IOC | USB_EP_dTD_ACTIVE);
                            14539 
                            14544 
                            14545 ; 1794 |
                            14546 ; 1795 |    // Pack the dTD
                            14547 ; 1796 |    FdTDPack(pStXd->btEndpointNum, pStXd->btDirection);
                            14548 
P:08FA 3B0200         2 523814499         move    #2,n3
P:08FB 23AE00         2 524014466         move    n5,a
P:08FC 62F433 rrrrrr  3 524314467         lsl     a	                #FdTD_Base_Scratch_Address,r2
P:08FE 77F450 FFFFFD  3 524614468         add     y0,a	                #-3,n7
P:0900 219A13         2 524814493         clr     a	                a1,n2
P:0901 6D6F00         4 525214454         move    r5,y:(r7+n7)
P:0902 63EA00         4 525614472         move    x:(r2+n2),r3
P:0903 77F400 FFFFFC  3 525914455         move    #-4,n7
P:0905 62F400 rrrrrr  3 526214480         move    #FdTD_Base_Address,r2
P:0907 686F00         4 526614457         move    r0,y:(r7+n7)
P:0908 76EA00         4 527014482         move    x:(r2+n2),n6
P:0909 77F400 FFFFFE  3 527314483         move    #-2,n7
P:090B 320300         2 527514506         move    #3,r2
P:090C 546300         2 527714494         move    a1,x:(r3)
P:090D 7E6F00         4 528114485         move    n6,y:(r7+n7)
P:090E 045FA0         2 528314508         movec   m0,n7
P:090F 23AE00         2 528514551         move    n5,a
P:0910 646B00         4 528914501         move    r4,x:(r3+n3)
P:0911 225B00         2 529114507         move    r2,n3
P:0912 62F400 008080  3 529414541         move    #$8080,r2
P:0914 666B00         4 529814511         move    r6,x:(r3+n3)
P:0915 21B648         2 530014525         add     x0,b	                b1,r6
P:0916 7B6F00         4 530414510         move    n3,y:(r7+n7)
P:0917 3B0400         2 530614518         move    #4,n3
P:0918 000000         2 530814518         nop             ; (inserted)
P:0919 666B00         4 531214520         move    r6,x:(r3+n3)
P:091A 3B0500         2 531414527         move    #5,n3
P:091B 000000         2 531614527         nop             ; (inserted)
P:091C 556B59         4 532014550         tfr     y0,b	                b1,x:(r3+n3)
P:091D 205B00         2 532214542         move    (r3)+
P:091E 625300         2 532414543         move    r2,x:(r3)-
P:091F 0BF080 rrrrrr  6 533014552         jsr     FdTDPack
                            14554 
                            14555 ; 1797 |
                            14556 ; 1798 |    // Convert dTD address to ARC address
                            14557 ; 1799 |    usArcdTD = (USHORT)(pdTD) - (USHORT)&dQH_Base_Add;
                            14558 
                            14570 
                            14571 ; 1800 |    usArcdTD *= 3;
                            14572 
                            14580 
                            14581 ; 1801 |
                            14582 ; 1802 |    // Initialize the dQH for the specific endpoint
                            14583 ; 1803 |    dQH_Scratch_Cap.pbtNextdTDPointer = (BYTE *)usArcdTD;  
                            14584 
                            14587 
                            14588 ; 1804 |
                            14589 ; 1805 |    // Pack the dQH 
                            14590 ; 1806 |    FdQHPackCap(pStXd->btEndpointNum, pStXd->btDirection, (BYTE)0x00);
                            14591 
P:0921 77F400 FFFFFE  3 533314560         move    #-2,n7
P:0923 46F400 rrrrrr  3 533614566         move    #FdQH_Base_Add,y0
P:0925 44F400 000003  3 533914574         move    #>3,x0
P:0927 5FEF00         4 534314562         move    y:(r7+n7),b
P:0928 77F45C FFFFFC  3 534614567         sub     y0,b	                #-4,n7
P:092A 21A600         2 534814568         move    b1,y0
P:092B 6EEF00         4 535214595         move    y:(r7+n7),r6
P:092C 000000         2 535414595         nop             ; (inserted)
P:092D 5EE6D8         2 535614575         mpy     y0,x0,b	                y:(r6),a
P:092E 77F42A FFFFFD  3 535914576         asr     b	                #-3,n7
P:0930 240000         2 536114603         move    #0,x0
P:0931 6EEF00         4 536514600         move    y:(r7+n7),r6
P:0932 517000 rrrrrr  3 536814586         move    b0,x:FdQH_Scratch_Cap+2
P:0934 5FE600         2 537014602         move    y:(r6),b
P:0935 0BF080 rrrrrr  6 537614604         jsr     FdQHPackCap
                            14605 
                            14606 ; 1807 |
                            14607 ; 1808 |    // Prime the endpoint
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  53

M:ADDR CODE           CYCLES LINE SOURCELINE
                            14608 ; 1809 |    write_usb_reg(HW_ARC_ENDPTPRIME,(DWORD)(1 << ((pStXd->btDirection<<4) + pStXd->btEndpointNum)));
                            14609 
P:0937 77F400 FFFFFD  3 537914611         move    #-3,n7
P:0939 000000         2 538114611         nop             ; (inserted)
P:093A 6EEF00         4 538514613         move    y:(r7+n7),r6
P:093B 77F400 FFFFFC  3 538814617         move    #-4,n7
P:093D 4EE600         2 539014615         move    y:(r6),y0
P:093E 6EEF00         4 539414619         move    y:(r7+n7),r6
P:093F 0114E8         2 539614616         mpy     y0,#20,b
P:0940 5EE600         2 539814621         move    y:(r6),a
P:0941 212600         2 540014622         move    b0,y0
P:0942 2D0150         2 540214623         add     y0,a	                #1,b1
P:0943 0AF0AF rrrrrr  6 540814625         jle     L93
P:0945 06CC20         4 541214626         rep     a1    
P:0946 20003B         2 541414628         lsl     b
                            14630 L93:
P:0947 2E0000         2 541614632         move    #0,a
P:0948 21A800         2 541814633         move    b1,a0
P:0949 57F400 0001B0  3 542114634         move    #432,b
P:094B 0BF080 rrrrrr  6 542714635         jsr     Fwrite_usb_reg
                            14636 
                            14637 ; 1810 |
                            14638 ; 1811 |    // This is risky. I did not have enough information from ARC about
                            14639 ; 1812 |    // delay between ENDPTPRIME to '0' and ENDPTSTAT to '1'.
                            14640 ; 1813 |    // Therefore do not include this code in the ROM
                            14641 ; 1814 |    
                            14642 ; 1815 |    if(pStXd->bIsDataPhase == TRUE)
                            14643 
P:094D 3E0900         2 542914645         move    #9,n6
P:094E 77F400 FFFFFC  3 543214646         move    #-4,n7
P:0950 47F400 000001  3 543514651         move    #>1,y1
P:0952 6EEF00         4 543914648         move    y:(r7+n7),r6
P:0953 000000         2 544114648         nop             ; (inserted)
P:0954 5FEE00         4 544514650         move    y:(r6+n6),b
P:0955 2B0000         2 544714652         move    #0,b2
P:0956 20007D         2 544914653         cmp     y1,b
P:0957 0AF0A2 rrrrrr  6 545514654         jne     L91
                            14655 
                            14656 ; 1816 |    {
                            14657 ; 1817 |        // Add code here to handle the case where a setup packet arrives 
                            14658 ; 1818 |        // while priming the endpoint for the data phase on the previous
                            14659 ; 1819 |        // setup packet. Arc documentation requires:
                            14660 ; 1820 |        // " After priming the data phase packet, the device driver must verify a new
                            14661 ; 1821 |        //   setup packet has not been received by reading the ENPTSETUPSTAT register
                            14662 ; 1822 |        //   immediately verifying that the prime had completed. If a new packetis indicated
                            14663 ; 1823 |        //   after the ENDPTPRIME bit is cleared, then the transfer descriptor
                            14664 ; 1824 |        //   can be freed and the device driver must reinterpret the setup packet.
                            14665 ; 1825 |        
                            14666 ; 1826 |        do
                            14667 ; 1827 |        {
                            14668 ; 1828 |            // Wait for end of prime
                            14669 ; 1829 |            read_usb_reg(HW_ARC_ENDPTPRIME, &dwReg);
                            14670 
P:0959 77F400 FFFFFA  3 545814672 L89:    move    #-6,n7
P:095B 56F400 0001B0  3 546114675         move    #432,a
P:095D 044F10         4 546514674         lua     (r7)+n7,r0
P:095E 0BF080 rrrrrr  6 547114676         jsr     Fread_usb_reg
                            14677 
                            14678 ; 1830 |//            dwReg &= (DWORD)(1 << ((16 * pStXd->btDirection) + pStXd->btEndpointNum));
                            14679 ; 1831 |        }while(dwReg);
                            14680 
P:0960 77F400 FFFFFA  3 547414682         move    #-6,n7
P:0962 205F00         2 547614683         move    (r7)+
P:0963 5FEF00         4 548014685         move    y:(r7+n7),b
P:0964 2B0000         2 548214689         move    #0,b2
P:0965 205700         2 548414686         move    (r7)-
P:0966 59EF00         4 548814688         move    y:(r7+n7),b0
P:0967 20000B         2 549014690         tst     b
P:0968 0AF0A2 rrrrrr  6 549614691         jne     L89
                            14692 
                            14693 ; 1832 |        
                            14694 ; 1833 |        // Check if new setup packet arrived
                            14695 ; 1834 |        wReg = read_usb_reg_16(HW_ARC_ENDPTSETUPSTAT);
                            14696 
P:096A 56F400 0001AC  3 549914698         move    #428,a
P:096C 0BF080 rrrrrr  6 550514699         jsr     Fread_usb_reg_16
                            14702 
                            14703 ; 1835 |        wReg &= (1 << pStXd->btEndpointNum);
                            14704 
P:096E 77F400 FFFFFC  3 550814706         move    #-4,n7
P:0970 2D0100         2 551014713         move    #1,b1
P:0971 6EEF00         4 551414708         move    y:(r7+n7),r6
P:0972 218600         2 551614700         move    a1,y0
P:0973 5EE600         2 551814710         move    y:(r6),a
P:0974 2A0000         2 552014714         move    #0,a2
P:0975 200003         2 552214715         tst     a
P:0976 0AF0AA rrrrrr  6 552814716         jeq     L94
P:0978 06CC20         4 553214717         rep     a1    
P:0979 20003B         2 553414719         lsl     b
                            14721 L94:
                            14731 
                            14732 ; 1836 |        if(wReg)
                            14733 
P:097A 21A651         2 553614723         tfr     y0,a	                b1,y0
P:097B 200056         2 553814725         and     y0,a
P:097C 218F00         2 554014729         move    a1,b
P:097D 2B0000         2 554214735         move    #0,b2
P:097E 20000B         2 554414736         tst     b
P:097F 0AF0AA rrrrrr  6 555014737         jeq     L91
                            14738 
                            14739 ; 1837 |        {
                            14740 ; 1838 |            // New setup packet arrived, free the dXD        
                            14741 ; 1839 |            pStXd->btStatus = USB_STATUS_TRANSFER_IDLE;
                            14742 
                            14750 
                            14751 ; 1840 |        }            
                            14752 ; 1841 |    }    
                            14753 ; 1842 |
                            14754 ; 1843 |    return USB_OK;
                            14755 
P:0981 045FA0         2 555214745         movec   m0,n7
P:0982 2F0000         2 555414744         move    #0,b
P:0983 7EEF00         4 555814747         move    y:(r7+n7),n6
P:0984 000000         2 556014747         nop             ; (inserted)
P:0985 5D6E00         4 556414749         move    b1,y:(r6+n6)
                            14757 L91:
                            14758 
                            14759 ; 1844 |
                            14760 ; 1845 |} /* EndBody */
                            14761 
P:0986 77F413 FFFFF9  3 556714757         clr     a	                #-7,n7
P:0988 000000         2 556914757         nop             ; (inserted)
P:0989 05EF7C         4 557314765         movec   y:(r7+n7),ssh
P:098A 204F00         2 557514767         move    (r7)+n7
P:098B 00000C         4 557914769         rts
                            14773 
                            14774 ; 1846 |
                            14775 ; 1847 |
                            14776 ; 1848 |
                            14777 ; 1849 |
                            14778 ; 1850 |////////////////////////////////////////////////////////////////////////////////
                            14779 ; 1851 |//
                            14780 ; 1852 |//>  Name:          usb_dci_set_test_mode
                            14781 ; 1853 |//
                            14782 ; 1854 |//   Type:          Functiorn
                            14783 ; 1855 |//
                            14784 ; 1856 |//   Description:   Prepares the arc core to execute USB test vector
                            14785 ; 1857 |//
                            14786 ; 1858 |//   Inputs:        
                            14787 ; 1859 |//                  usTest  : USB Vector test number 
                            14788 ; 1860 |//
                            14789 ; 1861 |//   Outputs:       none
                            14790 ; 1862 |//
                            14791 ; 1863 |//   Notes:
                            14792 ; 1864 |//<
                            14793 ; 1865 |////////////////////////////////////////////////////////////////////////////////
                            14794 ; 1866 |void _reentrant usb_dci_set_test_mode(USHORT usTest) 
                            14795 ; 1867 |{ /* Body */
                            14796 
                            14896 Fusb_dci_set_test_mode:
                            14907 
                            14908 ; 1868 |
                            14909 ; 1869 |    DWORD   dwRegister;
                            14910 
                            14917 
                            14918 ; 1870 |    
                            14919 ; 1871 |    // Reset the toggle bit
                            14920 ; 1872 |    read_usb_reg(HW_ARC_ENDPTCTRL(0), &dwRegister);
                            14921 
P:098C 055F7C         2 558114897         movec   ssh,y:(r7)+
P:098D 3F0300         2 558314900         move    #3,n7
P:098E 000000         2 558514900         nop             ; (inserted)
P:098F 204F00         2 558714902         move    (r7)+n7
P:0990 045FA0         2 558914912         movec   m0,n7
P:0991 000000         2 559114912         nop             ; (inserted)
P:0992 5C6F00         4 559514914         move    a1,y:(r7+n7)
P:0993 77F400 FFFFFD  3 559814923         move    #-3,n7
P:0995 56F400 0001C0  3 560114927         move    #$1C0,a
P:0997 044F1E         4 560514925         lua     (r7)+n7,n6
P:0998 23D000         2 560714926         move    n6,r0
P:0999 0BF080 rrrrrr  6 561314928         jsr     Fread_usb_reg
                            14929 
                            14930 ; 1873 |    dwRegister |= HW_ARC_ENDPTCTRL_TXR_SETMASK; 
                            14931 
                            14954 
                            14955 ; 1874 |    write_usb_reg(HW_ARC_ENDPTCTRL(0), dwRegister);
                            14956 
P:099B 77F400 FFFFFD  3 561614933         move    #-3,n7
P:099D 264000         2 561814941         move    #<$40,y0
P:099E 270000         2 562014940         move    #0,y1
P:099F 205F00         2 562214934         move    (r7)+
P:09A0 5FEF00         4 562614936         move    y:(r7+n7),b
P:09A1 205700         2 562814937         move    (r7)-
P:09A2 21A400         2 563014942         move    b1,x0
P:09A3 59EF00         4 563414939         move    y:(r7+n7),b0
P:09A4 212D00         2 563614943         move    b0,b1
P:09A5 205F5A         2 563814944         or      y0,b	                (r7)+
P:09A6 21A900         2 564014945         move    b1,b0
P:09A7 208D00         2 564214946         move    x0,b1
P:09A8 20007A         2 564414947         or      y1,b
P:09A9 5D6F00         4 564814950         move    b1,y:(r7+n7)
P:09AA 205700         2 565014951         move    (r7)-
P:09AB 596F00         4 565414953         move    b0,y:(r7+n7)
P:09AC 205F00         2 565614958         move    (r7)+
P:09AD 57F400 0001C0  3 565914964         move    #$1C0,b
P:09AF 5EEF00         4 566314960         move    y:(r7+n7),a
P:09B0 205700         2 566514961         move    (r7)-
P:09B1 58EF00         4 566914963         move    y:(r7+n7),a0
P:09B2 0BF080 rrrrrr  6 567514965         jsr     Fwrite_usb_reg
                            14966 
                            14967 ; 1875 |
                            14968 ; 1876 |    if((usTest == (USHORT)USB_TEST_MODE_TEST_J) || (usTest == (USHORT)USB_TEST_MODE_TEST_K))
                            14969 
P:09B4 045FA0         2 567714971         movec   m0,n7
P:09B5 44F400 000001  3 568014977         move    #>1,x0
P:09B7 6AEF00         4 568414973         move    y:(r7+n7),r2
P:09B8 224F00         2 568614974         move    r2,b
P:09B9 20004D         2 568814978         cmp     x0,b
P:09BA 0AF0AA rrrrrr  6 569414979         jeq     L95
P:09BC 44F400 000002  3 569714980         move    #>2,x0
P:09BE 20004D         2 569914981         cmp     x0,b
P:09BF 0AF0A2 rrrrrr  6 570514982         jne     L96
                            14983 
                            14984 ; 1877 |    {
                            14985 ; 1878 |        // This code was added for USB 2.0 compliance issues Test J and Test K
                            14986 ; 1879 |        // Levels must be less than 12 mV
                            14987 ; 1880 |
                            14988 ; 1881 |        // Power Down Rx and Tx components that are not used in Test J and Test K modes
                            14989 ; 1882 |        // RXPWDRX to 1.
                            14990 ; 1883 |        // RXPWDDIFF to 1.
                            14991 ; 1884 |        // RXPWD1PT1 to 1.
                            14992 ; 1885 |        // RXPWDENV to 1.
                            14993 ; 1886 |        // RXPWDDISCONDET to 1.
                            14994 ; 1887 |        // TXPWDCOMP to 1.
                            14995 ; 1888 |        HW_USBPHYPWD.I |= 0x1f4000;
                            14996 
                            14998 L95:
                            15002 
                            15003 ; 1889 |    
                            15004 ; 1890 |        // Selects crystal for DCLK instead of PLL
                            15005 ; 1891 |        HW_CCR.B.CKSRC = 0;
                            15006 
                            15009 
                            15010 ; 1892 |    
                            15011 ; 1893 |        // Runs UTMI and FS off DCLK instead of USB PLL
                            15012 ; 1894 |        HW_USBPHYRX.B.FSCKSOURCESEL = 0;
                            15013 
                            15016 
                            15017 ; 1895 |    
                            15018 ; 1896 |        // Slow Down USB PLL to its minimum frequency
                            15019 ; 1897 |        HW_USBPHYPLL.B.PLLCLKDIVSEL = 0x07;
                            15020 
                            15028 
                            15029 ; 1898 |        HW_USBPHYPLL.B.PLLCPNSEL = 0x07;
                            15030 
                            15038 
                            15039 ; 1899 |    }
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  54

M:ADDR CODE           CYCLES LINE SOURCELINE
                            15040 
P:09C1 54F000 00F210  3 570814998         move    x:$F210,a1
P:09C3 46F400 1F4000  3 571114999         move    #$1F4000,y0
P:09C5 44F452 FFF0FF  3 571415000         or      y0,a	                #$FFF0FF,x0
P:09C7 547000 00F210  3 571715001         move    a1,x:$F210
P:09C9 46F400 FF0FFF  3 572015023         move    #$FF0FFF,y0
P:09CB 0A7008 00FA00  6 572615008         bclr    #8,x:$FA00
P:09CD 0A7015 00F213  6 573215015         bclr    #21,x:$F213
P:09CF 56F000 00F212  3 573515022         move    x:$F212,a
P:09D1 46F456 007000  3 573815024         and     y0,a	                #$7000,y0
P:09D3 200052         2 574015026         or      y0,a
P:09D4 547000 00F212  3 574315027         move    a1,x:$F212
P:09D6 56F000 00F212  3 574615032         move    x:$F212,a
P:09D8 44F446 000700  3 574915034         and     x0,a	                #$700,x0
P:09DA 200042         2 575115036         or      x0,a
P:09DB 547000 00F212  3 575415037         move    a1,x:$F212
                            15042 L96:
                            15047 
                            15048 ; 1900 |
                            15049 ; 1901 |    // Check if Test required is send test packet 
                            15050 ; 1902 |    if(usTest == (USHORT)USB_TEST_MODE_TEST_PACKET)
                            15051 
P:09DD 045FA0         2 575615042         movec   m0,n7
P:09DE 56F400 000004  3 575915053         move    #>4,a
P:09E0 6A6F0D         4 576315054         cmp     a,b	                r2,y:(r7+n7)
P:09E1 0AF0A2 rrrrrr  6 576915055         jne     L97
                            15056 
                            15057 ; 1903 |    {
                            15058 ; 1904 |        usb_device_send_data(0, (void _X *)TestPacket, 0, USB_TEST_MODE_TEST_PACKET_LENGTH, FALSE,000000);
                            15059 
P:09E3 60F400 rrrrrr  3 577215061         move    #FTestPacket,r0
P:09E5 250013         2 577415063         clr     a	                #0,x1
P:09E6 44F469 000035  3 577715064         tfr     x1,b	                #>53,x0
P:09E8 20A600         2 577915065         move    x1,y0
P:09E9 0BF080 rrrrrr  6 578515067         jsr     Fusb_device_send_data
                            15068 
                            15069 ; 1905 |    }        
                            15070 ; 1906 |
                            15071 ; 1907 |    // Reset PORTSC[0] bits CSC, PEC, and OCC
                            15072 ; 1908 |    read_usb_reg(HW_ARC_PORTSC1, &dwRegister);
                            15073 
                            15075 L97:
P:09EB 77F400 FFFFFD  3 578815076         move    #-3,n7
P:09ED 56F400 000184  3 579115075         move    #388,a
P:09EF 044F10         4 579515078         lua     (r7)+n7,r0
P:09F0 0BF080 rrrrrr  6 580115079         jsr     Fread_usb_reg
                            15080 
                            15081 ; 1909 |    dwRegister &= (DWORD)HW_ARC_PORTSC1_CSC_CLRMASK     // was HW_ARC_PORTSC1_PE_CLRMASK
                            15082 ; 1910 |                & (DWORD)HW_ARC_PORTSC1_PEC_CLRMASK
                            15083 ; 1911 |                & (DWORD)HW_ARC_PORTSC1_OCC_CLRMASK; 
                            15084 
                            15107 
                            15108 ; 1912 |    write_usb_reg(HW_ARC_PORTSC1, dwRegister);
                            15109 
P:09F2 77F400 FFFFFD  3 580415086         move    #-3,n7
P:09F4 250000         2 580615093         move    #0,x1
P:09F5 44F400 FFFFD5  3 580915094         move    #16777173,x0
P:09F7 205F00         2 581115087         move    (r7)+
P:09F8 5FEF00         4 581515089         move    y:(r7+n7),b
P:09F9 205700         2 581715090         move    (r7)-
P:09FA 21A600         2 581915095         move    b1,y0
P:09FB 59EF00         4 582315092         move    y:(r7+n7),b0
P:09FC 212D00         2 582515096         move    b0,b1
P:09FD 205F4E         2 582715097         and     x0,b	                (r7)+
P:09FE 21A900         2 582915098         move    b1,b0
P:09FF 20CD00         2 583115099         move    y0,b1
P:0A00 20006E         2 583315100         and     x1,b
P:0A01 5D6F00         4 583715103         move    b1,y:(r7+n7)
P:0A02 205700         2 583915104         move    (r7)-
P:0A03 596F00         4 584315106         move    b0,y:(r7+n7)
P:0A04 205F00         2 584515111         move    (r7)+
P:0A05 57F400 000184  3 584815117         move    #388,b
P:0A07 5EEF00         4 585215113         move    y:(r7+n7),a
P:0A08 205700         2 585415114         move    (r7)-
P:0A09 58EF00         4 585815116         move    y:(r7+n7),a0
P:0A0A 0BF080 rrrrrr  6 586415118         jsr     Fwrite_usb_reg
                            15119 
                            15120 ; 1913 |    
                            15121 ; 1914 |    // Set test to execute in Arc Register
                            15122 ; 1915 |    dwRegister |= (DWORD)(usTest << HW_ARC_PORTSC1_PTC_BITPOS);
                            15123 
                            15154 
                            15155 ; 1916 |    write_usb_reg(HW_ARC_PORTSC1, dwRegister);
                            15156 
P:0A0C 77F400 FFFFFD  3 586715125         move    #-3,n7
P:0A0E 250000         2 586915139         move    #0,x1
P:0A0F 205F00         2 587115126         move    (r7)+
P:0A10 5EEF00         4 587515128         move    y:(r7+n7),a
P:0A11 205700         2 587715129         move    (r7)-
P:0A12 218600         2 587915141         move    a1,y0
P:0A13 58EF00         4 588315131         move    y:(r7+n7),a0
P:0A14 045FA0         2 588515132         movec   m0,n7
P:0A15 210C00         2 588715142         move    a0,a1
P:0A16 4CEF00         4 589115134         move    y:(r7+n7),x0
P:0A17 77F400 FFFFFD  3 589415147         move    #-3,n7
P:0A19 0108D8         2 589615135         mpy     x0,#8,b
P:0A1A 212400         2 589815138         move    b0,x0
P:0A1B 205F42         2 590015143         or      x0,a	                (r7)+
P:0A1C 218800         2 590215144         move    a1,a0
P:0A1D 20CC00         2 590415145         move    y0,a1
P:0A1E 57F462 000184  3 590715146         or      x1,a	                #388,b
P:0A20 5C6F00         4 591115150         move    a1,y:(r7+n7)
P:0A21 205700         2 591315151         move    (r7)-
P:0A22 586F00         4 591715153         move    a0,y:(r7+n7)
P:0A23 205F00         2 591915158         move    (r7)+
P:0A24 5EEF00         4 592315160         move    y:(r7+n7),a
P:0A25 205700         2 592515161         move    (r7)-
P:0A26 58EF00         4 592915163         move    y:(r7+n7),a0
P:0A27 0BF080 rrrrrr  6 593515165         jsr     Fwrite_usb_reg
                            15166 
                            15167 ; 1917 |    
                            15168 ; 1918 |} /* EndBody */
                            15169 
P:0A29 77F400 FFFFFC  3 593815171         move    #-4,n7
P:0A2B 000000         2 594015171         nop             ; (inserted)
P:0A2C 05EF7C         4 594415173         movec   y:(r7+n7),ssh
P:0A2D 204F00         2 594615175         move    (r7)+n7
P:0A2E 00000C         4 595015177         rts
                            15179 
                            15180 ; 1919 |
                            15181 ; 1920 |
                            15182 ; 1921 |
                            15183 ; 1922 |// This function unpacks the 48-bit double word into 2 16-bit words and writes 
                            15184 ; 1923 |// it back to the ARC register
                            15185 ; 1924 |//void _reentrant write_usb_reg(USHORT usRegAdd, DWORD dwData)         
                            15186 ; 1925 |//{
                            15187 ; 1926 |//    WORD wOldIVL;
                            15188 ; 1927 |//    wOldIVL = SysMaskAllInterrupts();
                            15189 ; 1928 |//    HW_USBARCDATALOW.B.DATA = (WORD)(dwData & (WORD)(HW_USBARCDATALOW_DATA_SETMASK));
                            15190 ; 1929 |//    HW_USBARCDATAHIGH.B.DATA = (WORD)((dwData >> 16) & (DWORD)(HW_USBARCDATALOW_DATA_SETMASK));
                            15191 ; 1930 |//    usRegAdd &= (USHORT)HW_USBARCACCESS_ADD_SETMASK;
                            15192 ; 1931 |//    HW_USBARCACCESS.B.ADD = usRegAdd;
                            15193 ; 1932 |//    HW_USBARCACCESS.B.RWB = 0;
                            15194 ; 1933 |//    HW_USBARCACCESS.B.KICK = 1;         
                            15195 ; 1934 |//    SysUnMaskAllInterrupts(wOldIVL);
                            15196 ; 1935 |//}    
                            15197 ; 1936 |
                            15198 ; 1937 |
                            15199 ; 1938 |// This macro reads the ARC 32-bit register and packs it in a 48-bit double word
                            15200 ; 1939 |// Use this macro in combination with WRITE_USB_REG macro to read-modify-write
                            15201 ; 1940 |// a ARC register
                            15202 ; 1941 |//void _reentrant read_usb_reg(USHORT usRegAdd, DWORD * dwData)
                            15203 ; 1942 |//{
                            15204 ; 1943 |//    WORD wOldIVL;
                            15205 ; 1944 |//    wOldIVL = SysMaskAllInterrupts();
                            15206 ; 1945 |//    usRegAdd &= HW_USBARCACCESS_ADD_SETMASK;
                            15207 ; 1946 |//    HW_USBARCACCESS.B.ADD = usRegAdd;
                            15208 ; 1947 |//    HW_USBARCACCESS.B.RWB = 1;
                            15209 ; 1948 |//    HW_USBARCACCESS.B.KICK = 1;
                            15210 ; 1949 |//    while(HW_USBARCACCESS.B.KICK);
                            15211 ; 1950 |//    *dwData = (DWORD)(HW_USBARCDATALOW.B.DATA & HW_USBARCDATALOW_DATA_SETMASK);
                            15212 ; 1951 |//    *dwData |= (DWORD)(HW_USBARCDATAHIGH.B.DATA << 16);
                            15213 ; 1952 |//    SysUnMaskAllInterrupts(wOldIVL);
                            15214 ; 1953 |//}
                            15215 ; 1954 |
                            15216 ; 1955 |// This function unpacks the 48-bit double word into 2 16-bit words and writes 
                            15217 ; 1956 |// it back to the ARC register
                            15218 ; 1957 |// Interrupts must be disabled prior to calling this function!
                            15219 ; 1958 |void _reentrant write_usb_reg(USHORT usRegAdd, DWORD dwData)         
                            15220 ; 1959 |{
                            15221 
                            15226 Fwrite_usb_reg:
                            15231 
                            15232 ; 1960 |
                            15233 ; 1961 |    #pragma asm
                            15234 
                            15237 
                            15243     
                            15244     push    a0
                            15245     push    a1
                            15246     push    b1
                            15247     
                            15248 ;    jsr     FSysMaskAllInterrupts
                            15250     
                            15251     pop     b1
                            15252     pop     a1
                            15253     pop     a0
                            15254     
                            15258     
                            15262     
                            15265 
                            15268     
                            15271 
                            15273 ;    jsr     FSysUnMaskAllInterrupts
                            15274 
                            15275 
                            15276 ; 2000 |    #pragma endasm  
                            15277 ; 2001 |
                            15278 ; 2002 |}    
                            15279 
P:0A2F 218600         2 595215249     move    a1,y0                   ; Saves old isr level
P:0A30 44F400 0001FF  3 595515255     move    #>HW_USBARCACCESS_ADD_SETMASK,x0
P:0A32 585F00         2 595715244     move    a0,y:(r7)+
P:0A33 5C5F00         2 595915245     move    a1,y:(r7)+
P:0A34 5D5F00         2 596115246     move    b1,y:(r7)+
P:0A35 5DFF00         4 596515251     move    y:-(r7),b1
P:0A36 5CFF00         4 596915252     move    y:-(r7),a1
P:0A37 45F44E 00FFFF  3 597215256     and     x0,b    #>$00ffff,x1
P:0A39 58FF00         4 597615253     move    y:-(r7),a0
P:0A3A 557000 00F202  3 597915257     move    b1,x:HW_USBARCACCESS
P:0A3C 210D00         2 598115259     move    a0,b1
P:0A3D 20006E         2 598315260     and     x1,b
P:0A3E 0608A0         4 598715263     rep     #8
P:0A3F 200032         2 598915264         asl     a
P:0A40 577066 00F203  3 599215266     and     x1,a	            b,x:HW_USBARCDATALOW
P:0A42 547000 00F204  3 599515267     move    a1,x:HW_USBARCDATAHIGH
P:0A44 0A7010 00F202  6 600115269     bclr    #HW_USBARCACCESS_RWB_BITPOS,x:HW_USBARCACCESS
P:0A46 20CC00         2 600315272     move    y0,a1                   ; Restores old isr level
P:0A47 0A7037 00F202  6 600915270     bset    #HW_USBARCACCESS_KICK_BITPOS,x:HW_USBARCACCESS
P:0A49 00000C         4 601315281         rts
                            15285 
                            15286 ; 2003 |
                            15287 ; 2004 |
                            15288 ; 2005 |
                            15289 ; 2006 |
                            15290 ; 2007 |
                            15291 ; 2008 |// This function reads the ARC 32-bit register and packs it in a 48-bit double word
                            15292 ; 2009 |// Use this macro in combination with WRITE_USB_REG macro to read-modify-write
                            15293 ; 2010 |// a ARC register
                            15294 ; 2011 |// Interrupts must be disabled prior to calling this function!
                            15295 ; 2012 |void _reentrant read_usb_reg(USHORT usRegAdd, DWORD * dwData)
                            15296 ; 2013 |{
                            15297 
                            15304 Fread_usb_reg:
                            15309 
                            15310 ; 2014 |    #pragma asm
                            15311 
                            15314 
                            15320     
                            15321     push    a1
                            15322     push    r0
                            15323     
                            15324 ;    jsr     FSysMaskAllInterrupts
P:0A4A 218600         2 601515325     move    a1,y0                   ; Saves old isr level
                            15326     
                            15327     pop     r0
                            15328     pop     a1
                            15329     
                            15330     ;Set Address, R/W/ Bit and kick transaction
P:0A4B 44F400 0001FF  3 601815331     move    #>HW_USBARCACCESS_ADD_SETMASK,x0
P:0A4D 5C5F00         2 602015321     move    a1,y:(r7)+
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  55

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0A4E 685F00         2 602215322     move    r0,y:(r7)+
P:0A4F 68FF00         4 602615327     move    y:-(r7),r0
P:0A50 5CFF00         4 603015328     move    y:-(r7),a1
P:0A51 200046         2 603215332     and     x0,a
P:0A52 547000 00F202  3 603515333     move    a1,x:HW_USBARCACCESS
P:0A54 0A7030 00F202  6 604115334     bset    #HW_USBARCACCESS_RWB_BITPOS,x:HW_USBARCACCESS
P:0A56 0A7037 00F202  6 604715335     bset    #HW_USBARCACCESS_KICK_BITPOS,x:HW_USBARCACCESS
                            15336 
                            15337     ;Wait end of transaction
                            15338 _Loop
P:0A58 50F000 00F202  3 605015339     move    x:HW_USBARCACCESS,a0
P:0A5A 0AC837 rrrrrr  6 605615340     jset    #HW_USBARCACCESS_KICK_BITPOS,a0,_Loop
                            15341 
                            15342     ;32-bit word ARC Register is split into 2 16-bit words
                            15343     ;Unify those 2 16-bit words in a DWORD result 
                            15348 
                            15353 
                            15356 
                            15358 ;    jsr     FSysUnMaskAllInterrupts
                            15359 
                            15360 
                            15361 ; 2061 |    #pragma endasm  
                            15362 ; 2062 |
                            15363 ; 2063 |}
                            15364 
P:0A5C 55F000 00F203  3 605915349     move    x:HW_USBARCDATALOW,b1       ;b1=XLL
P:0A5E 44F413 00FFFF  3 606215344     clr     a   #>$00ffff,x0       
P:0A60 54F000 00F204  3 606515345     move    x:HW_USBARCDATAHIGH,a1      ;a1=XHH
P:0A62 0608A0         4 606915346     rep     #8
P:0A63 200022         2 607115347         asr     a                       ;a1a0=XXHH00
P:0A64 21054E         2 607315350     and     x0,b    a0,x1               ;b1=0LL    x1=H00
P:0A65 44F46A 0000FF  3 607615351     or      x1,b    #>$0000ff,x0        ;b1=HLL
P:0A67 5D5846         2 607815352     and     x0,a	            b1,y:(r0)+
P:0A68 5C6000         2 608015355     move    a1,y:(r0)    
P:0A69 20CC00         2 608215357     move    y0,a1                   ; Restores old isr level
P:0A6A 00000C         4 608615366         rts
                            15370 
                            15371 ; 2064 |
                            15372 ; 2065 |
                            15373 ; 2066 |////////////////////////////////////////////////////////////////////////////////
                            15374 ; 2067 |//
                            15375 ; 2068 |//>  Name:          read_and_clear_usb_reg
                            15376 ; 2069 |//
                            15377 ; 2070 |//   Type:          Functiorn
                            15378 ; 2071 |//
                            15379 ; 2072 |//   Description:   Reads and clears the ARC register
                            15380 ; 2073 |//
                            15381 ; 2074 |//   Inputs:        
                            15382 ; 2075 |//                  usRegAdd = RAC Register Address to read and clear
                            15383 ; 2076 |//                  *dwData  = Pointer to variable to store ARC Register Value
                            15384 ; 2077 |//
                            15385 ; 2078 |//   Outputs:       
                            15386 ; 2079 |//                  none
                            15387 ; 2080 |//
                            15388 ; 2081 |//   Notes:
                            15389 ; 2082 |//                  This function was designed to speed up the USB ISR
                            15390 ; 2083 |//                  Do not call this function outside the ISR.
                            15391 ; 2084 |//<
                            15392 ; 2085 |////////////////////////////////////////////////////////////////////////////////
                            15393 ; 2086 |void _reentrant read_and_clear_usb_reg(USHORT usRegAdd, DWORD * dwData)
                            15394 ; 2087 |{
                            15395 
                            15400 Fread_and_clear_usb_reg:
                            15405 
                            15406 ; 2088 |    #pragma asm
                            15407 
                            15410 
                            15416     
                            15417     ;Set Address, R/W/ Bit and kick transaction
P:0A6B 44F400 0001FF  3 608915418     move    #>HW_USBARCACCESS_ADD_SETMASK,x0
P:0A6D 200046         2 609115419     and     x0,a
P:0A6E 547000 00F202  3 609415420     move    a1,x:HW_USBARCACCESS
P:0A70 0A7030 00F202  6 610015421     bset    #HW_USBARCACCESS_RWB_BITPOS,x:HW_USBARCACCESS
P:0A72 0A7037 00F202  6 610615422     bset    #HW_USBARCACCESS_KICK_BITPOS,x:HW_USBARCACCESS
                            15423 
                            15424     ;Wait end of transaction
                            15425 _Loop
P:0A74 50F000 00F202  3 610915426     move    x:HW_USBARCACCESS,a0
P:0A76 0AC837 rrrrrr  6 611515427     jset    #HW_USBARCACCESS_KICK_BITPOS,a0,_Loop
                            15428 
                            15432     
                            15435 
                            15438 
                            15439     ; Clear the arc register
                            15442 
                            15443 
                            15444 ; 2122 |    #pragma endasm  
                            15445 ; 2123 |
                            15446 ; 2124 |}
                            15447 
P:0A78 44F413 00FFFF  3 611815429     clr     a   #>$00ffff,x0       
P:0A7A 54F000 00F204  3 612115430     move    x:HW_USBARCDATAHIGH,a1      ;a1=XHH
P:0A7C 55F046 00F203  3 612415431     and     x0,a	            x:HW_USBARCDATALOW,b1       ;b1=XLL
P:0A7E 20004E         2 612615434     and     x0,b    
P:0A7F 0A7010 00F202  6 613215440     bclr    #HW_USBARCACCESS_RWB_BITPOS,x:HW_USBARCACCESS
P:0A81 5D5800         2 613415436     move    b1,y:(r0)+
P:0A82 0A7037 00F202  6 614015441     bset    #HW_USBARCACCESS_KICK_BITPOS,x:HW_USBARCACCESS
P:0A84 5C6000         2 614215437     move    a1,y:(r0)    
P:0A85 00000C         4 614615449         rts
                            15453 
                            15454 ; 2125 |
                            15455 ; 2126 |////////////////////////////////////////////////////////////////////////////////
                            15456 ; 2127 |//
                            15457 ; 2128 |//>  Name:          read_and_clear_arc_reg_usbsts
                            15458 ; 2129 |//
                            15459 ; 2130 |//   Type:          Functiorn
                            15460 ; 2131 |//
                            15461 ; 2132 |//   Description:   Reads and clears the ARC register USBSTATUS
                            15462 ; 2133 |//
                            15463 ; 2134 |//   Inputs:        
                            15464 ; 2135 |//                  none
                            15465 ; 2136 |//
                            15466 ; 2137 |//   Outputs:       
                            15467 ; 2138 |//                  Returns the ARC register USBSTATUS prior clearing it
                            15468 ; 2139 |//
                            15469 ; 2140 |//   Notes:
                            15470 ; 2141 |//                  This function was designed to speed up the USB ISR
                            15471 ; 2142 |//                  Do not call this function outside the ISR.
                            15472 ; 2143 |//<
                            15473 ; 2144 |////////////////////////////////////////////////////////////////////////////////
                            15474 ; 2145 |WORD _reentrant read_and_clear_arc_reg_usbsts(void)
                            15475 ; 2146 |{
                            15476 
                            15481 Fread_and_clear_arc_reg_usbsts:
                            15482 
                            15483 ; 2147 |    #pragma asm
                            15484 
                            15487 
                            15493 
                            15494     ;Set Address, R/W/ Bit and kick transaction
P:0A86 56F400 000144  3 614915496     move    #>HW_ARC_USBSTS,a
P:0A88 44F400 0001FF  3 615215495     move    #>HW_USBARCACCESS_ADD_SETMASK,x0
P:0A8A 200046         2 615415497     and     x0,a
P:0A8B 547000 00F202  3 615715498     move    a1,x:HW_USBARCACCESS
P:0A8D 0A7030 00F202  6 616315499     bset    #HW_USBARCACCESS_RWB_BITPOS,x:HW_USBARCACCESS
P:0A8F 0A7037 00F202  6 616915500     bset    #HW_USBARCACCESS_KICK_BITPOS,x:HW_USBARCACCESS
                            15501 
                            15502     ;Wait end of transaction
                            15503 _Loop
P:0A91 50F000 00F202  3 617215504     move    x:HW_USBARCACCESS,a0
P:0A93 0AC837 rrrrrr  6 617815505     jset    #HW_USBARCACCESS_KICK_BITPOS,a0,_Loop
                            15506 
                            15510         
                            15511     ; Clear the arc register
                            15514 
                            15515 
                            15516 ; 2176 |    #pragma endasm  
                            15517 ; 2177 |
                            15518 ; 2178 |}
                            15519 
P:0A95 44F413 00FFFF  3 618115507     clr     a  #$00ffff,x0
P:0A97 54F000 00F203  3 618415508     move    x:HW_USBARCDATALOW,a1
P:0A99 200046         2 618615509     and     x0,a
P:0A9A 0A7010 00F202  6 619215512     bclr    #HW_USBARCACCESS_RWB_BITPOS,x:HW_USBARCACCESS
P:0A9C 0A7037 00F202  6 619815513     bset    #HW_USBARCACCESS_KICK_BITPOS,x:HW_USBARCACCESS
P:0A9E 00000C         4 620215521         rts
                            15523 
                            15524 ; 2179 |
                            15525 ; 2180 |////////////////////////////////////////////////////////////////////////////////
                            15526 ; 2181 |//
                            15527 ; 2182 |//>  Name:          read_usb_reg_16
                            15528 ; 2183 |//
                            15529 ; 2184 |//   Type:          Functiorn
                            15530 ; 2185 |//
                            15531 ; 2186 |//   Description:   Returns the 16 LSBits from the specific ARC Register
                            15532 ; 2187 |//
                            15533 ; 2188 |//   Inputs:        
                            15534 ; 2189 |//                  usRegAdd    Address ARC Register to read
                            15535 ; 2190 |//
                            15536 ; 2191 |//   Outputs:       
                            15537 ; 2192 |//                  16 LSBits from the specific ARC Register
                            15538 ; 2193 |//
                            15539 ; 2194 |//   Notes:
                            15540 ; 2195 |//                  This function was designed to speed up the USB ISR
                            15541 ; 2196 |//                  Do not call this function outside the ISR.
                            15542 ; 2197 |//<
                            15543 ; 2198 |////////////////////////////////////////////////////////////////////////////////
                            15544 ; 2199 |WORD _reentrant read_usb_reg_16(USHORT usRegAdd)
                            15545 ; 2200 |{
                            15546 
                            15551 Fread_usb_reg_16:
                            15554 
                            15555 ; 2201 |    #pragma asm
                            15556 
                            15559 
                            15565     
                            15566     ;Set Address, R/W/ Bit and kick transaction
P:0A9F 44F400 0001FF  3 620515567     move    #>HW_USBARCACCESS_ADD_SETMASK,x0
P:0AA1 200046         2 620715568     and     x0,a
P:0AA2 547000 00F202  3 621015569     move    a1,x:HW_USBARCACCESS
P:0AA4 0A7030 00F202  6 621615570     bset    #HW_USBARCACCESS_RWB_BITPOS,x:HW_USBARCACCESS
P:0AA6 0A7037 00F202  6 622215571     bset    #HW_USBARCACCESS_KICK_BITPOS,x:HW_USBARCACCESS
                            15572 
                            15573     ;Wait end of transaction
                            15574 _Loop
P:0AA8 50F000 00F202  3 622515575     move    x:HW_USBARCACCESS,a0
P:0AAA 0AC837 rrrrrr  6 623115576     jset    #HW_USBARCACCESS_KICK_BITPOS,a0,_Loop
                            15577 
                            15581 
                            15582 
                            15583 ; 2225 |    #pragma endasm  
                            15584 ; 2226 |
                            15585 ; 2227 |}
                            15586 
P:0AAC 44F413 00FFFF  3 623415578     clr     a   #$00ffff,x0
P:0AAE 54F000 00F203  3 623715579     move    x:HW_USBARCDATALOW,a1     
P:0AB0 200046         2 623915580     and     x0,a
P:0AB1 00000C         4 624315588         rts
                            15591 
                            15592 ; 2228 |
                            15593 ; 2229 |
                            15594 ; 2230 |
                            15595 ; 2231 |
                            15596 ; 2232 |
                            15597 ; 2233 |void _reentrant usb_dci_finish_transaction(BYTE btEndpoint)
                            15598 ; 2234 |{
                            15599 
                            15604 Fusb_dci_finish_transaction:
                            15607 
                            15608 ; 2235 |    g_SetupData[btEndpoint].bValid=FALSE;
                            15609 
                            15623 
                            15624 ; 2236 |}
                            15625 
P:0AB2 218600         2 624515611         move    a1,y0
P:0AB3 47F400 000006  3 624815612         move    #>6,y1
P:0AB5 63F4B0 rrrrrr  3 625115613         mpy     y0,y1,a	                #Fg_SetupData,r3
P:0AB7 200022         2 625315614         asr     a
P:0AB8 211B1B         2 625515621         clr     b	                a0,n3
P:0AB9 000000         2 625715621         nop             ; (inserted)
P:0ABA 044B16         4 626115620         lua     (r3)+n3,r6
P:0ABB 000000         2 626315620         nop             ; (inserted)
P:0ABC 5D6600         2 626515622         move    b1,y:(r6)
P:0ABD 00000C         4 626915627         rts
                            15630 
                            15631 ; 2237 |
                            15632 ; 2238 |
                            15633 ; 2239 |void _reentrant usb_dci_update_connection_status(void)
                            15634 ; 2240 |{
                            15635 
                            15675 Fusb_dci_update_connection_status:
                            15678 
                            15679 ; 2241 |
                            15680 ; 2242 |    BOOL bSetBrownOut = FALSE;
                            15681 
                            15685 
                            15686 ; 2243 |    
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  56

M:ADDR CODE           CYCLES LINE SOURCELINE
                            15687 ; 2244 |    // If VDDIO Auto Brownout is set, disable it to sense 5V 
                            15688 ; 2245 |    if(HW_VDD5V_PWR_CHARGE.B.PWDN_ON_IOBRNOUT)
                            15689 
P:0ABE 56F01B 00FA1D  3 627215683         clr     b	                x:$FA1D,a
P:0AC0 0ACC0D rrrrrr  6 627815692         jclr    #13,a1,L104
                            15693 
                            15694 ; 2246 |    {
                            15695 ; 2247 |        bSetBrownOut = TRUE;
                            15696 
                            15699 
                            15700 ; 2248 |        HW_VDD5V_PWR_CHARGE.B.PWDN_ON_IOBRNOUT = 0;
                            15701 
                            15704 
                            15705 ; 2249 |    }     
                            15706 ; 2250 |
                            15707 ; 2251 |   // Check if power source is +5V
                            15708 ; 2252 |   // If power is not from +5V => USB is not connected.
                            15709 ; 2253 |   // If power is from +5V => USB connected or Charger Connected
                            15710 ; 2254 |    if(!HW_USBCSR.B.VBUSSENSE)
                            15711 
P:0AC2 0A700D 00FA1D  6 628415703         bclr    #13,x:$FA1D
P:0AC4 57F400 000001  3 628715698         move    #>1,b
P:0AC6 46F000 00F200  3 629015713 L104:   move    x:$F200,y0
P:0AC8 0AC617 rrrrrr  6 629615714         jclr    #23,y0,L106
                            15715 
                            15716 ; 2255 |    {
                            15717 ; 2256 |        stDeviceState.usConnectionState = USB_DISCONNECTED;
                            15718 ; 2257 |    }
                            15719 ; 2258 |    else
                            15720 ; 2259 |    {
                            15721 ; 2260 |        // Enable USB plug in circuit
                            15722 ; 2261 |        HW_USBCSR.B.PLUGGEDIN_EN = 1;
                            15723 
                            15726 
                            15727 ; 2262 |        
                            15728 ; 2263 |        #pragma asm
                            15729 
                            15732             ; The circuitry takes up to 1Usec to stabilize, which is 24 dclks
                            15733             ; at 24Mhz
                            15736 
                            15737 ; 2268 |        #pragma endasm
                            15738 ; 2269 |        
                            15739 ; 2270 |        if(HW_USBCSR.B.PLUGGEDIN)
                            15740 
P:0ACA 0618A0         4 630015734             rep #24
P:0ACB 000000         2 630215735                 nop
P:0ACC 0A702C 00F200  6 630815725         bset    #12,x:$F200
P:0ACE 46F000 00F200  3 631115742         move    x:$F200,y0
P:0AD0 0AC60D rrrrrr  6 631715743         jclr    #13,y0,L106
                            15744 
                            15745 ; 2271 |        {
                            15746 ; 2272 |            stDeviceState.usConnectionState = USB_CONNECTED;
                            15747 
                            15751 
                            15752 ; 2273 |        }
                            15753 
P:0AD2 350000         2 631915749         move    #0,r5
P:0AD3 6D7000 rrrrrr  3 632215750         move    r5,y:FstDeviceState+12
P:0AD5 0AF080 rrrrrr  6 632815755         jmp     L107
                            15756 
                            15757 ; 2274 |        else
                            15758 ; 2275 |        {
                            15759 ; 2276 |            stDeviceState.usConnectionState = USB_DISCONNECTED;
                            15760 
                            15762 L106:
                            15764 
                            15765 ; 2277 |        }
                            15766 ; 2278 |    }
                            15767 ; 2279 |
                            15768 ; 2280 |    // Restore VDDIO Auto Brown Out.
                            15769 ; 2281 |    if(bSetBrownOut)
                            15770 
P:0AD7 3C0100         2 633015762         move    #1,n4
P:0AD8 7C7000 rrrrrr  3 633315763         move    n4,y:FstDeviceState+12
P:0ADA 2B0000         2 633515772 L107:   move    #0,b2
P:0ADB 20000B         2 633715773         tst     b
P:0ADC 0AF0AA rrrrrr  6 634315774         jeq     L108
                            15775 
                            15776 ; 2282 |    {
                            15777 ; 2283 |        HW_VDD5V_PWR_CHARGE.B.PWDN_ON_IOBRNOUT = 1;
                            15778 
                            15781 
                            15782 ; 2284 |    }     
                            15783 
P:0ADE 0A702D 00FA1D  6 634915780         bset    #13,x:$FA1D
                            15785 L108:
                            15786 
                            15787 ; 2285 |
                            15788 ; 2286 |}
                            15789 
P:0AE0 00000C         4 635315791         rts
                            15794 
                            15795 ; 2287 |
                            15796 ; 2288 |////////////////////////////////////////////////////////////////////////////////
                            15797 ; 2289 |//
                            15798 ; 2290 |//>  Name:          usb_dci_shutdown
                            15799 ; 2291 |//
                            15800 ; 2292 |//   Type:          Function
                            15801 ; 2293 |//
                            15802 ; 2294 |//   Description:   Shut down the USB port
                            15803 ; 2295 |//
                            15804 ; 2296 |//   Inputs:        none
                            15805 ; 2297 |//
                            15806 ; 2298 |//   Outputs:       none
                            15807 ; 2299 |//
                            15808 ; 2300 |//   Notes:         none
                            15809 ; 2301 |//<
                            15810 ; 2302 |////////////////////////////////////////////////////////////////////////////////
                            15811 ; 2303 |void _reentrant usb_dci_shutdown(void)
                            15812 ; 2304 |{
                            15813 
                            15818 Fusb_dci_shutdown:
                            15819 
                            15820 ; 2305 |
                            15821 ; 2306 |  HW_USBCSR.B.USBEN = 0;
                            15822 
                            15825 
                            15826 ; 2307 |  HW_USBCSR.B.CLKOFF = 0;
                            15827 
                            15830 
                            15831 ; 2308 |  HW_USBCSR.B.USBEN = 1;
                            15832 
                            15835 
                            15836 ; 2309 |  
                            15837 ; 2310 |  // Turns OFF ARC Core
                            15838 ; 2311 |  HW_USBCSR.B.ARCCONNECT = 0;
                            15839 
                            15842 
                            15843 ; 2312 |  
                            15844 ; 2313 |  // Disables the USB Clock
                            15845 ; 2314 |  HW_USBCSR.B.CLKOFF = 1;
                            15846 
                            15849 
                            15850 ; 2315 |  
                            15851 ; 2316 |  // Disable USB STMP
                            15852 ; 2317 |  HW_USBCSR.B.USBEN = 0;
                            15853 
                            15856 
                            15857 ; 2318 |  
                            15858 ; 2319 |
                            15859 ; 2320 |}
                            15860 
P:0AE1 0A7000 00F200  6 635915824         bclr    #0,x:$F200
P:0AE3 0A7007 00F200  6 636515829         bclr    #7,x:$F200
P:0AE5 0A7020 00F200  6 637115834         bset    #0,x:$F200
P:0AE7 0A700B 00F200  6 637715841         bclr    #11,x:$F200
P:0AE9 0A7027 00F200  6 638315848         bset    #7,x:$F200
P:0AEB 0A7000 00F200  6 638915855         bclr    #0,x:$F200
P:0AED 00000C         4 639315862         rts
                            15864 
                            15865 ; 2321 |
                            15866 ; 2322 |////////////////////////////////////////////////////////////////////////////////
                            15867 ; 2323 |//
                            15868 ; 2324 |//>  Name:          usb_dci_chip_init
                            15869 ; 2325 |//
                            15870 ; 2326 |//   Type:          Function
                            15871 ; 2327 |//
                            15872 ; 2328 |//   Description:   
                            15873 ; 2329 |//
                            15874 ; 2330 |//   Inputs:        none
                            15875 ; 2331 |//
                            15876 ; 2332 |//   Outputs:       none
                            15877 ; 2333 |//
                            15878 ; 2334 |//   Notes:         none
                            15879 ; 2335 |//<
                            15880 ; 2336 |////////////////////////////////////////////////////////////////////////////////
                            15881 ; 2337 |//#define USBTEST_FOR_USBCV_1_3
                            15882 ; 2338 |#ifdef USBTEST_FOR_USBCV_1_3
                            15883 ; 2339 |void usb_dci_Reset_Bulk_Endpoint(void)
                            15884 ; 2340 |{
                            15885 ; 2341 |    DWORD    dwRegister;
                            15886 ; 2342 |    usb_dci_clear_dxd_queue(1,USB_IN);
                            15887 ; 2343 |    usb_dci_clear_dxd_queue(2,USB_OUT);
                            15888 ; 2344 |    usb_dci_clear_dxd_queue(1,USB_OUT);
                            15889 ; 2345 |    usb_dci_clear_dxd_queue(2,USB_IN);
                            15890 ; 2346 |
                            15891 ; 2347 |    /* Clear all the endpoint complete status bits */
                            15892 ; 2348 |    write_usb_reg(HW_ARC_ENDPTCOMPLETE,(DWORD)( (1 <<((1<<4) + 1)) + (1 << 2) ) );
                            15893 ; 2349 |    // Cancel all primed status by waiting untill all bits in the ENDPTPRIME are 0
                            15894 ; 2350 |    // then writing 0xffffffff to ENDPTFLUSH
                            15895 ; 2351 |    do
                            15896 ; 2352 |    {
                            15897 ; 2353 |        // Wait until all ENDPTPRIME bits cleared
                            15898 ; 2354 |        read_usb_reg(HW_ARC_ENDPTPRIME, &dwRegister);
                            15899 ; 2355 |    }while(dwRegister & ((DWORD)( (1 <<((1<<4) + 1)) + (1 << 2) )));
                            15900 ; 2356 |
                            15901 ; 2357 |
                            15902 ; 2358 |    /* Write 1s to the Flush register */
                            15903 ; 2359 |    write_usb_reg(HW_ARC_ENDPTFLUSH, (DWORD)( (1 <<((1<<4) + 1)) + (1 << 2) ) );
                            15904 ; 2360 |    // Set all transfer structures to idle
                            15905 ; 2361 |    dXD_Base_Address[1*2]->btStatus = USB_STATUS_TRANSFER_IDLE;
                            15906 ; 2362 |    dXD_Base_Address[(1*2) + 1]->btStatus = USB_STATUS_TRANSFER_IDLE;
                            15907 ; 2363 |    dXD_Base_Address[2*2]->btStatus = USB_STATUS_TRANSFER_IDLE;
                            15908 ; 2364 |    dXD_Base_Address[(2*2) + 1]->btStatus = USB_STATUS_TRANSFER_IDLE;
                            15909 ; 2365 |
                            15910 ; 2366 |    usb_dci_unstall_endpoint(1,USB_OUT);
                            15911 ; 2367 |    usb_dci_unstall_endpoint(1,USB_IN);
                            15912 ; 2368 |    usb_dci_unstall_endpoint(2,USB_OUT);
                            15913 ; 2369 |    usb_dci_unstall_endpoint(2,USB_IN);
                            15914 ; 2370 |}
                            15915 ; 2371 |#endif
                            15916 ; 2372 |
                            15917 
                            15939 
                            15942 
Y:0000                      15943         org     y,".ybssusb20dd",bss:
                            15944 FwRegComplete:
Y:0000 RESERVED             15945         ds      1
Y:0000
                            15947 Fs_wArcUsbIntRegShadow:
Y:0001 RESERVED             15948         ds      1
Y:0001
Y:0002 RESERVED             15951 FwMask: ds      1
Y:0002
                            15959 Fg_SetupData:
Y:0003                      15960         ds      48
   |   RESERVED                   
Y:0032
                            15977 FwUsbIsrSaveSp:
Y:0033 RESERVED             15978         ds      1
Y:0033
                            15983 FwRegCompleteRx:
Y:0034 RESERVED             15984         ds      1
Y:0034
                            15996 FwRegCompleteTx:
Y:0035 RESERVED             15997         ds      1
Y:0035
                            16006 
X:0000                      16007         org     x,".xbssusb20dd",bss:
                            16008 FusDevDriverSendData:
X:0000 RESERVED             16009         ds      1
X:0000
                            16010 
                            16011         extern  FInitUsbStructures, FdQHPackCap, FdQHUnpackSetup, FdTDPack
                            16012         extern  FdTDUnpack, IPRSetIVLPriority, FCapGetChipPartID, FFreeXd
                            16013         extern  FIcollEnable, FIcollInstallIsrVector, FIcollSetPriority
                            16014         extern  FIcollSetSteering, FPHY_Resume, FPHY_Shutdown
                            16015         extern  FPHY_Startup, FSysMaskAllInterrupts, FSysSetIrqLevel
                            16016         extern  FSysUnMaskAllInterrupts, x:FdQH_Base_Add
                            16017         extern  x:FdQH_Scratch_Cap, x:FdQH_Scratch_Setup_Buf
                            16018         extern  x:FdTD_Base_Address, x:FdTD_Base_Scratch_Address
                            16019         extern  x:FdXD_Base_Address, y:Fg_dXD_Queues, y:Fg_pStrings
                            16020         extern  Fparse_strings, y:FstDeviceState, Fusb_device_call_service
                            16021         extern  Fusb_device_hold, Fusb_device_init_endpoint
                            16022         extern  Fusb_device_send_data, Fusb_device_set_first_init
                            16023 
                            16024         global  FChipUpdateIdFlag, FProcessEndptComplete
                            16025         global  FProcessEndptSetup, FTestPacket, Fg_SetupData
                            16026         global  Fread_and_clear_arc_reg_usbsts, Fread_and_clear_usb_reg
                            16027         global  Fread_usb_reg, Fread_usb_reg_16, FusDevDriverSendData
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  57

M:ADDR CODE           CYCLES LINE SOURCELINE
                            16028         global  Fusb_dci_chip_enable, Fusb_dci_clear_dxd_queue
                            16029         global  Fusb_dci_finish_transaction, Fusb_dci_get_endpoint_status
                            16030         global  Fusb_dci_get_setup_data, Fusb_dci_get_transfer_status
                            16031         global  Fusb_dci_init, Fusb_dci_init_data_toggle_endpoint
                            16032         global  Fusb_dci_init_endpoint, Fusb_dci_isr
                            16033         global  Fusb_dci_process_port_change, Fusb_dci_process_reset
                            16034         global  Fusb_dci_process_suspend, Fusb_dci_process_tr_complete
                            16035         global  Fusb_dci_set_address, Fusb_dci_set_endpoint_status
                            16036         global  Fusb_dci_set_test_mode, Fusb_dci_shutdown
                            16037         global  Fusb_dci_stall_endpoint, Fusb_dci_transfer_data
                            16038         global  Fusb_dci_unstall_endpoint
                            16039         global  Fusb_dci_update_connection_status
                            16040         global  Fusb_dci_wait_until_suspend_ends, FwMask, FwRegComplete
                            16041         global  FwRegCompleteRx, FwRegCompleteTx, FwUsbIsrSaveSp
                            16042         global  Fwrite_usb_reg
                            16043 
                            16044         local   Fs_wArcUsbIntRegShadow, L3, L4, L5, L7, L8, L9, L10, L11
                            16045         local   L12, L13, L14, L15, L16, L20, L21, L22, L23, L24, L25, L26
                            16046         local   L27, L29, L30, L31, L32, L33, L34, L36, L37, L38, L39, L40
                            16047         local   L41, L42, L43, L44, L45, L46, L47, L48, L49, L50, L53, L54
                            16048         local   L55, L57, L58, L59, L61, L62, L63, L65, L67, L68, L69, L70
                            16049         local   L71, L72, L73, L74, L76, L77, L78, L79, L80, L81, L82, L83
                            16050         local   L84, L85, L86, L87, L88, L89, L91, L92, L93, L94, L95, L96
                            16051         local   L97, L104, L106, L107, L108, ss_usb_dci_isr
                            16052 
                            16053         calls   "ProcessEndptComplete", "FdTDUnpack", "FreeXd"
                            16054         calls   "ProcessEndptComplete", "usb_dci_transfer_data"
                            16055         calls   "ProcessEndptComplete", "usb_device_call_service"
                            16056         calls   "ProcessEndptSetup", "usb_device_call_service"
                            16057         calls   "usb_dci_chip_enable", "FInitUsbStructures", "FdQHPackCap"
                            16058         calls   "usb_dci_chip_enable", "read_usb_reg", "write_usb_reg"
                            16059         calls   "usb_dci_clear_dxd_queue", "FreeXd"
                            16060         calls   "usb_dci_get_endpoint_status", "read_usb_reg"
                            16061         calls   "usb_dci_get_setup_data", "FdQHUnpackSetup"
                            16062         calls   "usb_dci_get_setup_data", "write_usb_reg"
                            16063         calls   "usb_dci_init", "CapGetChipPartID", "IPRSetIVLPriority"
                            16064         calls   "usb_dci_init", "IcollEnable", "IcollInstallIsrVector"
                            16065         calls   "usb_dci_init", "IcollSetPriority", "IcollSetSteering"
                            16066         calls   "usb_dci_init", "PHY_Startup", "parse_strings"
                            16067         calls   "usb_dci_init", "usb_dci_update_connection_status"
                            16068         calls   "usb_dci_init_data_toggle_endpoint", "read_usb_reg"
                            16069         calls   "usb_dci_init_data_toggle_endpoint", "write_usb_reg"
                            16070         calls   "usb_dci_init_endpoint", "FdQHPackCap"
                            16071         calls   "usb_dci_init_endpoint", "SysMaskAllInterrupts"
                            16072         calls   "usb_dci_init_endpoint", "SysUnMaskAllInterrupts"
                            16073         calls   "usb_dci_init_endpoint", "read_usb_reg", "write_usb_reg"
                            16074         calls   "usb_dci_isr", "SysMaskAllInterrupts", "SysSetIrqLevel"
                            16075         calls   "usb_dci_isr", "SysUnMaskAllInterrupts"
                            16076         calls   "usb_dci_isr", "read_and_clear_arc_reg_usbsts"
                            16077         calls   "usb_dci_isr", "usb_dci_process_port_change"
                            16078         calls   "usb_dci_isr", "usb_dci_process_reset"
                            16079         calls   "usb_dci_isr", "usb_dci_process_suspend"
                            16080         calls   "usb_dci_isr", "usb_dci_process_tr_complete"
                            16081         calls   "usb_dci_process_port_change", "read_usb_reg"
                            16082         calls   "usb_dci_process_port_change", "usb_device_call_service"
                            16083         calls   "usb_dci_process_port_change", "write_usb_reg"
                            16084         calls   "usb_dci_process_reset", "read_usb_reg"
                            16085         calls   "usb_dci_process_reset", "usb_dci_chip_enable"
                            16086         calls   "usb_dci_process_reset", "usb_dci_clear_dxd_queue"
                            16087         calls   "usb_dci_process_reset", "usb_device_call_service"
                            16088         calls   "usb_dci_process_reset", "usb_device_init_endpoint"
                            16089         calls   "usb_dci_process_reset", "write_usb_reg"
                            16090         calls   "usb_dci_process_suspend", "PHY_Resume", "PHY_Shutdown"
                            16091         calls   "usb_dci_process_suspend", "usb_dci_process_reset"
                            16092         calls   "usb_dci_process_suspend", "usb_dci_wait_until_suspend_ends"
                            16093         calls   "usb_dci_process_suspend", "usb_device_call_service"
                            16094         calls   "usb_dci_process_suspend", "usb_device_hold"
                            16095         calls   "usb_dci_process_suspend", "usb_device_set_first_init"
                            16096         calls   "usb_dci_process_tr_complete", "read_and_clear_usb_reg"
                            16097         calls   "usb_dci_process_tr_complete", "read_usb_reg_16"
                            16098         calls   "usb_dci_set_address", "write_usb_reg"
                            16099         calls   "usb_dci_set_endpoint_status", "usb_dci_stall_endpoint"
                            16100         calls   "usb_dci_set_endpoint_status", "usb_dci_unstall_endpoint"
                            16101         calls   "usb_dci_set_test_mode", "read_usb_reg"
                            16102         calls   "usb_dci_set_test_mode", "usb_device_send_data"
                            16103         calls   "usb_dci_set_test_mode", "write_usb_reg"
                            16104         calls   "usb_dci_stall_endpoint", "read_usb_reg", "write_usb_reg"
                            16105         calls   "usb_dci_transfer_data", "FdQHPackCap", "FdTDPack"
                            16106         calls   "usb_dci_transfer_data", "read_usb_reg", "read_usb_reg_16"
                            16107         calls   "usb_dci_transfer_data", "write_usb_reg"
                            16108         calls   "usb_dci_unstall_endpoint", "read_usb_reg", "write_usb_reg"
                            16109 
